<clones>
<systeminfo processor="nicad6" system="source-code" granularity="functions" threshold="0%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="2037" npairs="903"/>
<runinfo ncompares="499475" cputime="15836"/>
<classinfo nclasses="175"/>

<class classid="1" nclones="13" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="71" endline="73" pcid="12">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="72" endline="74" pcid="93">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="97" endline="99" pcid="447">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="89" endline="91" pcid="423">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="146" endline="148" pcid="461">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="32" endline="34" pcid="1745">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="66" endline="68" pcid="153">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="40" endline="42" pcid="1682">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="145" endline="147" pcid="595">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="70" endline="72" pcid="928">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="66" endline="68" pcid="901">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="212" endline="214" pcid="1647">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="77" endline="79" pcid="61">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
</class>

<class classid="2" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="75" endline="77" pcid="13">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="208" endline="210" pcid="1646">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="135" endline="137" pcid="816">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="137" endline="139" pcid="593">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="70" endline="72" pcid="1983">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="68" endline="70" pcid="92">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
</class>

<class classid="3" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="79" endline="81" pcid="14">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="70" endline="72" pcid="902">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="515" endline="517" pcid="361">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="85" endline="87" pcid="422">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="42" endline="44" pcid="1518">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="139" endline="141" pcid="817">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="122" endline="124" pcid="455">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
</class>

<class classid="4" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="83" endline="85" pcid="15">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="62" endline="64" pcid="900">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="200" endline="202" pcid="1644">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="93" endline="95" pcid="446">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="125" endline="127" pcid="590">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="179" endline="181" pcid="827">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="114" endline="116" pcid="453">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="64" endline="66" pcid="91">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="46" endline="48" pcid="1540">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
</class>

<class classid="5" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="87" endline="89" pcid="16">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="36" endline="38" pcid="1326">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="141" endline="143" pcid="594">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
</class>

<class classid="6" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="91" endline="93" pcid="17">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="40" endline="42" pcid="1327">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="161" endline="163" pcid="599">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="33" endline="35" pcid="1334">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
</class>

<class classid="7" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="95" endline="97" pcid="18">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="216" endline="218" pcid="1648">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
</class>

<class classid="8" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="99" endline="101" pcid="19">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="169" endline="171" pcid="601">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="44" endline="46" pcid="1328">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
</class>

<class classid="9" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="103" endline="105" pcid="20">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="156" endline="158" pcid="1782">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
</class>

<class classid="10" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="69" endline="71" pcid="59">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="81" endline="83" pcid="421">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="204" endline="206" pcid="1645">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="134" endline="136" pcid="458">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="44" endline="46" pcid="2032">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="70" endline="72" pcid="154">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="147" endline="149" pcid="819">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
</class>

<class classid="11" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="73" endline="75" pcid="60">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="130" endline="132" pcid="457">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="58" endline="60" pcid="899">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="131" endline="133" pcid="815">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="58" endline="60" pcid="151">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
</class>

<class classid="12" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="81" endline="83" pcid="62">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="436" endline="438" pcid="138">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="1032" endline="1034" pcid="506">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="526" endline="529" pcid="546">
    function _notImplemented() internal pure {
        // slither-disable-next-line dead-code
        revert("Cannot be run on this layer");
    }
</source>
</class>

<class classid="13" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="98" endline="100" pcid="64">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="79" endline="81" pcid="1523">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
</class>

<class classid="14" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="76" endline="78" pcid="94">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="157" endline="159" pcid="598">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
</class>

<class classid="15" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="84" endline="86" pcid="96">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="151" endline="153" pcid="820">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
</class>

<class classid="16" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="206" endline="216" pcid="115">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="123" endline="133" pcid="1664">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
</class>

<class classid="17" nclones="2" nlines="11" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="483" endline="493" pcid="143">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
<source file="systems/source-code/Synth.sol" startline="278" endline="288" pcid="1653">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
</class>

<class classid="18" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="74" endline="76" pcid="155">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="79" endline="81" pcid="1230">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="40" endline="42" pcid="2031">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
</class>

<class classid="19" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="112" endline="114" pcid="174">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="167" endline="169" pcid="1367">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="213" endline="215" pcid="676">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
</class>

<class classid="20" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="116" endline="118" pcid="175">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="145" endline="147" pcid="231">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
</class>

<class classid="21" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="124" endline="126" pcid="177">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="141" endline="143" pcid="230">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="89" endline="91" pcid="445">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
</class>

<class classid="22" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="128" endline="130" pcid="178">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="77" endline="79" pcid="755">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="209" endline="211" pcid="675">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="163" endline="165" pcid="1366">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
</class>

<class classid="23" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="132" endline="134" pcid="179">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="73" endline="75" pcid="754">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
</class>

<class classid="24" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="83" endline="89" pcid="214">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="43" endline="49" pcid="223">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="53" endline="59" pcid="290">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
</class>

<class classid="25" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="91" endline="93" pcid="215">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="82" endline="84" pcid="294">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="51" endline="53" pcid="224">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
</class>

<class classid="26" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Depot.sol" startline="511" endline="513" pcid="360">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="66" endline="68" pcid="1982">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="78" endline="80" pcid="930">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
</class>

<class classid="27" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="76" endline="78" pcid="442">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="39" endline="41" pcid="1763">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="166" endline="168" pcid="466">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
</class>

<class classid="28" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="142" endline="144" pcid="460">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="159" endline="161" pcid="822">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="153" endline="155" pcid="597">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
</class>

<class classid="29" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="158" endline="160" pcid="464">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="32" endline="34" pcid="1762">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
</class>

<class classid="30" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="162" endline="164" pcid="465">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="166" endline="168" pcid="1784">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
</class>

<class classid="31" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="84" endline="86" pcid="510">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="116" endline="118" pcid="1775">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
</class>

<class classid="32" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="88" endline="90" pcid="511">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="160" endline="162" pcid="1783">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
</class>

<class classid="33" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="35" endline="37" pcid="549">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="226" endline="228" pcid="1795">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
</class>

<class classid="34" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="39" endline="41" pcid="550">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="232" endline="234" pcid="1796">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
</class>

<class classid="35" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="43" endline="45" pcid="551">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="244" endline="246" pcid="1798">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
</class>

<class classid="36" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="47" endline="49" pcid="552">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="250" endline="252" pcid="1799">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
</class>

<class classid="37" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="49" endline="51" pcid="560">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="220" endline="222" pcid="1794">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
</class>

<class classid="38" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="129" endline="131" pcid="591">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="66" endline="68" pcid="927">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="143" endline="145" pcid="818">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
</class>

<class classid="39" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="149" endline="151" pcid="596">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="45" endline="47" pcid="1659">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="163" endline="165" pcid="823">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="74" endline="76" pcid="929">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
</class>

<class classid="40" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="173" endline="175" pcid="602">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="209" endline="211" pcid="829">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="45" endline="47" pcid="1764">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="74" endline="76" pcid="903">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
</class>

<class classid="41" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="177" endline="179" pcid="603">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="53" endline="55" pcid="1765">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
</class>

<class classid="42" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="181" endline="183" pcid="604">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="58" endline="60" pcid="1766">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
</class>

<class classid="43" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="205" endline="207" pcid="674">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="159" endline="161" pcid="1365">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
</class>

<class classid="44" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="217" endline="219" pcid="677">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="171" endline="173" pcid="1368">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
</class>

<class classid="45" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="232" endline="238" pcid="679">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="186" endline="192" pcid="1370">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
</class>

<class classid="46" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="240" endline="244" pcid="680">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="194" endline="198" pcid="1371">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
</class>

<class classid="47" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="246" endline="251" pcid="681">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="200" endline="205" pcid="1372">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
</class>

<class classid="48" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="257" endline="259" pcid="682">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="211" endline="213" pcid="1373">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
</class>

<class classid="49" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="261" endline="264" pcid="683">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="215" endline="218" pcid="1374">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
</class>

<class classid="50" nclones="2" nlines="18" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="271" endline="305" pcid="684">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="225" endline="259" pcid="1375">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
</class>

<class classid="51" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="307" endline="309" pcid="685">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="261" endline="263" pcid="1376">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
</class>

<class classid="52" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="311" endline="314" pcid="686">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="265" endline="268" pcid="1377">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
</class>

<class classid="53" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="316" endline="323" pcid="687">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="270" endline="277" pcid="1378">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
</class>

<class classid="54" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="328" endline="331" pcid="688">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="282" endline="285" pcid="1379">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
</class>

<class classid="55" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="339" endline="358" pcid="689">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="293" endline="312" pcid="1380">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
</class>

<class classid="56" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="360" endline="365" pcid="690">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="314" endline="319" pcid="1381">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
</class>

<class classid="57" nclones="2" nlines="17" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="367" endline="390" pcid="691">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="321" endline="344" pcid="1382">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
</class>

<class classid="58" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="400" endline="406" pcid="692">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="354" endline="360" pcid="1383">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
</class>

<class classid="59" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="418" endline="421" pcid="693">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="372" endline="375" pcid="1384">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
</class>

<class classid="60" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="423" endline="430" pcid="694">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="377" endline="384" pcid="1385">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
</class>

<class classid="61" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="432" endline="443" pcid="695">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="386" endline="397" pcid="1386">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
</class>

<class classid="62" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="462" endline="464" pcid="697">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="411" endline="413" pcid="1388">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
</class>

<class classid="63" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="466" endline="468" pcid="698">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="415" endline="417" pcid="1389">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
</class>

<class classid="64" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="570" endline="572" pcid="700">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="519" endline="521" pcid="1391">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
</class>

<class classid="65" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="577" endline="579" pcid="701">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="526" endline="528" pcid="1392">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
</class>

<class classid="66" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="581" endline="583" pcid="702">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="530" endline="532" pcid="1393">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
</class>

<class classid="67" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="585" endline="587" pcid="703">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="534" endline="536" pcid="1394">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
</class>

<class classid="68" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="591" endline="593" pcid="704">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="540" endline="542" pcid="1395">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
</class>

<class classid="69" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="598" endline="600" pcid="705">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="547" endline="549" pcid="1396">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
</class>

<class classid="70" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="605" endline="609" pcid="706">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="554" endline="558" pcid="1397">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="71" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="614" endline="618" pcid="707">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="563" endline="567" pcid="1398">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="72" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="658" endline="667" pcid="710">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="622" endline="631" pcid="1402">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
</class>

<class classid="73" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="676" endline="689" pcid="711">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method is the only mutative method that uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="640" endline="653" pcid="1403">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
</class>

<class classid="74" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="694" endline="724" pcid="712">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="658" endline="688" pcid="1404">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
</class>

<class classid="75" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="726" endline="736" pcid="713">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="690" endline="700" pcid="1405">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
</class>

<class classid="76" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="741" endline="745" pcid="714">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="705" endline="709" pcid="1406">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
</class>

<class classid="77" nclones="2" nlines="16" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="782" endline="820" pcid="716">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);
        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="761" endline="800" pcid="1409">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);

        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
</class>

<class classid="78" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="838" endline="844" pcid="718">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="821" endline="827" pcid="1411">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
</class>

<class classid="79" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="908" endline="910" pcid="720">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="878" endline="880" pcid="1413">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="80" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="916" endline="918" pcid="721">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="886" endline="888" pcid="1414">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="81" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="938" endline="940" pcid="723">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="902" endline="904" pcid="1416">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
</class>

<class classid="82" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="943" endline="945" pcid="724">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="907" endline="909" pcid="1417">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
</class>

<class classid="83" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="1007" endline="1014" pcid="727">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="966" endline="973" pcid="1420">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
</class>

<class classid="84" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="33" endline="35" pcid="777">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="36" endline="38" pcid="1430">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
</class>

<class classid="85" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="70" endline="72" pcid="782">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="59" endline="61" pcid="1433">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
</class>

<class classid="86" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="77" endline="79" pcid="783">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="66" endline="68" pcid="1434">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
</class>

<class classid="87" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="91" endline="93" pcid="785">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="80" endline="82" pcid="1436">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
</class>

<class classid="88" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="98" endline="100" pcid="786">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="87" endline="89" pcid="1437">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
</class>

<class classid="89" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="132" endline="134" pcid="788">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="117" endline="119" pcid="1439">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
</class>

<class classid="90" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="140" endline="142" pcid="789">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="125" endline="127" pcid="1440">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
</class>

<class classid="91" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="147" endline="149" pcid="790">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="132" endline="134" pcid="1441">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
</class>

<class classid="92" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="155" endline="157" pcid="791">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="140" endline="142" pcid="1442">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
</class>

<class classid="93" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="163" endline="170" pcid="792">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="148" endline="155" pcid="1443">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
</class>

<class classid="94" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="192" endline="194" pcid="797">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="167" endline="169" pcid="1446">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
</class>

<class classid="95" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="196" endline="198" pcid="798">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="171" endline="173" pcid="1447">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
</class>

<class classid="96" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="215" endline="218" pcid="801">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="190" endline="193" pcid="1450">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
</class>

<class classid="97" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="220" endline="224" pcid="802">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="195" endline="199" pcid="1451">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
</class>

<class classid="98" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="250" endline="254" pcid="804">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="221" endline="225" pcid="1453">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
</class>

<class classid="99" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="256" endline="259" pcid="805">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="227" endline="230" pcid="1454">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
</class>

<class classid="100" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="261" endline="264" pcid="806">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="232" endline="235" pcid="1455">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
</class>

<class classid="101" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="266" endline="270" pcid="807">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="237" endline="241" pcid="1456">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
</class>

<class classid="102" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="374" endline="376" pcid="843">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="152" endline="154" pcid="1781">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
</class>

<class classid="103" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="22" endline="25" pcid="895">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
<source file="systems/source-code/State.sol" startline="23" endline="26" pcid="1624">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
</class>

<class classid="104" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="27" endline="33" pcid="896">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="25" endline="31" pcid="1979">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
</class>

<class classid="105" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="35" endline="37" pcid="897">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="39" endline="41" pcid="1980">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
</class>

<class classid="106" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="78" endline="80" pcid="904">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="64" endline="66" pcid="1767">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
</class>

<class classid="107" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="82" endline="84" pcid="905">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="71" endline="73" pcid="1768">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
</class>

<class classid="108" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="86" endline="88" pcid="906">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="91" endline="93" pcid="1771">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
</class>

<class classid="109" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="90" endline="92" pcid="907">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="77" endline="79" pcid="1769">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
</class>

<class classid="110" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="94" endline="96" pcid="908">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="97" endline="99" pcid="1772">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
</class>

<class classid="111" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="98" endline="100" pcid="909">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="109" endline="111" pcid="1774">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
</class>

<class classid="112" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="102" endline="104" pcid="910">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="103" endline="105" pcid="1773">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
</class>

<class classid="113" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="43" endline="49" pcid="967">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="43" endline="49" pcid="975">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
</class>

<class classid="114" nclones="23" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="73" endline="78" pcid="969">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="81" endline="86" pcid="1043">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="93" endline="98" pcid="1037">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="117" endline="122" pcid="1171">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="118" endline="123" pcid="1004">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="211" endline="216" pcid="1068">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="70" endline="75" pcid="1092">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="350" endline="355" pcid="1129">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="143" endline="148" pcid="1053">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="70" endline="75" pcid="1123">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="394" endline="399" pcid="1021">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="274" endline="279" pcid="1152">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="70" endline="75" pcid="1100">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="68" endline="73" pcid="1086">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="167" endline="172" pcid="1108">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="177" endline="182" pcid="1060">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="76" endline="81" pcid="1117">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="122" endline="127" pcid="995">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="75" endline="80" pcid="977">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="70" endline="75" pcid="1079">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="118" endline="123" pcid="1012">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="337" endline="342" pcid="1027">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="142" endline="147" pcid="985">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
</class>

<class classid="115" nclones="23" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="80" endline="85" pcid="970">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="184" endline="189" pcid="1061">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="125" endline="130" pcid="1013">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="218" endline="223" pcid="1069">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="150" endline="155" pcid="1054">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="344" endline="349" pcid="1028">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="88" endline="93" pcid="1044">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="100" endline="105" pcid="1038">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="401" endline="406" pcid="1022">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="82" endline="87" pcid="978">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="149" endline="154" pcid="986">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="77" endline="82" pcid="1080">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="281" endline="286" pcid="1153">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="129" endline="134" pcid="996">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="357" endline="362" pcid="1130">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="124" endline="129" pcid="1172">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="77" endline="82" pcid="1124">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="125" endline="130" pcid="1005">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="83" endline="88" pcid="1118">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="174" endline="179" pcid="1109">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="77" endline="82" pcid="1093">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="77" endline="82" pcid="1101">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="75" endline="80" pcid="1087">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
</class>

<class classid="116" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="87" endline="98" pcid="971">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="89" endline="100" pcid="979">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="117" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/Migration_Alphard.sol" startline="156" endline="171" pcid="987">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="136" endline="151" pcid="997">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="118" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="38" endline="43" pcid="1077">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="38" endline="43" pcid="1084">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
</class>

<class classid="119" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="84" endline="93" pcid="1081">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="82" endline="91" pcid="1088">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="120" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="38" endline="43" pcid="1090">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="38" endline="43" pcid="1098">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
</class>

<class classid="121" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="45" endline="68" pcid="1091">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="45" endline="68" pcid="1099">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="122" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="84" endline="93" pcid="1094">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="84" endline="93" pcid="1102">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="123" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Rasalhague.sol" startline="90" endline="99" pcid="1119">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="84" endline="93" pcid="1125">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="124" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="46" endline="49" pcid="1184">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="74" endline="77" pcid="1229">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="44" endline="47" pcid="1457">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
</class>

<class classid="125" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="51" endline="53" pcid="1185">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="49" endline="51" pcid="1458">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
</class>

<class classid="126" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="57" endline="59" pcid="1186">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="55" endline="57" pcid="1459">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
</class>

<class classid="127" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="77" endline="79" pcid="1191">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="67" endline="69" pcid="1462">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
</class>

<class classid="128" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="81" endline="83" pcid="1192">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="71" endline="73" pcid="1463">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
</class>

<class classid="129" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="89" endline="91" pcid="1194">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="79" endline="81" pcid="1465">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
</class>

<class classid="130" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="93" endline="95" pcid="1195">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="83" endline="85" pcid="1466">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
</class>

<class classid="131" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="97" endline="99" pcid="1196">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="87" endline="89" pcid="1467">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
</class>

<class classid="132" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="101" endline="103" pcid="1197">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="91" endline="93" pcid="1468">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
</class>

<class classid="133" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="105" endline="107" pcid="1198">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="95" endline="97" pcid="1469">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
</class>

<class classid="134" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="109" endline="111" pcid="1199">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="99" endline="101" pcid="1470">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
</class>

<class classid="135" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="31" endline="33" pcid="1200">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="31" endline="33" pcid="1421">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="136" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="37" endline="39" pcid="1201">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="37" endline="39" pcid="1422">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="137" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="232" endline="234" pcid="1205">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="230" endline="232" pcid="1426">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
</class>

<class classid="138" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="238" endline="240" pcid="1206">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="236" endline="238" pcid="1427">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
</class>

<class classid="139" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="14" endline="18" pcid="1208">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="14" endline="18" pcid="1471">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
</class>

<class classid="140" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="24" endline="27" pcid="1209">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="24" endline="27" pcid="1472">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
</class>

<class classid="141" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="33" endline="36" pcid="1210">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="33" endline="36" pcid="1473">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
</class>

<class classid="142" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="42" endline="45" pcid="1211">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="42" endline="45" pcid="1474">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
</class>

<class classid="143" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="50" endline="52" pcid="1212">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="50" endline="52" pcid="1475">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
</class>

<class classid="144" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="57" endline="60" pcid="1213">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="57" endline="60" pcid="1476">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
</class>

<class classid="145" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="65" endline="68" pcid="1214">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="65" endline="68" pcid="1477">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="146" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="73" endline="76" pcid="1215">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="73" endline="76" pcid="1478">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="147" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="81" endline="84" pcid="1216">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="81" endline="84" pcid="1479">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="148" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="90" endline="93" pcid="1217">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="90" endline="93" pcid="1480">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="149" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="130" endline="133" pcid="1220">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="121" endline="124" pcid="1482">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
</class>

<class classid="150" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="193" endline="223" pcid="1223">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="172" endline="202" pcid="1485">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
</class>

<class classid="151" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockEtherWrapper.sol" startline="13" endline="15" pcid="1285">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockWrapperFactory.sol" startline="13" endline="15" pcid="1325">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
</class>

<class classid="152" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="24" endline="26" pcid="1349">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="28" endline="30" pcid="1355">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
</class>

<class classid="153" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="17" endline="19" pcid="1500">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="17" endline="19" pcid="1503">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
</class>

<class classid="154" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="21" endline="27" pcid="1501">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="21" endline="27" pcid="1504">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
</class>

<class classid="155" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="32" endline="34" pcid="1502">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="32" endline="34" pcid="1505">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
</class>

<class classid="156" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="60" endline="63" pcid="1521">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="46" endline="49" pcid="1722">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
</class>

<class classid="157" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="98" endline="100" pcid="1526">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="71" endline="73" pcid="1725">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
</class>

<class classid="158" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="105" endline="107" pcid="1527">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="78" endline="80" pcid="1726">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
</class>

<class classid="159" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="112" endline="114" pcid="1528">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="85" endline="87" pcid="1727">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="160" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="143" endline="145" pcid="1531">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="116" endline="118" pcid="1730">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
</class>

<class classid="161" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="150" endline="152" pcid="1532">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="123" endline="125" pcid="1731">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="162" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="65" endline="67" pcid="1581">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="49" endline="51" pcid="1609">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
</class>

<class classid="163" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="69" endline="71" pcid="1582">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="53" endline="55" pcid="1610">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
</class>

<class classid="164" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="73" endline="75" pcid="1583">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="57" endline="59" pcid="1611">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
</class>

<class classid="165" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="77" endline="85" pcid="1584">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="61" endline="69" pcid="1612">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
</class>

<class classid="166" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="87" endline="89" pcid="1585">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="71" endline="73" pcid="1613">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
</class>

<class classid="167" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="91" endline="93" pcid="1586">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="75" endline="77" pcid="1614">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
</class>

<class classid="168" nclones="2" nlines="15" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="125" endline="144" pcid="1590">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="113" endline="132" pcid="1619">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
</class>

<class classid="169" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="146" endline="153" pcid="1591">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="141" endline="148" pcid="1621">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
</class>

<class classid="170" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="26" endline="28" pcid="1941">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="26" endline="28" pcid="1948">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
</class>

<class classid="171" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="12" endline="14" pcid="1954">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="12" endline="14" pcid="1964">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
</class>

<class classid="172" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="16" endline="19" pcid="1955">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="16" endline="19" pcid="1965">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
</class>

<class classid="173" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="21" endline="23" pcid="1956">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="21" endline="23" pcid="1966">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
</class>

<class classid="174" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="52" endline="56" pcid="1958">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="52" endline="56" pcid="1968">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
</class>

<class classid="175" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="61" endline="66" pcid="1959">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="61" endline="66" pcid="1969">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
</class>

</clones>
