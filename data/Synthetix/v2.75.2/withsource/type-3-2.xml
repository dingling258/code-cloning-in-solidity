<clones>
<systeminfo processor="nicad6" system="source-code" granularity="functions-blind" threshold="30%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="2037" npairs="14016"/>
<runinfo ncompares="653574" cputime="31333"/>
<classinfo nclasses="283"/>

<class classid="1" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/AddressResolver.sol" startline="49" endline="51" pcid="4">
    function getAddress(bytes32 name) external view returns (address) {
        return repository[name];
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="127" endline="129" pcid="284">
    function shortRateLastUpdated(bytes32 currency) internal view returns (uint) {
        return shortRatesLastUpdated[currency];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="28" endline="30" pcid="397">
    function getUIntValue(bytes32 record) external view returns (uint) {
        return UIntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="54" endline="56" pcid="403">
    function getAddressValue(bytes32 record) external view returns (address) {
        return AddressStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="106" endline="108" pcid="415">
    function getIntValue(bytes32 record) external view returns (int) {
        return IntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="80" endline="82" pcid="409">
    function getBytes32Value(bytes32 record) external view returns (bytes32) {
        return Bytes32Storage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="93" endline="95" pcid="412">
    function getBooleanValue(bytes32 record) external view returns (bool) {
        return BooleanStorage[record];
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="111" endline="113" pcid="22">
    function cachedSynthDebt(bytes32 currencyKey) external view returns (uint) {
        return _cachedSynthDebt[currencyKey];
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="80" endline="82" pcid="443">
    function lastExchangeRate(bytes32 currencyKey) external view returns (uint) {
        return _lastExchangeRate[currencyKey];
    }
</source>
</class>

<class classid="2" nclones="2" nlines="7" similarity="80">
<source file="systems/source-code/AddressSetLib.sol" startline="10" endline="16" pcid="7">
    function contains(AddressSet storage set, address candidate) internal view returns (bool) {
        if (set.elements.length == 0) {
            return false;
        }
        uint index = set.indices[candidate];
        return index != 0 || set.elements[0] == candidate;
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="10" endline="16" pcid="169">
    function contains(Bytes32Set storage set, bytes32 candidate) internal view returns (bool) {
        if (set.elements.length == 0) {
            return false;
        }
        uint index = set.indices[candidate];
        return index != 0 || set.elements[0] == candidate;
    }
</source>
</class>

<class classid="3" nclones="2" nlines="15" similarity="72">
<source file="systems/source-code/AddressSetLib.sol" startline="18" endline="40" pcid="8">
    function getPage(
        AddressSet storage set,
        uint index,
        uint pageSize
    ) internal view returns (address[] memory) {
        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+
        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.

        // If the page extends past the end of the list, truncate it.
        if (endIndex > set.elements.length) {
            endIndex = set.elements.length;
        }
        if (endIndex <= index) {
            return new address[](0);
        }

        uint n = endIndex - index; // We already checked for negative overflow.
        address[] memory page = new address[](n);
        for (uint i; i < n; i++) {
            page[i] = set.elements[i + index];
        }
        return page;
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="18" endline="40" pcid="170">
    function getPage(
        Bytes32Set storage set,
        uint index,
        uint pageSize
    ) internal view returns (bytes32[] memory) {
        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+
        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.

        // If the page extends past the end of the list, truncate it.
        if (endIndex > set.elements.length) {
            endIndex = set.elements.length;
        }
        if (endIndex <= index) {
            return new bytes32[](0);
        }

        uint n = endIndex - index; // We already checked for negative overflow.
        bytes32[] memory page = new bytes32[](n);
        for (uint i; i < n; i++) {
            page[i] = set.elements[i + index];
        }
        return page;
    }
</source>
</class>

<class classid="4" nclones="2" nlines="6" similarity="75">
<source file="systems/source-code/AddressSetLib.sol" startline="42" endline="48" pcid="9">
    function add(AddressSet storage set, address element) internal {
        // Adding to a set is an idempotent operation.
        if (!contains(set, element)) {
            set.indices[element] = set.elements.length;
            set.elements.push(element);
        }
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="42" endline="48" pcid="171">
    function add(Bytes32Set storage set, bytes32 element) internal {
        // Adding to a set is an idempotent operation.
        if (!contains(set, element)) {
            set.indices[element] = set.elements.length;
            set.elements.push(element);
        }
    }
</source>
</class>

<class classid="5" nclones="2" nlines="12" similarity="80">
<source file="systems/source-code/AddressSetLib.sol" startline="50" endline="63" pcid="10">
    function remove(AddressSet storage set, address element) internal {
        require(contains(set, element), "Element not in set.");
        // Replace the removed element with the last element of the list.
        uint index = set.indices[element];
        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.
        if (index != lastIndex) {
            // No need to shift the last element if it is the one we want to delete.
            address shiftedElement = set.elements[lastIndex];
            set.elements[index] = shiftedElement;
            set.indices[shiftedElement] = index;
        }
        set.elements.pop();
        delete set.indices[element];
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="50" endline="63" pcid="172">
    function remove(Bytes32Set storage set, bytes32 element) internal {
        require(contains(set, element), "Element not in set.");
        // Replace the removed element with the last element of the list.
        uint index = set.indices[element];
        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.
        if (index != lastIndex) {
            // No need to shift the last element if it is the one we want to delete.
            bytes32 shiftedElement = set.elements[lastIndex];
            set.elements[index] = shiftedElement;
            set.indices[shiftedElement] = index;
        }
        set.elements.pop();
        delete set.indices[element];
    }
</source>
</class>

<class classid="6" nclones="17" nlines="11" similarity="71">
<source file="systems/source-code/BaseDebtCache.sol" startline="57" endline="69" pcid="11">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](8);
        newAddresses[0] = CONTRACT_ISSUER;
        newAddresses[1] = CONTRACT_EXCHANGER;
        newAddresses[2] = CONTRACT_EXRATES;
        newAddresses[3] = CONTRACT_SYSTEMSTATUS;
        newAddresses[4] = CONTRACT_COLLATERALMANAGER;
        newAddresses[5] = CONTRACT_WRAPPER_FACTORY;
        newAddresses[6] = CONTRACT_ETHER_WRAPPER;
        newAddresses[7] = CONTRACT_FUTURESMARKETMANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="98" endline="112" pcid="452">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](10);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_EXCHANGESTATE;
        newAddresses[2] = CONTRACT_EXRATES;
        newAddresses[3] = CONTRACT_SYNTHETIX;
        newAddresses[4] = CONTRACT_FEEPOOL;
        newAddresses[5] = CONTRACT_TRADING_REWARDS;
        newAddresses[6] = CONTRACT_DELEGATEAPPROVALS;
        newAddresses[7] = CONTRACT_ISSUER;
        newAddresses[8] = CONTRACT_DEBTCACHE;
        newAddresses[9] = CONTRACT_CIRCUIT_BREAKER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="101" endline="113" pcid="160">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](8);
        newAddresses[0] = CONTRACT_EXT_MESSENGER;
        newAddresses[1] = CONTRACT_SYNTHETIX;
        newAddresses[2] = CONTRACT_REWARDESCROW;
        newAddresses[3] = CONTRACT_ISSUER;
        newAddresses[4] = CONTRACT_FEEPOOL;
        newAddresses[5] = CONTRACT_FLEXIBLESTORAGE;
        newAddresses[6] = CONTRACT_EXCHANGERATES;
        newAddresses[7] = CONTRACT_SYSTEM_STATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="95" endline="108" pcid="173">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](6);
        newAddresses[0] = CONTRACT_FEEPOOL;
        newAddresses[1] = CONTRACT_EXRATES;
        newAddresses[2] = CONTRACT_EXCHANGER;
        newAddresses[3] = CONTRACT_SYSTEMSTATUS;
        newAddresses[4] = CONTRACT_SYNTHSUSD;
        newAddresses[5] = CONTRACT_COLLATERALUTIL;

        bytes32[] memory combined = combineArrays(existingAddresses, newAddresses);

        addresses = combineArrays(combined, synths);
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="105" endline="123" pcid="589">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](14);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_SYNTHETIXDEBTSHARE;
        newAddresses[2] = CONTRACT_FEEPOOLETERNALSTORAGE;
        newAddresses[3] = CONTRACT_EXCHANGER;
        newAddresses[4] = CONTRACT_ISSUER;
        newAddresses[5] = CONTRACT_REWARDESCROW_V2;
        newAddresses[6] = CONTRACT_DELEGATEAPPROVALS;
        newAddresses[7] = CONTRACT_REWARDSDISTRIBUTION;
        newAddresses[8] = CONTRACT_COLLATERALMANAGER;
        newAddresses[9] = CONTRACT_WRAPPER_FACTORY;
        newAddresses[10] = CONTRACT_ETHER_WRAPPER;
        newAddresses[11] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;
        newAddresses[12] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;
        newAddresses[13] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="194" endline="203" pcid="673">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_FUTURESMARKETSETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="60" endline="70" pcid="418">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_SYNTHSETH;
        newAddresses[1] = CONTRACT_SYNTHSUSD;
        newAddresses[2] = CONTRACT_EXRATES;
        newAddresses[3] = CONTRACT_ISSUER;
        newAddresses[4] = CONTRACT_FEEPOOL;
        addresses = combineArrays(existingAddresses, newAddresses);
        return addresses;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="148" endline="157" pcid="1364">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = PerpsV2SettingsMixin.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_PERPSV2SETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="110" endline="129" pcid="814">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](15);
        newAddresses[0] = CONTRACT_SYNTHETIX;
        newAddresses[1] = CONTRACT_EXCHANGER;
        newAddresses[2] = CONTRACT_EXRATES;
        newAddresses[3] = CONTRACT_SYNTHETIXDEBTSHARE;
        newAddresses[4] = CONTRACT_FEEPOOL;
        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;
        newAddresses[6] = CONTRACT_REWARDESCROW_V2;
        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;
        newAddresses[8] = CONTRACT_LIQUIDATOR;
        newAddresses[9] = CONTRACT_LIQUIDATOR_REWARDS;
        newAddresses[10] = CONTRACT_DEBTCACHE;
        newAddresses[11] = CONTRACT_SYNTHREDEEMER;
        newAddresses[12] = CONTRACT_SYSTEMSTATUS;
        newAddresses[13] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;
        newAddresses[14] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="48" endline="56" pcid="898">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](4);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_SYNTHETIX;
        newAddresses[2] = CONTRACT_ISSUER;
        newAddresses[3] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="66" endline="74" pcid="1688">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetixBridge.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](4);
        newAddresses[0] = CONTRACT_ISSUER;
        newAddresses[1] = CONTRACT_REWARDSDISTRIBUTION;
        newAddresses[2] = CONTRACT_OVM_SYNTHETIXBRIDGETOBASE;
        newAddresses[3] = CONTRACT_SYNTHETIXBRIDGEESCROW;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="56" endline="64" pcid="926">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](4);
        newAddresses[0] = CONTRACT_SYNTHETIXDEBTSHARE;
        newAddresses[1] = CONTRACT_ISSUER;
        newAddresses[2] = CONTRACT_REWARDESCROW_V2;
        newAddresses[3] = CONTRACT_SYNTHETIX;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="48" endline="55" pcid="1329">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_COLLATERALMANAGER;
        newAddresses[1] = CONTRACT_ETHER_WRAPPER;
        newAddresses[2] = CONTRACT_WRAPPER_FACTORY;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="53" endline="60" pcid="439">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_EXRATES;
        newAddresses[2] = CONTRACT_ISSUER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="30" endline="37" pcid="1657">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetix.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_REWARD_ESCROW;
        newAddresses[1] = CONTRACT_REWARDESCROW_V2;
        newAddresses[2] = CONTRACT_SUPPLYSCHEDULE;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="29" endline="36" pcid="1537">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseRewardEscrowV2.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM;
        newAddresses[1] = CONTRACT_REWARD_ESCROW;
        newAddresses[2] = CONTRACT_SYSTEMSTATUS;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="43" endline="49" pcid="1352">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](2);
        newAddresses[0] = CONTRACT_EXT_MESSENGER;
        newAddresses[1] = CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="7" nclones="131" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="71" endline="73" pcid="12">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="135" endline="137" pcid="816">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="69" endline="71" pcid="59">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="79" endline="81" pcid="14">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="73" endline="75" pcid="60">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="213" endline="215" pcid="676">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="77" endline="79" pcid="61">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="139" endline="141" pcid="817">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="131" endline="133" pcid="815">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="49" endline="51" pcid="1458">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="171" endline="173" pcid="1368">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="209" endline="211" pcid="675">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="167" endline="169" pcid="1367">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="129" endline="131" pcid="591">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="163" endline="165" pcid="1366">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="54" endline="56" pcid="150">
    function messenger() internal view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="159" endline="161" pcid="1365">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="36" endline="38" pcid="1430">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="147" endline="149" pcid="819">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="151" endline="153" pcid="820">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="89" endline="91" pcid="423">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="28" endline="30" pcid="1355">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="155" endline="157" pcid="821">
    function liquidatorRewards() internal view returns (ILiquidatorRewards) {
        return ILiquidatorRewards(requireAndGetAddress(CONTRACT_LIQUIDATOR_REWARDS));
    }
</source>
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="24" endline="26" pcid="1349">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="58" endline="60" pcid="151">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="62" endline="64" pcid="152">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="133" endline="135" pcid="592">
    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {
        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="41" endline="43" pcid="1336">
    function synthsETH() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSETH));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="33" endline="35" pcid="1334">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="149" endline="151" pcid="596">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="205" endline="207" pcid="674">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="138" endline="140" pcid="459">
    function tradingRewards() internal view returns (ITradingRewards) {
        return ITradingRewards(requireAndGetAddress(CONTRACT_TRADING_REWARDS));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="44" endline="46" pcid="1328">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="159" endline="161" pcid="822">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="42" endline="44" pcid="1518">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="66" endline="68" pcid="1982">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="40" endline="42" pcid="1327">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="163" endline="165" pcid="823">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="36" endline="38" pcid="1326">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="66" endline="68" pcid="153">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="97" endline="99" pcid="447">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="70" endline="72" pcid="154">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="137" endline="139" pcid="593">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="126" endline="128" pcid="456">
    function exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="42" endline="44" pcid="1539">
    function oldRewardEscrow() internal view returns (IRewardEscrow) {
        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="46" endline="48" pcid="1540">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="153" endline="155" pcid="597">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="74" endline="76" pcid="155">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="78" endline="80" pcid="156">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXCHANGERATES));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="82" endline="84" pcid="157">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEM_STATUS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="167" endline="169" pcid="824">
    function synthetixEscrow() internal view returns (IHasBalance) {
        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="171" endline="173" pcid="825">
    function debtCache() internal view returns (IIssuerInternalDebtCache) {
        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="79" endline="81" pcid="1230">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="175" endline="177" pcid="826">
    function synthRedeemer() internal view returns (ISynthRedeemer) {
        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="134" endline="136" pcid="458">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="142" endline="144" pcid="460">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="217" endline="219" pcid="677">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="157" endline="159" pcid="598">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="83" endline="85" pcid="15">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="179" endline="181" pcid="827">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="85" endline="87" pcid="422">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="161" endline="163" pcid="599">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="59" endline="61" pcid="1580">
    function _short() internal view returns (ICollateralErc20) {
        return ICollateralErc20(requireAndGetAddress(CONTRACT_SHORT));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="146" endline="148" pcid="461">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="51" endline="53" pcid="1185">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="515" endline="517" pcid="361">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="130" endline="132" pcid="457">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="165" endline="167" pcid="600">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="81" endline="83" pcid="421">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="93" endline="95" pcid="446">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="511" endline="513" pcid="360">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="69" endline="71" pcid="753">
    function _sUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="73" endline="75" pcid="754">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="77" endline="79" pcid="755">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="507" endline="509" pcid="359">
    function synthsUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="70" endline="72" pcid="1983">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="64" endline="66" pcid="91">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="68" endline="70" pcid="92">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="72" endline="74" pcid="93">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="112" endline="114" pcid="174">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="76" endline="78" pcid="94">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="80" endline="82" pcid="95">
    function liquidatorRewards() internal view returns (ILiquidatorRewards) {
        return ILiquidatorRewards(requireAndGetAddress(CONTRACT_LIQUIDATORREWARDS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="84" endline="86" pcid="96">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="150" endline="152" pcid="462">
    function debtCache() internal view returns (IExchangerInternalDebtCache) {
        return IExchangerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="33" endline="35" pcid="777">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="200" endline="202" pcid="1644">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="204" endline="206" pcid="1645">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="169" endline="171" pcid="601">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="208" endline="210" pcid="1646">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="212" endline="214" pcid="1647">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="216" endline="218" pcid="1648">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="41" endline="43" pcid="1658">
    function rewardEscrow() internal view returns (IRewardEscrow) {
        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="45" endline="47" pcid="1659">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="49" endline="51" pcid="1660">
    function supplySchedule() internal view returns (ISupplySchedule) {
        return ISupplySchedule(requireAndGetAddress(CONTRACT_SUPPLYSCHEDULE));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="120" endline="122" pcid="176">
    function _synthsUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="124" endline="126" pcid="177">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="128" endline="130" pcid="178">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="36" endline="38" pcid="1681">
    function synthetixERC20() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="141" endline="143" pcid="594">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="40" endline="42" pcid="1682">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="132" endline="134" pcid="179">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="58" endline="60" pcid="899">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="136" endline="138" pcid="180">
    function _collateralUtil() internal view returns (ICollateralUtil) {
        return ICollateralUtil(requireAndGetAddress(CONTRACT_COLLATERALUTIL));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="36" endline="38" pcid="2030">
    function synthsUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTH_SUSD));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="141" endline="143" pcid="230">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="62" endline="64" pcid="900">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="122" endline="124" pcid="455">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="44" endline="46" pcid="2032">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="125" endline="127" pcid="590">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="66" endline="68" pcid="901">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="75" endline="77" pcid="13">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="32" endline="34" pcid="1745">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="36" endline="38" pcid="1746">
    function sUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="99" endline="101" pcid="19">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="95" endline="97" pcid="18">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="70" endline="72" pcid="902">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="91" endline="93" pcid="17">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="87" endline="89" pcid="16">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="143" endline="145" pcid="818">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="137" endline="139" pcid="229">
    function _issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="77" endline="79" pcid="420">
    function synthsETH() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSETH));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="73" endline="75" pcid="419">
    function synthsUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="114" endline="116" pcid="453">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="40" endline="42" pcid="2031">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="78" endline="80" pcid="930">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="74" endline="76" pcid="929">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="70" endline="72" pcid="928">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="66" endline="68" pcid="927">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="145" endline="147" pcid="595">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="118" endline="120" pcid="454">
    function exchangeState() internal view returns (IExchangeState) {
        return IExchangeState(requireAndGetAddress(CONTRACT_EXCHANGESTATE));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="89" endline="91" pcid="445">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
</class>

<class classid="8" nclones="60" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="103" endline="105" pcid="20">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="182" endline="184" pcid="1787">
    function etherWrapperMintFeeRate() external view returns (uint) {
        return getEtherWrapperMintFeeRate();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="209" endline="211" pcid="829">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="176" endline="178" pcid="1786">
    function etherWrapperMaxETH() external view returns (uint) {
        return getEtherWrapperMaxETH();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="166" endline="168" pcid="1784">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="160" endline="162" pcid="1783">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="156" endline="158" pcid="1782">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="132" endline="134" pcid="430">
    function mintFeeRate() public view returns (uint256) {
        return getEtherWrapperMintFeeRate();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="152" endline="154" pcid="1781">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="116" endline="118" pcid="1775">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="117" endline="119" pcid="1439">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="109" endline="111" pcid="1774">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="103" endline="105" pcid="1773">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="97" endline="99" pcid="1772">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="30" endline="32" pcid="1671">
    function counterpart() internal view returns (address) {
        return synthetixBridgeToOptimism();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="140" endline="142" pcid="789">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="91" endline="93" pcid="1771">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="83" endline="85" pcid="1770">
    function snxLiquidationPenalty() external view returns (uint) {
        return getSnxLiquidationPenalty();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="132" endline="134" pcid="788">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="77" endline="79" pcid="1769">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="188" endline="190" pcid="1788">
    function etherWrapperBurnFeeRate() external view returns (uint) {
        return getEtherWrapperBurnFeeRate();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="71" endline="73" pcid="1768">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="64" endline="66" pcid="1767">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="140" endline="142" pcid="1442">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="58" endline="60" pcid="1766">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="53" endline="55" pcid="1765">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="220" endline="222" pcid="1794">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="226" endline="228" pcid="1795">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="45" endline="47" pcid="1764">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="39" endline="41" pcid="1763">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="32" endline="34" pcid="1762">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="49" endline="51" pcid="560">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="102" endline="104" pcid="910">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="132" endline="134" pcid="1441">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="125" endline="127" pcid="1440">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="84" endline="86" pcid="510">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="155" endline="157" pcid="791">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="98" endline="100" pcid="909">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="94" endline="96" pcid="908">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="90" endline="92" pcid="907">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="86" endline="88" pcid="906">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="181" endline="183" pcid="604">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="82" endline="84" pcid="905">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="88" endline="90" pcid="511">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="78" endline="80" pcid="904">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="177" endline="179" pcid="603">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="74" endline="76" pcid="903">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="173" endline="175" pcid="602">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="158" endline="160" pcid="464">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="162" endline="164" pcid="465">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="35" endline="37" pcid="549">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="166" endline="168" pcid="466">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="138" endline="140" pcid="2019">
    function secsLeftInWaitingPeriod() external view returns (uint) {
        return secsLeft();
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="128" endline="130" pcid="2017">
    function rate() external view returns (uint) {
        return calcRate();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="136" endline="138" pcid="431">
    function burnFeeRate() public view returns (uint256) {
        return getEtherWrapperBurnFeeRate();
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="76" endline="78" pcid="442">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="128" endline="130" pcid="429">
    function maxETH() public view returns (uint256) {
        return getEtherWrapperMaxETH();
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="60" endline="62" pcid="1687">
    function counterpart() internal view returns (address) {
        return synthetixBridgeToBase();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="147" endline="149" pcid="790">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="374" endline="376" pcid="843">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
</class>

<class classid="9" nclones="22" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="107" endline="109" pcid="21">
    function cachedDebt() external view returns (uint) {
        return _cachedDebt;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="31" endline="33" pcid="1565">
    function preciseUnit() external pure returns (uint) {
        return PRECISE_UNIT;
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="61" endline="63" pcid="1842">
    function contractName() external view returns (bytes32) {
        return SETTINGS_CONTRACT_NAME;
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="32" endline="34" pcid="1593">
    function preciseUnit() external pure returns (int) {
        return PRECISE_UNIT;
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="12" endline="14" pcid="1954">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="24" endline="26" pcid="1564">
    function unit() external pure returns (uint) {
        return UNIT;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="110" endline="112" pcid="1275">
    function latestRound() public view returns (uint256) {
        return roundId;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="49" endline="51" pcid="1609">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="115" endline="117" pcid="23">
    function cacheTimestamp() external view returns (uint) {
        return _cacheTimestamp;
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="12" endline="14" pcid="1964">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="74" endline="76" pcid="1984">
    function getAvailableRewards() external view returns (uint) {
        return _balanceAssignedToRewards;
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="25" endline="27" pcid="1592">
    function unit() external pure returns (int) {
        return UNIT;
    }
</source>
<source file="systems/source-code/OneWeekSetup.sol" startline="10" endline="12" pcid="1345">
    function publicSetupExpiryTime() public view returns (uint) {
        return setupExpiryTime;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="86" endline="88" pcid="1987">
    function getPeriodController() external view returns (address) {
        return _periodController;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="90" endline="92" pcid="1988">
    function getCurrentPeriod() external view returns (uint) {
        return _currentPeriodID;
    }
</source>
<source file="systems/source-code/WETH.sol" startline="41" endline="46" pcid="2025">
    function totalSupply() public view returns (uint) {
        // Using _totalSupply instead of balanceOf[this]
        // as it would cause error in OVM compile
        // return address(this).balance;
        return _totalSupply;
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="81" endline="83" pcid="277">
    function ratesLastUpdated() public view returns (uint) {
        return borrowRatesLastUpdated;
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="65" endline="67" pcid="1581">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="140" endline="142" pcid="432">
    function weth() public view returns (IWETH) {
        return _weth;
    }
</source>
<source file="systems/source-code/MockMutator.sol" startline="6" endline="8" pcid="1309">
    function read() external view returns (uint) {
        return count;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="119" endline="121" pcid="24">
    function cacheInvalid() external view returns (bool) {
        return _cacheInvalid;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="114" endline="116" pcid="1276">
    function decimals() external view returns (uint8) {
        return keyDecimals;
    }
</source>
</class>

<class classid="10" nclones="19" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="130" endline="132" pcid="26">
    function cacheStale() external view returns (bool) {
        return _cacheStale(_cacheTimestamp);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="44" endline="46" pcid="1683">
    function rewardsDistribution() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="48" endline="50" pcid="1684">
    function synthetixBridgeToBase() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_OVM_SYNTHETIXBRIDGETOBASE);
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="32" endline="34" pcid="1356">
    function _ownerRelayOnEthereum() private view returns (address) {
        return requireAndGetAddress(CONTRACT_BASE_OWNER_RELAY_ON_ETHEREUM);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="26" endline="28" pcid="1670">
    function synthetixBridgeToOptimism() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_BASE_SYNTHETIXBRIDGETOOPTIMISM);
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="84" endline="86" pcid="444">
    function exchangeRates() public view returns (address) {
        return requireAndGetAddress(CONTRACT_EXRATES);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="175" endline="177" pcid="1369">
    function _settings() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_PERPSV2SETTINGS);
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="38" endline="40" pcid="1538">
    function synthetixBridgeToOptimism() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="119" endline="121" pcid="162">
    function synthTransferReceived() external view returns (uint) {
        return _sumTransferAmounts(SYNTH_TRANSFER_RECV);
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="112" endline="114" pcid="564">
    function _virtualSynthMastercopy() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_VIRTUALSYNTH_MASTERCOPY);
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="21" endline="23" pcid="1956">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="52" endline="54" pcid="1685">
    function synthetixBridgeEscrow() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIXBRIDGEESCROW);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="21" endline="23" pcid="1966">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/ImportableRewardEscrowV2.sol" startline="25" endline="27" pcid="811">
    function synthetixBridgeToBase() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE_BASE);
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="221" endline="223" pcid="678">
    function _settings() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_FUTURESMARKETSETTINGS);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="115" endline="117" pcid="161">
    function synthTransferSent() external view returns (uint) {
        return _sumTransferAmounts(SYNTH_TRANSFER_SENT);
    }
</source>
<source file="systems/source-code/FakeTradingRewards.sol" startline="20" endline="22" pcid="587">
    function synthetix() internal view returns (IERC20) {
        return IERC20(_mockSynthetixToken);
    }
</source>
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="28" endline="30" pcid="1350">
    function _ownerRelayOnOptimism() private view returns (address) {
        return requireAndGetAddress(CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM);
    }
</source>
<source file="systems/source-code/MintableSynthetix.sol" startline="44" endline="46" pcid="1180">
    function synthetixBridge() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE);
    }
</source>
</class>

<class classid="11" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="184" endline="191" pcid="30">
    function _cachedSynthDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {
        uint numKeys = currencyKeys.length;
        uint[] memory debts = new uint[](numKeys);
        for (uint i = 0; i < numKeys; i++) {
            debts[i] = _cachedSynthDebt[currencyKeys[i]];
        }
        return debts;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="197" endline="204" pcid="32">
    function _excludedIssuedDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {
        uint numKeys = currencyKeys.length;
        uint[] memory debts = new uint[](numKeys);
        for (uint i = 0; i < numKeys; i++) {
            debts[i] = _excludedIssuedDebt[currencyKeys[i]];
        }
        return debts;
    }
</source>
</class>

<class classid="12" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="193" endline="195" pcid="31">
    function cachedSynthDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory snxIssuedDebts) {
        return _cachedSynthDebts(currencyKeys);
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="206" endline="208" pcid="33">
    function excludedIssuedDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory excludedDebts) {
        return _excludedIssuedDebts(currencyKeys);
    }
</source>
</class>

<class classid="13" nclones="14" nlines="4" similarity="75">
<source file="systems/source-code/BaseOneNetAggregator.sol" startline="25" endline="29" pcid="53">
    function setOverrideTimestamp(uint timestamp) public onlyOwner {
        overrideTimestamp = timestamp;

        emit SetOverrideTimestamp(timestamp);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="328" endline="331" pcid="247">
    function setBaseBorrowRate(uint _baseBorrowRate) public onlyOwner {
        baseBorrowRate = _baseBorrowRate;
        emit BaseBorrowRateUpdated(baseBorrowRate);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="333" endline="336" pcid="248">
    function setBaseShortRate(uint _baseShortRate) public onlyOwner {
        baseShortRate = _baseShortRate;
        emit BaseShortRateUpdated(baseShortRate);
    }
</source>
<source file="systems/source-code/Depot.sol" startline="109" endline="114" pcid="341">
    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        // Do not allow us to set it less than 1 dollar opening up to fractional desposits in the queue again
        require(_amount > SafeDecimalMath.unit(), "Minimum deposit amount must be greater than UNIT");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="311" endline="315" pcid="244">
    function setUtilisationMultiplier(uint _utilisationMultiplier) public onlyOwner {
        require(_utilisationMultiplier > 0, "Must be greater than 0");
        utilisationMultiplier = _utilisationMultiplier;
        emit UtilisationMultiplierUpdated(utilisationMultiplier);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="317" endline="321" pcid="245">
    function setMaxDebt(uint _maxDebt) public onlyOwner {
        require(_maxDebt > 0, "Must be greater than 0");
        maxDebt = _maxDebt;
        emit MaxDebtUpdated(maxDebt);
    }
</source>
<source file="systems/source-code/SupplySchedule.sol" startline="132" endline="136" pcid="1629">
    function setMinterReward(uint amount) external onlyOwner {
        require(amount <= MAX_MINTER_REWARD, "Reward cannot exceed max minter reward");
        minterReward = amount;
        emit MinterRewardUpdated(minterReward);
    }
</source>
<source file="systems/source-code/SupplySchedule.sol" startline="154" endline="158" pcid="1631">
    function setInflationAmount(uint amount) external onlyOwner {
        require(amount <= maxInflationAmount, "Amount above maximum inflation");
        inflationAmount = amount;
        emit InflationAmountUpdated(inflationAmount);
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="186" endline="189" pcid="186">
    function setIssueFeeRate(uint _issueFeeRate) external onlyOwner {
        issueFeeRate = _issueFeeRate;
        emit IssueFeeRateUpdated(issueFeeRate);
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="181" endline="184" pcid="185">
    function setMinCollateral(uint _minCollateral) external onlyOwner {
        minCollateral = _minCollateral;
        emit MinCollateralUpdated(minCollateral);
    }
</source>
<source file="systems/source-code/Depot.sol" startline="91" endline="94" pcid="339">
    function setMaxEthPurchase(uint _maxEthPurchase) external onlyOwner {
        maxEthPurchase = _maxEthPurchase;
        emit MaxEthPurchaseUpdated(maxEthPurchase);
    }
</source>
<source file="systems/source-code/SupplySchedule.sol" startline="160" endline="163" pcid="1632">
    function setMaxInflationAmount(uint amount) external onlyOwner {
        maxInflationAmount = amount;
        emit MaxInflationAmountUpdated(inflationAmount);
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="58" endline="61" pcid="1541">
    function setMigrateEntriesThresholdAmount(uint amount) external onlyOwner {
        migrateEntriesThresholdAmount = amount;
        emit MigrateEntriesThresholdAmountUpdated(amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="323" endline="326" pcid="246">
    function setMaxSkewRate(uint _maxSkewRate) public onlyOwner {
        maxSkewRate = _maxSkewRate;
        emit MaxSkewRateUpdated(maxSkewRate);
    }
</source>
</class>

<class classid="14" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseOneNetAggregator.sol" startline="49" endline="51" pcid="56">
    function decimals() external view returns (uint8) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyEtherWrapper.sol" startline="10" endline="12" pcid="388">
    function totalIssuedSynths() public view returns (uint) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyFuturesMarketManager.sol" startline="18" endline="20" pcid="391">
    function numMarkets() external view returns (uint) {
        return 0;
    }
</source>
</class>

<class classid="15" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="81" endline="83" pcid="62">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="526" endline="529" pcid="546">
    function _notImplemented() internal pure {
        // slither-disable-next-line dead-code
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="1032" endline="1034" pcid="506">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="436" endline="438" pcid="138">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
</class>

<class classid="16" nclones="5" nlines="6" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="88" endline="93" pcid="63">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHETIX;
        addresses[1] = CONTRACT_FEEPOOL;
        addresses[2] = CONTRACT_ISSUER;
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="28" endline="33" pcid="2029">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTH_SUSD;
        addresses[1] = CONTRACT_FLEXIBLESTORAGE;
        addresses[2] = CONTRACT_FEEPOOL;
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="62" endline="67" pcid="752">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHSUSD;
        addresses[1] = CONTRACT_FEEPOOL;
        addresses[2] = CONTRACT_EXCHANGER;
    }
</source>
<source file="systems/source-code/Depot.sol" startline="465" endline="470" pcid="355">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHSUSD;
        addresses[1] = CONTRACT_EXRATES;
        addresses[2] = CONTRACT_SYNTHETIX;
    }
</source>
<source file="systems/source-code/TestableMixinResolver.sol" startline="15" endline="20" pcid="1962">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_EXAMPLE_1;
        addresses[1] = CONTRACT_EXAMPLE_2;
        addresses[2] = CONTRACT_EXAMPLE_3;
    }
</source>
</class>

<class classid="17" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="98" endline="100" pcid="64">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="53" endline="55" pcid="1610">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
<source file="systems/source-code/MockFlagsInterface.sol" startline="14" endline="16" pcid="1294">
    function getFlag(address aggregator) external view returns (bool) {
        return flags[aggregator];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="79" endline="81" pcid="1523">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="56" endline="58" pcid="1723">
    function balanceOf(address account) public view returns (uint) {
        return totalVestedAccountBalance[account];
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="69" endline="71" pcid="1582">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
</class>

<class classid="18" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="105" endline="107" pcid="65">
    function numVestingEntries(address account) external view returns (uint) {
        return accountVestingEntryIDs[account].length;
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="83" endline="85" pcid="1524">
    function _numVestingEntries(address account) internal view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="90" endline="92" pcid="1525">
    function numVestingEntries(address account) external view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="63" endline="65" pcid="1724">
    function numVestingEntries(address account) public view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
</class>

<class classid="19" nclones="5" nlines="5" similarity="75">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="294" endline="298" pcid="79">
    function setAccountMergingDuration(uint256 duration) external onlyOwner {
        require(duration <= maxAccountMergingDuration, "exceeds max merging duration");
        accountMergingDuration = duration;
        emit AccountMergingDurationUpdated(duration);
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="305" endline="308" pcid="81">
    function setMaxEscrowDuration(uint256 duration) external onlyOwner {
        max_duration = duration;
        emit MaxEscrowDurationUpdated(duration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="141" endline="148" pcid="1621">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="300" endline="303" pcid="80">
    function setMaxAccountMergingWindow(uint256 duration) external onlyOwner {
        maxAccountMergingDuration = duration;
        emit MaxAccountMergingDurationUpdated(duration);
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="146" endline="153" pcid="1591">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
</class>

<class classid="20" nclones="2" nlines="9" similarity="75">
<source file="systems/source-code/BaseSynthetix.sol" startline="54" endline="62" pcid="90">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](6);
        addresses[0] = CONTRACT_SYSTEMSTATUS;
        addresses[1] = CONTRACT_EXCHANGER;
        addresses[2] = CONTRACT_ISSUER;
        addresses[3] = CONTRACT_REWARDSDISTRIBUTION;
        addresses[4] = CONTRACT_LIQUIDATORREWARDS;
        addresses[5] = CONTRACT_LIQUIDATOR;
    }
</source>
<source file="systems/source-code/Synth.sol" startline="191" endline="198" pcid="1643">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](5);
        addresses[0] = CONTRACT_SYSTEMSTATUS;
        addresses[1] = CONTRACT_EXCHANGER;
        addresses[2] = CONTRACT_ISSUER;
        addresses[3] = CONTRACT_FEEPOOL;
        addresses[4] = CONTRACT_FUTURESMARKETMANAGER;
    }
</source>
</class>

<class classid="21" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="104" endline="106" pcid="101">
    function availableSynthCount() external view returns (uint) {
        return issuer().availableSynthCount();
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="37" endline="39" pcid="1335">
    function weth() internal view returns (IWETH) {
        return etherWrapper().weth();
    }
</source>
</class>

<class classid="22" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="112" endline="114" pcid="103">
    function synths(bytes32 currencyKey) external view returns (ISynth) {
        return issuer().synths(currencyKey);
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="170" endline="172" pcid="467">
    function lastExchangeRate(bytes32 currencyKey) external view returns (uint) {
        return exchangeCircuitBreaker().lastExchangeRate(currencyKey);
    }
</source>
</class>

<class classid="23" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="116" endline="118" pcid="104">
    function synthsByAddress(address synthAddress) external view returns (bytes32) {
        return issuer().synthsByAddress(synthAddress);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="144" endline="146" pcid="109">
    function collateralisationRatio(address _issuer) external view returns (uint) {
        return issuer().collateralisationRatio(_issuer);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="148" endline="150" pcid="110">
    function collateral(address account) external view returns (uint) {
        return issuer().collateral(account);
    }
</source>
</class>

<class classid="24" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="206" endline="216" pcid="115">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="123" endline="133" pcid="1664">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
</class>

<class classid="25" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="282" endline="284" pcid="120">
    function issueSynths(uint amount) external issuanceActive optionalProxy {
        return issuer().issueSynths(messageSender, amount);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="298" endline="300" pcid="124">
    function burnSynths(uint amount) external issuanceActive optionalProxy {
        return issuer().burnSynths(messageSender, amount);
    }
</source>
</class>

<class classid="26" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="286" endline="288" pcid="121">
    function issueSynthsOnBehalf(address issueForAddress, uint amount) external issuanceActive optionalProxy {
        return issuer().issueSynthsOnBehalf(issueForAddress, messageSender, amount);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="302" endline="304" pcid="125">
    function burnSynthsOnBehalf(address burnForAddress, uint amount) external issuanceActive optionalProxy {
        return issuer().burnSynthsOnBehalf(burnForAddress, messageSender, amount);
    }
</source>
</class>

<class classid="27" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="290" endline="292" pcid="122">
    function issueMaxSynths() external issuanceActive optionalProxy {
        return issuer().issueMaxSynths(messageSender);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="306" endline="308" pcid="126">
    function burnSynthsToTarget() external issuanceActive optionalProxy {
        return issuer().burnSynthsToTarget(messageSender);
    }
</source>
</class>

<class classid="28" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="294" endline="296" pcid="123">
    function issueMaxSynthsOnBehalf(address issueForAddress) external issuanceActive optionalProxy {
        return issuer().issueMaxSynthsOnBehalf(issueForAddress, messageSender);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="310" endline="312" pcid="127">
    function burnSynthsToTargetOnBehalf(address burnForAddress) external issuanceActive optionalProxy {
        return issuer().burnSynthsToTargetOnBehalf(burnForAddress, messageSender);
    }
</source>
</class>

<class classid="29" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="424" endline="426" pcid="135">
    function mintSecondary(address, uint) external {
        _notImplemented();
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="432" endline="434" pcid="137">
    function burnSecondary(address, uint) external {
        _notImplemented();
    }
</source>
</class>

<class classid="30" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="447" endline="449" pcid="139">
    function _systemActive() private view {
        systemStatus().requireSystemActive();
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="456" endline="458" pcid="140">
    function _issuanceActive() private view {
        systemStatus().requireIssuanceActive();
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="642" endline="644" pcid="209">
    function _requireIssuanceIsActive() private view {
        _systemStatus().requireIssuanceActive();
    }
</source>
</class>

<class classid="31" nclones="2" nlines="11" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="483" endline="493" pcid="143">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
<source file="systems/source-code/Synth.sol" startline="278" endline="288" pcid="1653">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
</class>

<class classid="32" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="542" endline="558" pcid="146">
    function emitSynthExchange(
        address account,
        bytes32 fromCurrencyKey,
        uint256 fromAmount,
        bytes32 toCurrencyKey,
        uint256 toAmount,
        address toAddress
    ) external onlyExchanger {
        proxy._emit(
            abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress),
            2,
            SYNTH_EXCHANGE_SIG,
            addressToBytes32(account),
            0,
            0
        );
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="198" endline="214" pcid="1667">
    function emitAtomicSynthExchange(
        address account,
        bytes32 fromCurrencyKey,
        uint256 fromAmount,
        bytes32 toCurrencyKey,
        uint256 toAmount,
        address toAddress
    ) external onlyExchanger {
        proxy._emit(
            abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress),
            2,
            ATOMIC_SYNTH_EXCHANGE_SIG,
            addressToBytes32(account),
            0,
            0
        );
    }
</source>
</class>

<class classid="33" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="575" endline="581" pcid="148">
    function emitExchangeReclaim(
        address account,
        bytes32 currencyKey,
        uint256 amount
    ) external onlyExchanger {
        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGERECLAIM_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="586" endline="592" pcid="149">
    function emitExchangeRebate(
        address account,
        bytes32 currencyKey,
        uint256 amount
    ) external onlyExchanger {
        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGEREBATE_SIG, addressToBytes32(account), 0, 0);
    }
</source>
</class>

<class classid="34" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="116" endline="118" pcid="175">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="145" endline="147" pcid="231">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
</class>

<class classid="35" nclones="2" nlines="15" similarity="70">
<source file="systems/source-code/Collateral.sol" startline="157" endline="177" pcid="184">
    function areSynthsAndCurrenciesSet(bytes32[] calldata _synthNamesInResolver, bytes32[] calldata _synthKeys)
        external
        view
        returns (bool)
    {
        if (synths.length != _synthNamesInResolver.length) {
            return false;
        }

        for (uint i = 0; i < _synthNamesInResolver.length; i++) {
            bytes32 synthName = _synthNamesInResolver[i];
            if (synths[i] != synthName) {
                return false;
            }
            if (synthsByKey[_synthKeys[i]] != synths[i]) {
                return false;
            }
        }

        return true;
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="380" endline="399" pcid="253">
    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)
        external
        view
        returns (bool)
    {
        if (_synths.elements.length != requiredSynthNamesInResolver.length) {
            return false;
        }

        for (uint i = 0; i < requiredSynthNamesInResolver.length; i++) {
            if (!_synths.contains(requiredSynthNamesInResolver[i])) {
                return false;
            }
            if (synthsByKey[synthKeys[i]] != requiredSynthNamesInResolver[i]) {
                return false;
            }
        }

        return true;
    }
</source>
</class>

<class classid="36" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="191" endline="194" pcid="187">
    function setCanOpenLoans(bool _canOpenLoans) external onlyOwner {
        canOpenLoans = _canOpenLoans;
        emit CanOpenLoansUpdated(canOpenLoans);
    }
</source>
<source file="systems/source-code/DappMaintenance.sol" startline="38" endline="41" pcid="308">
    function setMaintenanceModeSX(bool isPaused) external onlyOwner {
        isPausedSX = isPaused;
        emit SXMaintenance(isPausedSX);
    }
</source>
<source file="systems/source-code/DappMaintenance.sol" startline="33" endline="36" pcid="307">
    function setMaintenanceModeStaking(bool isPaused) external onlyOwner {
        isPausedStaking = isPaused;
        emit StakingMaintenance(isPausedStaking);
    }
</source>
</class>

<class classid="37" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="83" endline="89" pcid="214">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="53" endline="59" pcid="290">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="43" endline="49" pcid="223">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
</class>

<class classid="38" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="91" endline="93" pcid="215">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="82" endline="84" pcid="294">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="51" endline="53" pcid="224">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
</class>

<class classid="39" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="151" endline="153" pcid="232">
    function hasCollateral(address collateral) public view returns (bool) {
        return _collaterals.contains(collateral);
    }
</source>
<source file="systems/source-code/ExternStateToken.sol" startline="60" endline="62" pcid="577">
    function balanceOf(address account) external view returns (uint) {
        return tokenState.balanceOf(account);
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="10" endline="12" pcid="1937">
    function contains(address candidate) public view returns (bool) {
        return set.contains(candidate);
    }
</source>
</class>

<class classid="40" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="166" endline="168" pcid="234">
    function long(bytes32 synth) external view returns (uint amount) {
        return state.long(synth);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="170" endline="172" pcid="235">
    function short(bytes32 synth) external view returns (uint amount) {
        return state.short(synth);
    }
</source>
</class>

<class classid="41" nclones="2" nlines="8" similarity="80">
<source file="systems/source-code/CollateralManager.sol" startline="346" endline="353" pcid="250">
    function addCollaterals(address[] calldata collaterals) external onlyOwner {
        for (uint i = 0; i < collaterals.length; i++) {
            if (!_collaterals.contains(collaterals[i])) {
                _collaterals.add(collaterals[i]);
                emit CollateralAdded(collaterals[i]);
            }
        }
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="355" endline="362" pcid="251">
    function removeCollaterals(address[] calldata collaterals) external onlyOwner {
        for (uint i = 0; i < collaterals.length; i++) {
            if (_collaterals.contains(collaterals[i])) {
                _collaterals.remove(collaterals[i]);
                emit CollateralRemoved(collaterals[i]);
            }
        }
    }
</source>
</class>

<class classid="42" nclones="2" nlines="13" similarity="80">
<source file="systems/source-code/CollateralManager.sol" startline="364" endline="378" pcid="252">
    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external onlyOwner {
        require(synthNamesInResolver.length == synthKeys.length, "Input array length mismatch");

        for (uint i = 0; i < synthNamesInResolver.length; i++) {
            if (!_synths.contains(synthNamesInResolver[i])) {
                bytes32 synthName = synthNamesInResolver[i];
                _synths.add(synthName);
                _currencyKeys.add(synthKeys[i]);
                synthsByKey[synthKeys[i]] = synthName;
                emit SynthAdded(synthName);
            }
        }

        rebuildCache();
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="416" endline="439" pcid="255">
    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)
        external
        onlyOwner
    {
        require(requiredSynthNamesInResolver.length == synthKeys.length, "Input array length mismatch");

        for (uint i = 0; i < requiredSynthNamesInResolver.length; i++) {
            bytes32 synth = requiredSynthNamesInResolver[i];

            if (!_shortableSynths.contains(synth)) {
                // Add it to the address set lib.
                _shortableSynths.add(synth);

                shortableSynthsByKey[synthKeys[i]] = synth;

                emit ShortableSynthAdded(synth);

                // now the associated synth key to the CollateralManagerState
                state.addShortCurrency(synthKeys[i]);
            }
        }

        rebuildCache();
    }
</source>
</class>

<class classid="43" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="489" endline="491" pcid="260">
    function updateBorrowRatesCollateral(uint rate) external onlyCollateral {
        state.updateBorrowRates(rate);
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="84" endline="86" pcid="1740">
    function appendDebtLedgerValue(uint value) external onlyAssociatedContract {
        debtLedger.push(value);
    }
</source>
</class>

<class classid="44" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="493" endline="495" pcid="261">
    function updateShortRatesCollateral(bytes32 currency, uint rate) external onlyCollateral {
        state.updateShortRates(currency, rate);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="501" endline="503" pcid="263">
    function decrementLongs(bytes32 synth, uint amount) external onlyCollateral {
        state.decrementLongs(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="497" endline="499" pcid="262">
    function incrementLongs(bytes32 synth, uint amount) external onlyCollateral {
        state.incrementLongs(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="505" endline="507" pcid="264">
    function incrementShorts(bytes32 synth, uint amount) external onlyCollateral {
        state.incrementShorts(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="509" endline="511" pcid="265">
    function decrementShorts(bytes32 synth, uint amount) external onlyCollateral {
        state.decrementShorts(synth, amount);
    }
</source>
</class>

<class classid="45" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="42" endline="44" pcid="268">
    function long(bytes32 synth) external view onlyAssociatedContract returns (uint) {
        return totalIssuedSynths[synth].long;
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="46" endline="48" pcid="269">
    function short(bytes32 synth) external view onlyAssociatedContract returns (uint) {
        return totalIssuedSynths[synth].short;
    }
</source>
</class>

<class classid="46" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="50" endline="52" pcid="270">
    function incrementLongs(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.add(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="62" endline="64" pcid="273">
    function decrementShorts(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.sub(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="58" endline="60" pcid="272">
    function incrementShorts(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.add(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="54" endline="56" pcid="271">
    function decrementLongs(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.sub(amount);
    }
</source>
</class>

<class classid="47" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="72" endline="74" pcid="275">
    function getRatesLength() public view returns (uint) {
        return borrowRates.length;
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="50" endline="52" pcid="1475">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="93" endline="95" pcid="1741">
    function debtLedgerLength() external view returns (uint) {
        return debtLedger.length;
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="386" endline="388" pcid="846">
    function availableSynthCount() external view returns (uint) {
        return availableSynths.length;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="192" endline="194" pcid="1555">
    function distributionsLength() external view returns (uint) {
        return distributions.length;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="43" endline="45" pcid="1881">
    function systemSuspended() external view returns (bool) {
        return systemSuspension.suspended;
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="50" endline="52" pcid="1212">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
</class>

<class classid="48" nclones="8" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="110" endline="112" pcid="280">
    function removeShortCurrency(bytes32 currency) external onlyAssociatedContract {
        delete shortRates[currency];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="62" endline="64" pcid="405">
    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {
        delete AddressStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="49" endline="51" pcid="402">
    function deleteStringValue(bytes32 record) external onlyAssociatedContract {
        delete StringStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="114" endline="116" pcid="417">
    function deleteIntValue(bytes32 record) external onlyAssociatedContract {
        delete IntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="36" endline="38" pcid="399">
    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {
        delete UIntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="88" endline="90" pcid="411">
    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {
        delete Bytes32Storage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="101" endline="103" pcid="414">
    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {
        delete BooleanStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="75" endline="77" pcid="408">
    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {
        delete BytesStorage[record];
    }
</source>
</class>

<class classid="49" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/CollateralShort.sol" startline="29" endline="33" pcid="287">
    function close(uint id) external returns (uint amount, uint collateral) {
        (amount, collateral) = _close(msg.sender, id);

        IERC20(address(_synthsUSD())).transfer(msg.sender, collateral);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="61" endline="67" pcid="291">
    function closeWithCollateral(uint id) external returns (uint amount, uint collateral) {
        (amount, collateral) = _closeWithCollateral(msg.sender, id);

        if (collateral > 0) {
            IERC20(address(_synthsUSD())).transfer(msg.sender, collateral);
        }
    }
</source>
</class>

<class classid="50" nclones="8" nlines="6" similarity="80">
<source file="systems/source-code/CollateralUtil.sol" startline="27" endline="32" pcid="298">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="36" endline="41" pcid="1672">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetixBridge.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_BASE_SYNTHETIXBRIDGETOOPTIMISM;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="29" endline="34" pcid="1429">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = PerpsV2SettingsMixin.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/MintableSynthetix.sol" startline="37" endline="42" pcid="1179">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetix.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="40" endline="45" pcid="559">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Exchanger.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_VIRTUALSYNTH_MASTERCOPY;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="35" endline="40" pcid="1517">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="26" endline="31" pcid="776">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/ImportableRewardEscrowV2.sol" startline="18" endline="23" pcid="810">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseRewardEscrowV2.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE_BASE;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="51" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/DelegateApprovals.sol" startline="47" endline="49" pcid="320">
    function canBurnFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(BURN_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="55" endline="57" pcid="322">
    function canClaimFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(CLAIM_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="59" endline="61" pcid="323">
    function canExchangeFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(EXCHANGE_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="51" endline="53" pcid="321">
    function canIssueFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(ISSUE_FOR_ADDRESS, authoriser, delegate);
    }
</source>
</class>

<class classid="52" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/DelegateApprovals.sol" startline="83" endline="85" pcid="326">
    function approveAllDelegatePowers(address delegate) external {
        _setApproval(APPROVE_ALL, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="95" endline="97" pcid="328">
    function approveBurnOnBehalf(address delegate) external {
        _setApproval(BURN_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="104" endline="106" pcid="330">
    function approveIssueOnBehalf(address delegate) external {
        _setApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="117" endline="119" pcid="333">
    function removeClaimOnBehalf(address delegate) external {
        _withdrawApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="126" endline="128" pcid="335">
    function removeExchangeOnBehalf(address delegate) external {
        _withdrawApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="99" endline="101" pcid="329">
    function removeBurnOnBehalf(address delegate) external {
        _withdrawApproval(BURN_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="113" endline="115" pcid="332">
    function approveClaimOnBehalf(address delegate) external {
        _setApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="122" endline="124" pcid="334">
    function approveExchangeOnBehalf(address delegate) external {
        _setApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="108" endline="110" pcid="331">
    function removeIssueOnBehalf(address delegate) external {
        _withdrawApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
</class>

<class classid="53" nclones="4" nlines="5" similarity="75">
<source file="systems/source-code/DelegateApprovals.sol" startline="152" endline="156" pcid="338">
    function setEternalStorage(EternalStorage _eternalStorage) external onlyOwner {
        require(address(_eternalStorage) != address(0), "Can't set eternalStorage to address(0)");
        eternalStorage = _eternalStorage;
        emit EternalStorageUpdated(address(eternalStorage));
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="60" endline="63" pcid="1521">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="46" endline="49" pcid="1722">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="69" endline="72" pcid="1522">
    function setFeePool(IFeePool _feePool) external onlyOwner {
        feePool = _feePool;
        emit FeePoolUpdated(address(_feePool));
    }
</source>
</class>

<class classid="54" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Depot.sol" startline="477" endline="480" pcid="356">
    function synthetixReceivedForSynths(uint amount) public view returns (uint) {
        // And what would that be worth in SNX based on the current price?
        return amount.divideDecimal(exchangeRates().rateForCurrency(SNX));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="500" endline="503" pcid="358">
    function synthsReceivedForEther(uint amount) public view returns (uint) {
        // How many synths would that amount of ether be worth?
        return amount.multiplyDecimal(exchangeRates().rateForCurrency(ETH));
    }
</source>
</class>

<class classid="55" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="16" endline="18" pcid="364">
    function long(bytes32) external view returns (uint amount) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="20" endline="22" pcid="365">
    function short(bytes32) external view returns (uint amount) {
        return 0;
    }
</source>
</class>

<class classid="56" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="24" endline="26" pcid="366">
    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="28" endline="30" pcid="367">
    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyFuturesMarketManager.sol" startline="38" endline="40" pcid="395">
    function totalDebt() external view returns (uint debt, bool isInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="32" endline="34" pcid="368">
    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
</class>

<class classid="57" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="70" endline="72" pcid="373">
    function areSynthsAndCurrenciesSet(bytes32[] calldata, bytes32[] calldata) external view returns (bool) {
        return false;
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="74" endline="76" pcid="374">
    function areShortableSynthsSet(bytes32[] calldata, bytes32[] calldata) external view returns (bool) {
        return false;
    }
</source>
</class>

<class classid="58" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EtherWrapper.sol" startline="120" endline="122" pcid="427">
    function calculateMintFee(uint amount) public view returns (uint) {
        return amount.multiplyDecimalRound(mintFeeRate());
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="124" endline="126" pcid="428">
    function calculateBurnFee(uint amount) public view returns (uint) {
        return amount.multiplyDecimalRound(burnFeeRate());
    }
</source>
</class>

<class classid="59" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="711" endline="719" pcid="489">
    function reclaim(
        address from,
        bytes32 currencyKey,
        uint amount
    ) internal {
        // burn amount from user
        issuer().synths(currencyKey).burn(from, amount);
        ISynthetixInternal(address(synthetix())).emitExchangeReclaim(from, currencyKey, amount);
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="721" endline="729" pcid="490">
    function refund(
        address from,
        bytes32 currencyKey,
        uint amount
    ) internal {
        // issue amount to user
        issuer().synths(currencyKey).issue(from, amount);
        ISynthetixInternal(address(synthetix())).emitExchangeRebate(from, currencyKey, amount);
    }
</source>
</class>

<class classid="60" nclones="28" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="116" endline="118" pcid="514">
    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {
        return _getCurrentRoundId(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="87" endline="89" pcid="1437">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="121" endline="123" pcid="1776">
    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {
        return getExchangeFeeRate(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="49" endline="51" pcid="779">
    function makerFee(bytes32 _marketKey) public view returns (uint) {
        return _makerFee(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="232" endline="234" pcid="1796">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="56" endline="58" pcid="780">
    function takerFeeNextPrice(bytes32 _marketKey) external view returns (uint) {
        return _takerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="52" endline="54" pcid="1432">
    function baseFeeNextPrice(bytes32 _marketKey) external view returns (uint) {
        return _baseFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="77" endline="79" pcid="783">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="238" endline="240" pcid="1797">
    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {
        return getAtomicExchangeFeeRate(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="262" endline="264" pcid="1801">
    function crossChainSynthTransferEnabled(bytes32 currencyKey) external view returns (uint) {
        return getCrossChainSynthTransferEnabled(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="244" endline="246" pcid="1798">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="47" endline="49" pcid="552">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="80" endline="82" pcid="1436">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="256" endline="258" pcid="1800">
    function pureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) external view returns (bool) {
        return getPureChainlinkPriceForAtomicSwapsEnabled(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="73" endline="75" pcid="1435">
    function maxSingleSideValueUSD(bytes32 _marketKey) public view returns (uint) {
        return _maxSingleSideValueUSD(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="42" endline="44" pcid="778">
    function takerFee(bytes32 _marketKey) external view returns (uint) {
        return _takerFee(_marketKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="43" endline="45" pcid="551">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="84" endline="86" pcid="784">
    function maxMarketValueUSD(bytes32 _marketKey) public view returns (uint) {
        return _maxMarketValueUSD(_marketKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="39" endline="41" pcid="550">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="45" endline="47" pcid="1431">
    function baseFee(bytes32 _marketKey) external view returns (uint) {
        return _baseFee(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="63" endline="65" pcid="781">
    function makerFeeNextPrice(bytes32 _marketKey) public view returns (uint) {
        return _makerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="59" endline="61" pcid="1433">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="250" endline="252" pcid="1799">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="154" endline="156" pcid="517">
    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {
        return _getUpdatedTime(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="98" endline="100" pcid="786">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="91" endline="93" pcid="785">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="70" endline="72" pcid="782">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="66" endline="68" pcid="1434">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
</class>

<class classid="61" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="158" endline="166" pcid="518">
    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {
        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);

        for (uint i = 0; i < currencyKeys.length; i++) {
            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);
        }

        return lastUpdateTimes;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="242" endline="250" pcid="524">
    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {
        uint[] memory _localRates = new uint[](currencyKeys.length);

        for (uint i = 0; i < currencyKeys.length; i++) {
            _localRates[i] = _getRate(currencyKeys[i]);
        }

        return _localRates;
    }
</source>
</class>

<class classid="62" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="210" endline="212" pcid="522">
    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {
        return _getRateAndUpdatedTime(currencyKey).rate;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="452" endline="454" pcid="539">
    function _getRate(bytes32 currencyKey) internal view returns (uint256) {
        return _getRateAndUpdatedTime(currencyKey).rate;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="456" endline="458" pcid="540">
    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {
        return _getRateAndUpdatedTime(currencyKey).time;
    }
</source>
</class>

<class classid="63" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeState.sol" startline="18" endline="20" pcid="570">
    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {
        maxEntriesInQueue = _maxEntriesInQueue;
    }
</source>
<source file="systems/source-code/TestablePausable.sol" startline="14" endline="16" pcid="1963">
    function setSomeValue(uint _value) external notPaused {
        someValue = _value;
    }
</source>
<source file="systems/source-code/Synth.sol" startline="184" endline="186" pcid="1642">
    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {
        totalSupply = amount;
    }
</source>
<source file="systems/source-code/TestableTempOwned.sol" startline="13" endline="15" pcid="1971">
    function setTestValue(uint _testValue) external onlyTemporaryOwner {
        testValue = _testValue;
    }
</source>
</class>

<class classid="64" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExternStateToken.sol" startline="140" endline="146" pcid="584">
    function emitTransfer(
        address from,
        address to,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);
    }
</source>
<source file="systems/source-code/ExternStateToken.sol" startline="151" endline="157" pcid="585">
    function emitApproval(
        address owner,
        address spender,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);
    }
</source>
</class>

<class classid="65" nclones="2" nlines="16" similarity="76">
<source file="systems/source-code/FeePool.sol" startline="427" endline="453" pcid="618">
    function _recordFeePayment(uint sUSDAmount) internal returns (uint) {
        // Don't assign to the parameter
        uint remainingToAllocate = sUSDAmount;

        uint feesPaid;
        // Start at the oldest period and record the amount, moving to newer periods
        // until we've exhausted the amount.
        // The condition checks for overflow because we're going to 0 with an unsigned int.
        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {
            uint feesAlreadyClaimed = _recentFeePeriodsStorage(i).feesClaimed;
            uint delta = _recentFeePeriodsStorage(i).feesToDistribute.sub(feesAlreadyClaimed);

            if (delta > 0) {
                // Take the smaller of the amount left to claim in the period and the amount we need to allocate
                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;

                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed.add(amountInPeriod);
                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);
                feesPaid = feesPaid.add(amountInPeriod);

                // No need to continue iterating if we've recorded the whole amount;
                if (remainingToAllocate == 0) return feesPaid;
            }
        }

        return feesPaid;
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="459" endline="485" pcid="619">
    function _recordRewardPayment(uint snxAmount) internal returns (uint) {
        // Don't assign to the parameter
        uint remainingToAllocate = snxAmount;

        uint rewardPaid;

        // Start at the oldest period and record the amount, moving to newer periods
        // until we've exhausted the amount.
        // The condition checks for overflow because we're going to 0 with an unsigned int.
        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {
            uint toDistribute =
                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(_recentFeePeriodsStorage(i).rewardsClaimed);

            if (toDistribute > 0) {
                // Take the smaller of the amount left to claim in the period and the amount we need to allocate
                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;

                _recentFeePeriodsStorage(i).rewardsClaimed = _recentFeePeriodsStorage(i).rewardsClaimed.add(amountInPeriod);
                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);
                rewardPaid = rewardPaid.add(amountInPeriod);

                // No need to continue iterating if we've recorded the whole amount;
                if (remainingToAllocate == 0) return rewardPaid;
            }
        }
        return rewardPaid;
    }
</source>
</class>

<class classid="66" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="524" endline="534" pcid="622">
    function totalFeesAvailable() external view returns (uint) {
        uint totalFees = 0;

        // Fees in fee period [0] are not yet available for withdrawal
        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {
            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);
            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);
        }

        return totalFees;
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="539" endline="549" pcid="623">
    function totalRewardsAvailable() external view returns (uint) {
        uint totalRewards = 0;

        // Rewards in fee period [0] are not yet available for withdrawal
        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {
            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);
            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);
        }

        return totalRewards;
    }
</source>
</class>

<class classid="67" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/FlexibleStorage.sol" startline="69" endline="71" pcid="648">
    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint) {
        return uintStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="125" endline="127" pcid="656">
    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32) {
        return bytes32Storage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="83" endline="85" pcid="650">
    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int) {
        return intStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="111" endline="113" pcid="654">
    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool) {
        return boolStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="97" endline="99" pcid="652">
    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address) {
        return addressStorage[hashes[contractName]][record];
    }
</source>
</class>

<class classid="68" nclones="5" nlines="6" similarity="75">
<source file="systems/source-code/FlexibleStorage.sol" startline="148" endline="158" pcid="659">
    function setUIntValues(
        bytes32 contractName,
        bytes32[] calldata records,
        uint[] calldata values
    ) external onlyContract(contractName) {
        require(records.length == values.length, "Input lengths must match");

        for (uint i = 0; i < records.length; i++) {
            _setUIntValue(contractName, records[i], values[i]);
        }
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="200" endline="210" pcid="665">
    function setAddressValues(
        bytes32 contractName,
        bytes32[] calldata records,
        address[] calldata values
    ) external onlyContract(contractName) {
        require(records.length == values.length, "Input lengths must match");

        for (uint i = 0; i < records.length; i++) {
            _setAddressValue(contractName, records[i], values[i]);
        }
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="226" endline="236" pcid="668">
    function setBoolValues(
        bytes32 contractName,
        bytes32[] calldata records,
        bool[] calldata values
    ) external onlyContract(contractName) {
        require(records.length == values.length, "Input lengths must match");

        for (uint i = 0; i < records.length; i++) {
            _setBoolValue(contractName, records[i], values[i]);
        }
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="174" endline="184" pcid="662">
    function setIntValues(
        bytes32 contractName,
        bytes32[] calldata records,
        int[] calldata values
    ) external onlyContract(contractName) {
        require(records.length == values.length, "Input lengths must match");

        for (uint i = 0; i < records.length; i++) {
            _setIntValue(contractName, records[i], values[i]);
        }
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="252" endline="262" pcid="671">
    function setBytes32Values(
        bytes32 contractName,
        bytes32[] calldata records,
        bytes32[] calldata values
    ) external onlyContract(contractName) {
        require(records.length == values.length, "Input lengths must match");

        for (uint i = 0; i < records.length; i++) {
            _setBytes32Value(contractName, records[i], values[i]);
        }
    }
</source>
</class>

<class classid="69" nclones="5" nlines="5" similarity="75">
<source file="systems/source-code/FlexibleStorage.sol" startline="160" endline="164" pcid="660">
    function deleteUIntValue(bytes32 contractName, bytes32 record) external onlyContract(contractName) {
        uint value = uintStorage[hashes[contractName]][record];
        emit ValueDeletedUInt(contractName, record, value);
        delete uintStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="238" endline="242" pcid="669">
    function deleteBoolValue(bytes32 contractName, bytes32 record) external onlyContract(contractName) {
        bool value = boolStorage[hashes[contractName]][record];
        emit ValueDeletedBool(contractName, record, value);
        delete boolStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="212" endline="216" pcid="666">
    function deleteAddressValue(bytes32 contractName, bytes32 record) external onlyContract(contractName) {
        address value = addressStorage[hashes[contractName]][record];
        emit ValueDeletedAddress(contractName, record, value);
        delete addressStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="186" endline="190" pcid="663">
    function deleteIntValue(bytes32 contractName, bytes32 record) external onlyContract(contractName) {
        int value = intStorage[hashes[contractName]][record];
        emit ValueDeletedInt(contractName, record, value);
        delete intStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="264" endline="268" pcid="672">
    function deleteBytes32Value(bytes32 contractName, bytes32 record) external onlyContract(contractName) {
        bytes32 value = bytes32Storage[hashes[contractName]][record];
        emit ValueDeletedBytes32(contractName, record, value);
        delete bytes32Storage[hashes[contractName]][record];
    }
</source>
</class>

<class classid="70" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="232" endline="238" pcid="679">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="186" endline="192" pcid="1370">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
</class>

<class classid="71" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="240" endline="244" pcid="680">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="194" endline="198" pcid="1371">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
</class>

<class classid="72" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="246" endline="251" pcid="681">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="200" endline="205" pcid="1372">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
</class>

<class classid="73" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="257" endline="259" pcid="682">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="211" endline="213" pcid="1373">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
</class>

<class classid="74" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="261" endline="264" pcid="683">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="215" endline="218" pcid="1374">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
</class>

<class classid="75" nclones="2" nlines="18" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="271" endline="305" pcid="684">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="225" endline="259" pcid="1375">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
</class>

<class classid="76" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="307" endline="309" pcid="685">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="261" endline="263" pcid="1376">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
</class>

<class classid="77" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="311" endline="314" pcid="686">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="265" endline="268" pcid="1377">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
</class>

<class classid="78" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="316" endline="323" pcid="687">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="270" endline="277" pcid="1378">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
</class>

<class classid="79" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="328" endline="331" pcid="688">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="282" endline="285" pcid="1379">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
</class>

<class classid="80" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="339" endline="358" pcid="689">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="293" endline="312" pcid="1380">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
</class>

<class classid="81" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="360" endline="365" pcid="690">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="314" endline="319" pcid="1381">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
</class>

<class classid="82" nclones="2" nlines="17" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="367" endline="390" pcid="691">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="321" endline="344" pcid="1382">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
</class>

<class classid="83" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="400" endline="406" pcid="692">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="354" endline="360" pcid="1383">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
</class>

<class classid="84" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="418" endline="421" pcid="693">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="372" endline="375" pcid="1384">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
</class>

<class classid="85" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="423" endline="430" pcid="694">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="377" endline="384" pcid="1385">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
</class>

<class classid="86" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="432" endline="443" pcid="695">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="386" endline="397" pcid="1386">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
</class>

<class classid="87" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="462" endline="464" pcid="697">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="411" endline="413" pcid="1388">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
</class>

<class classid="88" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="466" endline="468" pcid="698">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="415" endline="417" pcid="1389">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
</class>

<class classid="89" nclones="2" nlines="37" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="470" endline="563" pcid="699">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxMarketValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="419" endline="512" pcid="1390">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxSingleSideValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
</class>

<class classid="90" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="570" endline="572" pcid="700">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="519" endline="521" pcid="1391">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="197" endline="199" pcid="1577">
    function signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
</class>

<class classid="91" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="577" endline="579" pcid="701">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="526" endline="528" pcid="1392">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="204" endline="206" pcid="1578">
    function abs(int x) internal pure returns (uint) {
        return uint(signedAbs(x));
    }
</source>
</class>

<class classid="92" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="581" endline="583" pcid="702">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="534" endline="536" pcid="1394">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="530" endline="532" pcid="1393">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="585" endline="587" pcid="703">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
</class>

<class classid="93" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="591" endline="593" pcid="704">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="540" endline="542" pcid="1395">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
</class>

<class classid="94" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="598" endline="600" pcid="705">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="547" endline="549" pcid="1396">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
</class>

<class classid="95" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="605" endline="609" pcid="706">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="554" endline="558" pcid="1397">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="96" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="614" endline="618" pcid="707">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="563" endline="567" pcid="1398">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="97" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/FuturesMarketBase.sol" startline="624" endline="629" pcid="708">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        // Ensure we catch uninitialised rates or suspended state / synth
        invalid = invalid || price == 0 || _systemStatus().synthSuspended(baseAsset);
        return (price, invalid);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="573" endline="576" pcid="1399">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        return (price, invalid);
    }
</source>
</class>

<class classid="98" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="658" endline="667" pcid="710">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="622" endline="631" pcid="1402">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
</class>

<class classid="99" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="676" endline="689" pcid="711">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method is the only mutative method that uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="640" endline="653" pcid="1403">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
</class>

<class classid="100" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="694" endline="724" pcid="712">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="658" endline="688" pcid="1404">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
</class>

<class classid="101" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="726" endline="736" pcid="713">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="690" endline="700" pcid="1405">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
</class>

<class classid="102" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="741" endline="745" pcid="714">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="705" endline="709" pcid="1406">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
</class>

<class classid="103" nclones="2" nlines="20" similarity="93">
<source file="systems/source-code/FuturesMarketBase.sol" startline="747" endline="779" pcid="715">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="711" endline="748" pcid="1407">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];

        // initialise id if not initialised and store update id=>account mapping
        _initPosition(sender, position);

        // add the margin
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
</class>

<class classid="104" nclones="2" nlines="16" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="782" endline="820" pcid="716">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);
        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="761" endline="800" pcid="1409">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);

        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
</class>

<class classid="105" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="838" endline="844" pcid="718">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="821" endline="827" pcid="1411">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
</class>

<class classid="106" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="908" endline="910" pcid="720">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="878" endline="880" pcid="1413">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="31" endline="33" pcid="1421">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="31" endline="33" pcid="1200">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="107" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="916" endline="918" pcid="721">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="886" endline="888" pcid="1414">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="37" endline="39" pcid="1201">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="37" endline="39" pcid="1422">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="108" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/FuturesMarketBase.sol" startline="920" endline="933" pcid="722">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="890" endline="897" pcid="1415">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: trackingCode})
        );
    }
</source>
</class>

<class classid="109" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="938" endline="940" pcid="723">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="902" endline="904" pcid="1416">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
</class>

<class classid="110" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="943" endline="945" pcid="724">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="907" endline="909" pcid="1417">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
</class>

<class classid="111" nclones="2" nlines="7" similarity="83">
<source file="systems/source-code/FuturesMarketBase.sol" startline="947" endline="962" pcid="725">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: -size,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="911" endline="920" pcid="1418">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({sizeDelta: -size, price: price, baseFee: _baseFee(marketKey), trackingCode: trackingCode})
        );
    }
</source>
</class>

<class classid="112" nclones="2" nlines="19" similarity="82">
<source file="systems/source-code/FuturesMarketBase.sol" startline="964" endline="1000" pcid="726">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position itself.
        delete positions[account];

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee));
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="922" endline="959" pcid="1419">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position size and margin
        delete positions[account].size;
        delete positions[account].margin;

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee), bytes32(0));
        }
    }
</source>
</class>

<class classid="113" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="1007" endline="1014" pcid="727">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="966" endline="973" pcid="1420">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
</class>

<class classid="114" nclones="2" nlines="14" similarity="75">
<source file="systems/source-code/FuturesMarketData.sol" startline="165" endline="192" pcid="733">
    function _marketSummaries(address[] memory markets) internal view returns (MarketSummary[] memory) {
        uint numMarkets = markets.length;
        MarketSummary[] memory summaries = new MarketSummary[](numMarkets);
        for (uint i; i < numMarkets; i++) {
            IFuturesMarket market = IFuturesMarket(markets[i]);
            bytes32 marketKey = market.marketKey();
            bytes32 baseAsset = market.baseAsset();
            IFuturesMarketSettings.Parameters memory params = _parameters(marketKey);

            (uint price, ) = market.assetPrice();
            (uint debt, ) = market.marketDebt();

            summaries[i] = MarketSummary(
                address(market),
                baseAsset,
                marketKey,
                params.maxLeverage,
                price,
                market.marketSize(),
                market.marketSkew(),
                debt,
                market.currentFundingRate(),
                FeeRates(params.takerFee, params.makerFee, params.takerFeeNextPrice, params.makerFeeNextPrice)
            );
        }

        return summaries;
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="145" endline="170" pcid="762">
    function _marketSummaries(address[] memory addresses) internal view returns (MarketSummary[] memory) {
        uint nMarkets = addresses.length;
        MarketSummary[] memory summaries = new MarketSummary[](nMarkets);
        for (uint i; i < nMarkets; i++) {
            IMarketViews market = IMarketViews(addresses[i]);
            bytes32 marketKey = market.marketKey();
            bytes32 baseAsset = market.baseAsset();

            (uint price, bool invalid) = market.assetPrice();
            (uint debt, ) = market.marketDebt();

            summaries[i] = MarketSummary({
                market: address(market),
                asset: baseAsset,
                marketKey: marketKey,
                price: price,
                marketSize: market.marketSize(),
                marketSkew: market.marketSkew(),
                marketDebt: debt,
                currentFundingRate: market.currentFundingRate(),
                priceInvalid: invalid
            });
        }

        return summaries;
    }
</source>
</class>

<class classid="115" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="194" endline="196" pcid="734">
    function marketSummaries(address[] calldata markets) external view returns (MarketSummary[] memory) {
        return _marketSummaries(markets);
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="172" endline="174" pcid="763">
    function marketSummaries(address[] calldata addresses) external view returns (MarketSummary[] memory) {
        return _marketSummaries(addresses);
    }
</source>
</class>

<class classid="116" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="270" endline="273" pcid="743">
    function _notionalValue(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.notionalValue(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="280" endline="283" pcid="745">
    function _accruedFunding(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.accruedFunding(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="275" endline="278" pcid="744">
    function _profitLoss(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.profitLoss(account);
        return value;
    }
</source>
</class>

<class classid="117" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="285" endline="288" pcid="746">
    function _remainingMargin(IFuturesMarket market, address account) internal view returns (uint) {
        (uint value, ) = market.remainingMargin(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="290" endline="293" pcid="747">
    function _accessibleMargin(IFuturesMarket market, address account) internal view returns (uint) {
        (uint value, ) = market.accessibleMargin(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="295" endline="298" pcid="748">
    function _liquidationPrice(IFuturesMarket market, address account) internal view returns (uint) {
        (uint liquidationPrice, ) = market.liquidationPrice(account);
        return liquidationPrice;
    }
</source>
</class>

<class classid="118" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketManager.sol" startline="84" endline="86" pcid="756">
    function markets(uint index, uint pageSize) external view returns (address[] memory) {
        return _markets.getPage(index, pageSize);
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="14" endline="16" pcid="1938">
    function getPage(uint index, uint pageSize) public view returns (address[] memory) {
        return set.getPage(index, pageSize);
    }
</source>
</class>

<class classid="119" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketManager.sol" startline="91" endline="93" pcid="757">
    function numMarkets() external view returns (uint) {
        return _markets.elements.length;
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="26" endline="28" pcid="1948">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="26" endline="28" pcid="1941">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
</class>

<class classid="120" nclones="2" nlines="10" similarity="70">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="102" endline="126" pcid="787">
    function parameters(bytes32 _marketKey)
        external
        view
        returns (
            uint takerFee,
            uint makerFee,
            uint takerFeeNextPrice,
            uint makerFeeNextPrice,
            uint nextPriceConfirmWindow,
            uint maxLeverage,
            uint maxMarketValueUSD,
            uint maxFundingRate,
            uint skewScaleUSD
        )
    {
        takerFee = _takerFee(_marketKey);
        makerFee = _makerFee(_marketKey);
        takerFeeNextPrice = _takerFeeNextPrice(_marketKey);
        makerFeeNextPrice = _makerFeeNextPrice(_marketKey);
        nextPriceConfirmWindow = _nextPriceConfirmWindow(_marketKey);
        maxLeverage = _maxLeverage(_marketKey);
        maxMarketValueUSD = _maxMarketValueUSD(_marketKey);
        maxFundingRate = _maxFundingRate(_marketKey);
        skewScaleUSD = _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="91" endline="111" pcid="1438">
    function parameters(bytes32 _marketKey)
        external
        view
        returns (
            uint baseFee,
            uint baseFeeNextPrice,
            uint nextPriceConfirmWindow,
            uint maxLeverage,
            uint maxSingleSideValueUSD,
            uint maxFundingRate,
            uint skewScaleUSD
        )
    {
        baseFee = _baseFee(_marketKey);
        baseFeeNextPrice = _baseFeeNextPrice(_marketKey);
        nextPriceConfirmWindow = _nextPriceConfirmWindow(_marketKey);
        maxLeverage = _maxLeverage(_marketKey);
        maxSingleSideValueUSD = _maxSingleSideValueUSD(_marketKey);
        maxFundingRate = _maxFundingRate(_marketKey);
        skewScaleUSD = _skewScaleUSD(_marketKey);
    }
</source>
</class>

<class classid="121" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="163" endline="170" pcid="792">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="148" endline="155" pcid="1443">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
</class>

<class classid="122" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="172" endline="175" pcid="793">
    function setTakerFee(bytes32 _marketKey, uint _takerFee) public onlyOwner {
        require(_takerFee <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE, _takerFee);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="157" endline="160" pcid="1444">
    function setBaseFee(bytes32 _marketKey, uint _baseFee) public onlyOwner {
        require(_baseFee <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_BASE_FEE, _baseFee);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="182" endline="185" pcid="795">
    function setTakerFeeNextPrice(bytes32 _marketKey, uint _takerFeeNextPrice) public onlyOwner {
        require(_takerFeeNextPrice <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE, _takerFeeNextPrice);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="162" endline="165" pcid="1445">
    function setBaseFeeNextPrice(bytes32 _marketKey, uint _baseFeeNextPrice) public onlyOwner {
        require(_baseFeeNextPrice <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_BASE_FEE_NEXT_PRICE, _baseFeeNextPrice);
    }
</source>
</class>

<class classid="123" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="177" endline="180" pcid="794">
    function setMakerFee(bytes32 _marketKey, uint _makerFee) public onlyOwner {
        require(_makerFee <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE, _makerFee);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="187" endline="190" pcid="796">
    function setMakerFeeNextPrice(bytes32 _marketKey, uint _makerFeeNextPrice) public onlyOwner {
        require(_makerFeeNextPrice <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE, _makerFeeNextPrice);
    }
</source>
</class>

<class classid="124" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="192" endline="194" pcid="797">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="175" endline="177" pcid="1448">
    function setMaxSingleSideValueUSD(bytes32 _marketKey, uint _maxSingleSideValueUSD) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_SINGLE_SIDE_VALUE, _maxSingleSideValueUSD);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="196" endline="198" pcid="798">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="171" endline="173" pcid="1447">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="200" endline="202" pcid="799">
    function setMaxMarketValueUSD(bytes32 _marketKey, uint _maxMarketValueUSD) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_MARKET_VALUE, _maxMarketValueUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="167" endline="169" pcid="1446">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
</class>

<class classid="125" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="207" endline="213" pcid="800">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IFuturesMarket market = IFuturesMarket(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="182" endline="188" pcid="1449">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IPerpsV2Market market = IPerpsV2Market(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
</class>

<class classid="126" nclones="4" nlines="4" similarity="75">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="215" endline="218" pcid="801">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="195" endline="199" pcid="1451">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="190" endline="193" pcid="1450">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="220" endline="224" pcid="802">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
</class>

<class classid="127" nclones="2" nlines="11" similarity="72">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="226" endline="248" pcid="803">
    function setParameters(
        bytes32 _marketKey,
        uint _takerFee,
        uint _makerFee,
        uint _takerFeeNextPrice,
        uint _makerFeeNextPrice,
        uint _nextPriceConfirmWindow,
        uint _maxLeverage,
        uint _maxMarketValueUSD,
        uint _maxFundingRate,
        uint _skewScaleUSD
    ) external onlyOwner {
        _recomputeFunding(_marketKey);
        setTakerFee(_marketKey, _takerFee);
        setMakerFee(_marketKey, _makerFee);
        setTakerFeeNextPrice(_marketKey, _takerFeeNextPrice);
        setMakerFeeNextPrice(_marketKey, _makerFeeNextPrice);
        setNextPriceConfirmWindow(_marketKey, _nextPriceConfirmWindow);
        setMaxLeverage(_marketKey, _maxLeverage);
        setMaxMarketValueUSD(_marketKey, _maxMarketValueUSD);
        setMaxFundingRate(_marketKey, _maxFundingRate);
        setSkewScaleUSD(_marketKey, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="201" endline="219" pcid="1452">
    function setParameters(
        bytes32 _marketKey,
        uint _baseFee,
        uint _baseFeeNextPrice,
        uint _nextPriceConfirmWindow,
        uint _maxLeverage,
        uint _maxSingleSideValueUSD,
        uint _maxFundingRate,
        uint _skewScaleUSD
    ) external onlyOwner {
        _recomputeFunding(_marketKey);
        setBaseFee(_marketKey, _baseFee);
        setBaseFeeNextPrice(_marketKey, _baseFeeNextPrice);
        setNextPriceConfirmWindow(_marketKey, _nextPriceConfirmWindow);
        setMaxLeverage(_marketKey, _maxLeverage);
        setMaxSingleSideValueUSD(_marketKey, _maxSingleSideValueUSD);
        setMaxFundingRate(_marketKey, _maxFundingRate);
        setSkewScaleUSD(_marketKey, _skewScaleUSD);
    }
</source>
</class>

<class classid="128" nclones="14" nlines="5" similarity="75">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="250" endline="254" pcid="804">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="237" endline="241" pcid="1456">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="221" endline="225" pcid="1453">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="261" endline="264" pcid="806">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="326" endline="329" pcid="1811">
    function setLiquidationEscrowDuration(uint duration) external onlyOwner {
        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_ESCROW_DURATION, duration);
        emit LiquidationEscrowDurationUpdated(duration);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="346" endline="349" pcid="1815">
    function setFlagReward(uint reward) external onlyOwner {
        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_FLAG_REWARD, reward);
        emit FlagRewardUpdated(reward);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="266" endline="270" pcid="807">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="386" endline="392" pcid="1820">
    function setExchangeDynamicFeeWeightDecay(uint weightDecay) external onlyOwner {
        require(weightDecay != 0, "Weight decay cannot be 0");

        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY, weightDecay);

        emit ExchangeDynamicFeeWeightDecayUpdated(weightDecay);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="232" endline="235" pcid="1455">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="227" endline="230" pcid="1454">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="256" endline="259" pcid="805">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="351" endline="354" pcid="1816">
    function setLiquidateReward(uint reward) external onlyOwner {
        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATE_REWARD, reward);
        emit LiquidateRewardUpdated(reward);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="375" endline="381" pcid="1819">
    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {
        require(threshold != 0, "Threshold cannot be 0");

        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);

        emit ExchangeDynamicFeeThresholdUpdated(threshold);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="397" endline="401" pcid="1821">
    function setExchangeDynamicFeeRounds(uint rounds) external onlyOwner {
        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS, rounds);

        emit ExchangeDynamicFeeRoundsUpdated(rounds);
    }
</source>
</class>

<class classid="129" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="297" endline="300" pcid="836">
    function _lastIssueEvent(address account) internal view returns (uint) {
        //  Get the timestamp of the last issue this account made
        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="247" endline="253" pcid="1260">
    function getCollapseFeeRate(address collateral) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="215" endline="221" pcid="1256">
    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="239" endline="245" pcid="1259">
    function getInteractionDelay(address collateral) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="223" endline="229" pcid="1257">
    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {
        return
            flexibleStorage().getIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="231" endline="237" pcid="1258">
    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {
        return
            flexibleStorage().getIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))
            );
    }
</source>
</class>

<class classid="130" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="327" endline="329" pcid="838">
    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {
        return amount.multiplyDecimalRound(snxRate);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="35" endline="37" pcid="1513">
    function divideDecimalRound(uint x, uint y) public pure returns (uint) {
        return x.divideDecimalRound(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="27" endline="29" pcid="1511">
    function multiplyDecimalRoundPrecise(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimalRoundPrecise(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="31" endline="33" pcid="1512">
    function divideDecimal(uint x, uint y) public pure returns (uint) {
        return x.divideDecimal(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="23" endline="25" pcid="1510">
    function multiplyDecimalRound(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimalRound(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="19" endline="21" pcid="1509">
    function multiplyDecimal(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimal(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="39" endline="41" pcid="1514">
    function divideDecimalRoundPrecise(uint x, uint y) public pure returns (uint) {
        return x.divideDecimalRoundPrecise(y);
    }
</source>
<source file="systems/source-code/PublicMath.sol" startline="11" endline="13" pcid="1506">
    function powerDecimal(uint x, uint y) public pure returns (uint) {
        return x.powDecimal(y);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="331" endline="333" pcid="839">
    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {
        return amount.divideDecimalRound(snxRate);
    }
</source>
</class>

<class classid="131" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="378" endline="380" pcid="844">
    function canBurnSynths(address account) external view returns (bool) {
        return _canBurnSynths(account);
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="134" endline="136" pcid="2018">
    function balanceOfUnderlying(address account) external view returns (uint) {
        return balanceUnderlying(account);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="210" endline="212" pcid="1792">
    function interactionDelay(address collateral) external view returns (uint) {
        return getInteractionDelay(collateral);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="414" endline="416" pcid="852">
    function collateral(address account) external view returns (uint) {
        return _collateral(account);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="398" endline="400" pcid="849">
    function lastIssueEvent(address account) external view returns (uint) {
        return _lastIssueEvent(account);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="194" endline="196" pcid="1789">
    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {
        return getWrapperMaxTokenAmount(wrapper);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="214" endline="216" pcid="1793">
    function collapseFeeRate(address collateral) external view returns (uint) {
        return getCollapseFeeRate(collateral);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="200" endline="202" pcid="1790">
    function wrapperMintFeeRate(address wrapper) external view returns (int) {
        return getWrapperMintFeeRate(wrapper);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="206" endline="208" pcid="1791">
    function wrapperBurnFeeRate(address wrapper) external view returns (int) {
        return getWrapperBurnFeeRate(wrapper);
    }
</source>
</class>

<class classid="132" nclones="2" nlines="9" similarity="75">
<source file="systems/source-code/Issuer.sol" startline="582" endline="602" pcid="864">
    function issueSynthsWithoutDebt(
        bytes32 currencyKey,
        address to,
        uint amount
    ) external onlyTrustedMinters returns (bool rateInvalid) {
        require(address(synths[currencyKey]) != address(0), "Issuer: synth doesn't exist");
        require(amount > 0, "Issuer: cannot issue 0 synths");

        // record issue timestamp
        _setLastIssueEvent(to);

        // Create their synths
        synths[currencyKey].issue(to, amount);

        // Account for the issued debt in the cache
        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);
        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount.multiplyDecimal(rate)));

        // returned so that the caller can decide what to do if the rate is invalid
        return rateInvalid;
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="604" endline="623" pcid="865">
    function burnSynthsWithoutDebt(
        bytes32 currencyKey,
        address from,
        uint amount
    ) external onlyTrustedMinters returns (bool rateInvalid) {
        require(address(synths[currencyKey]) != address(0), "Issuer: synth doesn't exist");
        require(amount > 0, "Issuer: cannot issue 0 synths");

        exchanger().settle(from, currencyKey);

        // Burn some synths
        synths[currencyKey].burn(from, amount);

        // Account for the burnt debt in the cache. If rate is invalid, the user won't be able to exchange
        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);
        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amount.multiplyDecimal(rate)));

        // returned so that the caller can decide what to do if the rate is invalid
        return rateInvalid;
    }
</source>
</class>

<class classid="133" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="647" endline="649" pcid="868">
    function issueMaxSynths(address from) external onlySynthetix {
        _issueSynths(from, 0, true);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="678" endline="680" pcid="873">
    function burnSynthsToTarget(address from) external onlySynthetix {
        _voluntaryBurnSynths(from, 0, true);
    }
</source>
</class>

<class classid="134" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="651" endline="658" pcid="869">
    function issueSynthsOnBehalf(
        address issueForAddress,
        address from,
        uint amount
    ) external onlySynthetix {
        _requireCanIssueOnBehalf(issueForAddress, from);
        _issueSynths(issueForAddress, amount, false);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="669" endline="676" pcid="872">
    function burnSynthsOnBehalf(
        address burnForAddress,
        address from,
        uint amount
    ) external onlySynthetix {
        _requireCanBurnOnBehalf(burnForAddress, from);
        _voluntaryBurnSynths(burnForAddress, amount, false);
    }
</source>
</class>

<class classid="135" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="660" endline="663" pcid="870">
    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {
        _requireCanIssueOnBehalf(issueForAddress, from);
        _issueSynths(issueForAddress, 0, true);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="682" endline="685" pcid="874">
    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {
        _requireCanBurnOnBehalf(burnForAddress, from);
        _voluntaryBurnSynths(burnForAddress, 0, true);
    }
</source>
</class>

<class classid="136" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="773" endline="775" pcid="880">
    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {
        require(delegateApprovals().canIssueFor(issueForAddress, from), "Not approved to act on behalf");
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="777" endline="779" pcid="881">
    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {
        require(delegateApprovals().canBurnFor(burnForAddress, from), "Not approved to act on behalf");
    }
</source>
</class>

<class classid="137" nclones="6" nlines="4" similarity="75">
<source file="systems/source-code/LegacyOwned.sol" startline="11" endline="14" pcid="893">
    function nominateOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
<source file="systems/source-code/LegacyTokenState.sol" startline="22" endline="25" pcid="895">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
<source file="systems/source-code/State.sol" startline="23" endline="26" pcid="1624">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
<source file="systems/source-code/TemporarilyOwned.sol" startline="21" endline="24" pcid="1934">
    function nominateNewOwner(address _owner) external onlyTemporaryOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="265" endline="271" pcid="2007">
    function setPeriodController(address newPeriodController) external onlyOwner {
        require(newPeriodController != address(0), "Invalid period controller");

        _periodController = newPeriodController;

        emit PeriodControllerChanged(newPeriodController);
    }
</source>
<source file="systems/source-code/Owned.sol" startline="14" endline="17" pcid="1346">
    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
</class>

<class classid="138" nclones="3" nlines="6" similarity="80">
<source file="systems/source-code/LegacyOwned.sol" startline="16" endline="21" pcid="894">
    function acceptOwnership() external {
        require(msg.sender == nominatedOwner);
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
</source>
<source file="systems/source-code/Owned.sol" startline="19" endline="24" pcid="1347">
    function acceptOwnership() external {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
</source>
<source file="systems/source-code/TemporarilyOwned.sol" startline="26" endline="32" pcid="1935">
    function acceptOwnership() external {
        require(block.timestamp < expiryTime, "Ownership expired");
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(temporaryOwner, nominatedOwner);
        temporaryOwner = nominatedOwner;
        nominatedOwner = address(0);
    }
</source>
</class>

<class classid="139" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="27" endline="33" pcid="896">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="25" endline="31" pcid="1979">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
</class>

<class classid="140" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="35" endline="37" pcid="897">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="39" endline="41" pcid="1980">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
</class>

<class classid="141" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="110" endline="113" pcid="912">
    function getLiquidationDeadlineForAccount(address account) external view returns (uint) {
        LiquidationEntry memory liquidation = _getLiquidationEntryForAccount(account);
        return liquidation.deadline;
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="115" endline="118" pcid="913">
    function getLiquidationCallerForAccount(address account) external view returns (address) {
        LiquidationEntry memory liquidation = _getLiquidationEntryForAccount(account);
        return liquidation.caller;
    }
</source>
</class>

<class classid="142" nclones="3" nlines="58" similarity="74">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="199" endline="322" pcid="936">
    function migrate2() external {
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUSD();
        // Ensure the sUSD synth can write to its TokenState;
        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);
        // Ensure the sUSD synth Proxy is correctly connected to the Synth;
        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sEUR();
        // Ensure the sEUR synth can write to its TokenState;
        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);
        // Ensure the sEUR synth Proxy is correctly connected to the Synth;
        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));
        // Ensure the ExchangeRates contract has the feed for sEUR;
        exchangerates_i.addAggregator("sEUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sJPY();
        // Ensure the sJPY synth can write to its TokenState;
        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);
        // Ensure the sJPY synth Proxy is correctly connected to the Synth;
        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));
        // Ensure the ExchangeRates contract has the feed for sJPY;
        exchangerates_i.addAggregator("sJPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAUD();
        // Ensure the sAUD synth can write to its TokenState;
        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);
        // Ensure the sAUD synth Proxy is correctly connected to the Synth;
        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));
        // Ensure the ExchangeRates contract has the feed for sAUD;
        exchangerates_i.addAggregator("sAUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sGBP();
        // Ensure the sGBP synth can write to its TokenState;
        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);
        // Ensure the sGBP synth Proxy is correctly connected to the Synth;
        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));
        // Ensure the ExchangeRates contract has the feed for sGBP;
        exchangerates_i.addAggregator("sGBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sCHF();
        // Ensure the sCHF synth can write to its TokenState;
        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);
        // Ensure the sCHF synth Proxy is correctly connected to the Synth;
        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));
        // Ensure the ExchangeRates contract has the feed for sCHF;
        exchangerates_i.addAggregator("sCHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sKRW();
        // Ensure the sKRW synth can write to its TokenState;
        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);
        // Ensure the sKRW synth Proxy is correctly connected to the Synth;
        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));
        // Ensure the ExchangeRates contract has the feed for sKRW;
        exchangerates_i.addAggregator("sKRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sBTC();
        // Ensure the sBTC synth can write to its TokenState;
        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);
        // Ensure the sBTC synth Proxy is correctly connected to the Synth;
        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));
        // Ensure the ExchangeRates contract has the feed for sBTC;
        exchangerates_i.addAggregator("sBTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETH();
        // Ensure the sETH synth can write to its TokenState;
        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);
        // Ensure the sETH synth Proxy is correctly connected to the Synth;
        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));
        // Ensure the ExchangeRates contract has the feed for sETH;
        exchangerates_i.addAggregator("sETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sLINK();
        // Ensure the sLINK synth can write to its TokenState;
        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);
        // Ensure the sLINK synth Proxy is correctly connected to the Synth;
        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));
        // Ensure the ExchangeRates contract has the feed for sLINK;
        exchangerates_i.addAggregator("sLINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sADA();
        // Ensure the sADA synth can write to its TokenState;
        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);
        // Ensure the sADA synth Proxy is correctly connected to the Synth;
        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));
        // Ensure the ExchangeRates contract has the feed for sADA;
        exchangerates_i.addAggregator("sADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAAVE();
        // Ensure the sAAVE synth can write to its TokenState;
        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);
        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;
        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));
        // Ensure the ExchangeRates contract has the feed for sAAVE;
        exchangerates_i.addAggregator("sAAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDOT();
        // Ensure the sDOT synth can write to its TokenState;
        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);
        // Ensure the sDOT synth Proxy is correctly connected to the Synth;
        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));
        // Ensure the ExchangeRates contract has the feed for sDOT;
        exchangerates_i.addAggregator("sDOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETHBTC();
        // Ensure the sETHBTC synth can write to its TokenState;
        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);
        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;
        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));
        // Ensure the ExchangeRates contract has the feed for sETHBTC;
        exchangerates_i.addAggregator("sETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDEFI();
        // Ensure the sDEFI synth can write to its TokenState;
        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);
        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;
        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));
        // Ensure the ExchangeRates contract has the feed for sDEFI;
        exchangerates_i.addAggregator("sDEFI", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_96();
        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);
        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="232" endline="348" pcid="1128">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUSD();
        // Ensure the sUSD synth can write to its TokenState;
        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);
        // Ensure the sUSD synth Proxy is correctly connected to the Synth;
        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sEUR();
        // Ensure the sEUR synth can write to its TokenState;
        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);
        // Ensure the sEUR synth Proxy is correctly connected to the Synth;
        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sJPY();
        // Ensure the sJPY synth can write to its TokenState;
        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);
        // Ensure the sJPY synth Proxy is correctly connected to the Synth;
        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAUD();
        // Ensure the sAUD synth can write to its TokenState;
        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);
        // Ensure the sAUD synth Proxy is correctly connected to the Synth;
        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sGBP();
        // Ensure the sGBP synth can write to its TokenState;
        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);
        // Ensure the sGBP synth Proxy is correctly connected to the Synth;
        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sCHF();
        // Ensure the sCHF synth can write to its TokenState;
        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);
        // Ensure the sCHF synth Proxy is correctly connected to the Synth;
        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sKRW();
        // Ensure the sKRW synth can write to its TokenState;
        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);
        // Ensure the sKRW synth Proxy is correctly connected to the Synth;
        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sBTC();
        // Ensure the sBTC synth can write to its TokenState;
        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);
        // Ensure the sBTC synth Proxy is correctly connected to the Synth;
        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETH();
        // Ensure the sETH synth can write to its TokenState;
        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);
        // Ensure the sETH synth Proxy is correctly connected to the Synth;
        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sLINK();
        // Ensure the sLINK synth can write to its TokenState;
        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);
        // Ensure the sLINK synth Proxy is correctly connected to the Synth;
        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sADA();
        // Ensure the sADA synth can write to its TokenState;
        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);
        // Ensure the sADA synth Proxy is correctly connected to the Synth;
        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAAVE();
        // Ensure the sAAVE synth can write to its TokenState;
        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);
        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;
        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDOT();
        // Ensure the sDOT synth can write to its TokenState;
        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);
        // Ensure the sDOT synth Proxy is correctly connected to the Synth;
        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETHBTC();
        // Ensure the sETHBTC synth can write to its TokenState;
        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);
        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;
        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDEFI();
        // Ensure the sDEFI synth can write to its TokenState;
        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);
        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;
        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_70();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="182" endline="272" pcid="1151">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUSD();
        // Ensure the sUSD synth can write to its TokenState;
        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);
        // Ensure the sUSD synth Proxy is correctly connected to the Synth;
        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETH();
        // Ensure the sETH synth can write to its TokenState;
        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);
        // Ensure the sETH synth Proxy is correctly connected to the Synth;
        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sBTC();
        // Ensure the sBTC synth can write to its TokenState;
        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);
        // Ensure the sBTC synth Proxy is correctly connected to the Synth;
        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sLINK();
        // Ensure the sLINK synth can write to its TokenState;
        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);
        // Ensure the sLINK synth Proxy is correctly connected to the Synth;
        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sSOL();
        // Ensure the sSOL synth can write to its TokenState;
        tokenstatessol_i.setAssociatedContract(new_SynthsSOL_contract);
        // Ensure the sSOL synth Proxy is correctly connected to the Synth;
        proxyssol_i.setTarget(Proxyable(new_SynthsSOL_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAVAX();
        // Ensure the sAVAX synth can write to its TokenState;
        tokenstatesavax_i.setAssociatedContract(new_SynthsAVAX_contract);
        // Ensure the sAVAX synth Proxy is correctly connected to the Synth;
        proxysavax_i.setTarget(Proxyable(new_SynthsAVAX_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sMATIC();
        // Ensure the sMATIC synth can write to its TokenState;
        tokenstatesmatic_i.setAssociatedContract(new_SynthsMATIC_contract);
        // Ensure the sMATIC synth Proxy is correctly connected to the Synth;
        proxysmatic_i.setTarget(Proxyable(new_SynthsMATIC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sEUR();
        // Ensure the sEUR synth can write to its TokenState;
        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);
        // Ensure the sEUR synth Proxy is correctly connected to the Synth;
        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAAVE();
        // Ensure the sAAVE synth can write to its TokenState;
        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);
        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;
        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUNI();
        // Ensure the sUNI synth can write to its TokenState;
        tokenstatesuni_i.setAssociatedContract(new_SynthsUNI_contract);
        // Ensure the sUNI synth Proxy is correctly connected to the Synth;
        proxysuni_i.setTarget(Proxyable(new_SynthsUNI_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sINR();
        // Ensure the sINR synth can write to its TokenState;
        tokenstatesinr_i.setAssociatedContract(new_SynthsINR_contract);
        // Ensure the sINR synth Proxy is correctly connected to the Synth;
        proxysinr_i.setTarget(Proxyable(new_SynthsINR_contract));
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_53();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="143" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="324" endline="330" pcid="937">
    function copyTotalSupplyFrom_sUSD() internal {
        // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA;
        Synth existingSynth = Synth(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);
        // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a;
        Synth newSynth = Synth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="453" endline="459" pcid="1134">
    function copyTotalSupplyFrom_sUSD() internal {
        // https://etherscan.io/address/0x7df9b3f8f1C011D8BD707430e97E747479DD532a;
        Synth existingSynth = Synth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        // https://etherscan.io/address/0x10A5F7D9D65bCc2734763444D4940a31b109275f;
        Synth newSynth = Synth(0x10A5F7D9D65bCc2734763444D4940a31b109275f);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="144" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="332" endline="338" pcid="938">
    function copyTotalSupplyFrom_sEUR() internal {
        // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0;
        Synth existingSynth = Synth(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);
        // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b;
        Synth newSynth = Synth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="461" endline="467" pcid="1135">
    function copyTotalSupplyFrom_sEUR() internal {
        // https://etherscan.io/address/0x1b06a00Df0B27E7871E753720D4917a7D1aac68b;
        Synth existingSynth = Synth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        // https://etherscan.io/address/0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9;
        Synth newSynth = Synth(0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="145" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="340" endline="346" pcid="939">
    function copyTotalSupplyFrom_sJPY() internal {
        // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A;
        Synth existingSynth = Synth(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);
        // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5;
        Synth newSynth = Synth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="469" endline="475" pcid="1136">
    function copyTotalSupplyFrom_sJPY() internal {
        // https://etherscan.io/address/0xB82f11f3168Ece7D56fe6a5679567948090de7C5;
        Synth existingSynth = Synth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        // https://etherscan.io/address/0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C;
        Synth newSynth = Synth(0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="146" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="348" endline="354" pcid="940">
    function copyTotalSupplyFrom_sAUD() internal {
        // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827;
        Synth existingSynth = Synth(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);
        // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C;
        Synth newSynth = Synth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="477" endline="483" pcid="1137">
    function copyTotalSupplyFrom_sAUD() internal {
        // https://etherscan.io/address/0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C;
        Synth existingSynth = Synth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        // https://etherscan.io/address/0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69;
        Synth newSynth = Synth(0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="147" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="356" endline="362" pcid="941">
    function copyTotalSupplyFrom_sGBP() internal {
        // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708;
        Synth existingSynth = Synth(0xde3892383965FBa6eC434bE6350F85f140098708);
        // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf;
        Synth newSynth = Synth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="485" endline="491" pcid="1138">
    function copyTotalSupplyFrom_sGBP() internal {
        // https://etherscan.io/address/0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf;
        Synth existingSynth = Synth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        // https://etherscan.io/address/0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD;
        Synth newSynth = Synth(0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="148" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="364" endline="370" pcid="942">
    function copyTotalSupplyFrom_sCHF() internal {
        // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D;
        Synth existingSynth = Synth(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);
        // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d;
        Synth newSynth = Synth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="493" endline="499" pcid="1139">
    function copyTotalSupplyFrom_sCHF() internal {
        // https://etherscan.io/address/0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d;
        Synth existingSynth = Synth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        // https://etherscan.io/address/0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88;
        Synth newSynth = Synth(0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="149" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="372" endline="378" pcid="943">
    function copyTotalSupplyFrom_sKRW() internal {
        // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455;
        Synth existingSynth = Synth(0xe2f532c389deb5E42DCe53e78A9762949A885455);
        // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C;
        Synth newSynth = Synth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="501" endline="507" pcid="1140">
    function copyTotalSupplyFrom_sKRW() internal {
        // https://etherscan.io/address/0x527637bE27640d6C3e751d24DC67129A6d13E11C;
        Synth existingSynth = Synth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        // https://etherscan.io/address/0xdAe6C79c46aB3B280Ca28259000695529cbD1339;
        Synth newSynth = Synth(0xdAe6C79c46aB3B280Ca28259000695529cbD1339);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="150" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="380" endline="386" pcid="944">
    function copyTotalSupplyFrom_sBTC() internal {
        // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353;
        Synth existingSynth = Synth(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);
        // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6;
        Synth newSynth = Synth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="509" endline="515" pcid="1141">
    function copyTotalSupplyFrom_sBTC() internal {
        // https://etherscan.io/address/0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6;
        Synth existingSynth = Synth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        // https://etherscan.io/address/0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7;
        Synth newSynth = Synth(0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="151" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="388" endline="394" pcid="945">
    function copyTotalSupplyFrom_sETH() internal {
        // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7;
        Synth existingSynth = Synth(0xc70B42930BD8D30A79B55415deC3be60827559f7);
        // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6;
        Synth newSynth = Synth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="517" endline="523" pcid="1142">
    function copyTotalSupplyFrom_sETH() internal {
        // https://etherscan.io/address/0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6;
        Synth existingSynth = Synth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        // https://etherscan.io/address/0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4;
        Synth newSynth = Synth(0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="152" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="396" endline="402" pcid="946">
    function copyTotalSupplyFrom_sLINK() internal {
        // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608;
        Synth existingSynth = Synth(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);
        // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6;
        Synth newSynth = Synth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="525" endline="531" pcid="1143">
    function copyTotalSupplyFrom_sLINK() internal {
        // https://etherscan.io/address/0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6;
        Synth existingSynth = Synth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        // https://etherscan.io/address/0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2;
        Synth newSynth = Synth(0xDF69bC4541b86Aa4c5A470B4347E730c38b2c3B2);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="153" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="404" endline="410" pcid="947">
    function copyTotalSupplyFrom_sADA() internal {
        // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a;
        Synth existingSynth = Synth(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);
        // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825;
        Synth newSynth = Synth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="533" endline="539" pcid="1144">
    function copyTotalSupplyFrom_sADA() internal {
        // https://etherscan.io/address/0xB34F4d7c207D8979D05EDb0F63f174764Bd67825;
        Synth existingSynth = Synth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        // https://etherscan.io/address/0x91b82d62Ff322b8e02b86f33E9A99a813437830d;
        Synth newSynth = Synth(0x91b82d62Ff322b8e02b86f33E9A99a813437830d);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="154" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="412" endline="418" pcid="948">
    function copyTotalSupplyFrom_sAAVE() internal {
        // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361;
        Synth existingSynth = Synth(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);
        // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e;
        Synth newSynth = Synth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="541" endline="547" pcid="1145">
    function copyTotalSupplyFrom_sAAVE() internal {
        // https://etherscan.io/address/0x95aE43E5E96314E4afffcf19D9419111cd11169e;
        Synth existingSynth = Synth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        // https://etherscan.io/address/0x942Eb6e8c029EB22103743C99985aF4F4515a559;
        Synth newSynth = Synth(0x942Eb6e8c029EB22103743C99985aF4F4515a559);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="155" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="420" endline="426" pcid="949">
    function copyTotalSupplyFrom_sDOT() internal {
        // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995;
        Synth existingSynth = Synth(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);
        // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5;
        Synth newSynth = Synth(0x27b45A4208b87A899009f45888139882477Acea5);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="549" endline="555" pcid="1146">
    function copyTotalSupplyFrom_sDOT() internal {
        // https://etherscan.io/address/0x27b45A4208b87A899009f45888139882477Acea5;
        Synth existingSynth = Synth(0x27b45A4208b87A899009f45888139882477Acea5);
        // https://etherscan.io/address/0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB;
        Synth newSynth = Synth(0x75A0c1597137AA36B40b6a515D997F9a6c6eefEB);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="156" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="428" endline="434" pcid="950">
    function copyTotalSupplyFrom_sETHBTC() internal {
        // https://etherscan.io/address/0xcc3aab773e2171b2E257Ee17001400eE378aa52B;
        Synth existingSynth = Synth(0xcc3aab773e2171b2E257Ee17001400eE378aa52B);
        // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662;
        Synth newSynth = Synth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="557" endline="563" pcid="1147">
    function copyTotalSupplyFrom_sETHBTC() internal {
        // https://etherscan.io/address/0x6DF798ec713b33BE823b917F27820f2aA0cf7662;
        Synth existingSynth = Synth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        // https://etherscan.io/address/0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD;
        Synth newSynth = Synth(0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="157" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="436" endline="442" pcid="951">
    function copyTotalSupplyFrom_sDEFI() internal {
        // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932;
        Synth existingSynth = Synth(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);
        // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124;
        Synth newSynth = Synth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="565" endline="571" pcid="1148">
    function copyTotalSupplyFrom_sDEFI() internal {
        // https://etherscan.io/address/0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124;
        Synth existingSynth = Synth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        // https://etherscan.io/address/0x918b1dbf0917FdD74D03fB9434915E2ECEc89286;
        Synth newSynth = Synth(0x918b1dbf0917FdD74D03fB9434915E2ECEc89286);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="158" nclones="18" nlines="12" similarity="70">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="444" endline="462" pcid="952">
    function issuer_addSynths_96() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_96_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_96_0[0] = ISynth(new_SynthsUSD_contract);
        issuer_addSynths_synthsToAdd_96_0[1] = ISynth(new_SynthsEUR_contract);
        issuer_addSynths_synthsToAdd_96_0[2] = ISynth(new_SynthsJPY_contract);
        issuer_addSynths_synthsToAdd_96_0[3] = ISynth(new_SynthsAUD_contract);
        issuer_addSynths_synthsToAdd_96_0[4] = ISynth(new_SynthsGBP_contract);
        issuer_addSynths_synthsToAdd_96_0[5] = ISynth(new_SynthsCHF_contract);
        issuer_addSynths_synthsToAdd_96_0[6] = ISynth(new_SynthsKRW_contract);
        issuer_addSynths_synthsToAdd_96_0[7] = ISynth(new_SynthsBTC_contract);
        issuer_addSynths_synthsToAdd_96_0[8] = ISynth(new_SynthsETH_contract);
        issuer_addSynths_synthsToAdd_96_0[9] = ISynth(new_SynthsLINK_contract);
        issuer_addSynths_synthsToAdd_96_0[10] = ISynth(new_SynthsADA_contract);
        issuer_addSynths_synthsToAdd_96_0[11] = ISynth(new_SynthsAAVE_contract);
        issuer_addSynths_synthsToAdd_96_0[12] = ISynth(new_SynthsDOT_contract);
        issuer_addSynths_synthsToAdd_96_0[13] = ISynth(new_SynthsETHBTC_contract);
        issuer_addSynths_synthsToAdd_96_0[14] = ISynth(new_SynthsDEFI_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_96_0);
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="453" endline="467" pcid="1168">
    function issuer_addSynths_53() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_53_0 = new ISynth[](11);
        issuer_addSynths_synthsToAdd_53_0[0] = ISynth(new_SynthsUSD_contract);
        issuer_addSynths_synthsToAdd_53_0[1] = ISynth(new_SynthsETH_contract);
        issuer_addSynths_synthsToAdd_53_0[2] = ISynth(new_SynthsBTC_contract);
        issuer_addSynths_synthsToAdd_53_0[3] = ISynth(new_SynthsLINK_contract);
        issuer_addSynths_synthsToAdd_53_0[4] = ISynth(new_SynthsSOL_contract);
        issuer_addSynths_synthsToAdd_53_0[5] = ISynth(new_SynthsAVAX_contract);
        issuer_addSynths_synthsToAdd_53_0[6] = ISynth(new_SynthsMATIC_contract);
        issuer_addSynths_synthsToAdd_53_0[7] = ISynth(new_SynthsEUR_contract);
        issuer_addSynths_synthsToAdd_53_0[8] = ISynth(new_SynthsAAVE_contract);
        issuer_addSynths_synthsToAdd_53_0[9] = ISynth(new_SynthsUNI_contract);
        issuer_addSynths_synthsToAdd_53_0[10] = ISynth(new_SynthsINR_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_53_0);
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="573" endline="591" pcid="1149">
    function issuer_addSynths_70() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_70_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_70_0[0] = ISynth(new_SynthsUSD_contract);
        issuer_addSynths_synthsToAdd_70_0[1] = ISynth(new_SynthsEUR_contract);
        issuer_addSynths_synthsToAdd_70_0[2] = ISynth(new_SynthsJPY_contract);
        issuer_addSynths_synthsToAdd_70_0[3] = ISynth(new_SynthsAUD_contract);
        issuer_addSynths_synthsToAdd_70_0[4] = ISynth(new_SynthsGBP_contract);
        issuer_addSynths_synthsToAdd_70_0[5] = ISynth(new_SynthsCHF_contract);
        issuer_addSynths_synthsToAdd_70_0[6] = ISynth(new_SynthsKRW_contract);
        issuer_addSynths_synthsToAdd_70_0[7] = ISynth(new_SynthsBTC_contract);
        issuer_addSynths_synthsToAdd_70_0[8] = ISynth(new_SynthsETH_contract);
        issuer_addSynths_synthsToAdd_70_0[9] = ISynth(new_SynthsLINK_contract);
        issuer_addSynths_synthsToAdd_70_0[10] = ISynth(new_SynthsADA_contract);
        issuer_addSynths_synthsToAdd_70_0[11] = ISynth(new_SynthsAAVE_contract);
        issuer_addSynths_synthsToAdd_70_0[12] = ISynth(new_SynthsDOT_contract);
        issuer_addSynths_synthsToAdd_70_0[13] = ISynth(new_SynthsETHBTC_contract);
        issuer_addSynths_synthsToAdd_70_0[14] = ISynth(new_SynthsDEFI_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_70_0);
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="89" endline="104" pcid="1066">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](13);
        contracts[0] = address(futuresmarketmanager_i);
        contracts[1] = address(addressresolver_i);
        contracts[2] = address(proxysynthetix_i);
        contracts[3] = address(exchangestate_i);
        contracts[4] = address(systemstatus_i);
        contracts[5] = address(tokenstatesynthetix_i);
        contracts[6] = address(rewardsdistribution_i);
        contracts[7] = address(exchangerates_i);
        contracts[8] = address(tokenstatesinr_i);
        contracts[9] = address(proxysinr_i);
        contracts[10] = address(issuer_i);
        contracts[11] = address(systemsettings_i);
        contracts[12] = address(futuresmarketsettings_i);
    }
</source>
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="296" endline="309" pcid="957">
    function issuer_addSynths_74() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_74_0 = new ISynth[](10);
        issuer_addSynths_synthsToAdd_74_0[0] = ISynth(new_SynthsUSD_contract);
        issuer_addSynths_synthsToAdd_74_0[1] = ISynth(new_SynthsETH_contract);
        issuer_addSynths_synthsToAdd_74_0[2] = ISynth(new_SynthsBTC_contract);
        issuer_addSynths_synthsToAdd_74_0[3] = ISynth(new_SynthsLINK_contract);
        issuer_addSynths_synthsToAdd_74_0[4] = ISynth(new_SynthsSOL_contract);
        issuer_addSynths_synthsToAdd_74_0[5] = ISynth(new_SynthsAVAX_contract);
        issuer_addSynths_synthsToAdd_74_0[6] = ISynth(new_SynthsMATIC_contract);
        issuer_addSynths_synthsToAdd_74_0[7] = ISynth(new_SynthsEUR_contract);
        issuer_addSynths_synthsToAdd_74_0[8] = ISynth(new_SynthsAAVE_contract);
        issuer_addSynths_synthsToAdd_74_0[9] = ISynth(new_SynthsUNI_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_74_0);
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="71" endline="83" pcid="1058">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](10);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(exchangestate_i);
        contracts[3] = address(systemstatus_i);
        contracts[4] = address(tokenstatesynthetix_i);
        contracts[5] = address(rewardescrow_i);
        contracts[6] = address(rewardsdistribution_i);
        contracts[7] = address(exchangerates_i);
        contracts[8] = address(issuer_i);
        contracts[9] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="70" endline="83" pcid="983">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](11);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxyfeepool_i);
        contracts[2] = address(feepooleternalstorage_i);
        contracts[3] = address(feepoolstate_i);
        contracts[4] = address(proxysynthetix_i);
        contracts[5] = address(tokenstatesynthetix_i);
        contracts[6] = address(synthetixstate_i);
        contracts[7] = address(rewardescrow_i);
        contracts[8] = address(rewardsdistribution_i);
        contracts[9] = address(feepool_i);
        contracts[10] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="67" endline="78" pcid="1002">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](9);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(exchangestate_i);
        contracts[3] = address(systemstatus_i);
        contracts[4] = address(tokenstatesynthetix_i);
        contracts[5] = address(rewardescrow_i);
        contracts[6] = address(rewardsdistribution_i);
        contracts[7] = address(issuer_i);
        contracts[8] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="64" endline="75" pcid="993">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](9);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxyfeepool_i);
        contracts[2] = address(feepooleternalstorage_i);
        contracts[3] = address(feepoolstate_i);
        contracts[4] = address(proxysynthetix_i);
        contracts[5] = address(tokenstatesynthetix_i);
        contracts[6] = address(rewardsdistribution_i);
        contracts[7] = address(feepool_i);
        contracts[8] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="64" endline="74" pcid="1010">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](8);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(exchangestate_i);
        contracts[3] = address(systemstatus_i);
        contracts[4] = address(tokenstatesynthetix_i);
        contracts[5] = address(rewardsdistribution_i);
        contracts[6] = address(issuer_i);
        contracts[7] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="67" endline="77" pcid="1106">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](8);
        contracts[0] = address(futuresmarketmanager_i);
        contracts[1] = address(addressresolver_i);
        contracts[2] = address(exchangerates_i);
        contracts[3] = address(tokenstateswti_i);
        contracts[4] = address(proxyswti_i);
        contracts[5] = address(issuer_i);
        contracts[6] = address(systemsettings_i);
        contracts[7] = address(futuresmarketsettings_i);
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="57" endline="66" pcid="1051">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](7);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(exchangestate_i);
        contracts[3] = address(tokenstatesynthetix_i);
        contracts[4] = address(rewardsdistribution_i);
        contracts[5] = address(exchangerates_i);
        contracts[6] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="50" endline="58" pcid="1035">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](6);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(tokenstatesynthetix_i);
        contracts[3] = address(rewardescrow_i);
        contracts[4] = address(supplyschedule_i);
        contracts[5] = address(rewardsdistribution_i);
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="46" endline="53" pcid="1041">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](5);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(collateralmanager_i);
        contracts[4] = address(collateralshort_i);
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="45" endline="52" pcid="1115">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](5);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(tokenstatesynthetix_i);
        contracts[3] = address(rewardescrow_i);
        contracts[4] = address(rewardsdistribution_i);
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="43" endline="49" pcid="975">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_Algol.sol" startline="43" endline="49" pcid="967">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="42" endline="48" pcid="1121">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(tokenstatesynthetix_i);
        contracts[3] = address(rewardsdistribution_i);
    }
</source>
</class>

<class classid="159" nclones="2" nlines="24" similarity="73">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="529" endline="552" pcid="954">
    function addressresolver_rebuildCaches_1() external {
        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);
        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);
        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);
        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(new_FeePool_contract);
        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xE95A536cF5C7384FF1ef54819Dc54E03d0FF1979);
        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(new_DebtCache_contract);
        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(new_Exchanger_contract);
        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(new_ExchangeCircuitBreaker_contract);
        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(new_Issuer_contract);
        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(new_SynthsUSD_contract);
        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(new_SynthsEUR_contract);
        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(new_SynthsJPY_contract);
        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(new_SynthsAUD_contract);
        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(new_SynthsGBP_contract);
        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SynthsCHF_contract);
        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(new_SynthsKRW_contract);
        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(new_SynthsBTC_contract);
        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(new_SynthsETH_contract);
        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(new_SynthsLINK_contract);
        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(new_SynthsADA_contract);
        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(new_SynthsAAVE_contract);
        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="432" endline="455" pcid="1031">
    function addressresolver_rebuildCaches_2() internal {
        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](20);
        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0x14E6f8e6Da00a32C069b11b64e48EA1FEF2361D4);
        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(new_FeePool_contract);
        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x8518f879a2B8138405E947A48326F55FF9D5f3aD);
        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(new_DebtCache_contract);
        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(new_Exchanger_contract);
        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(new_ExchangeCircuitBreaker_contract);
        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(new_Issuer_contract);
        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(new_SynthsUSD_contract);
        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(new_SynthsETH_contract);
        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(new_SynthsBTC_contract);
        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(new_SynthsLINK_contract);
        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(new_SynthsSOL_contract);
        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(new_SynthsAVAX_contract);
        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(new_SynthsMATIC_contract);
        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(new_SynthsEUR_contract);
        addressresolver_rebuildCaches_destinations_2_0[15] = MixinResolver(new_SynthsAAVE_contract);
        addressresolver_rebuildCaches_destinations_2_0[16] = MixinResolver(new_SynthsUNI_contract);
        addressresolver_rebuildCaches_destinations_2_0[17] = MixinResolver(0x308AD16ef90fe7caCb85B784A603CB6E71b1A41a);
        addressresolver_rebuildCaches_destinations_2_0[18] = MixinResolver(0xEbCe9728E2fDdC26C9f4B00df5180BdC5e184953);
        addressresolver_rebuildCaches_destinations_2_0[19] = MixinResolver(new_FuturesMarketBTC_contract);
        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);
    }
</source>
</class>

<class classid="160" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="311" endline="317" pcid="958">
    function copyTotalSupplyFrom_sUSD() internal {
        // https://explorer.optimism.io/address/0x78aAA3fb165deCAA729DFE3cf0E97Ab6FCF484da;
        Synth existingSynth = Synth(0x78aAA3fb165deCAA729DFE3cf0E97Ab6FCF484da);
        // https://explorer.optimism.io/address/0xD1599E478cC818AFa42A4839a6C665D9279C3E50;
        Synth newSynth = Synth(0xD1599E478cC818AFa42A4839a6C665D9279C3E50);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="365" endline="371" pcid="1157">
    function copyTotalSupplyFrom_sUSD() internal {
        // https://explorer.optimism.io/address/0xD1599E478cC818AFa42A4839a6C665D9279C3E50;
        Synth existingSynth = Synth(0xD1599E478cC818AFa42A4839a6C665D9279C3E50);
        // https://explorer.optimism.io/address/0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB;
        Synth newSynth = Synth(0xDfA2d3a0d32F870D87f8A0d7AA6b9CdEB7bc5AdB);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="161" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="319" endline="325" pcid="959">
    function copyTotalSupplyFrom_sETH() internal {
        // https://explorer.optimism.io/address/0xBD2657CF89F930F27eE1854EF4B389773DF43b29;
        Synth existingSynth = Synth(0xBD2657CF89F930F27eE1854EF4B389773DF43b29);
        // https://explorer.optimism.io/address/0x0681883084b5De1564FE2706C87affD77F1677D5;
        Synth newSynth = Synth(0x0681883084b5De1564FE2706C87affD77F1677D5);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="373" endline="379" pcid="1158">
    function copyTotalSupplyFrom_sETH() internal {
        // https://explorer.optimism.io/address/0x0681883084b5De1564FE2706C87affD77F1677D5;
        Synth existingSynth = Synth(0x0681883084b5De1564FE2706C87affD77F1677D5);
        // https://explorer.optimism.io/address/0xe9dceA0136FEFC76c4E639Ec60CCE70482E2aCF7;
        Synth newSynth = Synth(0xe9dceA0136FEFC76c4E639Ec60CCE70482E2aCF7);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="162" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="327" endline="333" pcid="960">
    function copyTotalSupplyFrom_sBTC() internal {
        // https://explorer.optimism.io/address/0x8Ce809a955DB85b41e7A378D7659e348e0C6AdD2;
        Synth existingSynth = Synth(0x8Ce809a955DB85b41e7A378D7659e348e0C6AdD2);
        // https://explorer.optimism.io/address/0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2;
        Synth newSynth = Synth(0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="381" endline="387" pcid="1159">
    function copyTotalSupplyFrom_sBTC() internal {
        // https://explorer.optimism.io/address/0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2;
        Synth existingSynth = Synth(0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2);
        // https://explorer.optimism.io/address/0x421DEF861D623F7123dfE0878D86E9576cbb3975;
        Synth newSynth = Synth(0x421DEF861D623F7123dfE0878D86E9576cbb3975);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="163" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="335" endline="341" pcid="961">
    function copyTotalSupplyFrom_sLINK() internal {
        // https://explorer.optimism.io/address/0xF33e7B48538C9D0480a48f3b5eEf79026e2a28f6;
        Synth existingSynth = Synth(0xF33e7B48538C9D0480a48f3b5eEf79026e2a28f6);
        // https://explorer.optimism.io/address/0x2302D7F7783e2712C48aA684451b9d706e74F299;
        Synth newSynth = Synth(0x2302D7F7783e2712C48aA684451b9d706e74F299);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="389" endline="395" pcid="1160">
    function copyTotalSupplyFrom_sLINK() internal {
        // https://explorer.optimism.io/address/0x2302D7F7783e2712C48aA684451b9d706e74F299;
        Synth existingSynth = Synth(0x2302D7F7783e2712C48aA684451b9d706e74F299);
        // https://explorer.optimism.io/address/0x0F6877e0Bb54a0739C6173A814B39D5127804123;
        Synth newSynth = Synth(0x0F6877e0Bb54a0739C6173A814B39D5127804123);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="164" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="343" endline="349" pcid="962">
    function copyTotalSupplyFrom_sSOL() internal {
        // https://explorer.optimism.io/address/0x8ab13Ca3b6591554a086B7Ad2A012d25C3efD704;
        Synth existingSynth = Synth(0x8ab13Ca3b6591554a086B7Ad2A012d25C3efD704);
        // https://explorer.optimism.io/address/0x91DBC6f587D043FEfbaAD050AB48696B30F13d89;
        Synth newSynth = Synth(0x91DBC6f587D043FEfbaAD050AB48696B30F13d89);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="397" endline="403" pcid="1161">
    function copyTotalSupplyFrom_sSOL() internal {
        // https://explorer.optimism.io/address/0x91DBC6f587D043FEfbaAD050AB48696B30F13d89;
        Synth existingSynth = Synth(0x91DBC6f587D043FEfbaAD050AB48696B30F13d89);
        // https://explorer.optimism.io/address/0x04B50a5992Ea2281E14d43494d656698EA9C24dD;
        Synth newSynth = Synth(0x04B50a5992Ea2281E14d43494d656698EA9C24dD);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="165" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="351" endline="357" pcid="963">
    function copyTotalSupplyFrom_sAVAX() internal {
        // https://explorer.optimism.io/address/0x5C2B0fdB3C828f087FDdA19Cf7F6fF7c51022aFb;
        Synth existingSynth = Synth(0x5C2B0fdB3C828f087FDdA19Cf7F6fF7c51022aFb);
        // https://explorer.optimism.io/address/0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D;
        Synth newSynth = Synth(0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="405" endline="411" pcid="1162">
    function copyTotalSupplyFrom_sAVAX() internal {
        // https://explorer.optimism.io/address/0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D;
        Synth existingSynth = Synth(0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D);
        // https://explorer.optimism.io/address/0x368A5126fF8e659004b6f9C9F723E15632e2B428;
        Synth newSynth = Synth(0x368A5126fF8e659004b6f9C9F723E15632e2B428);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="166" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="359" endline="365" pcid="964">
    function copyTotalSupplyFrom_sMATIC() internal {
        // https://explorer.optimism.io/address/0x6E3FfC4161931793B7FD084E761C0D12126FD376;
        Synth existingSynth = Synth(0x6E3FfC4161931793B7FD084E761C0D12126FD376);
        // https://explorer.optimism.io/address/0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e;
        Synth newSynth = Synth(0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="413" endline="419" pcid="1163">
    function copyTotalSupplyFrom_sMATIC() internal {
        // https://explorer.optimism.io/address/0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e;
        Synth existingSynth = Synth(0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e);
        // https://explorer.optimism.io/address/0xf49C194954b6B91855aC06D6C88Be316da60eD96;
        Synth newSynth = Synth(0xf49C194954b6B91855aC06D6C88Be316da60eD96);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="167" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MigrationLib_DiphdaOptimism.sol" startline="367" endline="373" pcid="965">
    function copyTotalSupplyFrom_sEUR() internal {
        // https://explorer.optimism.io/address/0x824dA469B59eC0E6E6BB5D611888aBF440970414;
        Synth existingSynth = Synth(0x824dA469B59eC0E6E6BB5D611888aBF440970414);
        // https://explorer.optimism.io/address/0xB16ef128b11e457afA07B09FCE52A01f5B05a937;
        Synth newSynth = Synth(0xB16ef128b11e457afA07B09FCE52A01f5B05a937);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="421" endline="427" pcid="1164">
    function copyTotalSupplyFrom_sEUR() internal {
        // https://explorer.optimism.io/address/0xB16ef128b11e457afA07B09FCE52A01f5B05a937;
        Synth existingSynth = Synth(0xB16ef128b11e457afA07B09FCE52A01f5B05a937);
        // https://explorer.optimism.io/address/0xdEdb0b04AFF1525bb4B6167F00e61601690c1fF2;
        Synth newSynth = Synth(0xdEdb0b04AFF1525bb4B6167F00e61601690c1fF2);
        newSynth.setTotalSupply(existingSynth.totalSupply());
    }
</source>
</class>

<class classid="168" nclones="5" nlines="10" similarity="72">
<source file="systems/source-code/Migration_Algol.sol" startline="51" endline="71" pcid="968">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Set the penalty amount of SNX from a liquidated account;
        systemsettings_i.setSnxLiquidationPenalty(300000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="51" endline="73" pcid="976">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Set the penalty amount of SNX from a liquidated account;
        systemsettings_i.setSnxLiquidationPenalty(300000000000000000);
        // Set the penalty amount of Collateral from a liquidated account;
        systemsettings_i.setLiquidationPenalty(100000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="45" endline="68" pcid="1091">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="45" endline="68" pcid="1099">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="55" endline="79" pcid="1042">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Ensure the CollateralManager has all Collateral contracts added;
        collateralmanager_addCollaterals_8();
        // Ensure the CollateralShort contract has all associated synths added;
        collateralshort_addSynths_9();
        // Ensure the CollateralShort contract has its issue fee rate set;
        collateralshort_i.setIssueFeeRate(4000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="169" nclones="46" nlines="6" similarity="75">
<source file="systems/source-code/Migration_Algol.sol" startline="73" endline="78" pcid="969">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Algol.sol" startline="80" endline="85" pcid="970">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="143" endline="148" pcid="1053">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="75" endline="80" pcid="977">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="211" endline="216" pcid="1068">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="82" endline="87" pcid="978">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="81" endline="86" pcid="1043">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="142" endline="147" pcid="985">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="184" endline="189" pcid="1061">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="88" endline="93" pcid="1044">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="149" endline="154" pcid="986">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="100" endline="105" pcid="1038">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="118" endline="123" pcid="1012">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="122" endline="127" pcid="995">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="177" endline="182" pcid="1060">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="93" endline="98" pcid="1037">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="281" endline="286" pcid="1153">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="117" endline="122" pcid="1171">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="274" endline="279" pcid="1152">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="218" endline="223" pcid="1069">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="129" endline="134" pcid="996">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="357" endline="362" pcid="1130">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="150" endline="155" pcid="1054">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="344" endline="349" pcid="1028">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="337" endline="342" pcid="1027">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="350" endline="355" pcid="1129">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="70" endline="75" pcid="1092">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="401" endline="406" pcid="1022">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="77" endline="82" pcid="1124">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="75" endline="80" pcid="1087">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="77" endline="82" pcid="1093">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="70" endline="75" pcid="1079">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="70" endline="75" pcid="1123">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="68" endline="73" pcid="1086">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="77" endline="82" pcid="1080">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="394" endline="399" pcid="1021">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="125" endline="130" pcid="1005">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="125" endline="130" pcid="1013">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="70" endline="75" pcid="1100">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="77" endline="82" pcid="1101">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="83" endline="88" pcid="1118">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="76" endline="81" pcid="1117">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="118" endline="123" pcid="1004">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="167" endline="172" pcid="1108">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="174" endline="179" pcid="1109">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="124" endline="129" pcid="1172">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
</class>

<class classid="170" nclones="4" nlines="9" similarity="75">
<source file="systems/source-code/Migration_Algol.sol" startline="87" endline="98" pcid="971">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="89" endline="100" pcid="979">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="95" endline="106" pcid="1045">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        addressresolver_importAddresses_names_0_0[1] = bytes32("CollateralShort");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_CollateralShort_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="107" endline="118" pcid="1039">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[1] = bytes32("SupplySchedule");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_SupplySchedule_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="171" nclones="2" nlines="21" similarity="77">
<source file="systems/source-code/Migration_Alphard.sol" startline="85" endline="140" pcid="984">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_SynthetixDebtShare_contract).CONTRACT_NAME() == "SynthetixDebtShare",
            "Invalid contract supplied for SynthetixDebtShare"
        );
        require(
            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == "FeePool",
            "Invalid contract supplied for FeePool"
        );
        require(
            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == "Synthetix",
            "Invalid contract supplied for Synthetix"
        );
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the ProxyFeePool contract has the correct FeePool target set;
        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));
        // Ensure the FeePool contract can write to its EternalStorage;
        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);
        // Ensure the FeePool contract can write to its State;
        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure that Synthetix can write to its State contract;
        synthetixstate_i.setAssociatedContract(new_Issuer_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the legacy RewardEscrow contract is connected to the FeePool contract;
        rewardescrow_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Import fee period from existing fee pool at index 0;
        importFeePeriod_0();
        // Import fee period from existing fee pool at index 1;
        importFeePeriod_1();
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_19();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="77" endline="120" pcid="994">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_SynthetixDebtShare_contract).CONTRACT_NAME() == "SynthetixDebtShare",
            "Invalid contract supplied for SynthetixDebtShare"
        );
        require(
            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == "FeePool",
            "Invalid contract supplied for FeePool"
        );
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the ProxyFeePool contract has the correct FeePool target set;
        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));
        // Ensure the FeePool contract can write to its EternalStorage;
        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);
        // Ensure the FeePool contract can write to its State;
        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Import fee period from existing fee pool at index 0;
        importFeePeriod_0();
        // Import fee period from existing fee pool at index 1;
        importFeePeriod_1();
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_16();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="172" nclones="3" nlines="13" similarity="75">
<source file="systems/source-code/Migration_Alphard.sol" startline="156" endline="171" pcid="987">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="157" endline="172" pcid="1055">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("ExchangeRates");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_ExchangeRates_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="136" endline="151" pcid="997">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="173" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/Migration_Alphard.sol" startline="215" endline="238" pcid="990">
    function importFeePeriod_0() internal {
        // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd;
        FeePool existingFeePool = FeePool(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);
        // https://etherscan.io/address/0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec;
        FeePool newFeePool = FeePool(0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec);
        (
            uint64 feePeriodId_0,
            uint64 unused_0,
            uint64 startTime_0,
            uint feesToDistribute_0,
            uint feesClaimed_0,
            uint rewardsToDistribute_0,
            uint rewardsClaimed_0
        ) = existingFeePool.recentFeePeriods(0);
        newFeePool.importFeePeriod(
            0,
            feePeriodId_0,
            startTime_0,
            feesToDistribute_0,
            feesClaimed_0,
            rewardsToDistribute_0,
            rewardsClaimed_0
        );
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="408" endline="431" pcid="1023">
    function importFeePeriod_0() internal {
        // https://etherscan.io/address/0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec;
        FeePool existingFeePool = FeePool(0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec);
        // https://etherscan.io/address/0x3B2f389AeE480238A49E3A9985cd6815370712eB;
        FeePool newFeePool = FeePool(0x3B2f389AeE480238A49E3A9985cd6815370712eB);
        (
            uint64 feePeriodId_0,
            uint64 unused_0,
            uint64 startTime_0,
            uint feesToDistribute_0,
            uint feesClaimed_0,
            uint rewardsToDistribute_0,
            uint rewardsClaimed_0
        ) = existingFeePool.recentFeePeriods(0);
        newFeePool.importFeePeriod(
            0,
            feePeriodId_0,
            startTime_0,
            feesToDistribute_0,
            feesClaimed_0,
            rewardsToDistribute_0,
            rewardsClaimed_0
        );
    }
</source>
</class>

<class classid="174" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/Migration_Alphard.sol" startline="240" endline="263" pcid="991">
    function importFeePeriod_1() internal {
        // https://etherscan.io/address/0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd;
        FeePool existingFeePool = FeePool(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);
        // https://etherscan.io/address/0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec;
        FeePool newFeePool = FeePool(0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec);
        (
            uint64 feePeriodId_1,
            uint64 unused_1,
            uint64 startTime_1,
            uint feesToDistribute_1,
            uint feesClaimed_1,
            uint rewardsToDistribute_1,
            uint rewardsClaimed_1
        ) = existingFeePool.recentFeePeriods(1);
        newFeePool.importFeePeriod(
            1,
            feePeriodId_1,
            startTime_1,
            feesToDistribute_1,
            feesClaimed_1,
            rewardsToDistribute_1,
            rewardsClaimed_1
        );
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="433" endline="456" pcid="1024">
    function importFeePeriod_1() internal {
        // https://etherscan.io/address/0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec;
        FeePool existingFeePool = FeePool(0xBE02A2C22a581D796b90b200CF530Fdd1e6f54ec);
        // https://etherscan.io/address/0x3B2f389AeE480238A49E3A9985cd6815370712eB;
        FeePool newFeePool = FeePool(0x3B2f389AeE480238A49E3A9985cd6815370712eB);
        (
            uint64 feePeriodId_1,
            uint64 unused_1,
            uint64 startTime_1,
            uint feesToDistribute_1,
            uint feesClaimed_1,
            uint rewardsToDistribute_1,
            uint rewardsClaimed_1
        ) = existingFeePool.recentFeePeriods(1);
        newFeePool.importFeePeriod(
            1,
            feePeriodId_1,
            startTime_1,
            feesToDistribute_1,
            feesClaimed_1,
            rewardsToDistribute_1,
            rewardsClaimed_1
        );
    }
</source>
</class>

<class classid="175" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="177" endline="200" pcid="999">
    function importFeePeriod_0() internal {
        // https://explorer.optimism.io/address/0xFDf3Be612c65464AEB4859047350a6220F304F52;
        FeePool existingFeePool = FeePool(0xFDf3Be612c65464AEB4859047350a6220F304F52);
        // https://explorer.optimism.io/address/0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54;
        FeePool newFeePool = FeePool(0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54);
        (
            uint64 feePeriodId_0,
            uint64 unused_0,
            uint64 startTime_0,
            uint feesToDistribute_0,
            uint feesClaimed_0,
            uint rewardsToDistribute_0,
            uint rewardsClaimed_0
        ) = existingFeePool.recentFeePeriods(0);
        newFeePool.importFeePeriod(
            0,
            feePeriodId_0,
            startTime_0,
            feesToDistribute_0,
            feesClaimed_0,
            rewardsToDistribute_0,
            rewardsClaimed_0
        );
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="478" endline="501" pcid="1033">
    function importFeePeriod_0() internal {
        // https://explorer.optimism.io/address/0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54;
        FeePool existingFeePool = FeePool(0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54);
        // https://explorer.optimism.io/address/0xD3739A5F06747e148E716Dcb7147B9BA15b70fcc;
        FeePool newFeePool = FeePool(0xD3739A5F06747e148E716Dcb7147B9BA15b70fcc);
        (
            uint64 feePeriodId_0,
            uint64 unused_0,
            uint64 startTime_0,
            uint feesToDistribute_0,
            uint feesClaimed_0,
            uint rewardsToDistribute_0,
            uint rewardsClaimed_0
        ) = existingFeePool.recentFeePeriods(0);
        newFeePool.importFeePeriod(
            0,
            feePeriodId_0,
            startTime_0,
            feesToDistribute_0,
            feesClaimed_0,
            rewardsToDistribute_0,
            rewardsClaimed_0
        );
    }
</source>
</class>

<class classid="176" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="202" endline="225" pcid="1000">
    function importFeePeriod_1() internal {
        // https://explorer.optimism.io/address/0xFDf3Be612c65464AEB4859047350a6220F304F52;
        FeePool existingFeePool = FeePool(0xFDf3Be612c65464AEB4859047350a6220F304F52);
        // https://explorer.optimism.io/address/0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54;
        FeePool newFeePool = FeePool(0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54);
        (
            uint64 feePeriodId_1,
            uint64 unused_1,
            uint64 startTime_1,
            uint feesToDistribute_1,
            uint feesClaimed_1,
            uint rewardsToDistribute_1,
            uint rewardsClaimed_1
        ) = existingFeePool.recentFeePeriods(1);
        newFeePool.importFeePeriod(
            1,
            feePeriodId_1,
            startTime_1,
            feesToDistribute_1,
            feesClaimed_1,
            rewardsToDistribute_1,
            rewardsClaimed_1
        );
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="503" endline="526" pcid="1034">
    function importFeePeriod_1() internal {
        // https://explorer.optimism.io/address/0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54;
        FeePool existingFeePool = FeePool(0xcFDcCFf3835Eb002eF0360F9514A66E6717fCC54);
        // https://explorer.optimism.io/address/0xD3739A5F06747e148E716Dcb7147B9BA15b70fcc;
        FeePool newFeePool = FeePool(0xD3739A5F06747e148E716Dcb7147B9BA15b70fcc);
        (
            uint64 feePeriodId_1,
            uint64 unused_1,
            uint64 startTime_1,
            uint feesToDistribute_1,
            uint feesClaimed_1,
            uint rewardsToDistribute_1,
            uint rewardsClaimed_1
        ) = existingFeePool.recentFeePeriods(1);
        newFeePool.importFeePeriod(
            1,
            feePeriodId_1,
            startTime_1,
            feesToDistribute_1,
            feesClaimed_1,
            rewardsToDistribute_1,
            rewardsClaimed_1
        );
    }
</source>
</class>

<class classid="177" nclones="2" nlines="19" similarity="73">
<source file="systems/source-code/Migration_Alpheratz.sol" startline="80" endline="116" pcid="1003">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_15();
        // Set the penalty for self liquidation of an account;
        systemsettings_i.setSelfLiquidationPenalty(200000000000000000);
        // Set the duration of how long liquidation rewards are escrowed for;
        systemsettings_i.setLiquidationEscrowDuration(31536000);
        // Set the reward amount for flagging an account for liquidation;
        systemsettings_i.setFlagReward(10000000000000000000);
        // Set the reward amount for peforming a liquidation;
        systemsettings_i.setLiquidateReward(20000000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="76" endline="116" pcid="1011">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 3;
        addressresolver_rebuildCaches_3();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_15();
        // Set the penalty for self liquidation of an account;
        systemsettings_i.setSelfLiquidationPenalty(200000000000000000);
        // Set the duration of how long liquidation rewards are escrowed for;
        systemsettings_i.setLiquidationEscrowDuration(31536000);
        // Set the reward amount for flagging an account for liquidation;
        systemsettings_i.setFlagReward(1000000000000000000);
        // Set the reward amount for peforming a liquidation;
        systemsettings_i.setLiquidateReward(2000000000000000000);
        // Set the amount for the liquidation c-ratio;
        systemsettings_i.setLiquidationRatio(666666666666666666);
        // Set the duration for the liquidation delay;
        systemsettings_i.setLiquidationDelay(43200);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="178" nclones="2" nlines="17" similarity="87">
<source file="systems/source-code/Migration_Alpheratz.sol" startline="132" endline="151" pcid="1006">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](6);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("LiquidatorRewards");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Liquidator");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Exchanger");
        addressresolver_importAddresses_names_0_0[4] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[5] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](6);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_LiquidatorRewards_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Liquidator_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);
        addressresolver_importAddresses_destinations_0_1[4] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[5] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="132" endline="151" pcid="1014">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](6);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Liquidator");
        addressresolver_importAddresses_names_0_0[2] = bytes32("LiquidatorRewards");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Exchanger");
        addressresolver_importAddresses_names_0_0[4] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[5] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](6);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Liquidator_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_LiquidatorRewards_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);
        addressresolver_importAddresses_destinations_0_1[4] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[5] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="179" nclones="3" nlines="19" similarity="100">
<source file="systems/source-code/Migration_Alpheratz.sol" startline="197" endline="215" pcid="1009">
    function issuer_addSynths_15() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_15_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_15_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        issuer_addSynths_synthsToAdd_15_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        issuer_addSynths_synthsToAdd_15_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        issuer_addSynths_synthsToAdd_15_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        issuer_addSynths_synthsToAdd_15_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        issuer_addSynths_synthsToAdd_15_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        issuer_addSynths_synthsToAdd_15_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        issuer_addSynths_synthsToAdd_15_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        issuer_addSynths_synthsToAdd_15_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        issuer_addSynths_synthsToAdd_15_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        issuer_addSynths_synthsToAdd_15_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        issuer_addSynths_synthsToAdd_15_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        issuer_addSynths_synthsToAdd_15_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);
        issuer_addSynths_synthsToAdd_15_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        issuer_addSynths_synthsToAdd_15_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_15_0);
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="257" endline="275" pcid="1065">
    function issuer_addSynths_44() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_44_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_44_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        issuer_addSynths_synthsToAdd_44_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        issuer_addSynths_synthsToAdd_44_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        issuer_addSynths_synthsToAdd_44_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        issuer_addSynths_synthsToAdd_44_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        issuer_addSynths_synthsToAdd_44_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        issuer_addSynths_synthsToAdd_44_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        issuer_addSynths_synthsToAdd_44_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        issuer_addSynths_synthsToAdd_44_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        issuer_addSynths_synthsToAdd_44_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        issuer_addSynths_synthsToAdd_44_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        issuer_addSynths_synthsToAdd_44_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        issuer_addSynths_synthsToAdd_44_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);
        issuer_addSynths_synthsToAdd_44_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        issuer_addSynths_synthsToAdd_44_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_44_0);
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="133" endline="151" pcid="1097">
    function issuer_addSynths_5() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_5_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_5_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        issuer_addSynths_synthsToAdd_5_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        issuer_addSynths_synthsToAdd_5_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        issuer_addSynths_synthsToAdd_5_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        issuer_addSynths_synthsToAdd_5_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        issuer_addSynths_synthsToAdd_5_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        issuer_addSynths_synthsToAdd_5_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        issuer_addSynths_synthsToAdd_5_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        issuer_addSynths_synthsToAdd_5_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        issuer_addSynths_synthsToAdd_5_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        issuer_addSynths_synthsToAdd_5_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        issuer_addSynths_synthsToAdd_5_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        issuer_addSynths_synthsToAdd_5_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);
        issuer_addSynths_synthsToAdd_5_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        issuer_addSynths_synthsToAdd_5_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_5_0);
    }
</source>
</class>

<class classid="180" nclones="3" nlines="15" similarity="85">
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="210" endline="224" pcid="1018">
    function issuer_addSynths_15() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_15_0 = new ISynth[](11);
        issuer_addSynths_synthsToAdd_15_0[0] = ISynth(0xD1599E478cC818AFa42A4839a6C665D9279C3E50);
        issuer_addSynths_synthsToAdd_15_0[1] = ISynth(0x0681883084b5De1564FE2706C87affD77F1677D5);
        issuer_addSynths_synthsToAdd_15_0[2] = ISynth(0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2);
        issuer_addSynths_synthsToAdd_15_0[3] = ISynth(0x2302D7F7783e2712C48aA684451b9d706e74F299);
        issuer_addSynths_synthsToAdd_15_0[4] = ISynth(0x91DBC6f587D043FEfbaAD050AB48696B30F13d89);
        issuer_addSynths_synthsToAdd_15_0[5] = ISynth(0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D);
        issuer_addSynths_synthsToAdd_15_0[6] = ISynth(0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e);
        issuer_addSynths_synthsToAdd_15_0[7] = ISynth(0xB16ef128b11e457afA07B09FCE52A01f5B05a937);
        issuer_addSynths_synthsToAdd_15_0[8] = ISynth(0x5eA2544551448cF6DcC1D853aDdd663D480fd8d3);
        issuer_addSynths_synthsToAdd_15_0[9] = ISynth(0xC19d27d1dA572d582723C1745650E51AC4Fc877F);
        issuer_addSynths_synthsToAdd_15_0[10] = ISynth(0xc66499aCe3B6c6a30c784bE5511E8d338d543913);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_15_0);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="126" endline="139" pcid="1105">
    function issuer_addSynths_5() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_5_0 = new ISynth[](10);
        issuer_addSynths_synthsToAdd_5_0[0] = ISynth(0xD1599E478cC818AFa42A4839a6C665D9279C3E50);
        issuer_addSynths_synthsToAdd_5_0[1] = ISynth(0x0681883084b5De1564FE2706C87affD77F1677D5);
        issuer_addSynths_synthsToAdd_5_0[2] = ISynth(0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2);
        issuer_addSynths_synthsToAdd_5_0[3] = ISynth(0x2302D7F7783e2712C48aA684451b9d706e74F299);
        issuer_addSynths_synthsToAdd_5_0[4] = ISynth(0x91DBC6f587D043FEfbaAD050AB48696B30F13d89);
        issuer_addSynths_synthsToAdd_5_0[5] = ISynth(0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D);
        issuer_addSynths_synthsToAdd_5_0[6] = ISynth(0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e);
        issuer_addSynths_synthsToAdd_5_0[7] = ISynth(0xB16ef128b11e457afA07B09FCE52A01f5B05a937);
        issuer_addSynths_synthsToAdd_5_0[8] = ISynth(0x5eA2544551448cF6DcC1D853aDdd663D480fd8d3);
        issuer_addSynths_synthsToAdd_5_0[9] = ISynth(0xC19d27d1dA572d582723C1745650E51AC4Fc877F);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_5_0);
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="324" endline="338" pcid="1075">
    function issuer_addSynths_46() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_46_0 = new ISynth[](11);
        issuer_addSynths_synthsToAdd_46_0[0] = ISynth(0xD1599E478cC818AFa42A4839a6C665D9279C3E50);
        issuer_addSynths_synthsToAdd_46_0[1] = ISynth(0x0681883084b5De1564FE2706C87affD77F1677D5);
        issuer_addSynths_synthsToAdd_46_0[2] = ISynth(0xC4Be4583bc0307C56CF301975b2B2B1E5f95fcB2);
        issuer_addSynths_synthsToAdd_46_0[3] = ISynth(0x2302D7F7783e2712C48aA684451b9d706e74F299);
        issuer_addSynths_synthsToAdd_46_0[4] = ISynth(0x91DBC6f587D043FEfbaAD050AB48696B30F13d89);
        issuer_addSynths_synthsToAdd_46_0[5] = ISynth(0x5D7569CD81dc7c8E7FA201e66266C9D0c8a3712D);
        issuer_addSynths_synthsToAdd_46_0[6] = ISynth(0xF5d0BFBc617d3969C1AcE93490A76cE80Db1Ed0e);
        issuer_addSynths_synthsToAdd_46_0[7] = ISynth(0xB16ef128b11e457afA07B09FCE52A01f5B05a937);
        issuer_addSynths_synthsToAdd_46_0[8] = ISynth(0x5eA2544551448cF6DcC1D853aDdd663D480fd8d3);
        issuer_addSynths_synthsToAdd_46_0[9] = ISynth(0xC19d27d1dA572d582723C1745650E51AC4Fc877F);
        issuer_addSynths_synthsToAdd_46_0[10] = ISynth(new_SynthsINR_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_46_0);
    }
</source>
</class>

<class classid="181" nclones="4" nlines="52" similarity="70">
<source file="systems/source-code/Migration_Diphda.sol" startline="186" endline="243" pcid="1019">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](55);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxyfeepool_i);
        contracts[2] = address(feepooleternalstorage_i);
        contracts[3] = address(exchangestate_i);
        contracts[4] = address(systemstatus_i);
        contracts[5] = address(rewardescrow_i);
        contracts[6] = address(feepool_i);
        contracts[7] = address(debtcache_i);
        contracts[8] = address(exchangerates_i);
        contracts[9] = address(synthsusd_i);
        contracts[10] = address(tokenstatesusd_i);
        contracts[11] = address(proxysusd_i);
        contracts[12] = address(synthseur_i);
        contracts[13] = address(tokenstateseur_i);
        contracts[14] = address(proxyseur_i);
        contracts[15] = address(synthsjpy_i);
        contracts[16] = address(tokenstatesjpy_i);
        contracts[17] = address(proxysjpy_i);
        contracts[18] = address(synthsaud_i);
        contracts[19] = address(tokenstatesaud_i);
        contracts[20] = address(proxysaud_i);
        contracts[21] = address(synthsgbp_i);
        contracts[22] = address(tokenstatesgbp_i);
        contracts[23] = address(proxysgbp_i);
        contracts[24] = address(synthschf_i);
        contracts[25] = address(tokenstateschf_i);
        contracts[26] = address(proxyschf_i);
        contracts[27] = address(synthskrw_i);
        contracts[28] = address(tokenstateskrw_i);
        contracts[29] = address(proxyskrw_i);
        contracts[30] = address(synthsbtc_i);
        contracts[31] = address(tokenstatesbtc_i);
        contracts[32] = address(proxysbtc_i);
        contracts[33] = address(synthseth_i);
        contracts[34] = address(tokenstateseth_i);
        contracts[35] = address(proxyseth_i);
        contracts[36] = address(synthslink_i);
        contracts[37] = address(tokenstateslink_i);
        contracts[38] = address(proxyslink_i);
        contracts[39] = address(synthsada_i);
        contracts[40] = address(tokenstatesada_i);
        contracts[41] = address(proxysada_i);
        contracts[42] = address(synthsaave_i);
        contracts[43] = address(tokenstatesaave_i);
        contracts[44] = address(proxysaave_i);
        contracts[45] = address(synthsdot_i);
        contracts[46] = address(tokenstatesdot_i);
        contracts[47] = address(proxysdot_i);
        contracts[48] = address(synthsethbtc_i);
        contracts[49] = address(tokenstatesethbtc_i);
        contracts[50] = address(proxysethbtc_i);
        contracts[51] = address(synthsdefi_i);
        contracts[52] = address(tokenstatesdefi_i);
        contracts[53] = address(proxysdefi_i);
        contracts[54] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="165" endline="207" pcid="1025">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](40);
        contracts[0] = address(futuresmarketmanager_i);
        contracts[1] = address(addressresolver_i);
        contracts[2] = address(proxyfeepool_i);
        contracts[3] = address(feepooleternalstorage_i);
        contracts[4] = address(exchangestate_i);
        contracts[5] = address(systemstatus_i);
        contracts[6] = address(feepool_i);
        contracts[7] = address(debtcache_i);
        contracts[8] = address(exchangerates_i);
        contracts[9] = address(synthsusd_i);
        contracts[10] = address(tokenstatesusd_i);
        contracts[11] = address(proxysusd_i);
        contracts[12] = address(synthseth_i);
        contracts[13] = address(tokenstateseth_i);
        contracts[14] = address(proxyseth_i);
        contracts[15] = address(synthsbtc_i);
        contracts[16] = address(tokenstatesbtc_i);
        contracts[17] = address(proxysbtc_i);
        contracts[18] = address(synthslink_i);
        contracts[19] = address(tokenstateslink_i);
        contracts[20] = address(proxyslink_i);
        contracts[21] = address(synthssol_i);
        contracts[22] = address(tokenstatessol_i);
        contracts[23] = address(proxyssol_i);
        contracts[24] = address(synthsavax_i);
        contracts[25] = address(tokenstatesavax_i);
        contracts[26] = address(proxysavax_i);
        contracts[27] = address(synthsmatic_i);
        contracts[28] = address(tokenstatesmatic_i);
        contracts[29] = address(proxysmatic_i);
        contracts[30] = address(synthseur_i);
        contracts[31] = address(tokenstateseur_i);
        contracts[32] = address(proxyseur_i);
        contracts[33] = address(tokenstatesaave_i);
        contracts[34] = address(proxysaave_i);
        contracts[35] = address(tokenstatesuni_i);
        contracts[36] = address(proxysuni_i);
        contracts[37] = address(issuer_i);
        contracts[38] = address(systemsettings_i);
        contracts[39] = address(futuresmarketsettings_i);
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="176" endline="230" pcid="1127">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](52);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(systemstatus_i);
        contracts[3] = address(tokenstatesynthetix_i);
        contracts[4] = address(rewardescrow_i);
        contracts[5] = address(rewardsdistribution_i);
        contracts[6] = address(synthsusd_i);
        contracts[7] = address(tokenstatesusd_i);
        contracts[8] = address(proxysusd_i);
        contracts[9] = address(synthseur_i);
        contracts[10] = address(tokenstateseur_i);
        contracts[11] = address(proxyseur_i);
        contracts[12] = address(synthsjpy_i);
        contracts[13] = address(tokenstatesjpy_i);
        contracts[14] = address(proxysjpy_i);
        contracts[15] = address(synthsaud_i);
        contracts[16] = address(tokenstatesaud_i);
        contracts[17] = address(proxysaud_i);
        contracts[18] = address(synthsgbp_i);
        contracts[19] = address(tokenstatesgbp_i);
        contracts[20] = address(proxysgbp_i);
        contracts[21] = address(synthschf_i);
        contracts[22] = address(tokenstateschf_i);
        contracts[23] = address(proxyschf_i);
        contracts[24] = address(synthskrw_i);
        contracts[25] = address(tokenstateskrw_i);
        contracts[26] = address(proxyskrw_i);
        contracts[27] = address(synthsbtc_i);
        contracts[28] = address(tokenstatesbtc_i);
        contracts[29] = address(proxysbtc_i);
        contracts[30] = address(synthseth_i);
        contracts[31] = address(tokenstateseth_i);
        contracts[32] = address(proxyseth_i);
        contracts[33] = address(synthslink_i);
        contracts[34] = address(tokenstateslink_i);
        contracts[35] = address(proxyslink_i);
        contracts[36] = address(synthsada_i);
        contracts[37] = address(tokenstatesada_i);
        contracts[38] = address(proxysada_i);
        contracts[39] = address(synthsaave_i);
        contracts[40] = address(tokenstatesaave_i);
        contracts[41] = address(proxysaave_i);
        contracts[42] = address(synthsdot_i);
        contracts[43] = address(tokenstatesdot_i);
        contracts[44] = address(proxysdot_i);
        contracts[45] = address(synthsethbtc_i);
        contracts[46] = address(tokenstatesethbtc_i);
        contracts[47] = address(proxysethbtc_i);
        contracts[48] = address(synthsdefi_i);
        contracts[49] = address(tokenstatesdefi_i);
        contracts[50] = address(proxysdefi_i);
        contracts[51] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="139" endline="180" pcid="1150">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](39);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(proxysynthetix_i);
        contracts[2] = address(systemstatus_i);
        contracts[3] = address(tokenstatesynthetix_i);
        contracts[4] = address(rewardsdistribution_i);
        contracts[5] = address(synthsusd_i);
        contracts[6] = address(tokenstatesusd_i);
        contracts[7] = address(proxysusd_i);
        contracts[8] = address(synthseth_i);
        contracts[9] = address(tokenstateseth_i);
        contracts[10] = address(proxyseth_i);
        contracts[11] = address(synthsbtc_i);
        contracts[12] = address(tokenstatesbtc_i);
        contracts[13] = address(proxysbtc_i);
        contracts[14] = address(synthslink_i);
        contracts[15] = address(tokenstateslink_i);
        contracts[16] = address(proxyslink_i);
        contracts[17] = address(synthssol_i);
        contracts[18] = address(tokenstatessol_i);
        contracts[19] = address(proxyssol_i);
        contracts[20] = address(synthsavax_i);
        contracts[21] = address(tokenstatesavax_i);
        contracts[22] = address(proxysavax_i);
        contracts[23] = address(synthsmatic_i);
        contracts[24] = address(tokenstatesmatic_i);
        contracts[25] = address(proxysmatic_i);
        contracts[26] = address(synthseur_i);
        contracts[27] = address(tokenstateseur_i);
        contracts[28] = address(proxyseur_i);
        contracts[29] = address(synthsaave_i);
        contracts[30] = address(tokenstatesaave_i);
        contracts[31] = address(proxysaave_i);
        contracts[32] = address(synthsuni_i);
        contracts[33] = address(tokenstatesuni_i);
        contracts[34] = address(proxysuni_i);
        contracts[35] = address(synthsinr_i);
        contracts[36] = address(tokenstatesinr_i);
        contracts[37] = address(proxysinr_i);
        contracts[38] = address(issuer_i);
    }
</source>
</class>

<class classid="182" nclones="3" nlines="8" similarity="71">
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="351" endline="357" pcid="1029">
    function futuresmarketmanager_addMarkets_0() internal {
        address[] memory futuresmarketmanager_addMarkets_marketsToAdd_0_0 = new address[](3);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[0] = address(new_FuturesMarketBTC_contract);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[1] = address(new_FuturesMarketETH_contract);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[2] = address(new_FuturesMarketLINK_contract);
        futuresmarketmanager_i.addMarkets(futuresmarketmanager_addMarkets_marketsToAdd_0_0);
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="181" endline="188" pcid="1110">
    function futuresmarketmanager_addMarkets_0() internal {
        address[] memory futuresmarketmanager_addMarkets_marketsToAdd_0_0 = new address[](4);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[0] = address(new_FuturesMarketSOL_contract);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[1] = address(new_FuturesMarketAVAX_contract);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[2] = address(new_FuturesMarketMATIC_contract);
        futuresmarketmanager_addMarkets_marketsToAdd_0_0[3] = address(new_FuturesMarketWTI_contract);
        futuresmarketmanager_i.addMarkets(futuresmarketmanager_addMarkets_marketsToAdd_0_0);
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="213" endline="221" pcid="1112">
    function addressresolver_rebuildCaches_2() internal {
        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](5);
        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_SynthsWTI_contract);
        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(new_FuturesMarketSOL_contract);
        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(new_FuturesMarketAVAX_contract);
        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(new_FuturesMarketMATIC_contract);
        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(new_FuturesMarketWTI_contract);
        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);
    }
</source>
</class>

<class classid="183" nclones="5" nlines="10" similarity="75">
<source file="systems/source-code/Migration_Hamal.sol" startline="60" endline="91" pcid="1036">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == "Synthetix",
            "Invalid contract supplied for Synthetix"
        );
        require(
            ISynthetixNamedContract(new_SupplySchedule_contract).CONTRACT_NAME() == "SupplySchedule",
            "Invalid contract supplied for SupplySchedule"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the SupplySchedule is connected to the SNX proxy for reading;
        supplyschedule_i.setSynthetixProxy(ISynthetix(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="54" endline="74" pcid="1116">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="50" endline="68" pcid="1122">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="45" endline="66" pcid="1085">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == "Exchanger",
            "Invalid contract supplied for Exchanger"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure the Exchanger contract can suspend synths - see SIP-65;
        systemstatus_i.updateAccessControl("Synth", new_Exchanger_contract, true, false);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="45" endline="68" pcid="1078">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == "ExchangerWithFeeRecAlternatives",
            "Invalid contract supplied for Exchanger"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure the Exchanger contract can suspend synths - see SIP-65;
        systemstatus_i.updateAccessControl("Synth", new_Exchanger_contract, true, false);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="184" nclones="3" nlines="5" similarity="75">
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="161" endline="165" pcid="1049">
    function collateralmanager_addCollaterals_8() internal {
        address[] memory collateralmanager_addCollaterals_collaterals_8_0 = new address[](1);
        collateralmanager_addCollaterals_collaterals_8_0[0] = address(new_CollateralShort_contract);
        collateralmanager_i.addCollaterals(collateralmanager_addCollaterals_collaterals_8_0);
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="223" endline="227" pcid="1113">
    function issuer_addSynths_19() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_19_0 = new ISynth[](1);
        issuer_addSynths_synthsToAdd_19_0[0] = ISynth(new_SynthsWTI_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_19_0);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="120" endline="124" pcid="1104">
    function addressresolver_rebuildCaches_2() internal {
        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](1);
        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_Issuer_contract);
        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);
    }
</source>
</class>

<class classid="185" nclones="2" nlines="40" similarity="75">
<source file="systems/source-code/Migration_Mirach.sol" startline="85" endline="175" pcid="1059">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Ensure the ExchangeRates contract has the standalone feed for SNX;
        exchangerates_i.addAggregator("SNX", 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699);
        // Ensure the ExchangeRates contract has the standalone feed for ETH;
        exchangerates_i.addAggregator("ETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the ExchangeRates contract has the standalone feed for AAVE;
        exchangerates_i.addAggregator("AAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the ExchangeRates contract has the standalone feed for DOT;
        exchangerates_i.addAggregator("DOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the ExchangeRates contract has the standalone feed for BTC;
        exchangerates_i.addAggregator("BTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the ExchangeRates contract has the standalone feed for LINK;
        exchangerates_i.addAggregator("LINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the ExchangeRates contract has the standalone feed for ADA;
        exchangerates_i.addAggregator("ADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the ExchangeRates contract has the standalone feed for DEFI;
        exchangerates_i.addAggregator("DEFI", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);
        // Ensure the ExchangeRates contract has the standalone feed for ETHBTC;
        exchangerates_i.addAggregator("ETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // Ensure the ExchangeRates contract has the standalone feed for EUR;
        exchangerates_i.addAggregator("EUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the ExchangeRates contract has the standalone feed for JPY;
        exchangerates_i.addAggregator("JPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the ExchangeRates contract has the standalone feed for AUD;
        exchangerates_i.addAggregator("AUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the ExchangeRates contract has the standalone feed for GBP;
        exchangerates_i.addAggregator("GBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the ExchangeRates contract has the standalone feed for CHF;
        exchangerates_i.addAggregator("CHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the ExchangeRates contract has the standalone feed for KRW;
        exchangerates_i.addAggregator("KRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the ExchangeRates contract has the feed for sEUR;
        exchangerates_i.addAggregator("sEUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the ExchangeRates contract has the feed for sJPY;
        exchangerates_i.addAggregator("sJPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the ExchangeRates contract has the feed for sAUD;
        exchangerates_i.addAggregator("sAUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the ExchangeRates contract has the feed for sGBP;
        exchangerates_i.addAggregator("sGBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the ExchangeRates contract has the feed for sCHF;
        exchangerates_i.addAggregator("sCHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the ExchangeRates contract has the feed for sKRW;
        exchangerates_i.addAggregator("sKRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the ExchangeRates contract has the feed for sBTC;
        exchangerates_i.addAggregator("sBTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the ExchangeRates contract has the feed for sETH;
        exchangerates_i.addAggregator("sETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the ExchangeRates contract has the feed for sLINK;
        exchangerates_i.addAggregator("sLINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the ExchangeRates contract has the feed for sADA;
        exchangerates_i.addAggregator("sADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the ExchangeRates contract has the feed for sAAVE;
        exchangerates_i.addAggregator("sAAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the ExchangeRates contract has the feed for sDOT;
        exchangerates_i.addAggregator("sDOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the ExchangeRates contract has the feed for sETHBTC;
        exchangerates_i.addAggregator("sETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // Ensure the ExchangeRates contract has the feed for sDEFI;
        exchangerates_i.addAggregator("sDEFI", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_44();
        // Set the max amount of Ether allowed in the EtherWrapper (SIP-112);
        systemsettings_i.setEtherWrapperMaxETH(5000000000000000000000);
        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);
        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="42" endline="115" pcid="1170">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_ExchangeRates_contract).CONTRACT_NAME() == "ExchangeRatesWithDexPricing",
            "Invalid contract supplied for ExchangeRates"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the ExchangeRates contract has the standalone feed for SNX;
        exchangerates_i.addAggregator("SNX", 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699);
        // Ensure the ExchangeRates contract has the standalone feed for ETH;
        exchangerates_i.addAggregator("ETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the ExchangeRates contract has the standalone feed for AAVE;
        exchangerates_i.addAggregator("AAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the ExchangeRates contract has the standalone feed for DOT;
        exchangerates_i.addAggregator("DOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the ExchangeRates contract has the standalone feed for BTC;
        exchangerates_i.addAggregator("BTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the ExchangeRates contract has the standalone feed for LINK;
        exchangerates_i.addAggregator("LINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the ExchangeRates contract has the standalone feed for ADA;
        exchangerates_i.addAggregator("ADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the ExchangeRates contract has the standalone feed for ETHBTC;
        exchangerates_i.addAggregator("ETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // Ensure the ExchangeRates contract has the standalone feed for EUR;
        exchangerates_i.addAggregator("EUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the ExchangeRates contract has the standalone feed for JPY;
        exchangerates_i.addAggregator("JPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the ExchangeRates contract has the standalone feed for AUD;
        exchangerates_i.addAggregator("AUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the ExchangeRates contract has the standalone feed for GBP;
        exchangerates_i.addAggregator("GBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the ExchangeRates contract has the standalone feed for CHF;
        exchangerates_i.addAggregator("CHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the ExchangeRates contract has the standalone feed for KRW;
        exchangerates_i.addAggregator("KRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the ExchangeRates contract has the feed for sEUR;
        exchangerates_i.addAggregator("sEUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the ExchangeRates contract has the feed for sJPY;
        exchangerates_i.addAggregator("sJPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the ExchangeRates contract has the feed for sAUD;
        exchangerates_i.addAggregator("sAUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the ExchangeRates contract has the feed for sGBP;
        exchangerates_i.addAggregator("sGBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the ExchangeRates contract has the feed for sCHF;
        exchangerates_i.addAggregator("sCHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the ExchangeRates contract has the feed for sKRW;
        exchangerates_i.addAggregator("sKRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the ExchangeRates contract has the feed for sBTC;
        exchangerates_i.addAggregator("sBTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the ExchangeRates contract has the feed for sETH;
        exchangerates_i.addAggregator("sETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the ExchangeRates contract has the feed for sLINK;
        exchangerates_i.addAggregator("sLINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the ExchangeRates contract has the feed for sADA;
        exchangerates_i.addAggregator("sADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the ExchangeRates contract has the feed for sAAVE;
        exchangerates_i.addAggregator("sAAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the ExchangeRates contract has the feed for sDOT;
        exchangerates_i.addAggregator("sDOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the ExchangeRates contract has the feed for sETHBTC;
        exchangerates_i.addAggregator("sETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);
        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="186" nclones="4" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="38" endline="43" pcid="1077">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="38" endline="43" pcid="1098">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="38" endline="43" pcid="1084">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="38" endline="43" pcid="1090">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
</class>

<class classid="187" nclones="7" nlines="7" similarity="83">
<source file="systems/source-code/Migration_Mirzam.sol" startline="84" endline="93" pcid="1081">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="84" endline="93" pcid="1094">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="82" endline="91" pcid="1088">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="84" endline="93" pcid="1102">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="90" endline="99" pcid="1119">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_Tiaki.sol" startline="131" endline="140" pcid="1173">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("ExchangeRates");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_ExchangeRates_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="84" endline="93" pcid="1125">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="188" nclones="3" nlines="5" similarity="75">
<source file="systems/source-code/MintableSynthetix.sol" startline="19" endline="23" pcid="1177">
    function _mintSecondary(address account, uint amount) internal {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));
        emitTransfer(address(this), account, amount);
        totalSupply = totalSupply.add(amount);
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="97" endline="101" pcid="1320">
    function burn(address account, uint amount) external {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));
        totalSupply = totalSupply.sub(amount);
        emit Burned(account, amount);
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="91" endline="95" pcid="1319">
    function issue(address account, uint amount) external {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));
        totalSupply = totalSupply.add(amount);
        emit Issued(account, amount);
    }
</source>
</class>

<class classid="189" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/MintableSynthetix.sol" startline="50" endline="52" pcid="1181">
    function mintSecondary(address account, uint amount) external onlyBridge {
        _mintSecondary(account, amount);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="163" endline="165" pcid="1639">
    function burn(address account, uint amount) external onlyInternalContracts {
        _internalBurn(account, amount);
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="217" endline="219" pcid="1535">
    function appendVestingEntry(address account, uint quantity) external onlyFeePool {
        _appendVestingEntry(account, quantity);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="159" endline="161" pcid="1638">
    function issue(address account, uint amount) external onlyInternalContracts {
        _internalIssue(account, amount);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="50" endline="52" pcid="1674">
    function withdrawTo(address to, uint amount) external requireInitiationActive {
        _initiateWithdraw(to, amount);
    }
</source>
</class>

<class classid="190" nclones="5" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="46" endline="49" pcid="1184">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="44" endline="47" pcid="1457">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="81" endline="84" pcid="1701">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_ISSUER;
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="54" endline="57" pcid="1579">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_SHORT;
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="74" endline="77" pcid="1229">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
</class>

<class classid="191" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="57" endline="59" pcid="1186">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="55" endline="57" pcid="1459">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
</class>

<class classid="192" nclones="16" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="61" endline="63" pcid="1187">
    function _takerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="65" endline="67" pcid="1188">
    function _makerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="59" endline="61" pcid="1460">
    function _baseFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_BASE_FEE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="63" endline="65" pcid="1461">
    function _baseFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_BASE_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="67" endline="69" pcid="1462">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="69" endline="71" pcid="1189">
    function _takerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="71" endline="73" pcid="1463">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="73" endline="75" pcid="1190">
    function _makerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="75" endline="77" pcid="1464">
    function _maxSingleSideValueUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_SINGLE_SIDE_VALUE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="77" endline="79" pcid="1191">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="81" endline="83" pcid="1192">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="93" endline="95" pcid="1195">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="79" endline="81" pcid="1465">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="83" endline="85" pcid="1466">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="89" endline="91" pcid="1194">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="85" endline="87" pcid="1193">
    function _maxMarketValueUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_MARKET_VALUE);
    }
</source>
</class>

<class classid="193" nclones="31" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="97" endline="99" pcid="1196">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="117" endline="120" pcid="1236">
    function getIssuanceRatio() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="122" endline="125" pcid="1237">
    function getFeePeriodDuration() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="127" endline="130" pcid="1238">
    function getTargetThreshold() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="113" endline="115" pcid="1235">
    function getPriceDeviationThresholdFactor() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="132" endline="134" pcid="1239">
    function getLiquidationDelay() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="136" endline="138" pcid="1240">
    function getLiquidationRatio() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="140" endline="142" pcid="1241">
    function getLiquidationEscrowDuration() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_ESCROW_DURATION);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="144" endline="146" pcid="1242">
    function getLiquidationPenalty() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="109" endline="111" pcid="1234">
    function getWaitingPeriodSecs() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="148" endline="150" pcid="1243">
    function getSnxLiquidationPenalty() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_SNX_LIQUIDATION_PENALTY);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="152" endline="154" pcid="1244">
    function getSelfLiquidationPenalty() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_SELF_LIQUIDATION_PENALTY);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="156" endline="158" pcid="1245">
    function getFlagReward() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FLAG_REWARD);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="160" endline="162" pcid="1246">
    function getLiquidateReward() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATE_REWARD);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="164" endline="166" pcid="1247">
    function getRateStalePeriod() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="191" endline="193" pcid="1250">
    function getMinimumStakeTime() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="195" endline="197" pcid="1251">
    function getAggregatorWarningFlags() internal view returns (address) {
        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="199" endline="201" pcid="1252">
    function getDebtSnapshotStaleTime() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="203" endline="205" pcid="1253">
    function getEtherWrapperMaxETH() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="105" endline="107" pcid="1198">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="105" endline="107" pcid="1233">
    function getTradingRewardsEnabled() internal view returns (bool) {
        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="109" endline="111" pcid="1199">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="101" endline="103" pcid="1197">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="207" endline="209" pcid="1254">
    function getEtherWrapperMintFeeRate() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="211" endline="213" pcid="1255">
    function getEtherWrapperBurnFeeRate() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="255" endline="257" pcid="1261">
    function getAtomicMaxVolumePerBlock() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="259" endline="261" pcid="1262">
    function getAtomicTwapWindow() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="87" endline="89" pcid="1467">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="99" endline="101" pcid="1470">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="91" endline="93" pcid="1468">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="95" endline="97" pcid="1469">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
</class>

<class classid="194" nclones="2" nlines="17" similarity="93">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="41" endline="91" pcid="1202">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="41" endline="90" pcid="1423">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                baseFee: _baseFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
</class>

<class classid="195" nclones="2" nlines="19" similarity="93">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="105" endline="149" pcid="1203">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="104" endline="148" pcid="1424">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit, order.trackingCode);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="196" nclones="2" nlines="23" similarity="95">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="164" endline="226" pcid="1204">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise future knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="163" endline="224" pcid="1425">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise perps knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                baseFee: _baseFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="197" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="232" endline="234" pcid="1205">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="230" endline="232" pcid="1426">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
</class>

<class classid="198" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="238" endline="240" pcid="1206">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="236" endline="238" pcid="1427">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
</class>

<class classid="199" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="243" endline="253" pcid="1207">
    function _nextPriceCommitDeposit(TradeParams memory params) internal view returns (uint) {
        // modify params to spot fee
        params.takerFee = _takerFee(marketKey);
        params.makerFee = _makerFee(marketKey);
        // Commit fee is equal to the spot fee that would be paid.
        // This is to prevent free cancellation manipulations (by e.g. withdrawing the margin).
        // The dynamic fee rate is passed as 0 since for the purposes of the commitment deposit
        // it is not important since at the time of order execution it will be refunded and the correct
        // dynamic fee will be charged.
        return _orderFee(params, 0);
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="241" endline="250" pcid="1428">
    function _nextPriceCommitDeposit(TradeParams memory params) internal view returns (uint) {
        // modify params to spot fee
        params.baseFee = _baseFee(marketKey);
        // Commit fee is equal to the spot fee that would be paid.
        // This is to prevent free cancellation manipulations (by e.g. withdrawing the margin).
        // The dynamic fee rate is passed as 0 since for the purposes of the commitment deposit
        // it is not important since at the time of order execution it will be refunded and the correct
        // dynamic fee will be charged.
        return _orderFee(params, 0);
    }
</source>
</class>

<class classid="200" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="14" endline="18" pcid="1208">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="14" endline="18" pcid="1471">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
</class>

<class classid="201" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="24" endline="27" pcid="1209">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="24" endline="27" pcid="1472">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
</class>

<class classid="202" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="33" endline="36" pcid="1210">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="16" endline="19" pcid="1955">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="33" endline="36" pcid="1473">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="16" endline="19" pcid="1965">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
</class>

<class classid="203" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="42" endline="45" pcid="1211">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="42" endline="45" pcid="1474">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
</class>

<class classid="204" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="57" endline="60" pcid="1213">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="57" endline="60" pcid="1476">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
</class>

<class classid="205" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="65" endline="68" pcid="1214">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="73" endline="76" pcid="1215">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="65" endline="68" pcid="1477">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="73" endline="76" pcid="1478">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="206" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="81" endline="84" pcid="1216">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="90" endline="93" pcid="1217">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="90" endline="93" pcid="1480">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="81" endline="84" pcid="1479">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="207" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="130" endline="133" pcid="1220">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="121" endline="124" pcid="1482">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
</class>

<class classid="208" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/MixinFuturesViews.sol" startline="143" endline="155" pcid="1221">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="134" endline="140" pcid="1483">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: bytes32(0)});
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
</class>

<class classid="209" nclones="2" nlines="11" similarity="88">
<source file="systems/source-code/MixinFuturesViews.sol" startline="160" endline="190" pcid="1222">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="145" endline="169" pcid="1484">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: bytes32(0)});
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
</class>

<class classid="210" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="193" endline="223" pcid="1223">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="172" endline="202" pcid="1485">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
</class>

<class classid="211" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/MixinSystemSettings.sol" startline="169" endline="175" pcid="1248">
    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="287" endline="293" pcid="1266">
    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="279" endline="285" pcid="1265">
    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="303" endline="309" pcid="1268">
    function getCrossChainSynthTransferEnabled(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="271" endline="277" pcid="1264">
    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="263" endline="269" pcid="1263">
    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {
        return
            flexibleStorage().getAddressValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="295" endline="301" pcid="1267">
    function getPureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) internal view returns (bool) {
        return
            flexibleStorage().getBoolValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED, currencyKey))
            );
    }
</source>
</class>

<class classid="212" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="81" endline="83" pcid="1271">
    function setAllRoundDataShouldRevert(bool _shouldRevert) external {
        allRoundDataShouldRevert = _shouldRevert;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="85" endline="87" pcid="1272">
    function setLatestRoundDataShouldRevert(bool _shouldRevert) external {
        latestRoundDataShouldRevert = _shouldRevert;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="46" endline="48" pcid="1302">
    function setInvalid(bool _invalid) external {
        invalid = _invalid;
    }
</source>
<source file="systems/source-code/MockDexPriceAggregator.sol" startline="36" endline="38" pcid="1284">
    function setAssetToAssetShouldRevert(bool _shouldRevert) external {
        assetToAssetShouldRevert = _shouldRevert;
    }
</source>
</class>

<class classid="213" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="118" endline="121" pcid="1277">
    function getAnswer(uint256 _roundId) external view returns (int256) {
        Entry memory entry = entries[_roundId];
        return entry.answer;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="123" endline="126" pcid="1278">
    function getTimestamp(uint256 _roundId) external view returns (uint256) {
        Entry memory entry = entries[_roundId];
        return entry.updatedAt;
    }
</source>
</class>

<class classid="214" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockEtherWrapper.sol" startline="13" endline="15" pcid="1285">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="42" endline="44" pcid="1301">
    function setMarketDebt(uint _debt) external {
        debt = _debt;
    }
</source>
<source file="systems/source-code/MockWrapperFactory.sol" startline="13" endline="15" pcid="1325">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="91" endline="93" pcid="1293">
    function setMaxSecsLeft(uint _maxSecsLeft) external {
        _mockMaxSecsLeft = _maxSecsLeft;
    }
</source>
</class>

<class classid="215" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockExchanger.sol" startline="79" endline="81" pcid="1290">
    function setReclaim(uint256 _reclaimAmount) external {
        _mockReclaimAmount = _reclaimAmount;
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="34" endline="36" pcid="1315">
    function setTotalSupply(uint256 _totalSupply) external {
        totalSupply = _totalSupply;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="87" endline="89" pcid="1292">
    function setNumEntries(uint256 _numEntries) external {
        _mockNumEntries = _numEntries;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="83" endline="85" pcid="1291">
    function setRefund(uint256 _refundAmount) external {
        _mockRefundAmount = _refundAmount;
    }
</source>
</class>

<class classid="216" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="30" endline="32" pcid="1298">
    function setManager(IFuturesMarketManagerInternal _manager) external {
        manager = _manager;
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="29" endline="31" pcid="1314">
    function setAddressResolver(IAddressResolver _resolver) external {
        addressResolver = _resolver;
    }
</source>
</class>

<class classid="217" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="34" endline="36" pcid="1299">
    function setBaseAsset(bytes32 _baseAsset) external {
        baseAsset = _baseAsset;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="38" endline="40" pcid="1300">
    function setMarketKey(bytes32 _marketKey) external {
        marketKey = _marketKey;
    }
</source>
</class>

<class classid="218" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="54" endline="56" pcid="1304">
    function issueSUSD(address account, uint amount) external {
        manager.issueSUSD(account, amount);
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="58" endline="60" pcid="1305">
    function burnSUSD(address account, uint amount) external {
        manager.burnSUSD(account, amount);
    }
</source>
</class>

<class classid="219" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MockMintableSynthetix.sol" startline="10" endline="13" pcid="1307">
    function mintSecondary(address account, uint amount) external {
        mintSecondaryCallAccount = account;
        mintSecondaryCallAmount = amount;
    }
</source>
<source file="systems/source-code/MockMintableSynthetix.sol" startline="15" endline="18" pcid="1308">
    function burnSecondary(address account, uint amount) external {
        burnSecondaryCallAccount = account;
        burnSecondaryCallAmount = amount;
    }
</source>
</class>

<class classid="220" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MultiCollateralSynth.sol" startline="64" endline="66" pcid="1330">
    function issue(address account, uint amount) external onlyInternalContracts {
        super._internalIssue(account, amount);
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="73" endline="75" pcid="1331">
    function burn(address account, uint amount) external onlyInternalContracts {
        super._internalBurn(account, amount);
    }
</source>
</class>

<class classid="221" nclones="2" nlines="9" similarity="75">
<source file="systems/source-code/OneNetAggregatorDebtRatio.sol" startline="10" endline="36" pcid="1340">
    function getRoundData(uint80)
        public
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        uint totalIssuedSynths =
            IIssuer(resolver.requireAndGetAddress("Issuer", "aggregate debt info")).totalIssuedSynths("sUSD", true);
        uint totalDebtShares =
            ISynthetixDebtShare(resolver.requireAndGetAddress("SynthetixDebtShare", "aggregate debt info")).totalSupply();

        uint result =
            totalDebtShares == 0 ? 0 : totalIssuedSynths.decimalToPreciseDecimal().divideDecimalRound(totalDebtShares);

        uint dataTimestamp = now;

        if (overrideTimestamp != 0) {
            dataTimestamp = overrideTimestamp;
        }

        return (1, int256(result), dataTimestamp, dataTimestamp, 1);
    }
</source>
<source file="systems/source-code/OneNetAggregatorIssuedSynths.sol" startline="10" endline="31" pcid="1341">
    function getRoundData(uint80)
        public
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        uint totalIssuedSynths =
            IIssuer(resolver.requireAndGetAddress("Issuer", "aggregate debt info")).totalIssuedSynths("sUSD", true);

        uint dataTimestamp = now;

        if (overrideTimestamp != 0) {
            dataTimestamp = overrideTimestamp;
        }

        return (1, int256(totalIssuedSynths), dataTimestamp, dataTimestamp, 1);
    }
</source>
</class>

<class classid="222" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="57" endline="61" pcid="1359">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_EXT_MESSENGER;
        addresses[1] = CONTRACT_BASE_OWNER_RELAY_ON_ETHEREUM;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="60" endline="64" pcid="1981">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_EXCHANGER;
        addresses[1] = CONTRACT_SYNTHETIX;
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="26" endline="30" pcid="1744">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_ISSUER;
        addresses[1] = CONTRACT_SYNTHSUSD;
    }
</source>
</class>

<class classid="223" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="65" endline="69" pcid="1360">
    function directRelay(address target, bytes calldata payload) external onlyTemporaryOwner {
        _relayCall(target, payload);

        emit DirectRelay(target, payload);
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="71" endline="75" pcid="1361">
    function finalizeRelay(address target, bytes calldata payload) external onlyMessengerAndL1Relayer {
        _relayCall(target, payload);

        emit RelayFinalized(target, payload);
    }
</source>
</class>

<class classid="224" nclones="8" nlines="3" similarity="100">
<source file="systems/source-code/Proxyable.sol" startline="34" endline="36" pcid="1487">
    function setMessageSender(address sender) external onlyProxy {
        messageSender = sender;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="72" endline="74" pcid="1549">
    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {
        feePoolProxy = _feePoolProxy;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="68" endline="70" pcid="1548">
    function setRewardEscrow(address _rewardEscrow) external onlyOwner {
        rewardEscrow = _rewardEscrow;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="80" endline="82" pcid="1550">
    function setAuthority(address _authority) external onlyOwner {
        authority = _authority;
    }
</source>
<source file="systems/source-code/RewardsDistributionRecipient.sol" startline="17" endline="19" pcid="1556">
    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {
        rewardsDistribution = _rewardsDistribution;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="64" endline="66" pcid="1547">
    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {
        synthetixProxy = _synthetixProxy;
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="19" endline="21" pcid="1972">
    function setSynthetixProxy(address _integrationProxy) external onlyOwner {
        integrationProxy = _integrationProxy;
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="23" endline="25" pcid="1973">
    function setSynthetix(address _synthetix) external onlyOwner {
        synthetix = _synthetix;
    }
</source>
</class>

<class classid="225" nclones="2" nlines="6" similarity="75">
<source file="systems/source-code/Proxyable.sol" startline="52" endline="56" pcid="1489">
    function _optionalProxy() private {
        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {
            messageSender = msg.sender;
        }
    }
</source>
<source file="systems/source-code/Proxyable.sol" startline="64" endline="69" pcid="1490">
    function _optionalProxy_onlyOwner() private {
        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {
            messageSender = msg.sender;
        }
        require(messageSender == owner, "Owner only function");
    }
</source>
</class>

<class classid="226" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="13" endline="16" pcid="1491">
    function name() public view returns (string memory) {
        // Immutable static call from target contract
        return IERC20(address(target)).name();
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="18" endline="21" pcid="1492">
    function symbol() public view returns (string memory) {
        // Immutable static call from target contract
        return IERC20(address(target)).symbol();
    }
</source>
</class>

<class classid="227" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="23" endline="26" pcid="1493">
    function decimals() public view returns (uint8) {
        // Immutable static call from target contract
        return IERC20(address(target)).decimals();
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="33" endline="36" pcid="1494">
    function totalSupply() public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(address(target)).totalSupply();
    }
</source>
</class>

<class classid="228" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="64" endline="73" pcid="1497">
    function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(address(target)).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="84" endline="93" pcid="1498">
    function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(address(target)).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
</source>
</class>

<class classid="229" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="17" endline="19" pcid="1500">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="17" endline="19" pcid="1503">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
</class>

<class classid="230" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="21" endline="27" pcid="1501">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="21" endline="27" pcid="1504">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
</class>

<class classid="231" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="32" endline="34" pcid="1502">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="32" endline="34" pcid="1505">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
</class>

<class classid="232" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="11" endline="13" pcid="1507">
    function unit() public pure returns (uint) {
        return SafeDecimalMath.unit();
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="15" endline="17" pcid="1508">
    function preciseUnit() public pure returns (uint) {
        return SafeDecimalMath.preciseUnit();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="25" endline="27" pcid="1761">
    function CONTRACT_NAME() external view returns (bytes32) {
        return SystemSettingsLib.contractName();
    }
</source>
</class>

<class classid="233" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="43" endline="45" pcid="1515">
    function decimalToPreciseDecimal(uint i) public pure returns (uint) {
        return i.decimalToPreciseDecimal();
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="47" endline="49" pcid="1516">
    function preciseDecimalToDecimal(uint i) public pure returns (uint) {
        return i.preciseDecimalToDecimal();
    }
</source>
</class>

<class classid="234" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/PurgeableSynth.sol" startline="72" endline="74" pcid="1520">
    function emitPurged(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, PURGED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="319" endline="321" pcid="1656">
    function emitBurned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="311" endline="313" pcid="1655">
    function emitIssued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
</class>

<class classid="235" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="98" endline="100" pcid="1526">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="71" endline="73" pcid="1725">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
</class>

<class classid="236" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="105" endline="107" pcid="1527">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="85" endline="87" pcid="1727">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="78" endline="80" pcid="1726">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="112" endline="114" pcid="1528">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="237" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="119" endline="127" pcid="1529">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = _numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="92" endline="100" pcid="1728">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
</class>

<class classid="238" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="132" endline="138" pcid="1530">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == _numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="105" endline="111" pcid="1729">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
</class>

<class classid="239" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="143" endline="145" pcid="1531">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="150" endline="152" pcid="1532">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="123" endline="125" pcid="1731">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="116" endline="118" pcid="1730">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
</class>

<class classid="240" nclones="2" nlines="17" similarity="71">
<source file="systems/source-code/RewardEscrow.sol" startline="173" endline="206" pcid="1534">
    function _appendVestingEntry(address account, uint quantity) internal {
        /* No empty or already-passed vesting entries allowed. */
        require(quantity != 0, "Quantity cannot be zero");

        /* There must be enough balance in the contract to provide for the vesting entry. */
        totalEscrowedBalance = totalEscrowedBalance.add(quantity);
        require(
            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),
            "Must be enough balance in the contract to provide for the vesting entry"
        );

        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */
        uint scheduleLength = vestingSchedules[account].length;
        require(scheduleLength <= MAX_VESTING_ENTRIES, "Vesting schedule is too long");

        /* Escrow the tokens for 1 year. */
        uint time = now + 52 weeks;

        if (scheduleLength == 0) {
            totalEscrowedAccountBalance[account] = quantity;
        } else {
            /* Disallow adding new vested SNX earlier than the last one.
             * Since entries are only appended, this means that no vesting date can be repeated. */
            require(
                getVestingTime(account, scheduleLength - 1) < time,
                "Cannot add new vested entries earlier than the last one"
            );
            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);
        }

        vestingSchedules[account].push([time, quantity]);

        emit VestingEntryCreated(account, now, quantity);
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="151" endline="184" pcid="1733">
    function appendVestingEntry(
        address account,
        uint time,
        uint quantity
    ) public onlyOwner onlyDuringSetup {
        /* No empty or already-passed vesting entries allowed. */
        require(now < time, "Time must be in the future");
        require(quantity != 0, "Quantity cannot be zero");

        /* There must be enough balance in the contract to provide for the vesting entry. */
        totalVestedBalance = totalVestedBalance.add(quantity);
        require(
            totalVestedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),
            "Must be enough balance in the contract to provide for the vesting entry"
        );

        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */
        uint scheduleLength = vestingSchedules[account].length;
        require(scheduleLength <= MAX_VESTING_ENTRIES, "Vesting schedule is too long");

        if (scheduleLength == 0) {
            totalVestedAccountBalance[account] = quantity;
        } else {
            /* Disallow adding new vested SNX earlier than the last one.
             * Since entries are only appended, this means that no vesting date can be repeated. */
            require(
                getVestingTime(account, numVestingEntries(account) - 1) < time,
                "Cannot add new vested entries earlier than the last one"
            );
            totalVestedAccountBalance[account] = totalVestedAccountBalance[account].add(quantity);
        }

        vestingSchedules[account].push([time, quantity]);
    }
</source>
</class>

<class classid="241" nclones="2" nlines="22" similarity="94">
<source file="systems/source-code/RewardEscrow.sol" startline="224" endline="247" pcid="1536">
    function vest() external {
        uint numEntries = _numVestingEntries(msg.sender);
        uint total;
        for (uint i = 0; i < numEntries; i++) {
            uint time = getVestingTime(msg.sender, i);
            /* The list is sorted; when we reach the first future time, bail out. */
            if (time > now) {
                break;
            }
            uint qty = getVestingQuantity(msg.sender, i);
            if (qty > 0) {
                vestingSchedules[msg.sender][i] = [0, 0];
                total = total.add(qty);
            }
        }

        if (total != 0) {
            totalEscrowedBalance = totalEscrowedBalance.sub(total);
            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);
            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);
            IERC20(address(synthetix)).transfer(msg.sender, total);
            emit Vested(msg.sender, now, total);
        }
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="206" endline="228" pcid="1735">
    function vest() external {
        uint numEntries = numVestingEntries(msg.sender);
        uint total;
        for (uint i = 0; i < numEntries; i++) {
            uint time = getVestingTime(msg.sender, i);
            /* The list is sorted; when we reach the first future time, bail out. */
            if (time > now) {
                break;
            }
            uint qty = getVestingQuantity(msg.sender, i);
            if (qty > 0) {
                vestingSchedules[msg.sender][i] = [0, 0];
                total = total.add(qty);
            }
        }

        if (total != 0) {
            totalVestedBalance = totalVestedBalance.sub(total);
            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].sub(total);
            IERC20(address(synthetix)).transfer(msg.sender, total);
            emit Vested(msg.sender, now, total);
        }
    }
</source>
</class>

<class classid="242" nclones="2" nlines="7" similarity="80">
<source file="systems/source-code/SafeDecimalMath.sol" startline="61" endline="74" pcid="1567">
    function _multiplyDecimalRound(
        uint x,
        uint y,
        uint precisionUnit
    ) private pure returns (uint) {
        /* Divide by UNIT to remove the extra factor introduced by the product. */
        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);

        if (quotientTimesTen % 10 >= 5) {
            quotientTimesTen += 10;
        }

        return quotientTimesTen / 10;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="130" endline="142" pcid="1571">
    function _divideDecimalRound(
        uint x,
        uint y,
        uint precisionUnit
    ) private pure returns (uint) {
        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);

        if (resultTimesTen % 10 >= 5) {
            resultTimesTen += 10;
        }

        return resultTimesTen / 10;
    }
</source>
</class>

<class classid="243" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SafeDecimalMath.sol" startline="88" endline="90" pcid="1568">
    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {
        return _multiplyDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="164" endline="166" pcid="1573">
    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {
        return _divideDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="152" endline="154" pcid="1572">
    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {
        return _divideDecimalRound(x, y, UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="104" endline="106" pcid="1569">
    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {
        return _multiplyDecimalRound(x, y, UNIT);
    }
</source>
</class>

<class classid="244" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="73" endline="75" pcid="1583">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="57" endline="59" pcid="1611">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
</class>

<class classid="245" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="77" endline="85" pcid="1584">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="61" endline="69" pcid="1612">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
</class>

<class classid="246" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="87" endline="89" pcid="1585">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="71" endline="73" pcid="1613">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
</class>

<class classid="247" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="91" endline="93" pcid="1586">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="75" endline="77" pcid="1614">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
</class>

<class classid="248" nclones="2" nlines="15" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="125" endline="144" pcid="1590">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="113" endline="132" pcid="1619">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
</class>

<class classid="249" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="100" endline="102" pcid="1597">
    function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {
        return _multiplyDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="171" endline="173" pcid="1602">
    function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {
        return _divideDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="116" endline="118" pcid="1598">
    function multiplyDecimalRound(int x, int y) internal pure returns (int) {
        return _multiplyDecimalRound(x, y, UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="159" endline="161" pcid="1601">
    function divideDecimalRound(int x, int y) internal pure returns (int) {
        return _divideDecimalRound(x, y, UNIT);
    }
</source>
</class>

<class classid="250" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="142" endline="145" pcid="1708">
    function addAuthorizedBroker(address target) external onlyOwner {
        authorizedBrokers[target] = true;
        emit ChangeAuthorizedBroker(target, true);
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="152" endline="155" pcid="1710">
    function addAuthorizedToSnapshot(address target) external onlyOwner {
        authorizedToSnapshot[target] = true;
        emit ChangeAuthorizedToSnapshot(target, true);
    }
</source>
</class>

<class classid="251" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="147" endline="150" pcid="1709">
    function removeAuthorizedBroker(address target) external onlyOwner {
        authorizedBrokers[target] = false;
        emit ChangeAuthorizedBroker(target, false);
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="157" endline="160" pcid="1711">
    function removeAuthorizedToSnapshot(address target) external onlyOwner {
        authorizedToSnapshot[target] = false;
        emit ChangeAuthorizedToSnapshot(target, false);
    }
</source>
</class>

<class classid="252" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="189" endline="191" pcid="1715">
    function approve(address, uint256) external pure returns (bool) {
        revert("debt shares are not transferrable");
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="193" endline="195" pcid="1716">
    function transfer(address, uint256) external pure returns (bool) {
        revert("debt shares are not transferrable");
    }
</source>
</class>

<class classid="253" nclones="2" nlines="13" similarity="70">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="240" endline="254" pcid="1720">
    function _increaseBalance(address account, uint amount) internal {
        uint accountBalanceCount = balances[account].length;

        if (accountBalanceCount == 0) {
            balances[account].push(PeriodBalance(uint128(amount), uint128(currentPeriodId)));
        } else {
            uint128 newAmount = uint128(uint(balances[account][accountBalanceCount - 1].amount).add(amount));

            if (balances[account][accountBalanceCount - 1].periodId != currentPeriodId) {
                balances[account].push(PeriodBalance(newAmount, currentPeriodId));
            } else {
                balances[account][accountBalanceCount - 1].amount = newAmount;
            }
        }
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="256" endline="268" pcid="1721">
    function _deductBalance(address account, uint amount) internal {
        uint accountBalanceCount = balances[account].length;

        require(accountBalanceCount != 0, "SynthetixDebtShare: account has no share to deduct");

        uint128 newAmount = uint128(uint(balances[account][accountBalanceCount - 1].amount).sub(amount));

        if (balances[account][accountBalanceCount - 1].periodId != currentPeriodId) {
            balances[account].push(PeriodBalance(newAmount, currentPeriodId));
        } else {
            balances[account][accountBalanceCount - 1].amount = newAmount;
        }
    }
</source>
</class>

<class classid="254" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SynthetixState.sol" startline="67" endline="69" pcid="1738">
    function incrementTotalIssuerCount() external onlyAssociatedContract {
        totalIssuerCount = totalIssuerCount.add(1);
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="75" endline="77" pcid="1739">
    function decrementTotalIssuerCount() external onlyAssociatedContract {
        totalIssuerCount = totalIssuerCount.sub(1);
    }
</source>
</class>

<class classid="255" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="128" endline="130" pcid="1777">
    function exchangeDynamicFeeThreshold() external view returns (uint) {
        return getExchangeDynamicFeeConfig().threshold;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="140" endline="142" pcid="1779">
    function exchangeDynamicFeeRounds() external view returns (uint) {
        return getExchangeDynamicFeeConfig().rounds;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="146" endline="148" pcid="1780">
    function exchangeMaxDynamicFee() external view returns (uint) {
        return getExchangeDynamicFeeConfig().maxFee;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="134" endline="136" pcid="1778">
    function exchangeDynamicFeeWeightDecay() external view returns (uint) {
        return getExchangeDynamicFeeConfig().weightDecay;
    }
</source>
</class>

<class classid="256" nclones="17" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="276" endline="279" pcid="1803">
    function setIssuanceRatio(uint ratio) external onlyOwner {
        flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO, ratio);
        emit IssuanceRatioUpdated(ratio);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="356" endline="359" pcid="1817">
    function setRateStalePeriod(uint period) external onlyOwner {
        flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD, period);
        emit RateStalePeriodUpdated(period);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="336" endline="339" pcid="1813">
    function setLiquidationPenalty(uint penalty) external onlyOwner {
        flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY, penalty);
        emit LiquidationPenaltyUpdated(penalty);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="331" endline="334" pcid="1812">
    function setSnxLiquidationPenalty(uint penalty) external onlyOwner {
        flexibleStorage().setSnxLiquidationPenalty(SETTING_SNX_LIQUIDATION_PENALTY, penalty);
        emit SnxLiquidationPenaltyUpdated(penalty);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="309" endline="312" pcid="1809">
    function setLiquidationDelay(uint time) external onlyOwner {
        flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY, time);
        emit LiquidationDelayUpdated(time);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="291" endline="297" pcid="1806">
    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {
        flexibleStorage().setPriceDeviationThresholdFactor(
            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,
            _priceDeviationThresholdFactor
        );
        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="426" endline="429" pcid="1826">
    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {
        flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);
        emit EtherWrapperMaxETHUpdated(_maxETH);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="436" endline="439" pcid="1828">
    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {
        flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);
        emit EtherWrapperBurnFeeRateUpdated(_rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="431" endline="434" pcid="1827">
    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {
        flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);
        emit EtherWrapperMintFeeRateUpdated(_rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="481" endline="484" pcid="1835">
    function setAtomicTwapWindow(uint _window) external onlyOwner {
        flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW, _window);
        emit AtomicTwapWindowUpdated(_window);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="406" endline="409" pcid="1822">
    function setExchangeMaxDynamicFee(uint maxFee) external onlyOwner {
        flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE, maxFee);
        emit ExchangeMaxDynamicFeeUpdated(maxFee);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="341" endline="344" pcid="1814">
    function setSelfLiquidationPenalty(uint penalty) external onlyOwner {
        flexibleStorage().setSelfLiquidationPenalty(SETTING_SELF_LIQUIDATION_PENALTY, penalty);
        emit SelfLiquidationPenaltyUpdated(penalty);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="299" endline="302" pcid="1807">
    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {
        flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);
        emit FeePeriodDurationUpdated(_feePeriodDuration);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="416" endline="419" pcid="1824">
    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {
        flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);
        emit DebtSnapshotStaleTimeUpdated(_seconds);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="411" endline="414" pcid="1823">
    function setMinimumStakeTime(uint _seconds) external onlyOwner {
        flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME, _seconds);
        emit MinimumStakeTimeUpdated(_seconds);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="286" endline="289" pcid="1805">
    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {
        flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);
        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="476" endline="479" pcid="1834">
    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {
        flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);
        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);
    }
</source>
</class>

<class classid="257" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="446" endline="454" pcid="1830">
    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {
        flexibleStorage().setWrapperMintFeeRate(
            SETTING_WRAPPER_MINT_FEE_RATE,
            _wrapper,
            _rate,
            getWrapperBurnFeeRate(_wrapper)
        );
        emit WrapperMintFeeRateUpdated(_wrapper, _rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="456" endline="464" pcid="1831">
    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {
        flexibleStorage().setWrapperBurnFeeRate(
            SETTING_WRAPPER_BURN_FEE_RATE,
            _wrapper,
            _rate,
            getWrapperMintFeeRate(_wrapper)
        );
        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);
    }
</source>
</class>

<class classid="258" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="466" endline="469" pcid="1832">
    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {
        flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY, _collateral, _interactionDelay);
        emit InteractionDelayUpdated(_interactionDelay);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="471" endline="474" pcid="1833">
    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {
        flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE, _collateral, _collapseFeeRate);
        emit CollapseFeeRateUpdated(_collapseFeeRate);
    }
</source>
</class>

<class classid="259" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="500" endline="507" pcid="1838">
    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {
        flexibleStorage().setAtomicVolatilityConsiderationWindow(
            SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,
            _currencyKey,
            _window
        );
        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="527" endline="530" pcid="1841">
    function setCrossChainSynthTransferEnabled(bytes32 _currencyKey, uint _value) external onlyOwner {
        flexibleStorage().setCrossChainSynthTransferEnabled(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, _currencyKey, _value);
        emit CrossChainSynthTransferEnabledUpdated(_currencyKey, _value);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="509" endline="516" pcid="1839">
    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {
        flexibleStorage().setAtomicVolatilityUpdateThreshold(
            SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,
            _currencyKey,
            _threshold
        );
        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);
    }
</source>
</class>

<class classid="260" nclones="8" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="95" endline="101" pcid="1846">
    function setWaitingPeriodSecs(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _waitingPeriodSecs
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _waitingPeriodSecs);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="253" endline="259" pcid="1861">
    function setDebtSnapshotStaleTime(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _seconds
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="270" endline="276" pcid="1863">
    function setEtherWrapperMaxETH(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _maxETH
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxETH);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="219" endline="225" pcid="1858">
    function setRateStalePeriod(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint period
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, period);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="211" endline="217" pcid="1857">
    function setLiquidateReward(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint reward
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, reward);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="103" endline="109" pcid="1847">
    function setPriceDeviationThresholdFactor(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _priceDeviationThresholdFactor
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _priceDeviationThresholdFactor);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="203" endline="209" pcid="1856">
    function setFlagReward(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint reward
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, reward);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="164" endline="170" pcid="1852">
    function setLiquidationEscrowDuration(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint duration
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, duration);
    }
</source>
</class>

<class classid="261" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="172" endline="181" pcid="1853">
    function setSnxLiquidationPenalty(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint penalty
    ) external {
        // MAX_LIQUIDATION_PENALTY is enforced on both Collateral and SNX liquidations
        require(penalty <= MAX_LIQUIDATION_PENALTY, "penalty > MAX_LIQUIDATION_PENALTY");

        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, penalty);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="183" endline="191" pcid="1854">
    function setSelfLiquidationPenalty(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint penalty
    ) external {
        require(penalty <= MAX_LIQUIDATION_PENALTY, "penalty > MAX_LIQUIDATION_PENALTY");

        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, penalty);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="193" endline="201" pcid="1855">
    function setLiquidationPenalty(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint penalty
    ) external {
        require(penalty <= MAX_LIQUIDATION_PENALTY, "penalty > MAX_LIQUIDATION_PENALTY");

        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, penalty);
    }
</source>
</class>

<class classid="262" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="296" endline="307" pcid="1866">
    function setWrapperMaxTokenAmount(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        address _wrapper,
        uint _maxTokenAmount
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _wrapper)),
            _maxTokenAmount
        );
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="361" endline="372" pcid="1870">
    function setCollapseFeeRate(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        address _collateral,
        uint _collapseFeeRate
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _collateral)),
            _collapseFeeRate
        );
    }
</source>
</class>

<class classid="263" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="444" endline="455" pcid="1876">
    function setAtomicVolatilityUpdateThreshold(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        bytes32 _currencyKey,
        uint _threshold
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _currencyKey)),
            _threshold
        );
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="470" endline="477" pcid="1878">
    function setCrossChainSynthTransferEnabled(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        bytes32 _currencyKey,
        uint _value
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _currencyKey)), _value);
    }
</source>
</class>

<class classid="264" nclones="3" nlines="4" similarity="75">
<source file="systems/source-code/SystemStatus.sol" startline="47" endline="53" pcid="1882">
    function requireIssuanceActive() external view {
        // Issuance requires the system be active
        _internalRequireSystemActive();

        // and issuance itself of course
        _internalRequireIssuanceActive();
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="55" endline="61" pcid="1883">
    function requireExchangeActive() external view {
        // Exchanging requires the system be active
        _internalRequireSystemActive();

        // and exchanging itself of course
        _internalRequireExchangeActive();
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="69" endline="73" pcid="1885">
    function requireFuturesActive() external view {
        _internalRequireSystemActive();
        _internalRequireExchangeActive();
        _internalRequireFuturesActive();
    }
</source>
</class>

<class classid="265" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="63" endline="67" pcid="1884">
    function requireSynthExchangeActive(bytes32 currencyKey) external view {
        // Synth exchange and transfer requires the system be active
        _internalRequireSystemActive();
        _internalRequireSynthExchangeActive(currencyKey);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="87" endline="91" pcid="1888">
    function requireSynthActive(bytes32 currencyKey) external view {
        // Synth exchange and transfer requires the system be active
        _internalRequireSystemActive();
        _internalRequireSynthActive(currencyKey);
    }
</source>
</class>

<class classid="266" nclones="3" nlines="8" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="120" endline="132" pcid="1892">
    function getSynthExchangeSuspensions(bytes32[] calldata synths)
        external
        view
        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)
    {
        exchangeSuspensions = new bool[](synths.length);
        reasons = new uint256[](synths.length);

        for (uint i = 0; i < synths.length; i++) {
            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;
            reasons[i] = synthExchangeSuspension[synths[i]].reason;
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="149" endline="161" pcid="1894">
    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)
        external
        view
        returns (bool[] memory suspensions, uint256[] memory reasons)
    {
        suspensions = new bool[](marketKeys.length);
        reasons = new uint256[](marketKeys.length);

        for (uint i = 0; i < marketKeys.length; i++) {
            suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended;
            reasons[i] = futuresMarketSuspension[marketKeys[i]].reason;
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="134" endline="146" pcid="1893">
    function getSynthSuspensions(bytes32[] calldata synths)
        external
        view
        returns (bool[] memory suspensions, uint256[] memory reasons)
    {
        suspensions = new bool[](synths.length);
        reasons = new uint256[](synths.length);

        for (uint i = 0; i < synths.length; i++) {
            suspensions[i] = synthSuspension[synths[i]].suspended;
            reasons[i] = synthSuspension[synths[i]].reason;
        }
    }
</source>
</class>

<class classid="267" nclones="4" nlines="6" similarity="80">
<source file="systems/source-code/SystemStatus.sol" startline="190" endline="195" pcid="1897">
    function suspendSystem(uint256 reason) external {
        _requireAccessToSuspend(SECTION_SYSTEM);
        systemSuspension.suspended = true;
        systemSuspension.reason = uint248(reason);
        emit SystemSuspended(systemSuspension.reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="232" endline="237" pcid="1903">
    function suspendFutures(uint256 reason) external {
        _requireAccessToSuspend(SECTION_FUTURES);
        futuresSuspension.suspended = true;
        futuresSuspension.reason = uint248(reason);
        emit FuturesSuspended(reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="218" endline="223" pcid="1901">
    function suspendExchange(uint256 reason) external {
        _requireAccessToSuspend(SECTION_EXCHANGE);
        exchangeSuspension.suspended = true;
        exchangeSuspension.reason = uint248(reason);
        emit ExchangeSuspended(reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="204" endline="209" pcid="1899">
    function suspendIssuance(uint256 reason) external {
        _requireAccessToSuspend(SECTION_ISSUANCE);
        issuanceSuspension.suspended = true;
        issuanceSuspension.reason = uint248(reason);
        emit IssuanceSuspended(reason);
    }
</source>
</class>

<class classid="268" nclones="4" nlines="6" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="197" endline="202" pcid="1898">
    function resumeSystem() external {
        _requireAccessToResume(SECTION_SYSTEM);
        systemSuspension.suspended = false;
        emit SystemResumed(uint256(systemSuspension.reason));
        systemSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="239" endline="244" pcid="1904">
    function resumeFutures() external {
        _requireAccessToResume(SECTION_FUTURES);
        futuresSuspension.suspended = false;
        emit FuturesResumed(uint256(futuresSuspension.reason));
        futuresSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="225" endline="230" pcid="1902">
    function resumeExchange() external {
        _requireAccessToResume(SECTION_EXCHANGE);
        exchangeSuspension.suspended = false;
        emit ExchangeResumed(uint256(exchangeSuspension.reason));
        exchangeSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="211" endline="216" pcid="1900">
    function resumeIssuance() external {
        _requireAccessToResume(SECTION_ISSUANCE);
        issuanceSuspension.suspended = false;
        emit IssuanceResumed(uint256(issuanceSuspension.reason));
        issuanceSuspension.reason = 0;
    }
</source>
</class>

<class classid="269" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="247" endline="251" pcid="1905">
    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external {
        bytes32[] memory marketKeys = new bytes32[](1);
        marketKeys[0] = marketKey;
        _internalSuspendFuturesMarkets(marketKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="270" endline="274" pcid="1909">
    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalSuspendSynthExchange(currencyKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="290" endline="294" pcid="1913">
    function suspendSynth(bytes32 currencyKey, uint256 reason) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalSuspendSynths(currencyKeys, reason);
    }
</source>
</class>

<class classid="270" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="254" endline="256" pcid="1906">
    function suspendFuturesMarkets(bytes32[] calldata marketKeys, uint256 reason) external {
        _internalSuspendFuturesMarkets(marketKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="296" endline="298" pcid="1914">
    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {
        _internalSuspendSynths(currencyKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="276" endline="278" pcid="1910">
    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {
        _internalSuspendSynthExchange(currencyKeys, reason);
    }
</source>
</class>

<class classid="271" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="259" endline="263" pcid="1907">
    function resumeFuturesMarket(bytes32 marketKey) external {
        bytes32[] memory marketKeys = new bytes32[](1);
        marketKeys[0] = marketKey;
        _internalResumeFuturesMarkets(marketKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="300" endline="304" pcid="1915">
    function resumeSynth(bytes32 currencyKey) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalResumeSynths(currencyKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="280" endline="284" pcid="1911">
    function resumeSynthExchange(bytes32 currencyKey) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalResumeSynthsExchange(currencyKeys);
    }
</source>
</class>

<class classid="272" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="266" endline="268" pcid="1908">
    function resumeFuturesMarkets(bytes32[] calldata marketKeys) external {
        _internalResumeFuturesMarkets(marketKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="306" endline="308" pcid="1916">
    function resumeSynths(bytes32[] calldata currencyKeys) external {
        _internalResumeSynths(currencyKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="286" endline="288" pcid="1912">
    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {
        _internalResumeSynthsExchange(currencyKeys);
    }
</source>
</class>

<class classid="273" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="312" endline="314" pcid="1917">
    function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="316" endline="318" pcid="1918">
    function _requireAccessToResume(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canResume, "Restricted to access control list");
    }
</source>
</class>

<class classid="274" nclones="3" nlines="9" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="353" endline="361" pcid="1926">
    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_SYNTH);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            synthSuspension[currencyKey].suspended = true;
            synthSuspension[currencyKey].reason = uint248(reason);
            emit SynthSuspended(currencyKey, reason);
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="391" endline="399" pcid="1930">
    function _internalSuspendFuturesMarkets(bytes32[] memory marketKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_FUTURES);
        for (uint i = 0; i < marketKeys.length; i++) {
            bytes32 marketKey = marketKeys[i];
            futuresMarketSuspension[marketKey].suspended = true;
            futuresMarketSuspension[marketKey].reason = uint248(reason);
            emit FuturesMarketSuspended(marketKey, reason);
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="372" endline="380" pcid="1928">
    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            synthExchangeSuspension[currencyKey].suspended = true;
            synthExchangeSuspension[currencyKey].reason = uint248(reason);
            emit SynthExchangeSuspended(currencyKey, reason);
        }
    }
</source>
</class>

<class classid="275" nclones="3" nlines="8" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="363" endline="370" pcid="1927">
    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {
        _requireAccessToResume(SECTION_SYNTH);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));
            delete synthSuspension[currencyKey];
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="401" endline="408" pcid="1931">
    function _internalResumeFuturesMarkets(bytes32[] memory marketKeys) internal {
        _requireAccessToResume(SECTION_FUTURES);
        for (uint i = 0; i < marketKeys.length; i++) {
            bytes32 marketKey = marketKeys[i];
            emit FuturesMarketResumed(marketKey, uint256(futuresMarketSuspension[marketKey].reason));
            delete futuresMarketSuspension[marketKey];
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="382" endline="389" pcid="1929">
    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {
        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));
            delete synthExchangeSuspension[currencyKey];
        }
    }
</source>
</class>

<class classid="276" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="18" endline="20" pcid="1939">
    function add(address element) public {
        set.add(element);
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="22" endline="24" pcid="1940">
    function remove(address element) public {
        set.remove(element);
    }
</source>
</class>

<class classid="277" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="30" endline="32" pcid="1942">
    function element(uint index) public view returns (address) {
        return set.elements[index];
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="30" endline="32" pcid="1949">
    function element(uint index) public view returns (bytes32) {
        return set.elements[index];
    }
</source>
</class>

<class classid="278" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableBytes32Set.sol" startline="18" endline="20" pcid="1946">
    function add(bytes32 element) public {
        set.add(element);
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="22" endline="24" pcid="1947">
    function remove(bytes32 element) public {
        set.remove(element);
    }
</source>
</class>

<class classid="279" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="28" endline="44" pcid="1957">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxMarketValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="28" endline="44" pcid="1967">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxSingleSideValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
</class>

<class classid="280" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="52" endline="56" pcid="1958">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="52" endline="56" pcid="1968">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
</class>

<class classid="281" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="61" endline="66" pcid="1959">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="61" endline="66" pcid="1969">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
</class>

<class classid="282" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TokenExchanger.sol" startline="27" endline="29" pcid="1974">
    function checkBalance(address account) public view synthetixProxyIsSet returns (uint) {
        return IERC20(integrationProxy).balanceOf(account);
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="35" endline="37" pcid="1976">
    function checkBalanceSNXDirect(address account) public view synthetixProxyIsSet returns (uint) {
        return IERC20(synthetix).balanceOf(account);
    }
</source>
</class>

<class classid="283" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/TradingRewards.sol" startline="94" endline="96" pcid="1989">
    function getPeriodIsClaimable(uint periodID) external view returns (bool) {
        return _periods[periodID].isFinalized;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="106" endline="108" pcid="1992">
    function getPeriodTotalRewards(uint periodID) external view returns (uint) {
        return _periods[periodID].totalRewards;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="98" endline="100" pcid="1990">
    function getPeriodIsFinalized(uint periodID) external view returns (bool) {
        return _periods[periodID].isFinalized;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="110" endline="112" pcid="1993">
    function getPeriodAvailableRewards(uint periodID) external view returns (uint) {
        return _periods[periodID].availableRewards;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="102" endline="104" pcid="1991">
    function getPeriodRecordedFees(uint periodID) external view returns (uint) {
        return _periods[periodID].recordedFees;
    }
</source>
</class>

</clones>
