<clones>
<systeminfo processor="nicad6" system="source-code" granularity="functions-consistent" threshold="0%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="1890" npairs="11341"/>
<runinfo ncompares="466934" cputime="24295"/>
<classinfo nclasses="237"/>

<class classid="1" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/AddressResolver.sol" startline="49" endline="51" pcid="4">
    function getAddress(bytes32 name) external view returns (address) {
        return repository[name];
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="111" endline="113" pcid="22">
    function cachedSynthDebt(bytes32 currencyKey) external view returns (uint) {
        return _cachedSynthDebt[currencyKey];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="106" endline="108" pcid="409">
    function getIntValue(bytes32 record) external view returns (int) {
        return IntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="93" endline="95" pcid="406">
    function getBooleanValue(bytes32 record) external view returns (bool) {
        return BooleanStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="54" endline="56" pcid="397">
    function getAddressValue(bytes32 record) external view returns (address) {
        return AddressStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="80" endline="82" pcid="403">
    function getBytes32Value(bytes32 record) external view returns (bytes32) {
        return Bytes32Storage[record];
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="80" endline="82" pcid="437">
    function lastExchangeRate(bytes32 currencyKey) external view returns (uint) {
        return _lastExchangeRate[currencyKey];
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="127" endline="129" pcid="280">
    function shortRateLastUpdated(bytes32 currency) internal view returns (uint) {
        return shortRatesLastUpdated[currency];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="28" endline="30" pcid="391">
    function getUIntValue(bytes32 record) external view returns (uint) {
        return UIntStorage[record];
    }
</source>
</class>

<class classid="2" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="57" endline="69" pcid="11">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](8);
        newAddresses[0] = CONTRACT_ISSUER;
        newAddresses[1] = CONTRACT_EXCHANGER;
        newAddresses[2] = CONTRACT_EXRATES;
        newAddresses[3] = CONTRACT_SYSTEMSTATUS;
        newAddresses[4] = CONTRACT_COLLATERALMANAGER;
        newAddresses[5] = CONTRACT_WRAPPER_FACTORY;
        newAddresses[6] = CONTRACT_ETHER_WRAPPER;
        newAddresses[7] = CONTRACT_FUTURESMARKETMANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="101" endline="113" pcid="154">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](8);
        newAddresses[0] = CONTRACT_EXT_MESSENGER;
        newAddresses[1] = CONTRACT_SYNTHETIX;
        newAddresses[2] = CONTRACT_REWARDESCROW;
        newAddresses[3] = CONTRACT_ISSUER;
        newAddresses[4] = CONTRACT_FEEPOOL;
        newAddresses[5] = CONTRACT_FLEXIBLESTORAGE;
        newAddresses[6] = CONTRACT_EXCHANGERATES;
        newAddresses[7] = CONTRACT_SYSTEM_STATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="3" nclones="125" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="71" endline="73" pcid="12">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="44" endline="46" pcid="1885">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="70" endline="72" pcid="1836">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="75" endline="77" pcid="13">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="66" endline="68" pcid="1835">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="40" endline="42" pcid="1884">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="36" endline="38" pcid="1883">
    function synthsUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTH_SUSD));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="149" endline="151" pcid="590">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="69" endline="71" pcid="892">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="41" endline="43" pcid="1243">
    function synthsETH() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSETH));
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="51" endline="53" pcid="1058">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="79" endline="81" pcid="14">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="165" endline="167" pcid="594">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="58" endline="60" pcid="91">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="217" endline="219" pcid="671">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="507" endline="509" pcid="353">
    function synthsUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="139" endline="141" pcid="810">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="40" endline="42" pcid="1550">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="155" endline="157" pcid="1270">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="204" endline="206" pcid="1515">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="132" endline="134" pcid="173">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="49" endline="51" pcid="1528">
    function supplySchedule() internal view returns (ISupplySchedule) {
        return ISupplySchedule(requireAndGetAddress(CONTRACT_SUPPLYSCHEDULE));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="91" endline="93" pcid="17">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="118" endline="120" pcid="448">
    function exchangeState() internal view returns (IExchangeState) {
        return IExchangeState(requireAndGetAddress(CONTRACT_EXCHANGESTATE));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="209" endline="211" pcid="669">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="216" endline="218" pcid="1518">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="59" endline="61" pcid="1450">
    function _short() internal view returns (ICollateralErc20) {
        return ICollateralErc20(requireAndGetAddress(CONTRACT_SHORT));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="87" endline="89" pcid="16">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="74" endline="76" pcid="1143">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="83" endline="85" pcid="15">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="42" endline="44" pcid="1388">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="66" endline="68" pcid="93">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="40" endline="42" pcid="1235">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="135" endline="137" pcid="809">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="122" endline="124" pcid="449">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="33" endline="35" pcid="769">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="99" endline="101" pcid="19">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="143" endline="145" pcid="811">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="208" endline="210" pcid="1516">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="34" endline="36" pcid="1325">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="128" endline="130" pcid="172">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="74" endline="76" pcid="893">
    function eternalStorageLiquidations() internal view returns (EternalStorage) {
        return EternalStorage(requireAndGetAddress(CONTRACT_ETERNALSTORAGE_LIQUIDATIONS));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="36" endline="38" pcid="1549">
    function synthetixERC20() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="159" endline="161" pcid="1271">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="131" endline="133" pcid="808">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="73" endline="75" pcid="60">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="73" endline="75" pcid="748">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="114" endline="116" pcid="447">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="36" endline="38" pcid="1614">
    function sUSD() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="89" endline="91" pcid="417">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="169" endline="171" pcid="595">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="65" endline="67" pcid="891">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="133" endline="135" pcid="586">
    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {
        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="32" endline="34" pcid="1613">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="138" endline="140" pcid="453">
    function tradingRewards() internal view returns (ITradingRewards) {
        return ITradingRewards(requireAndGetAddress(CONTRACT_TRADING_REWARDS));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="89" endline="91" pcid="439">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="147" endline="149" pcid="812">
    function liquidations() internal view returns (ILiquidations) {
        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="82" endline="84" pcid="151">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEM_STATUS));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="163" endline="165" pcid="1272">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="146" endline="148" pcid="455">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="61" endline="63" pcid="890">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="62" endline="64" pcid="146">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="150" endline="152" pcid="456">
    function debtCache() internal view returns (IExchangerInternalDebtCache) {
        return IExchangerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="130" endline="132" pcid="451">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="42" endline="44" pcid="1409">
    function oldRewardEscrow() internal view returns (IRewardEscrow) {
        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="93" endline="95" pcid="440">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="46" endline="48" pcid="1410">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="125" endline="127" pcid="584">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="153" endline="155" pcid="591">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="28" endline="30" pcid="1260">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="120" endline="122" pcid="170">
    function _synthsUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="141" endline="143" pcid="588">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="151" endline="153" pcid="813">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="200" endline="202" pcid="1514">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="57" endline="59" pcid="889">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="97" endline="99" pcid="441">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="127" endline="129" pcid="807">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="137" endline="139" pcid="587">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="515" endline="517" pcid="355">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="41" endline="43" pcid="1526">
    function rewardEscrow() internal view returns (IRewardEscrow) {
        return IRewardEscrow(requireAndGetAddress(CONTRACT_REWARD_ESCROW));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="44" endline="46" pcid="1236">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="95" endline="97" pcid="18">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="145" endline="147" pcid="589">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="112" endline="114" pcid="168">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="137" endline="139" pcid="225">
    function _issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="136" endline="138" pcid="174">
    function _collateralUtil() internal view returns (ICollateralUtil) {
        return ICollateralUtil(requireAndGetAddress(CONTRACT_COLLATERALUTIL));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="73" endline="75" pcid="413">
    function synthsUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="511" endline="513" pcid="354">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="126" endline="128" pcid="450">
    function exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="69" endline="71" pcid="747">
    function _sUSD() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSUSD));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="205" endline="207" pcid="668">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="85" endline="87" pcid="416">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="155" endline="157" pcid="814">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="70" endline="72" pcid="94">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="78" endline="80" pcid="150">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXCHANGERATES));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="142" endline="144" pcid="454">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="33" endline="35" pcid="1241">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="24" endline="26" pcid="1254">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="77" endline="79" pcid="61">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="159" endline="161" pcid="815">
    function synthetixEscrow() internal view returns (IHasBalance) {
        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="124" endline="126" pcid="171">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="141" endline="143" pcid="226">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="45" endline="47" pcid="1527">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="58" endline="60" pcid="145">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="171" endline="173" pcid="818">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="62" endline="64" pcid="92">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="54" endline="56" pcid="144">
    function messenger() internal view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="66" endline="68" pcid="147">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="51" endline="53" pcid="1106">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="134" endline="136" pcid="452">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="157" endline="159" pcid="592">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="163" endline="165" pcid="816">
    function debtCache() internal view returns (IIssuerInternalDebtCache) {
        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="167" endline="169" pcid="817">
    function synthRedeemer() internal view returns (ISynthRedeemer) {
        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="213" endline="215" pcid="670">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="77" endline="79" pcid="414">
    function synthsETH() internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(CONTRACT_SYNTHSETH));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="81" endline="83" pcid="415">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="69" endline="71" pcid="59">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="212" endline="214" pcid="1517">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="70" endline="72" pcid="148">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="36" endline="38" pcid="1234">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="77" endline="79" pcid="749">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="74" endline="76" pcid="149">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="161" endline="163" pcid="593">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="129" endline="131" pcid="585">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="167" endline="169" pcid="1273">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
</class>

<class classid="4" nclones="51" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="103" endline="105" pcid="20">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="186" endline="188" pcid="1657">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="154" endline="156" pcid="1651">
    function etherWrapperBurnFeeRate() external view returns (uint) {
        return getEtherWrapperBurnFeeRate();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="148" endline="150" pcid="1650">
    function etherWrapperMintFeeRate() external view returns (uint) {
        return getEtherWrapperMintFeeRate();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="142" endline="144" pcid="1649">
    function etherWrapperMaxETH() external view returns (uint) {
        return getEtherWrapperMaxETH();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="132" endline="134" pcid="1647">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="126" endline="128" pcid="1646">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="122" endline="124" pcid="1645">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="118" endline="120" pcid="1644">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="82" endline="84" pcid="1638">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="77" endline="79" pcid="1637">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="71" endline="73" pcid="1636">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="192" endline="194" pcid="1658">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="197" endline="199" pcid="820">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="155" endline="157" pcid="783">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="35" endline="37" pcid="543">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="132" endline="134" pcid="424">
    function mintFeeRate() public view returns (uint256) {
        return getEtherWrapperMintFeeRate();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="147" endline="149" pcid="782">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="30" endline="32" pcid="1539">
    function counterpart() internal view returns (address) {
        return synthetixBridgeToOptimism();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="128" endline="130" pcid="423">
    function maxETH() public view returns (uint256) {
        return getEtherWrapperMaxETH();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="140" endline="142" pcid="781">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="132" endline="134" pcid="780">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="138" endline="140" pcid="1872">
    function secsLeftInWaitingPeriod() external view returns (uint) {
        return secsLeft();
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="128" endline="130" pcid="1870">
    function rate() external view returns (uint) {
        return calcRate();
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="49" endline="51" pcid="554">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="148" endline="150" pcid="1338">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="181" endline="183" pcid="598">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="64" endline="66" pcid="1635">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="58" endline="60" pcid="1634">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="177" endline="179" pcid="597">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="78" endline="80" pcid="894">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="53" endline="55" pcid="1633">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="166" endline="168" pcid="460">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="45" endline="47" pcid="1632">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="358" endline="360" pcid="834">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="39" endline="41" pcid="1631">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="88" endline="90" pcid="505">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="90" endline="92" pcid="897">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="156" endline="158" pcid="1339">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="136" endline="138" pcid="425">
    function burnFeeRate() public view returns (uint256) {
        return getEtherWrapperBurnFeeRate();
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="173" endline="175" pcid="596">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="82" endline="84" pcid="895">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="86" endline="88" pcid="896">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="84" endline="86" pcid="504">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="141" endline="143" pcid="1337">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="32" endline="34" pcid="1630">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="133" endline="135" pcid="1336">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="162" endline="164" pcid="459">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="76" endline="78" pcid="436">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="60" endline="62" pcid="1555">
    function counterpart() internal view returns (address) {
        return synthetixBridgeToBase();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="158" endline="160" pcid="458">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
</class>

<class classid="5" nclones="22" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="107" endline="109" pcid="21">
    function cachedDebt() external view returns (uint) {
        return _cachedDebt;
    }
</source>
<source file="systems/source-code/WETH.sol" startline="41" endline="46" pcid="1878">
    function totalSupply() public view returns (uint) {
        // Using _totalSupply instead of balanceOf[this]
        // as it would cause error in OVM compile
        // return address(this).balance;
        return _totalSupply;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="90" endline="92" pcid="1841">
    function getCurrentPeriod() external view returns (uint) {
        return _currentPeriodID;
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="65" endline="67" pcid="1451">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="114" endline="116" pcid="1184">
    function decimals() external view returns (uint8) {
        return keyDecimals;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="86" endline="88" pcid="1840">
    function getPeriodController() external view returns (address) {
        return _periodController;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="110" endline="112" pcid="1183">
    function latestRound() public view returns (uint256) {
        return roundId;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="74" endline="76" pcid="1837">
    function getAvailableRewards() external view returns (uint) {
        return _balanceAssignedToRewards;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="31" endline="33" pcid="1435">
    function preciseUnit() external pure returns (uint) {
        return PRECISE_UNIT;
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="12" endline="14" pcid="1817">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="115" endline="117" pcid="23">
    function cacheTimestamp() external view returns (uint) {
        return _cacheTimestamp;
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="12" endline="14" pcid="1807">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="25" endline="27" pcid="1462">
    function unit() external pure returns (int) {
        return UNIT;
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="81" endline="83" pcid="273">
    function ratesLastUpdated() public view returns (uint) {
        return borrowRatesLastUpdated;
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="140" endline="142" pcid="426">
    function weth() public view returns (IWETH) {
        return _weth;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="24" endline="26" pcid="1434">
    function unit() external pure returns (uint) {
        return UNIT;
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="61" endline="63" pcid="1700">
    function contractName() external view returns (bytes32) {
        return SETTINGS_CONTRACT_NAME;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="49" endline="51" pcid="1479">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="32" endline="34" pcid="1463">
    function preciseUnit() external pure returns (int) {
        return PRECISE_UNIT;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="119" endline="121" pcid="24">
    function cacheInvalid() external view returns (bool) {
        return _cacheInvalid;
    }
</source>
<source file="systems/source-code/MockMutator.sol" startline="6" endline="8" pcid="1217">
    function read() external view returns (uint) {
        return count;
    }
</source>
<source file="systems/source-code/OneWeekSetup.sol" startline="10" endline="12" pcid="1250">
    function publicSetupExpiryTime() public view returns (uint) {
        return setupExpiryTime;
    }
</source>
</class>

<class classid="6" nclones="18" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="130" endline="132" pcid="26">
    function cacheStale() external view returns (bool) {
        return _cacheStale(_cacheTimestamp);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="119" endline="121" pcid="156">
    function synthTransferReceived() external view returns (uint) {
        return _sumTransferAmounts(SYNTH_TRANSFER_RECV);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="26" endline="28" pcid="1538">
    function synthetixBridgeToOptimism() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_BASE_SYNTHETIXBRIDGETOOPTIMISM);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="171" endline="173" pcid="1274">
    function _settings() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_PERPSV2SETTINGS);
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="38" endline="40" pcid="1408">
    function synthetixBridgeToOptimism() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM);
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="221" endline="223" pcid="672">
    function _settings() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_FUTURESMARKETSETTINGS);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="21" endline="23" pcid="1819">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="115" endline="117" pcid="155">
    function synthTransferSent() external view returns (uint) {
        return _sumTransferAmounts(SYNTH_TRANSFER_SENT);
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="32" endline="34" pcid="1261">
    function _ownerRelayOnEthereum() private view returns (address) {
        return requireAndGetAddress(CONTRACT_BASE_OWNER_RELAY_ON_ETHEREUM);
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="84" endline="86" pcid="438">
    function exchangeRates() public view returns (address) {
        return requireAndGetAddress(CONTRACT_EXRATES);
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="112" endline="114" pcid="558">
    function _virtualSynthMastercopy() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_VIRTUALSYNTH_MASTERCOPY);
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="21" endline="23" pcid="1809">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/MintableSynthetix.sol" startline="44" endline="46" pcid="1053">
    function synthetixBridge() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="44" endline="46" pcid="1551">
    function rewardsDistribution() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION);
    }
</source>
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="28" endline="30" pcid="1255">
    function _ownerRelayOnOptimism() private view returns (address) {
        return requireAndGetAddress(CONTRACT_OVM_OWNER_RELAY_ON_OPTIMISM);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="52" endline="54" pcid="1553">
    function synthetixBridgeEscrow() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIXBRIDGEESCROW);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="48" endline="50" pcid="1552">
    function synthetixBridgeToBase() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_OVM_SYNTHETIXBRIDGETOBASE);
    }
</source>
<source file="systems/source-code/ImportableRewardEscrowV2.sol" startline="25" endline="27" pcid="803">
    function synthetixBridgeToBase() internal view returns (address) {
        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE_BASE);
    }
</source>
</class>

<class classid="7" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="184" endline="191" pcid="30">
    function _cachedSynthDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {
        uint numKeys = currencyKeys.length;
        uint[] memory debts = new uint[](numKeys);
        for (uint i = 0; i < numKeys; i++) {
            debts[i] = _cachedSynthDebt[currencyKeys[i]];
        }
        return debts;
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="197" endline="204" pcid="32">
    function _excludedIssuedDebts(bytes32[] memory currencyKeys) internal view returns (uint[] memory) {
        uint numKeys = currencyKeys.length;
        uint[] memory debts = new uint[](numKeys);
        for (uint i = 0; i < numKeys; i++) {
            debts[i] = _excludedIssuedDebt[currencyKeys[i]];
        }
        return debts;
    }
</source>
</class>

<class classid="8" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="193" endline="195" pcid="31">
    function cachedSynthDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory snxIssuedDebts) {
        return _cachedSynthDebts(currencyKeys);
    }
</source>
<source file="systems/source-code/BaseDebtCache.sol" startline="206" endline="208" pcid="33">
    function excludedIssuedDebts(bytes32[] calldata currencyKeys) external view returns (uint[] memory excludedDebts) {
        return _excludedIssuedDebts(currencyKeys);
    }
</source>
</class>

<class classid="9" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/BaseOneNetAggregator.sol" startline="25" endline="29" pcid="53">
    function setOverrideTimestamp(uint timestamp) public onlyOwner {
        overrideTimestamp = timestamp;

        emit SetOverrideTimestamp(timestamp);
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="58" endline="61" pcid="1411">
    function setMigrateEntriesThresholdAmount(uint amount) external onlyOwner {
        migrateEntriesThresholdAmount = amount;
        emit MigrateEntriesThresholdAmountUpdated(amount);
    }
</source>
</class>

<class classid="10" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseOneNetAggregator.sol" startline="49" endline="51" pcid="56">
    function decimals() external view returns (uint8) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyEtherWrapper.sol" startline="10" endline="12" pcid="382">
    function totalIssuedSynths() public view returns (uint) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyFuturesMarketManager.sol" startline="18" endline="20" pcid="385">
    function numMarkets() external view returns (uint) {
        return 0;
    }
</source>
</class>

<class classid="11" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="81" endline="83" pcid="62">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="361" endline="363" pcid="134">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="526" endline="529" pcid="540">
    function _notImplemented() internal pure {
        // slither-disable-next-line dead-code
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="1038" endline="1040" pcid="500">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
</class>

<class classid="12" nclones="5" nlines="6" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="88" endline="93" pcid="63">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHETIX;
        addresses[1] = CONTRACT_FEEPOOL;
        addresses[2] = CONTRACT_ISSUER;
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="62" endline="67" pcid="746">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHSUSD;
        addresses[1] = CONTRACT_FEEPOOL;
        addresses[2] = CONTRACT_EXCHANGER;
    }
</source>
<source file="systems/source-code/Depot.sol" startline="465" endline="470" pcid="349">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTHSUSD;
        addresses[1] = CONTRACT_EXRATES;
        addresses[2] = CONTRACT_SYNTHETIX;
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="28" endline="33" pcid="1882">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_SYNTH_SUSD;
        addresses[1] = CONTRACT_FLEXIBLESTORAGE;
        addresses[2] = CONTRACT_FEEPOOL;
    }
</source>
<source file="systems/source-code/TestableMixinResolver.sol" startline="15" endline="20" pcid="1815">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_EXAMPLE_1;
        addresses[1] = CONTRACT_EXAMPLE_2;
        addresses[2] = CONTRACT_EXAMPLE_3;
    }
</source>
</class>

<class classid="13" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="98" endline="100" pcid="64">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/MockFlagsInterface.sol" startline="14" endline="16" pcid="1202">
    function getFlag(address aggregator) external view returns (bool) {
        return flags[aggregator];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="79" endline="81" pcid="1393">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="69" endline="71" pcid="1452">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="53" endline="55" pcid="1480">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="56" endline="58" pcid="1591">
    function balanceOf(address account) public view returns (uint) {
        return totalVestedAccountBalance[account];
    }
</source>
</class>

<class classid="14" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="105" endline="107" pcid="65">
    function numVestingEntries(address account) external view returns (uint) {
        return accountVestingEntryIDs[account].length;
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="63" endline="65" pcid="1592">
    function numVestingEntries(address account) public view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="90" endline="92" pcid="1395">
    function numVestingEntries(address account) external view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="83" endline="85" pcid="1394">
    function _numVestingEntries(address account) internal view returns (uint) {
        return vestingSchedules[account].length;
    }
</source>
</class>

<class classid="15" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="300" endline="303" pcid="80">
    function setMaxAccountMergingWindow(uint256 duration) external onlyOwner {
        maxAccountMergingDuration = duration;
        emit MaxAccountMergingDurationUpdated(duration);
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="305" endline="308" pcid="81">
    function setMaxEscrowDuration(uint256 duration) external onlyOwner {
        max_duration = duration;
        emit MaxEscrowDurationUpdated(duration);
    }
</source>
</class>

<class classid="16" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="90" endline="92" pcid="99">
    function availableSynthCount() external view returns (uint) {
        return issuer().availableSynthCount();
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="37" endline="39" pcid="1242">
    function weth() internal view returns (IWETH) {
        return etherWrapper().weth();
    }
</source>
</class>

<class classid="17" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="98" endline="100" pcid="101">
    function synths(bytes32 currencyKey) external view returns (ISynth) {
        return issuer().synths(currencyKey);
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="170" endline="172" pcid="461">
    function lastExchangeRate(bytes32 currencyKey) external view returns (uint) {
        return exchangeCircuitBreaker().lastExchangeRate(currencyKey);
    }
</source>
</class>

<class classid="18" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="102" endline="104" pcid="102">
    function synthsByAddress(address synthAddress) external view returns (bytes32) {
        return issuer().synthsByAddress(synthAddress);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="134" endline="136" pcid="108">
    function collateral(address account) external view returns (uint) {
        return issuer().collateral(account);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="130" endline="132" pcid="107">
    function collateralisationRatio(address _issuer) external view returns (uint) {
        return issuer().collateralisationRatio(_issuer);
    }
</source>
</class>

<class classid="19" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="192" endline="202" pcid="113">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="123" endline="133" pcid="1532">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
</class>

<class classid="20" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="268" endline="270" pcid="118">
    function issueSynths(uint amount) external issuanceActive optionalProxy {
        return issuer().issueSynths(messageSender, amount);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="284" endline="286" pcid="122">
    function burnSynths(uint amount) external issuanceActive optionalProxy {
        return issuer().burnSynths(messageSender, amount);
    }
</source>
</class>

<class classid="21" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="272" endline="274" pcid="119">
    function issueSynthsOnBehalf(address issueForAddress, uint amount) external issuanceActive optionalProxy {
        return issuer().issueSynthsOnBehalf(issueForAddress, messageSender, amount);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="288" endline="290" pcid="123">
    function burnSynthsOnBehalf(address burnForAddress, uint amount) external issuanceActive optionalProxy {
        return issuer().burnSynthsOnBehalf(burnForAddress, messageSender, amount);
    }
</source>
</class>

<class classid="22" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="276" endline="278" pcid="120">
    function issueMaxSynths() external issuanceActive optionalProxy {
        return issuer().issueMaxSynths(messageSender);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="292" endline="294" pcid="124">
    function burnSynthsToTarget() external issuanceActive optionalProxy {
        return issuer().burnSynthsToTarget(messageSender);
    }
</source>
</class>

<class classid="23" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="280" endline="282" pcid="121">
    function issueMaxSynthsOnBehalf(address issueForAddress) external issuanceActive optionalProxy {
        return issuer().issueMaxSynthsOnBehalf(issueForAddress, messageSender);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="296" endline="298" pcid="125">
    function burnSynthsToTargetOnBehalf(address burnForAddress) external issuanceActive optionalProxy {
        return issuer().burnSynthsToTargetOnBehalf(burnForAddress, messageSender);
    }
</source>
</class>

<class classid="24" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="349" endline="351" pcid="131">
    function mintSecondary(address, uint) external {
        _notImplemented();
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="357" endline="359" pcid="133">
    function burnSecondary(address, uint) external {
        _notImplemented();
    }
</source>
</class>

<class classid="25" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="372" endline="374" pcid="135">
    function _systemActive() private {
        systemStatus().requireSystemActive();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="945" endline="947" pcid="881">
    function _issuanceActive() private {
        systemStatus().requireIssuanceActive();
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="381" endline="383" pcid="136">
    function _issuanceActive() private {
        systemStatus().requireIssuanceActive();
    }
</source>
</class>

<class classid="26" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="434" endline="450" pcid="140">
    function emitSynthExchange(
        address account,
        bytes32 fromCurrencyKey,
        uint256 fromAmount,
        bytes32 toCurrencyKey,
        uint256 toAmount,
        address toAddress
    ) external onlyExchanger {
        proxy._emit(
            abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress),
            2,
            SYNTH_EXCHANGE_SIG,
            addressToBytes32(account),
            0,
            0
        );
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="198" endline="214" pcid="1535">
    function emitAtomicSynthExchange(
        address account,
        bytes32 fromCurrencyKey,
        uint256 fromAmount,
        bytes32 toCurrencyKey,
        uint256 toAmount,
        address toAddress
    ) external onlyExchanger {
        proxy._emit(
            abi.encode(fromCurrencyKey, fromAmount, toCurrencyKey, toAmount, toAddress),
            2,
            ATOMIC_SYNTH_EXCHANGE_SIG,
            addressToBytes32(account),
            0,
            0
        );
    }
</source>
</class>

<class classid="27" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="467" endline="473" pcid="142">
    function emitExchangeReclaim(
        address account,
        bytes32 currencyKey,
        uint256 amount
    ) external onlyExchanger {
        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGERECLAIM_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="478" endline="484" pcid="143">
    function emitExchangeRebate(
        address account,
        bytes32 currencyKey,
        uint256 amount
    ) external onlyExchanger {
        proxy._emit(abi.encode(currencyKey, amount), 2, EXCHANGEREBATE_SIG, addressToBytes32(account), 0, 0);
    }
</source>
</class>

<class classid="28" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="116" endline="118" pcid="169">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="145" endline="147" pcid="227">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
</class>

<class classid="29" nclones="6" nlines="4" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="181" endline="184" pcid="179">
    function setMinCollateral(uint _minCollateral) external onlyOwner {
        minCollateral = _minCollateral;
        emit MinCollateralUpdated(minCollateral);
    }
</source>
<source file="systems/source-code/Collateral.sol" startline="186" endline="189" pcid="180">
    function setIssueFeeRate(uint _issueFeeRate) external onlyOwner {
        issueFeeRate = _issueFeeRate;
        emit IssueFeeRateUpdated(issueFeeRate);
    }
</source>
<source file="systems/source-code/Depot.sol" startline="91" endline="94" pcid="333">
    function setMaxEthPurchase(uint _maxEthPurchase) external onlyOwner {
        maxEthPurchase = _maxEthPurchase;
        emit MaxEthPurchaseUpdated(maxEthPurchase);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="333" endline="336" pcid="244">
    function setBaseShortRate(uint _baseShortRate) public onlyOwner {
        baseShortRate = _baseShortRate;
        emit BaseShortRateUpdated(baseShortRate);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="323" endline="326" pcid="242">
    function setMaxSkewRate(uint _maxSkewRate) public onlyOwner {
        maxSkewRate = _maxSkewRate;
        emit MaxSkewRateUpdated(maxSkewRate);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="328" endline="331" pcid="243">
    function setBaseBorrowRate(uint _baseBorrowRate) public onlyOwner {
        baseBorrowRate = _baseBorrowRate;
        emit BaseBorrowRateUpdated(baseBorrowRate);
    }
</source>
</class>

<class classid="30" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="191" endline="194" pcid="181">
    function setCanOpenLoans(bool _canOpenLoans) external onlyOwner {
        canOpenLoans = _canOpenLoans;
        emit CanOpenLoansUpdated(canOpenLoans);
    }
</source>
<source file="systems/source-code/DappMaintenance.sol" startline="33" endline="36" pcid="301">
    function setMaintenanceModeStaking(bool isPaused) external onlyOwner {
        isPausedStaking = isPaused;
        emit StakingMaintenance(isPausedStaking);
    }
</source>
<source file="systems/source-code/DappMaintenance.sol" startline="38" endline="41" pcid="302">
    function setMaintenanceModeSX(bool isPaused) external onlyOwner {
        isPausedSX = isPaused;
        emit SXMaintenance(isPausedSX);
    }
</source>
</class>

<class classid="31" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="83" endline="89" pcid="210">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="43" endline="49" pcid="219">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="53" endline="59" pcid="286">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
</class>

<class classid="32" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="91" endline="93" pcid="211">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="82" endline="84" pcid="290">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="51" endline="53" pcid="220">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
</class>

<class classid="33" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="166" endline="168" pcid="230">
    function long(bytes32 synth) external view returns (uint amount) {
        return state.long(synth);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="170" endline="172" pcid="231">
    function short(bytes32 synth) external view returns (uint amount) {
        return state.short(synth);
    }
</source>
</class>

<class classid="34" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="311" endline="315" pcid="240">
    function setUtilisationMultiplier(uint _utilisationMultiplier) public onlyOwner {
        require(_utilisationMultiplier > 0, "Must be greater than 0");
        utilisationMultiplier = _utilisationMultiplier;
        emit UtilisationMultiplierUpdated(utilisationMultiplier);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="317" endline="321" pcid="241">
    function setMaxDebt(uint _maxDebt) public onlyOwner {
        require(_maxDebt > 0, "Must be greater than 0");
        maxDebt = _maxDebt;
        emit MaxDebtUpdated(maxDebt);
    }
</source>
</class>

<class classid="35" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="489" endline="491" pcid="256">
    function updateBorrowRatesCollateral(uint rate) external onlyCollateral {
        state.updateBorrowRates(rate);
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="84" endline="86" pcid="1608">
    function appendDebtLedgerValue(uint value) external onlyAssociatedContract {
        debtLedger.push(value);
    }
</source>
</class>

<class classid="36" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManager.sol" startline="497" endline="499" pcid="258">
    function incrementLongs(bytes32 synth, uint amount) external onlyCollateral {
        state.incrementLongs(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="505" endline="507" pcid="260">
    function incrementShorts(bytes32 synth, uint amount) external onlyCollateral {
        state.incrementShorts(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="509" endline="511" pcid="261">
    function decrementShorts(bytes32 synth, uint amount) external onlyCollateral {
        state.decrementShorts(synth, amount);
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="501" endline="503" pcid="259">
    function decrementLongs(bytes32 synth, uint amount) external onlyCollateral {
        state.decrementLongs(synth, amount);
    }
</source>
</class>

<class classid="37" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="42" endline="44" pcid="264">
    function long(bytes32 synth) external view onlyAssociatedContract returns (uint) {
        return totalIssuedSynths[synth].long;
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="46" endline="48" pcid="265">
    function short(bytes32 synth) external view onlyAssociatedContract returns (uint) {
        return totalIssuedSynths[synth].short;
    }
</source>
</class>

<class classid="38" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="50" endline="52" pcid="266">
    function incrementLongs(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.add(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="58" endline="60" pcid="268">
    function incrementShorts(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.add(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="54" endline="56" pcid="267">
    function decrementLongs(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.sub(amount);
    }
</source>
<source file="systems/source-code/CollateralManagerState.sol" startline="62" endline="64" pcid="269">
    function decrementShorts(bytes32 synth, uint256 amount) external onlyAssociatedContract {
        totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.sub(amount);
    }
</source>
</class>

<class classid="39" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="72" endline="74" pcid="271">
    function getRatesLength() public view returns (uint) {
        return borrowRates.length;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="192" endline="194" pcid="1425">
    function distributionsLength() external view returns (uint) {
        return distributions.length;
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="93" endline="95" pcid="1609">
    function debtLedgerLength() external view returns (uint) {
        return debtLedger.length;
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="370" endline="372" pcid="837">
    function availableSynthCount() external view returns (uint) {
        return availableSynths.length;
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="50" endline="52" pcid="1125">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="50" endline="52" pcid="1085">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="43" endline="45" pcid="1734">
    function systemSuspended() external view returns (bool) {
        return systemSuspension.suspended;
    }
</source>
</class>

<class classid="40" nclones="8" nlines="3" similarity="100">
<source file="systems/source-code/CollateralManagerState.sol" startline="110" endline="112" pcid="276">
    function removeShortCurrency(bytes32 currency) external onlyAssociatedContract {
        delete shortRates[currency];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="75" endline="77" pcid="402">
    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {
        delete BytesStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="62" endline="64" pcid="399">
    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {
        delete AddressStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="101" endline="103" pcid="408">
    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {
        delete BooleanStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="88" endline="90" pcid="405">
    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {
        delete Bytes32Storage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="36" endline="38" pcid="393">
    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {
        delete UIntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="114" endline="116" pcid="411">
    function deleteIntValue(bytes32 record) external onlyAssociatedContract {
        delete IntStorage[record];
    }
</source>
<source file="systems/source-code/EternalStorage.sol" startline="49" endline="51" pcid="396">
    function deleteStringValue(bytes32 record) external onlyAssociatedContract {
        delete StringStorage[record];
    }
</source>
</class>

<class classid="41" nclones="7" nlines="6" similarity="100">
<source file="systems/source-code/CollateralUtil.sol" startline="27" endline="32" pcid="292">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="26" endline="31" pcid="768">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/MintableSynthetix.sol" startline="37" endline="42" pcid="1052">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetix.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="40" endline="45" pcid="553">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Exchanger.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_VIRTUALSYNTH_MASTERCOPY;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="36" endline="41" pcid="1540">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetixBridge.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_BASE_SYNTHETIXBRIDGETOOPTIMISM;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="35" endline="40" pcid="1387">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="27" endline="32" pcid="1324">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinPerpsV2MarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="42" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/DelegateApprovals.sol" startline="47" endline="49" pcid="314">
    function canBurnFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(BURN_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="59" endline="61" pcid="317">
    function canExchangeFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(EXCHANGE_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="51" endline="53" pcid="315">
    function canIssueFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(ISSUE_FOR_ADDRESS, authoriser, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="55" endline="57" pcid="316">
    function canClaimFor(address authoriser, address delegate) external view returns (bool) {
        return _checkApproval(CLAIM_FOR_ADDRESS, authoriser, delegate);
    }
</source>
</class>

<class classid="43" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/DelegateApprovals.sol" startline="83" endline="85" pcid="320">
    function approveAllDelegatePowers(address delegate) external {
        _setApproval(APPROVE_ALL, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="122" endline="124" pcid="328">
    function approveExchangeOnBehalf(address delegate) external {
        _setApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="108" endline="110" pcid="325">
    function removeIssueOnBehalf(address delegate) external {
        _withdrawApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="113" endline="115" pcid="326">
    function approveClaimOnBehalf(address delegate) external {
        _setApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="117" endline="119" pcid="327">
    function removeClaimOnBehalf(address delegate) external {
        _withdrawApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="126" endline="128" pcid="329">
    function removeExchangeOnBehalf(address delegate) external {
        _withdrawApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="95" endline="97" pcid="322">
    function approveBurnOnBehalf(address delegate) external {
        _setApproval(BURN_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="99" endline="101" pcid="323">
    function removeBurnOnBehalf(address delegate) external {
        _withdrawApproval(BURN_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
<source file="systems/source-code/DelegateApprovals.sol" startline="104" endline="106" pcid="324">
    function approveIssueOnBehalf(address delegate) external {
        _setApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);
    }
</source>
</class>

<class classid="44" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Depot.sol" startline="477" endline="480" pcid="350">
    function synthetixReceivedForSynths(uint amount) public view returns (uint) {
        // And what would that be worth in SNX based on the current price?
        return amount.divideDecimal(exchangeRates().rateForCurrency(SNX));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="500" endline="503" pcid="352">
    function synthsReceivedForEther(uint amount) public view returns (uint) {
        // How many synths would that amount of ether be worth?
        return amount.multiplyDecimal(exchangeRates().rateForCurrency(ETH));
    }
</source>
</class>

<class classid="45" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="16" endline="18" pcid="358">
    function long(bytes32) external view returns (uint amount) {
        return 0;
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="20" endline="22" pcid="359">
    function short(bytes32) external view returns (uint amount) {
        return 0;
    }
</source>
</class>

<class classid="46" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="24" endline="26" pcid="360">
    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="32" endline="34" pcid="362">
    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="28" endline="30" pcid="361">
    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid) {
        return (0, false);
    }
</source>
<source file="systems/source-code/EmptyFuturesMarketManager.sol" startline="38" endline="40" pcid="389">
    function totalDebt() external view returns (uint debt, bool isInvalid) {
        return (0, false);
    }
</source>
</class>

<class classid="47" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EmptyCollateralManager.sol" startline="70" endline="72" pcid="367">
    function areSynthsAndCurrenciesSet(bytes32[] calldata, bytes32[] calldata) external view returns (bool) {
        return false;
    }
</source>
<source file="systems/source-code/EmptyCollateralManager.sol" startline="74" endline="76" pcid="368">
    function areShortableSynthsSet(bytes32[] calldata, bytes32[] calldata) external view returns (bool) {
        return false;
    }
</source>
</class>

<class classid="48" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/EtherWrapper.sol" startline="120" endline="122" pcid="421">
    function calculateMintFee(uint amount) public view returns (uint) {
        return amount.multiplyDecimalRound(mintFeeRate());
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="124" endline="126" pcid="422">
    function calculateBurnFee(uint amount) public view returns (uint) {
        return amount.multiplyDecimalRound(burnFeeRate());
    }
</source>
</class>

<class classid="49" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="53" endline="60" pcid="433">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_EXRATES;
        newAddresses[2] = CONTRACT_ISSUER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="48" endline="55" pcid="1237">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_COLLATERALMANAGER;
        newAddresses[1] = CONTRACT_ETHER_WRAPPER;
        newAddresses[2] = CONTRACT_WRAPPER_FACTORY;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="50" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="717" endline="725" pcid="483">
    function reclaim(
        address from,
        bytes32 currencyKey,
        uint amount
    ) internal {
        // burn amount from user
        issuer().synths(currencyKey).burn(from, amount);
        ISynthetixInternal(address(synthetix())).emitExchangeReclaim(from, currencyKey, amount);
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="727" endline="735" pcid="484">
    function refund(
        address from,
        bytes32 currencyKey,
        uint amount
    ) internal {
        // issue amount to user
        issuer().synths(currencyKey).issue(from, amount);
        ISynthetixInternal(address(synthetix())).emitExchangeRebate(from, currencyKey, amount);
    }
</source>
</class>

<class classid="51" nclones="30" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="116" endline="118" pcid="508">
    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {
        return _getCurrentRoundId(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="57" endline="59" pcid="1328">
    function takerFeeNextPrice(bytes32 _marketKey) external view returns (uint) {
        return _takerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="50" endline="52" pcid="1327">
    function makerFee(bytes32 _marketKey) public view returns (uint) {
        return _makerFee(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="43" endline="45" pcid="1326">
    function takerFee(bytes32 _marketKey) external view returns (uint) {
        return _takerFee(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="64" endline="66" pcid="1329">
    function makerFeeNextPrice(bytes32 _marketKey) public view returns (uint) {
        return _makerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="154" endline="156" pcid="511">
    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {
        return _getUpdatedTime(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="71" endline="73" pcid="1330">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="43" endline="45" pcid="545">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="78" endline="80" pcid="1331">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="85" endline="87" pcid="1332">
    function maxMarketValueUSD(bytes32 _marketKey) public view returns (uint) {
        return _maxMarketValueUSD(_marketKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="39" endline="41" pcid="544">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="98" endline="100" pcid="778">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="92" endline="94" pcid="1333">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="91" endline="93" pcid="777">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="84" endline="86" pcid="776">
    function maxMarketValueUSD(bytes32 _marketKey) public view returns (uint) {
        return _maxMarketValueUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="99" endline="101" pcid="1334">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="77" endline="79" pcid="775">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="87" endline="89" pcid="1639">
    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {
        return getExchangeFeeRate(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="70" endline="72" pcid="774">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="198" endline="200" pcid="1659">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="204" endline="206" pcid="1660">
    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {
        return getAtomicExchangeFeeRate(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="210" endline="212" pcid="1661">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="216" endline="218" pcid="1662">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="222" endline="224" pcid="1663">
    function pureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) external view returns (bool) {
        return getPureChainlinkPriceForAtomicSwapsEnabled(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="228" endline="230" pcid="1664">
    function crossChainSynthTransferEnabled(bytes32 currencyKey) external view returns (uint) {
        return getCrossChainSynthTransferEnabled(currencyKey);
    }
</source>
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="47" endline="49" pcid="546">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="63" endline="65" pcid="773">
    function makerFeeNextPrice(bytes32 _marketKey) public view returns (uint) {
        return _makerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="56" endline="58" pcid="772">
    function takerFeeNextPrice(bytes32 _marketKey) external view returns (uint) {
        return _takerFeeNextPrice(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="42" endline="44" pcid="770">
    function takerFee(bytes32 _marketKey) external view returns (uint) {
        return _takerFee(_marketKey);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="49" endline="51" pcid="771">
    function makerFee(bytes32 _marketKey) public view returns (uint) {
        return _makerFee(_marketKey);
    }
</source>
</class>

<class classid="52" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="158" endline="166" pcid="512">
    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {
        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);

        for (uint i = 0; i < currencyKeys.length; i++) {
            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);
        }

        return lastUpdateTimes;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="242" endline="250" pcid="518">
    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {
        uint[] memory _localRates = new uint[](currencyKeys.length);

        for (uint i = 0; i < currencyKeys.length; i++) {
            _localRates[i] = _getRate(currencyKeys[i]);
        }

        return _localRates;
    }
</source>
</class>

<class classid="53" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="210" endline="212" pcid="516">
    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {
        return _getRateAndUpdatedTime(currencyKey).rate;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="452" endline="454" pcid="533">
    function _getRate(bytes32 currencyKey) internal view returns (uint256) {
        return _getRateAndUpdatedTime(currencyKey).rate;
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="456" endline="458" pcid="534">
    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {
        return _getRateAndUpdatedTime(currencyKey).time;
    }
</source>
</class>

<class classid="54" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeState.sol" startline="18" endline="20" pcid="564">
    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {
        maxEntriesInQueue = _maxEntriesInQueue;
    }
</source>
<source file="systems/source-code/Synth.sol" startline="184" endline="186" pcid="1512">
    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {
        totalSupply = amount;
    }
</source>
<source file="systems/source-code/TestablePausable.sol" startline="14" endline="16" pcid="1816">
    function setSomeValue(uint _value) external notPaused {
        someValue = _value;
    }
</source>
<source file="systems/source-code/TestableTempOwned.sol" startline="13" endline="15" pcid="1824">
    function setTestValue(uint _testValue) external onlyTemporaryOwner {
        testValue = _testValue;
    }
</source>
</class>

<class classid="55" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExternStateToken.sol" startline="60" endline="62" pcid="571">
    function balanceOf(address account) external view returns (uint) {
        return tokenState.balanceOf(account);
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="10" endline="12" pcid="1790">
    function contains(address candidate) public view returns (bool) {
        return set.contains(candidate);
    }
</source>
</class>

<class classid="56" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExternStateToken.sol" startline="140" endline="146" pcid="578">
    function emitTransfer(
        address from,
        address to,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);
    }
</source>
<source file="systems/source-code/ExternStateToken.sol" startline="151" endline="157" pcid="579">
    function emitApproval(
        address owner,
        address spender,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);
    }
</source>
</class>

<class classid="57" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="524" endline="534" pcid="616">
    function totalFeesAvailable() external view returns (uint) {
        uint totalFees = 0;

        // Fees in fee period [0] are not yet available for withdrawal
        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {
            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);
            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);
        }

        return totalFees;
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="539" endline="549" pcid="617">
    function totalRewardsAvailable() external view returns (uint) {
        uint totalRewards = 0;

        // Rewards in fee period [0] are not yet available for withdrawal
        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {
            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);
            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);
        }

        return totalRewards;
    }
</source>
</class>

<class classid="58" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/FlexibleStorage.sol" startline="69" endline="71" pcid="642">
    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint) {
        return uintStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="111" endline="113" pcid="648">
    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool) {
        return boolStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="97" endline="99" pcid="646">
    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address) {
        return addressStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="83" endline="85" pcid="644">
    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int) {
        return intStorage[hashes[contractName]][record];
    }
</source>
<source file="systems/source-code/FlexibleStorage.sol" startline="125" endline="127" pcid="650">
    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32) {
        return bytes32Storage[hashes[contractName]][record];
    }
</source>
</class>

<class classid="59" nclones="3" nlines="10" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="194" endline="203" pcid="667">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_FUTURESMARKETSETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="144" endline="153" pcid="1269">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinPerpsV2MarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_PERPSV2SETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Liquidations.sol" startline="46" endline="55" pcid="888">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_SYSTEMSTATUS;
        newAddresses[1] = CONTRACT_SYNTHETIX;
        newAddresses[2] = CONTRACT_ETERNALSTORAGE_LIQUIDATIONS;
        newAddresses[3] = CONTRACT_ISSUER;
        newAddresses[4] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="60" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="232" endline="238" pcid="673">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="182" endline="188" pcid="1275">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
</class>

<class classid="61" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="240" endline="244" pcid="674">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="190" endline="194" pcid="1276">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
</class>

<class classid="62" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="246" endline="251" pcid="675">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="196" endline="201" pcid="1277">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
</class>

<class classid="63" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="257" endline="259" pcid="676">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="207" endline="209" pcid="1278">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
</class>

<class classid="64" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="261" endline="264" pcid="677">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="211" endline="214" pcid="1279">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
</class>

<class classid="65" nclones="2" nlines="18" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="271" endline="305" pcid="678">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="221" endline="255" pcid="1280">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
</class>

<class classid="66" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="307" endline="309" pcid="679">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="257" endline="259" pcid="1281">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
</class>

<class classid="67" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="311" endline="314" pcid="680">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="261" endline="264" pcid="1282">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
</class>

<class classid="68" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="316" endline="323" pcid="681">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="266" endline="273" pcid="1283">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
</class>

<class classid="69" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="328" endline="331" pcid="682">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="278" endline="281" pcid="1284">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
</class>

<class classid="70" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="339" endline="358" pcid="683">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="289" endline="308" pcid="1285">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
</class>

<class classid="71" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="360" endline="365" pcid="684">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="310" endline="315" pcid="1286">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
</class>

<class classid="72" nclones="2" nlines="17" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="367" endline="390" pcid="685">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="317" endline="340" pcid="1287">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
</class>

<class classid="73" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="400" endline="406" pcid="686">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="350" endline="356" pcid="1288">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
</class>

<class classid="74" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="418" endline="421" pcid="687">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="368" endline="371" pcid="1289">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
</class>

<class classid="75" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="423" endline="430" pcid="688">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="373" endline="380" pcid="1290">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
</class>

<class classid="76" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="432" endline="443" pcid="689">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="382" endline="393" pcid="1291">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
</class>

<class classid="77" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="445" endline="456" pcid="690">
    function _orderFee(TradeParams memory params, uint dynamicFeeRate) internal view returns (uint fee) {
        // usd value of the difference in position
        int notionalDiff = params.sizeDelta.multiplyDecimal(int(params.price));

        // If the order is submitted on the same side as the skew (increasing it) - the taker fee is charged.
        // Otherwise if the order is opposite to the skew, the maker fee is charged.
        // the case where the order flips the skew is ignored for simplicity due to being negligible
        // in both size of effect and frequency of occurrence
        uint staticRate = _sameSide(notionalDiff, marketSkew) ? params.takerFee : params.makerFee;
        uint feeRate = staticRate.add(dynamicFeeRate);
        return _abs(notionalDiff.multiplyDecimal(int(feeRate)));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="395" endline="406" pcid="1292">
    function _orderFee(TradeParams memory params, uint dynamicFeeRate) internal view returns (uint fee) {
        // usd value of the difference in position
        int notionalDiff = params.sizeDelta.multiplyDecimal(int(params.price));

        // If the order is submitted on the same side as the skew (increasing it) - the taker fee is charged.
        // Otherwise if the order is opposite to the skew, the maker fee is charged.
        // the case where the order flips the skew is ignored for simplicity due to being negligible
        // in both size of effect and frequency of occurrence
        uint staticRate = _sameSide(notionalDiff, marketSkew) ? params.takerFee : params.makerFee;
        uint feeRate = staticRate.add(dynamicFeeRate);
        return _abs(notionalDiff.multiplyDecimal(int(feeRate)));
    }
</source>
</class>

<class classid="78" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="462" endline="464" pcid="691">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="412" endline="414" pcid="1293">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
</class>

<class classid="79" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="466" endline="468" pcid="692">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="416" endline="418" pcid="1294">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
</class>

<class classid="80" nclones="2" nlines="37" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="470" endline="563" pcid="693">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxMarketValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="420" endline="513" pcid="1295">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxMarketValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
</class>

<class classid="81" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="570" endline="572" pcid="694">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="197" endline="199" pcid="1447">
    function signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="520" endline="522" pcid="1296">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
</class>

<class classid="82" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="577" endline="579" pcid="695">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="204" endline="206" pcid="1448">
    function abs(int x) internal pure returns (uint) {
        return uint(signedAbs(x));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="527" endline="529" pcid="1297">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
</class>

<class classid="83" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="581" endline="583" pcid="696">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="531" endline="533" pcid="1298">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
</class>

<class classid="84" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="585" endline="587" pcid="697">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="535" endline="537" pcid="1299">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
</class>

<class classid="85" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="591" endline="593" pcid="698">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="541" endline="543" pcid="1300">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
</class>

<class classid="86" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="598" endline="600" pcid="699">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="548" endline="550" pcid="1301">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
</class>

<class classid="87" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="605" endline="609" pcid="700">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="555" endline="559" pcid="1302">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="88" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="614" endline="618" pcid="701">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="564" endline="568" pcid="1303">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="89" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="624" endline="629" pcid="702">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        // Ensure we catch uninitialised rates or suspended state / synth
        invalid = invalid || price == 0 || _systemStatus().synthSuspended(baseAsset);
        return (price, invalid);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="574" endline="579" pcid="1304">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        // Ensure we catch uninitialised rates or suspended state / synth
        invalid = invalid || price == 0 || _systemStatus().synthSuspended(baseAsset);
        return (price, invalid);
    }
</source>
</class>

<class classid="90" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="658" endline="667" pcid="704">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="612" endline="621" pcid="1306">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
</class>

<class classid="91" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="676" endline="689" pcid="705">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method is the only mutative method that uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="630" endline="643" pcid="1307">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method is the only mutative method that uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
</class>

<class classid="92" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="694" endline="724" pcid="706">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="648" endline="678" pcid="1308">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
</class>

<class classid="93" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="726" endline="736" pcid="707">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="680" endline="690" pcid="1309">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
</class>

<class classid="94" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="741" endline="745" pcid="708">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="695" endline="699" pcid="1310">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
</class>

<class classid="95" nclones="2" nlines="19" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="747" endline="779" pcid="709">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="701" endline="733" pcid="1311">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
</class>

<class classid="96" nclones="2" nlines="16" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="782" endline="820" pcid="710">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);
        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="736" endline="774" pcid="1312">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);
        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
</class>

<class classid="97" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="828" endline="832" pcid="711">
    function transferMargin(int marginDelta) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _transferMargin(marginDelta, price, msg.sender);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="782" endline="786" pcid="1313">
    function transferMargin(int marginDelta) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _transferMargin(marginDelta, price, msg.sender);
    }
</source>
</class>

<class classid="98" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="838" endline="844" pcid="712">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="792" endline="798" pcid="1314">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
</class>

<class classid="99" nclones="2" nlines="35" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="846" endline="902" pcid="713">
    function _trade(address sender, TradeParams memory params) internal {
        Position storage position = positions[sender];
        Position memory oldPosition = position;

        // Compute the new position after performing the trade
        (Position memory newPosition, uint fee, Status status) = _postTradeDetails(oldPosition, params);
        _revertIfError(status);

        // Update the aggregated market size and skew with the new order size
        marketSkew = int128(int(marketSkew).add(newPosition.size).sub(oldPosition.size));
        marketSize = uint128(uint(marketSize).add(_abs(newPosition.size)).sub(_abs(oldPosition.size)));

        // Send the fee to the fee pool
        if (0 < fee) {
            _manager().payFee(fee);
            // emit tracking code event
            if (params.trackingCode != bytes32(0)) {
                emit FuturesTracking(params.trackingCode, baseAsset, marketKey, params.sizeDelta, fee);
            }
        }

        // Update the margin, and apply the resulting debt correction
        position.margin = newPosition.margin;
        _applyDebtCorrection(newPosition, oldPosition);

        // Record the trade
        uint64 id = oldPosition.id;
        uint fundingIndex = _latestFundingIndex();
        if (newPosition.size == 0) {
            // If the position is being closed, we no longer need to track these details.
            delete position.id;
            delete position.size;
            delete position.lastPrice;
            delete position.lastFundingIndex;
        } else {
            if (oldPosition.size == 0) {
                // New positions get new ids.
                id = _nextPositionId;
                _nextPositionId += 1;
            }
            position.id = id;
            position.size = newPosition.size;
            position.lastPrice = uint128(params.price);
            position.lastFundingIndex = uint64(fundingIndex);
        }
        // emit the modification event
        emit PositionModified(
            id,
            sender,
            newPosition.margin,
            newPosition.size,
            params.sizeDelta,
            params.price,
            fundingIndex,
            fee
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="800" endline="856" pcid="1315">
    function _trade(address sender, TradeParams memory params) internal {
        Position storage position = positions[sender];
        Position memory oldPosition = position;

        // Compute the new position after performing the trade
        (Position memory newPosition, uint fee, Status status) = _postTradeDetails(oldPosition, params);
        _revertIfError(status);

        // Update the aggregated market size and skew with the new order size
        marketSkew = int128(int(marketSkew).add(newPosition.size).sub(oldPosition.size));
        marketSize = uint128(uint(marketSize).add(_abs(newPosition.size)).sub(_abs(oldPosition.size)));

        // Send the fee to the fee pool
        if (0 < fee) {
            _manager().payFee(fee);
            // emit tracking code event
            if (params.trackingCode != bytes32(0)) {
                emit Tracking(params.trackingCode, baseAsset, marketKey, params.sizeDelta, fee);
            }
        }

        // Update the margin, and apply the resulting debt correction
        position.margin = newPosition.margin;
        _applyDebtCorrection(newPosition, oldPosition);

        // Record the trade
        uint64 id = oldPosition.id;
        uint fundingIndex = _latestFundingIndex();
        if (newPosition.size == 0) {
            // If the position is being closed, we no longer need to track these details.
            delete position.id;
            delete position.size;
            delete position.lastPrice;
            delete position.lastFundingIndex;
        } else {
            if (oldPosition.size == 0) {
                // New positions get new ids.
                id = _nextPositionId;
                _nextPositionId += 1;
            }
            position.id = id;
            position.size = newPosition.size;
            position.lastPrice = uint128(params.price);
            position.lastFundingIndex = uint64(fundingIndex);
        }
        // emit the modification event
        emit PositionModified(
            id,
            sender,
            newPosition.margin,
            newPosition.size,
            params.sizeDelta,
            params.price,
            fundingIndex,
            fee
        );
    }
</source>
</class>

<class classid="100" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="908" endline="910" pcid="714">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="862" endline="864" pcid="1316">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="31" endline="33" pcid="1073">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="31" endline="33" pcid="1097">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="101" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="916" endline="918" pcid="715">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="37" endline="39" pcid="1074">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="37" endline="39" pcid="1098">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="870" endline="872" pcid="1317">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="102" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="920" endline="933" pcid="716">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="874" endline="887" pcid="1318">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
</class>

<class classid="103" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="938" endline="940" pcid="717">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="892" endline="894" pcid="1319">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
</class>

<class classid="104" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="943" endline="945" pcid="718">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="897" endline="899" pcid="1320">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
</class>

<class classid="105" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="947" endline="962" pcid="719">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: -size,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="901" endline="916" pcid="1321">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: -size,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
</class>

<class classid="106" nclones="2" nlines="18" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="964" endline="1000" pcid="720">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position itself.
        delete positions[account];

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee));
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="918" endline="954" pcid="1322">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position itself.
        delete positions[account];

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee));
        }
    }
</source>
</class>

<class classid="107" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="1007" endline="1014" pcid="721">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="961" endline="968" pcid="1323">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
</class>

<class classid="108" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="194" endline="196" pcid="728">
    function marketSummaries(address[] calldata markets) external view returns (MarketSummary[] memory) {
        return _marketSummaries(markets);
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="172" endline="174" pcid="757">
    function marketSummaries(address[] calldata addresses) external view returns (MarketSummary[] memory) {
        return _marketSummaries(addresses);
    }
</source>
</class>

<class classid="109" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="270" endline="273" pcid="737">
    function _notionalValue(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.notionalValue(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="275" endline="278" pcid="738">
    function _profitLoss(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.profitLoss(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="280" endline="283" pcid="739">
    function _accruedFunding(IFuturesMarket market, address account) internal view returns (int) {
        (int value, ) = market.accruedFunding(account);
        return value;
    }
</source>
</class>

<class classid="110" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketData.sol" startline="285" endline="288" pcid="740">
    function _remainingMargin(IFuturesMarket market, address account) internal view returns (uint) {
        (uint value, ) = market.remainingMargin(account);
        return value;
    }
</source>
<source file="systems/source-code/FuturesMarketData.sol" startline="290" endline="293" pcid="741">
    function _accessibleMargin(IFuturesMarket market, address account) internal view returns (uint) {
        (uint value, ) = market.accessibleMargin(account);
        return value;
    }
</source>
</class>

<class classid="111" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketManager.sol" startline="91" endline="93" pcid="751">
    function numMarkets() external view returns (uint) {
        return _markets.elements.length;
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="26" endline="28" pcid="1801">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="26" endline="28" pcid="1794">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
</class>

<class classid="112" nclones="2" nlines="11" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="102" endline="126" pcid="779">
    function parameters(bytes32 _marketKey)
        external
        view
        returns (
            uint takerFee,
            uint makerFee,
            uint takerFeeNextPrice,
            uint makerFeeNextPrice,
            uint nextPriceConfirmWindow,
            uint maxLeverage,
            uint maxMarketValueUSD,
            uint maxFundingRate,
            uint skewScaleUSD
        )
    {
        takerFee = _takerFee(_marketKey);
        makerFee = _makerFee(_marketKey);
        takerFeeNextPrice = _takerFeeNextPrice(_marketKey);
        makerFeeNextPrice = _makerFeeNextPrice(_marketKey);
        nextPriceConfirmWindow = _nextPriceConfirmWindow(_marketKey);
        maxLeverage = _maxLeverage(_marketKey);
        maxMarketValueUSD = _maxMarketValueUSD(_marketKey);
        maxFundingRate = _maxFundingRate(_marketKey);
        skewScaleUSD = _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="103" endline="127" pcid="1335">
    function parameters(bytes32 _marketKey)
        external
        view
        returns (
            uint takerFee,
            uint makerFee,
            uint takerFeeNextPrice,
            uint makerFeeNextPrice,
            uint nextPriceConfirmWindow,
            uint maxLeverage,
            uint maxMarketValueUSD,
            uint maxFundingRate,
            uint skewScaleUSD
        )
    {
        takerFee = _takerFee(_marketKey);
        makerFee = _makerFee(_marketKey);
        takerFeeNextPrice = _takerFeeNextPrice(_marketKey);
        makerFeeNextPrice = _makerFeeNextPrice(_marketKey);
        nextPriceConfirmWindow = _nextPriceConfirmWindow(_marketKey);
        maxLeverage = _maxLeverage(_marketKey);
        maxMarketValueUSD = _maxMarketValueUSD(_marketKey);
        maxFundingRate = _maxFundingRate(_marketKey);
        skewScaleUSD = _skewScaleUSD(_marketKey);
    }
</source>
</class>

<class classid="113" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="163" endline="170" pcid="784">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="164" endline="171" pcid="1340">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
</class>

<class classid="114" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="172" endline="175" pcid="785">
    function setTakerFee(bytes32 _marketKey, uint _takerFee) public onlyOwner {
        require(_takerFee <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE, _takerFee);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="173" endline="176" pcid="1341">
    function setTakerFee(bytes32 _marketKey, uint _takerFee) public onlyOwner {
        require(_takerFee <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE, _takerFee);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="182" endline="185" pcid="787">
    function setTakerFeeNextPrice(bytes32 _marketKey, uint _takerFeeNextPrice) public onlyOwner {
        require(_takerFeeNextPrice <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE, _takerFeeNextPrice);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="183" endline="186" pcid="1343">
    function setTakerFeeNextPrice(bytes32 _marketKey, uint _takerFeeNextPrice) public onlyOwner {
        require(_takerFeeNextPrice <= 1e18, "taker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE, _takerFeeNextPrice);
    }
</source>
</class>

<class classid="115" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="177" endline="180" pcid="786">
    function setMakerFee(bytes32 _marketKey, uint _makerFee) public onlyOwner {
        require(_makerFee <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE, _makerFee);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="187" endline="190" pcid="788">
    function setMakerFeeNextPrice(bytes32 _marketKey, uint _makerFeeNextPrice) public onlyOwner {
        require(_makerFeeNextPrice <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE, _makerFeeNextPrice);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="178" endline="181" pcid="1342">
    function setMakerFee(bytes32 _marketKey, uint _makerFee) public onlyOwner {
        require(_makerFee <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE, _makerFee);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="188" endline="191" pcid="1344">
    function setMakerFeeNextPrice(bytes32 _marketKey, uint _makerFeeNextPrice) public onlyOwner {
        require(_makerFeeNextPrice <= 1e18, "maker fee greater than 1");
        _setParameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE, _makerFeeNextPrice);
    }
</source>
</class>

<class classid="116" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="192" endline="194" pcid="789">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="197" endline="199" pcid="1346">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="193" endline="195" pcid="1345">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="200" endline="202" pcid="791">
    function setMaxMarketValueUSD(bytes32 _marketKey, uint _maxMarketValueUSD) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_MARKET_VALUE, _maxMarketValueUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="201" endline="203" pcid="1347">
    function setMaxMarketValueUSD(bytes32 _marketKey, uint _maxMarketValueUSD) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_MARKET_VALUE, _maxMarketValueUSD);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="196" endline="198" pcid="790">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
</class>

<class classid="117" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="207" endline="213" pcid="792">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IFuturesMarket market = IFuturesMarket(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="208" endline="214" pcid="1348">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IPerpsV2Market market = IPerpsV2Market(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
</class>

<class classid="118" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="215" endline="218" pcid="793">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="216" endline="219" pcid="1349">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
</class>

<class classid="119" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="220" endline="224" pcid="794">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="221" endline="225" pcid="1350">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
</class>

<class classid="120" nclones="2" nlines="12" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="226" endline="248" pcid="795">
    function setParameters(
        bytes32 _marketKey,
        uint _takerFee,
        uint _makerFee,
        uint _takerFeeNextPrice,
        uint _makerFeeNextPrice,
        uint _nextPriceConfirmWindow,
        uint _maxLeverage,
        uint _maxMarketValueUSD,
        uint _maxFundingRate,
        uint _skewScaleUSD
    ) external onlyOwner {
        _recomputeFunding(_marketKey);
        setTakerFee(_marketKey, _takerFee);
        setMakerFee(_marketKey, _makerFee);
        setTakerFeeNextPrice(_marketKey, _takerFeeNextPrice);
        setMakerFeeNextPrice(_marketKey, _makerFeeNextPrice);
        setNextPriceConfirmWindow(_marketKey, _nextPriceConfirmWindow);
        setMaxLeverage(_marketKey, _maxLeverage);
        setMaxMarketValueUSD(_marketKey, _maxMarketValueUSD);
        setMaxFundingRate(_marketKey, _maxFundingRate);
        setSkewScaleUSD(_marketKey, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="227" endline="249" pcid="1351">
    function setParameters(
        bytes32 _marketKey,
        uint _takerFee,
        uint _makerFee,
        uint _takerFeeNextPrice,
        uint _makerFeeNextPrice,
        uint _nextPriceConfirmWindow,
        uint _maxLeverage,
        uint _maxMarketValueUSD,
        uint _maxFundingRate,
        uint _skewScaleUSD
    ) external onlyOwner {
        _recomputeFunding(_marketKey);
        setTakerFee(_marketKey, _takerFee);
        setMakerFee(_marketKey, _makerFee);
        setTakerFeeNextPrice(_marketKey, _takerFeeNextPrice);
        setMakerFeeNextPrice(_marketKey, _makerFeeNextPrice);
        setNextPriceConfirmWindow(_marketKey, _nextPriceConfirmWindow);
        setMaxLeverage(_marketKey, _maxLeverage);
        setMaxMarketValueUSD(_marketKey, _maxMarketValueUSD);
        setMaxFundingRate(_marketKey, _maxFundingRate);
        setSkewScaleUSD(_marketKey, _skewScaleUSD);
    }
</source>
</class>

<class classid="121" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="250" endline="254" pcid="796">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="251" endline="255" pcid="1352">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
</class>

<class classid="122" nclones="5" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="256" endline="259" pcid="797">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="262" endline="265" pcid="1354">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="257" endline="260" pcid="1353">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/FuturesMarketSettings.sol" startline="261" endline="264" pcid="798">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="338" endline="342" pcid="1679">
    function setExchangeDynamicFeeRounds(uint rounds) external onlyOwner {
        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS, rounds);

        emit ExchangeDynamicFeeRoundsUpdated(rounds);
    }
</source>
</class>

<class classid="123" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="266" endline="270" pcid="799">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="267" endline="271" pcid="1355">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
</class>

<class classid="124" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="285" endline="288" pcid="827">
    function _lastIssueEvent(address account) internal view returns (uint) {
        //  Get the timestamp of the last issue this account made
        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="222" endline="228" pcid="1168">
    function getCollapseFeeRate(address collateral) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="214" endline="220" pcid="1167">
    function getInteractionDelay(address collateral) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="206" endline="212" pcid="1166">
    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {
        return
            flexibleStorage().getIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="198" endline="204" pcid="1165">
    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {
        return
            flexibleStorage().getIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="190" endline="196" pcid="1164">
    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))
            );
    }
</source>
</class>

<class classid="125" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="315" endline="317" pcid="829">
    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {
        return amount.multiplyDecimalRound(snxRate);
    }
</source>
<source file="systems/source-code/PublicMath.sol" startline="11" endline="13" pcid="1376">
    function powerDecimal(uint x, uint y) public pure returns (uint) {
        return x.powDecimal(y);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="319" endline="321" pcid="830">
    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {
        return amount.divideDecimalRound(snxRate);
    }
</source>
</class>

<class classid="126" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="362" endline="364" pcid="835">
    function canBurnSynths(address account) external view returns (bool) {
        return _canBurnSynths(account);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="398" endline="400" pcid="843">
    function collateral(address account) external view returns (uint) {
        return _collateral(account);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="172" endline="174" pcid="1654">
    function wrapperBurnFeeRate(address wrapper) external view returns (int) {
        return getWrapperBurnFeeRate(wrapper);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="166" endline="168" pcid="1653">
    function wrapperMintFeeRate(address wrapper) external view returns (int) {
        return getWrapperMintFeeRate(wrapper);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="176" endline="178" pcid="1655">
    function interactionDelay(address collateral) external view returns (uint) {
        return getInteractionDelay(collateral);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="180" endline="182" pcid="1656">
    function collapseFeeRate(address collateral) external view returns (uint) {
        return getCollapseFeeRate(collateral);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="160" endline="162" pcid="1652">
    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {
        return getWrapperMaxTokenAmount(wrapper);
    }
</source>
<source file="systems/source-code/VirtualSynth.sol" startline="134" endline="136" pcid="1871">
    function balanceOfUnderlying(address account) external view returns (uint) {
        return balanceUnderlying(account);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="382" endline="384" pcid="840">
    function lastIssueEvent(address account) external view returns (uint) {
        return _lastIssueEvent(account);
    }
</source>
</class>

<class classid="127" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="615" endline="617" pcid="858">
    function issueMaxSynths(address from) external onlySynthetix {
        _issueSynths(from, 0, true);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="646" endline="648" pcid="863">
    function burnSynthsToTarget(address from) external onlySynthetix {
        _voluntaryBurnSynths(from, 0, true);
    }
</source>
</class>

<class classid="128" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="619" endline="626" pcid="859">
    function issueSynthsOnBehalf(
        address issueForAddress,
        address from,
        uint amount
    ) external onlySynthetix {
        _requireCanIssueOnBehalf(issueForAddress, from);
        _issueSynths(issueForAddress, amount, false);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="637" endline="644" pcid="862">
    function burnSynthsOnBehalf(
        address burnForAddress,
        address from,
        uint amount
    ) external onlySynthetix {
        _requireCanBurnOnBehalf(burnForAddress, from);
        _voluntaryBurnSynths(burnForAddress, amount, false);
    }
</source>
</class>

<class classid="129" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="628" endline="631" pcid="860">
    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {
        _requireCanIssueOnBehalf(issueForAddress, from);
        _issueSynths(issueForAddress, 0, true);
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="650" endline="653" pcid="864">
    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {
        _requireCanBurnOnBehalf(burnForAddress, from);
        _voluntaryBurnSynths(burnForAddress, 0, true);
    }
</source>
</class>

<class classid="130" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="741" endline="743" pcid="870">
    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {
        require(delegateApprovals().canIssueFor(issueForAddress, from), "Not approved to act on behalf");
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="745" endline="747" pcid="871">
    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {
        require(delegateApprovals().canBurnFor(burnForAddress, from), "Not approved to act on behalf");
    }
</source>
</class>

<class classid="131" nclones="5" nlines="4" similarity="100">
<source file="systems/source-code/LegacyOwned.sol" startline="11" endline="14" pcid="883">
    function nominateOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
<source file="systems/source-code/LegacyTokenState.sol" startline="22" endline="25" pcid="885">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
<source file="systems/source-code/Owned.sol" startline="14" endline="17" pcid="1251">
    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
<source file="systems/source-code/TemporarilyOwned.sol" startline="21" endline="24" pcid="1787">
    function nominateNewOwner(address _owner) external onlyTemporaryOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
</source>
<source file="systems/source-code/State.sol" startline="23" endline="26" pcid="1494">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
</class>

<class classid="132" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="27" endline="33" pcid="886">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="25" endline="31" pcid="1832">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
</class>

<class classid="133" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="35" endline="37" pcid="887">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="39" endline="41" pcid="1833">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
</class>

<class classid="134" nclones="13" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Alphard.sol" startline="142" endline="147" pcid="945">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="394" endline="399" pcid="964">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="167" endline="172" pcid="1041">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="122" endline="127" pcid="955">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="68" endline="73" pcid="1019">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="70" endline="75" pcid="1012">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="143" endline="148" pcid="986">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="177" endline="182" pcid="993">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="70" endline="75" pcid="1033">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="93" endline="98" pcid="980">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="211" endline="216" pcid="1001">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="337" endline="342" pcid="970">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="70" endline="75" pcid="1025">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
</class>

<class classid="135" nclones="13" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Alphard.sol" startline="149" endline="154" pcid="946">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="100" endline="105" pcid="981">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="77" endline="82" pcid="1026">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="218" endline="223" pcid="1002">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="77" endline="82" pcid="1034">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="174" endline="179" pcid="1042">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="75" endline="80" pcid="1020">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="129" endline="134" pcid="956">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="184" endline="189" pcid="994">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="77" endline="82" pcid="1013">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="150" endline="155" pcid="987">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="344" endline="349" pcid="971">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="401" endline="406" pcid="965">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
</class>

<class classid="136" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/Migration_Alphard.sol" startline="156" endline="171" pcid="947">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="136" endline="151" pcid="957">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="137" nclones="2" nlines="19" similarity="100">
<source file="systems/source-code/Migration_Mirach.sol" startline="257" endline="275" pcid="998">
    function issuer_addSynths_44() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_44_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_44_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        issuer_addSynths_synthsToAdd_44_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        issuer_addSynths_synthsToAdd_44_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        issuer_addSynths_synthsToAdd_44_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        issuer_addSynths_synthsToAdd_44_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        issuer_addSynths_synthsToAdd_44_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        issuer_addSynths_synthsToAdd_44_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        issuer_addSynths_synthsToAdd_44_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        issuer_addSynths_synthsToAdd_44_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        issuer_addSynths_synthsToAdd_44_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        issuer_addSynths_synthsToAdd_44_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        issuer_addSynths_synthsToAdd_44_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        issuer_addSynths_synthsToAdd_44_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);
        issuer_addSynths_synthsToAdd_44_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        issuer_addSynths_synthsToAdd_44_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_44_0);
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="133" endline="151" pcid="1030">
    function issuer_addSynths_5() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_5_0 = new ISynth[](15);
        issuer_addSynths_synthsToAdd_5_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);
        issuer_addSynths_synthsToAdd_5_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);
        issuer_addSynths_synthsToAdd_5_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);
        issuer_addSynths_synthsToAdd_5_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);
        issuer_addSynths_synthsToAdd_5_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);
        issuer_addSynths_synthsToAdd_5_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);
        issuer_addSynths_synthsToAdd_5_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);
        issuer_addSynths_synthsToAdd_5_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);
        issuer_addSynths_synthsToAdd_5_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);
        issuer_addSynths_synthsToAdd_5_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);
        issuer_addSynths_synthsToAdd_5_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);
        issuer_addSynths_synthsToAdd_5_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);
        issuer_addSynths_synthsToAdd_5_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);
        issuer_addSynths_synthsToAdd_5_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);
        issuer_addSynths_synthsToAdd_5_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_5_0);
    }
</source>
</class>

<class classid="138" nclones="4" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="38" endline="43" pcid="1010">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="38" endline="43" pcid="1017">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="38" endline="43" pcid="1031">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="38" endline="43" pcid="1023">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
</class>

<class classid="139" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="84" endline="93" pcid="1014">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="82" endline="91" pcid="1021">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="140" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="45" endline="68" pcid="1024">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="45" endline="68" pcid="1032">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="141" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="84" endline="93" pcid="1027">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="84" endline="93" pcid="1035">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="142" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="120" endline="124" pcid="1037">
    function addressresolver_rebuildCaches_2() internal {
        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](1);
        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_Issuer_contract);
        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="223" endline="227" pcid="1046">
    function issuer_addSynths_19() internal {
        ISynth[] memory issuer_addSynths_synthsToAdd_19_0 = new ISynth[](1);
        issuer_addSynths_synthsToAdd_19_0[0] = ISynth(new_SynthsWTI_contract);
        issuer_i.addSynths(issuer_addSynths_synthsToAdd_19_0);
    }
</source>
</class>

<class classid="143" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/MintableSynthetix.sol" startline="50" endline="52" pcid="1054">
    function mintSecondary(address account, uint amount) external onlyBridge {
        _mintSecondary(account, amount);
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="217" endline="219" pcid="1405">
    function appendVestingEntry(address account, uint quantity) external onlyFeePool {
        _appendVestingEntry(account, quantity);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="159" endline="161" pcid="1508">
    function issue(address account, uint amount) external onlyInternalContracts {
        _internalIssue(account, amount);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="163" endline="165" pcid="1509">
    function burn(address account, uint amount) external onlyInternalContracts {
        _internalBurn(account, amount);
    }
</source>
<source file="systems/source-code/SynthetixBridgeToBase.sol" startline="50" endline="52" pcid="1542">
    function withdrawTo(address to, uint amount) external requireInitiationActive {
        _initiateWithdraw(to, amount);
    }
</source>
</class>

<class classid="144" nclones="5" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="46" endline="49" pcid="1057">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="46" endline="49" pcid="1105">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="69" endline="72" pcid="1142">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/ShortingRewards.sol" startline="54" endline="57" pcid="1449">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_SHORT;
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="81" endline="84" pcid="1569">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_ISSUER;
    }
</source>
</class>

<class classid="145" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="57" endline="59" pcid="1059">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="57" endline="59" pcid="1107">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
</class>

<class classid="146" nclones="18" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="61" endline="63" pcid="1060">
    function _takerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="81" endline="83" pcid="1065">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="77" endline="79" pcid="1064">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="73" endline="75" pcid="1063">
    function _makerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="85" endline="87" pcid="1066">
    function _maxMarketValueUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_MARKET_VALUE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="89" endline="91" pcid="1067">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="93" endline="95" pcid="1068">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="69" endline="71" pcid="1062">
    function _takerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="65" endline="67" pcid="1061">
    function _makerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="61" endline="63" pcid="1108">
    function _takerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="65" endline="67" pcid="1109">
    function _makerFee(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="93" endline="95" pcid="1116">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="89" endline="91" pcid="1115">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="69" endline="71" pcid="1110">
    function _takerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_TAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="73" endline="75" pcid="1111">
    function _makerFeeNextPrice(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAKER_FEE_NEXT_PRICE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="77" endline="79" pcid="1112">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="81" endline="83" pcid="1113">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="85" endline="87" pcid="1114">
    function _maxMarketValueUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_MARKET_VALUE);
    }
</source>
</class>

<class classid="147" nclones="26" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="97" endline="99" pcid="1069">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="100" endline="102" pcid="1146">
    function getTradingRewardsEnabled() internal view returns (bool) {
        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="104" endline="106" pcid="1147">
    function getWaitingPeriodSecs() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="178" endline="180" pcid="1161">
    function getEtherWrapperMaxETH() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="174" endline="176" pcid="1160">
    function getDebtSnapshotStaleTime() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="182" endline="184" pcid="1162">
    function getEtherWrapperMintFeeRate() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="186" endline="188" pcid="1163">
    function getEtherWrapperBurnFeeRate() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="230" endline="232" pcid="1169">
    function getAtomicMaxVolumePerBlock() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="122" endline="125" pcid="1151">
    function getTargetThreshold() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="170" endline="172" pcid="1159">
    function getAggregatorWarningFlags() internal view returns (address) {
        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="234" endline="236" pcid="1170">
    function getAtomicTwapWindow() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="108" endline="110" pcid="1148">
    function getPriceDeviationThresholdFactor() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="127" endline="129" pcid="1152">
    function getLiquidationDelay() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="166" endline="168" pcid="1158">
    function getMinimumStakeTime() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="112" endline="115" pcid="1149">
    function getIssuanceRatio() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="117" endline="120" pcid="1150">
    function getFeePeriodDuration() internal view returns (uint) {
        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="139" endline="141" pcid="1155">
    function getRateStalePeriod() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="109" endline="111" pcid="1120">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="131" endline="133" pcid="1153">
    function getLiquidationRatio() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="101" endline="103" pcid="1070">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="105" endline="107" pcid="1071">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="109" endline="111" pcid="1072">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="97" endline="99" pcid="1117">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="135" endline="137" pcid="1154">
    function getLiquidationPenalty() internal view returns (uint) {
        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="101" endline="103" pcid="1118">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketSettings.sol" startline="105" endline="107" pcid="1119">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
</class>

<class classid="148" nclones="2" nlines="17" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="41" endline="91" pcid="1075">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="41" endline="91" pcid="1099">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
</class>

<class classid="149" nclones="2" nlines="19" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="105" endline="149" pcid="1076">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="105" endline="149" pcid="1100">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="150" nclones="2" nlines="23" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="164" endline="226" pcid="1077">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise future knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="164" endline="226" pcid="1101">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise perps knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="151" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="232" endline="234" pcid="1078">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="232" endline="234" pcid="1102">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
</class>

<class classid="152" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="238" endline="240" pcid="1079">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="238" endline="240" pcid="1103">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
</class>

<class classid="153" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="243" endline="253" pcid="1080">
    function _nextPriceCommitDeposit(TradeParams memory params) internal view returns (uint) {
        // modify params to spot fee
        params.takerFee = _takerFee(marketKey);
        params.makerFee = _makerFee(marketKey);
        // Commit fee is equal to the spot fee that would be paid.
        // This is to prevent free cancellation manipulations (by e.g. withdrawing the margin).
        // The dynamic fee rate is passed as 0 since for the purposes of the commitment deposit
        // it is not important since at the time of order execution it will be refunded and the correct
        // dynamic fee will be charged.
        return _orderFee(params, 0);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketNextPrice.sol" startline="243" endline="253" pcid="1104">
    function _nextPriceCommitDeposit(TradeParams memory params) internal view returns (uint) {
        // modify params to spot fee
        params.takerFee = _takerFee(marketKey);
        params.makerFee = _makerFee(marketKey);
        // Commit fee is equal to the spot fee that would be paid.
        // This is to prevent free cancellation manipulations (by e.g. withdrawing the margin).
        // The dynamic fee rate is passed as 0 since for the purposes of the commitment deposit
        // it is not important since at the time of order execution it will be refunded and the correct
        // dynamic fee will be charged.
        return _orderFee(params, 0);
    }
</source>
</class>

<class classid="154" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="14" endline="18" pcid="1081">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="14" endline="18" pcid="1121">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
</class>

<class classid="155" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="24" endline="27" pcid="1082">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="24" endline="27" pcid="1122">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
</class>

<class classid="156" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="33" endline="36" pcid="1083">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="16" endline="19" pcid="1818">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
<source file="systems/source-code/TestableFuturesMarket.sol" startline="16" endline="19" pcid="1808">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="33" endline="36" pcid="1123">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
</class>

<class classid="157" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="42" endline="45" pcid="1084">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="42" endline="45" pcid="1124">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
</class>

<class classid="158" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="57" endline="60" pcid="1086">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="57" endline="60" pcid="1126">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
</class>

<class classid="159" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="65" endline="68" pcid="1087">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="65" endline="68" pcid="1127">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="73" endline="76" pcid="1128">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="73" endline="76" pcid="1088">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="160" nclones="4" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="81" endline="84" pcid="1089">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="90" endline="93" pcid="1130">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinFuturesViews.sol" startline="90" endline="93" pcid="1090">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="81" endline="84" pcid="1129">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="161" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="102" endline="106" pcid="1091">
    function liquidationPrice(address account) external view returns (uint price, bool invalid) {
        (uint aPrice, bool isInvalid) = assetPrice();
        uint liqPrice = _approxLiquidationPrice(positions[account], aPrice);
        return (liqPrice, isInvalid);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="102" endline="106" pcid="1131">
    function liquidationPrice(address account) external view returns (uint price, bool invalid) {
        (uint aPrice, bool isInvalid) = assetPrice();
        uint liqPrice = _approxLiquidationPrice(positions[account], aPrice);
        return (liqPrice, isInvalid);
    }
</source>
</class>

<class classid="162" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="115" endline="125" pcid="1092">
    function liquidationFee(address account) external view returns (uint) {
        (uint price, bool invalid) = assetPrice();
        if (!invalid && _canLiquidate(positions[account], price)) {
            return _liquidationFee(int(positions[account].size), price);
        } else {
            // theoretically we can calculate a value, but this value is always incorrect because
            // it's for a price at which liquidation cannot happen - so is misleading, because
            // it won't be paid, and what will be paid is a different fee (for a different price)
            return 0;
        }
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="115" endline="125" pcid="1132">
    function liquidationFee(address account) external view returns (uint) {
        (uint price, bool invalid) = assetPrice();
        if (!invalid && _canLiquidate(positions[account], price)) {
            return _liquidationFee(int(positions[account].size), price);
        } else {
            // theoretically we can calculate a value, but this value is always incorrect because
            // it's for a price at which liquidation cannot happen - so is misleading, because
            // it won't be paid, and what will be paid is a different fee (for a different price)
            return 0;
        }
    }
</source>
</class>

<class classid="163" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="130" endline="133" pcid="1093">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="130" endline="133" pcid="1133">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
</class>

<class classid="164" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="143" endline="155" pcid="1094">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="143" endline="155" pcid="1134">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
</class>

<class classid="165" nclones="2" nlines="11" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="160" endline="190" pcid="1095">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="160" endline="190" pcid="1135">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
</class>

<class classid="166" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="193" endline="223" pcid="1096">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
<source file="systems/source-code/MixinPerpsV2MarketViews.sol" startline="193" endline="223" pcid="1136">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
</class>

<class classid="167" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/MixinSystemSettings.sol" startline="144" endline="150" pcid="1156">
    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="270" endline="276" pcid="1175">
    function getPureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) internal view returns (bool) {
        return
            flexibleStorage().getBoolValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="246" endline="252" pcid="1172">
    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="262" endline="268" pcid="1174">
    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="254" endline="260" pcid="1173">
    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="278" endline="284" pcid="1176">
    function getCrossChainSynthTransferEnabled(bytes32 currencyKey) internal view returns (uint) {
        return
            flexibleStorage().getUIntValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, currencyKey))
            );
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="238" endline="244" pcid="1171">
    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {
        return
            flexibleStorage().getAddressValue(
                SETTING_CONTRACT_NAME,
                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))
            );
    }
</source>
</class>

<class classid="168" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="81" endline="83" pcid="1179">
    function setAllRoundDataShouldRevert(bool _shouldRevert) external {
        allRoundDataShouldRevert = _shouldRevert;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="46" endline="48" pcid="1210">
    function setInvalid(bool _invalid) external {
        invalid = _invalid;
    }
</source>
<source file="systems/source-code/MockDexPriceAggregator.sol" startline="41" endline="43" pcid="1192">
    function setAssetToAssetShouldRevert(bool _shouldRevert) external {
        assetToAssetShouldRevert = _shouldRevert;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="85" endline="87" pcid="1180">
    function setLatestRoundDataShouldRevert(bool _shouldRevert) external {
        latestRoundDataShouldRevert = _shouldRevert;
    }
</source>
</class>

<class classid="169" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="118" endline="121" pcid="1185">
    function getAnswer(uint256 _roundId) external view returns (int256) {
        Entry memory entry = entries[_roundId];
        return entry.answer;
    }
</source>
<source file="systems/source-code/MockAggregatorV2V3.sol" startline="123" endline="126" pcid="1186">
    function getTimestamp(uint256 _roundId) external view returns (uint256) {
        Entry memory entry = entries[_roundId];
        return entry.updatedAt;
    }
</source>
</class>

<class classid="170" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockEtherWrapper.sol" startline="13" endline="15" pcid="1193">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockWrapperFactory.sol" startline="13" endline="15" pcid="1233">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="42" endline="44" pcid="1209">
    function setMarketDebt(uint _debt) external {
        debt = _debt;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="91" endline="93" pcid="1201">
    function setMaxSecsLeft(uint _maxSecsLeft) external {
        _mockMaxSecsLeft = _maxSecsLeft;
    }
</source>
</class>

<class classid="171" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/MockExchanger.sol" startline="79" endline="81" pcid="1198">
    function setReclaim(uint256 _reclaimAmount) external {
        _mockReclaimAmount = _reclaimAmount;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="83" endline="85" pcid="1199">
    function setRefund(uint256 _refundAmount) external {
        _mockRefundAmount = _refundAmount;
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="34" endline="36" pcid="1223">
    function setTotalSupply(uint256 _totalSupply) external {
        totalSupply = _totalSupply;
    }
</source>
<source file="systems/source-code/MockExchanger.sol" startline="87" endline="89" pcid="1200">
    function setNumEntries(uint256 _numEntries) external {
        _mockNumEntries = _numEntries;
    }
</source>
</class>

<class classid="172" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="30" endline="32" pcid="1206">
    function setManager(IFuturesMarketManagerInternal _manager) external {
        manager = _manager;
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="29" endline="31" pcid="1222">
    function setAddressResolver(IAddressResolver _resolver) external {
        addressResolver = _resolver;
    }
</source>
</class>

<class classid="173" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="34" endline="36" pcid="1207">
    function setBaseAsset(bytes32 _baseAsset) external {
        baseAsset = _baseAsset;
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="38" endline="40" pcid="1208">
    function setMarketKey(bytes32 _marketKey) external {
        marketKey = _marketKey;
    }
</source>
</class>

<class classid="174" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockFuturesMarket.sol" startline="54" endline="56" pcid="1212">
    function issueSUSD(address account, uint amount) external {
        manager.issueSUSD(account, amount);
    }
</source>
<source file="systems/source-code/MockFuturesMarket.sol" startline="58" endline="60" pcid="1213">
    function burnSUSD(address account, uint amount) external {
        manager.burnSUSD(account, amount);
    }
</source>
</class>

<class classid="175" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MockMintableSynthetix.sol" startline="10" endline="13" pcid="1215">
    function mintSecondary(address account, uint amount) external {
        mintSecondaryCallAccount = account;
        mintSecondaryCallAmount = amount;
    }
</source>
<source file="systems/source-code/MockMintableSynthetix.sol" startline="15" endline="18" pcid="1216">
    function burnSecondary(address account, uint amount) external {
        burnSecondaryCallAccount = account;
        burnSecondaryCallAmount = amount;
    }
</source>
</class>

<class classid="176" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MockSynth.sol" startline="91" endline="95" pcid="1227">
    function issue(address account, uint amount) external {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));
        totalSupply = totalSupply.add(amount);
        emit Issued(account, amount);
    }
</source>
<source file="systems/source-code/MockSynth.sol" startline="97" endline="101" pcid="1228">
    function burn(address account, uint amount) external {
        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));
        totalSupply = totalSupply.sub(amount);
        emit Burned(account, amount);
    }
</source>
</class>

<class classid="177" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MultiCollateralSynth.sol" startline="64" endline="66" pcid="1238">
    function issue(address account, uint amount) external onlyInternalContracts {
        super._internalIssue(account, amount);
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="73" endline="75" pcid="1239">
    function burn(address account, uint amount) external onlyInternalContracts {
        super._internalBurn(account, amount);
    }
</source>
</class>

<class classid="178" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="57" endline="61" pcid="1264">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_EXT_MESSENGER;
        addresses[1] = CONTRACT_BASE_OWNER_RELAY_ON_ETHEREUM;
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="26" endline="30" pcid="1612">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_ISSUER;
        addresses[1] = CONTRACT_SYNTHSUSD;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="60" endline="64" pcid="1834">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](2);
        addresses[0] = CONTRACT_EXCHANGER;
        addresses[1] = CONTRACT_SYNTHETIX;
    }
</source>
</class>

<class classid="179" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="65" endline="69" pcid="1265">
    function directRelay(address target, bytes calldata payload) external onlyTemporaryOwner {
        _relayCall(target, payload);

        emit DirectRelay(target, payload);
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="71" endline="75" pcid="1266">
    function finalizeRelay(address target, bytes calldata payload) external onlyMessengerAndL1Relayer {
        _relayCall(target, payload);

        emit RelayFinalized(target, payload);
    }
</source>
</class>

<class classid="180" nclones="8" nlines="3" similarity="100">
<source file="systems/source-code/Proxyable.sol" startline="34" endline="36" pcid="1357">
    function setMessageSender(address sender) external onlyProxy {
        messageSender = sender;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="64" endline="66" pcid="1417">
    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {
        synthetixProxy = _synthetixProxy;
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="23" endline="25" pcid="1826">
    function setSynthetix(address _synthetix) external onlyOwner {
        synthetix = _synthetix;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="68" endline="70" pcid="1418">
    function setRewardEscrow(address _rewardEscrow) external onlyOwner {
        rewardEscrow = _rewardEscrow;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="72" endline="74" pcid="1419">
    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {
        feePoolProxy = _feePoolProxy;
    }
</source>
<source file="systems/source-code/RewardsDistribution.sol" startline="80" endline="82" pcid="1420">
    function setAuthority(address _authority) external onlyOwner {
        authority = _authority;
    }
</source>
<source file="systems/source-code/RewardsDistributionRecipient.sol" startline="17" endline="19" pcid="1426">
    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {
        rewardsDistribution = _rewardsDistribution;
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="19" endline="21" pcid="1825">
    function setSynthetixProxy(address _integrationProxy) external onlyOwner {
        integrationProxy = _integrationProxy;
    }
</source>
</class>

<class classid="181" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="13" endline="16" pcid="1361">
    function name() public view returns (string memory) {
        // Immutable static call from target contract
        return IERC20(address(target)).name();
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="18" endline="21" pcid="1362">
    function symbol() public view returns (string memory) {
        // Immutable static call from target contract
        return IERC20(address(target)).symbol();
    }
</source>
</class>

<class classid="182" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="23" endline="26" pcid="1363">
    function decimals() public view returns (uint8) {
        // Immutable static call from target contract
        return IERC20(address(target)).decimals();
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="33" endline="36" pcid="1364">
    function totalSupply() public view returns (uint256) {
        // Immutable static call from target contract
        return IERC20(address(target)).totalSupply();
    }
</source>
</class>

<class classid="183" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/ProxyERC20.sol" startline="64" endline="73" pcid="1367">
    function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(address(target)).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
</source>
<source file="systems/source-code/ProxyERC20.sol" startline="84" endline="93" pcid="1368">
    function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(address(target)).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
</source>
</class>

<class classid="184" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="17" endline="19" pcid="1370">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="17" endline="19" pcid="1373">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
</class>

<class classid="185" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="21" endline="27" pcid="1371">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="21" endline="27" pcid="1374">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
</class>

<class classid="186" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="32" endline="34" pcid="1372">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="32" endline="34" pcid="1375">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
</class>

<class classid="187" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="11" endline="13" pcid="1377">
    function unit() public pure returns (uint) {
        return SafeDecimalMath.unit();
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="15" endline="17" pcid="1378">
    function preciseUnit() public pure returns (uint) {
        return SafeDecimalMath.preciseUnit();
    }
</source>
</class>

<class classid="188" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="19" endline="21" pcid="1379">
    function multiplyDecimal(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimal(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="27" endline="29" pcid="1381">
    function multiplyDecimalRoundPrecise(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimalRoundPrecise(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="35" endline="37" pcid="1383">
    function divideDecimalRound(uint x, uint y) public pure returns (uint) {
        return x.divideDecimalRound(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="31" endline="33" pcid="1382">
    function divideDecimal(uint x, uint y) public pure returns (uint) {
        return x.divideDecimal(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="39" endline="41" pcid="1384">
    function divideDecimalRoundPrecise(uint x, uint y) public pure returns (uint) {
        return x.divideDecimalRoundPrecise(y);
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="23" endline="25" pcid="1380">
    function multiplyDecimalRound(uint x, uint y) public pure returns (uint) {
        return x.multiplyDecimalRound(y);
    }
</source>
</class>

<class classid="189" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="43" endline="45" pcid="1385">
    function decimalToPreciseDecimal(uint i) public pure returns (uint) {
        return i.decimalToPreciseDecimal();
    }
</source>
<source file="systems/source-code/PublicSafeDecimalMath.sol" startline="47" endline="49" pcid="1386">
    function preciseDecimalToDecimal(uint i) public pure returns (uint) {
        return i.preciseDecimalToDecimal();
    }
</source>
</class>

<class classid="190" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/PurgeableSynth.sol" startline="72" endline="74" pcid="1390">
    function emitPurged(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, PURGED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="277" endline="279" pcid="1523">
    function emitIssued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
<source file="systems/source-code/Synth.sol" startline="284" endline="286" pcid="1524">
    function emitBurned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);
    }
</source>
</class>

<class classid="191" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="60" endline="63" pcid="1391">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="69" endline="72" pcid="1392">
    function setFeePool(IFeePool _feePool) external onlyOwner {
        feePool = _feePool;
        emit FeePoolUpdated(address(_feePool));
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="46" endline="49" pcid="1590">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
</class>

<class classid="192" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="98" endline="100" pcid="1396">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="71" endline="73" pcid="1593">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
</class>

<class classid="193" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="105" endline="107" pcid="1397">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="85" endline="87" pcid="1595">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="78" endline="80" pcid="1594">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="112" endline="114" pcid="1398">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="194" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="119" endline="127" pcid="1399">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = _numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="92" endline="100" pcid="1596">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
</class>

<class classid="195" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="132" endline="138" pcid="1400">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == _numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="105" endline="111" pcid="1597">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
</class>

<class classid="196" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="143" endline="145" pcid="1401">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="150" endline="152" pcid="1402">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="123" endline="125" pcid="1599">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="116" endline="118" pcid="1598">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
</class>

<class classid="197" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/RewardEscrowV2.sol" startline="29" endline="36" pcid="1407">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseRewardEscrowV2.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM;
        newAddresses[1] = CONTRACT_REWARD_ESCROW;
        newAddresses[2] = CONTRACT_SYSTEMSTATUS;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="30" endline="37" pcid="1525">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = BaseSynthetix.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](3);
        newAddresses[0] = CONTRACT_REWARD_ESCROW;
        newAddresses[1] = CONTRACT_REWARDESCROW_V2;
        newAddresses[2] = CONTRACT_SUPPLYSCHEDULE;
        return combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="198" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SafeDecimalMath.sol" startline="88" endline="90" pcid="1438">
    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {
        return _multiplyDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="104" endline="106" pcid="1439">
    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {
        return _multiplyDecimalRound(x, y, UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="164" endline="166" pcid="1443">
    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {
        return _divideDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SafeDecimalMath.sol" startline="152" endline="154" pcid="1442">
    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {
        return _divideDecimalRound(x, y, UNIT);
    }
</source>
</class>

<class classid="199" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="73" endline="75" pcid="1453">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="57" endline="59" pcid="1481">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
</class>

<class classid="200" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="77" endline="85" pcid="1454">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="61" endline="69" pcid="1482">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
</class>

<class classid="201" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="87" endline="89" pcid="1455">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="71" endline="73" pcid="1483">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
</class>

<class classid="202" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="91" endline="93" pcid="1456">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="75" endline="77" pcid="1484">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
</class>

<class classid="203" nclones="2" nlines="15" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="125" endline="144" pcid="1460">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="113" endline="132" pcid="1489">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
</class>

<class classid="204" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="146" endline="153" pcid="1461">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="141" endline="148" pcid="1491">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
</class>

<class classid="205" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="100" endline="102" pcid="1467">
    function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {
        return _multiplyDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="116" endline="118" pcid="1468">
    function multiplyDecimalRound(int x, int y) internal pure returns (int) {
        return _multiplyDecimalRound(x, y, UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="159" endline="161" pcid="1471">
    function divideDecimalRound(int x, int y) internal pure returns (int) {
        return _divideDecimalRound(x, y, UNIT);
    }
</source>
<source file="systems/source-code/SignedSafeDecimalMath.sol" startline="171" endline="173" pcid="1472">
    function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {
        return _divideDecimalRound(x, y, PRECISE_UNIT);
    }
</source>
</class>

<class classid="206" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="142" endline="145" pcid="1576">
    function addAuthorizedBroker(address target) external onlyOwner {
        authorizedBrokers[target] = true;
        emit ChangeAuthorizedBroker(target, true);
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="152" endline="155" pcid="1578">
    function addAuthorizedToSnapshot(address target) external onlyOwner {
        authorizedToSnapshot[target] = true;
        emit ChangeAuthorizedToSnapshot(target, true);
    }
</source>
</class>

<class classid="207" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="147" endline="150" pcid="1577">
    function removeAuthorizedBroker(address target) external onlyOwner {
        authorizedBrokers[target] = false;
        emit ChangeAuthorizedBroker(target, false);
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="157" endline="160" pcid="1579">
    function removeAuthorizedToSnapshot(address target) external onlyOwner {
        authorizedToSnapshot[target] = false;
        emit ChangeAuthorizedToSnapshot(target, false);
    }
</source>
</class>

<class classid="208" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SynthetixDebtShare.sol" startline="189" endline="191" pcid="1583">
    function approve(address, uint256) external pure returns (bool) {
        revert("debt shares are not transferrable");
    }
</source>
<source file="systems/source-code/SynthetixDebtShare.sol" startline="193" endline="195" pcid="1584">
    function transfer(address, uint256) external pure returns (bool) {
        revert("debt shares are not transferrable");
    }
</source>
</class>

<class classid="209" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SynthetixState.sol" startline="67" endline="69" pcid="1606">
    function incrementTotalIssuerCount() external onlyAssociatedContract {
        totalIssuerCount = totalIssuerCount.add(1);
    }
</source>
<source file="systems/source-code/SynthetixState.sol" startline="75" endline="77" pcid="1607">
    function decrementTotalIssuerCount() external onlyAssociatedContract {
        totalIssuerCount = totalIssuerCount.sub(1);
    }
</source>
</class>

<class classid="210" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="94" endline="96" pcid="1640">
    function exchangeDynamicFeeThreshold() external view returns (uint) {
        return getExchangeDynamicFeeConfig().threshold;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="100" endline="102" pcid="1641">
    function exchangeDynamicFeeWeightDecay() external view returns (uint) {
        return getExchangeDynamicFeeConfig().weightDecay;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="112" endline="114" pcid="1643">
    function exchangeMaxDynamicFee() external view returns (uint) {
        return getExchangeDynamicFeeConfig().maxFee;
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="106" endline="108" pcid="1642">
    function exchangeDynamicFeeRounds() external view returns (uint) {
        return getExchangeDynamicFeeConfig().rounds;
    }
</source>
</class>

<class classid="211" nclones="15" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="242" endline="245" pcid="1666">
    function setIssuanceRatio(uint ratio) external onlyOwner {
        flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO, ratio);
        emit IssuanceRatioUpdated(ratio);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="265" endline="268" pcid="1670">
    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {
        flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);
        emit FeePeriodDurationUpdated(_feePeriodDuration);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="377" endline="380" pcid="1686">
    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {
        flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);
        emit EtherWrapperBurnFeeRateUpdated(_rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="347" endline="350" pcid="1680">
    function setExchangeMaxDynamicFee(uint maxFee) external onlyOwner {
        flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE, maxFee);
        emit ExchangeMaxDynamicFeeUpdated(maxFee);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="417" endline="420" pcid="1692">
    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {
        flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);
        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="275" endline="278" pcid="1672">
    function setLiquidationDelay(uint time) external onlyOwner {
        flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY, time);
        emit LiquidationDelayUpdated(time);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="357" endline="360" pcid="1682">
    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {
        flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);
        emit DebtSnapshotStaleTimeUpdated(_seconds);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="252" endline="255" pcid="1668">
    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {
        flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);
        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="367" endline="370" pcid="1684">
    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {
        flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);
        emit EtherWrapperMaxETHUpdated(_maxETH);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="292" endline="295" pcid="1674">
    function setLiquidationPenalty(uint penalty) external onlyOwner {
        flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY, penalty);
        emit LiquidationPenaltyUpdated(penalty);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="422" endline="425" pcid="1693">
    function setAtomicTwapWindow(uint _window) external onlyOwner {
        flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW, _window);
        emit AtomicTwapWindowUpdated(_window);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="297" endline="300" pcid="1675">
    function setRateStalePeriod(uint period) external onlyOwner {
        flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD, period);
        emit RateStalePeriodUpdated(period);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="372" endline="375" pcid="1685">
    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {
        flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);
        emit EtherWrapperMintFeeRateUpdated(_rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="257" endline="263" pcid="1669">
    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {
        flexibleStorage().setPriceDeviationThresholdFactor(
            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,
            _priceDeviationThresholdFactor
        );
        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="352" endline="355" pcid="1681">
    function setMinimumStakeTime(uint _seconds) external onlyOwner {
        flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME, _seconds);
        emit MinimumStakeTimeUpdated(_seconds);
    }
</source>
</class>

<class classid="212" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="387" endline="395" pcid="1688">
    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {
        flexibleStorage().setWrapperMintFeeRate(
            SETTING_WRAPPER_MINT_FEE_RATE,
            _wrapper,
            _rate,
            getWrapperBurnFeeRate(_wrapper)
        );
        emit WrapperMintFeeRateUpdated(_wrapper, _rate);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="397" endline="405" pcid="1689">
    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {
        flexibleStorage().setWrapperBurnFeeRate(
            SETTING_WRAPPER_BURN_FEE_RATE,
            _wrapper,
            _rate,
            getWrapperMintFeeRate(_wrapper)
        );
        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);
    }
</source>
</class>

<class classid="213" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="407" endline="410" pcid="1690">
    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {
        flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY, _collateral, _interactionDelay);
        emit InteractionDelayUpdated(_interactionDelay);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="412" endline="415" pcid="1691">
    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {
        flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE, _collateral, _collapseFeeRate);
        emit CollapseFeeRateUpdated(_collapseFeeRate);
    }
</source>
</class>

<class classid="214" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/SystemSettings.sol" startline="441" endline="448" pcid="1696">
    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {
        flexibleStorage().setAtomicVolatilityConsiderationWindow(
            SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,
            _currencyKey,
            _window
        );
        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="468" endline="471" pcid="1699">
    function setCrossChainSynthTransferEnabled(bytes32 _currencyKey, uint _value) external onlyOwner {
        flexibleStorage().setCrossChainSynthTransferEnabled(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, _currencyKey, _value);
        emit CrossChainSynthTransferEnabledUpdated(_currencyKey, _value);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="450" endline="457" pcid="1697">
    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {
        flexibleStorage().setAtomicVolatilityUpdateThreshold(
            SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,
            _currencyKey,
            _threshold
        );
        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);
    }
</source>
</class>

<class classid="215" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="95" endline="101" pcid="1704">
    function setWaitingPeriodSecs(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _waitingPeriodSecs
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _waitingPeriodSecs);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="225" endline="231" pcid="1716">
    function setEtherWrapperMaxETH(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _maxETH
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxETH);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="174" endline="180" pcid="1711">
    function setRateStalePeriod(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint period
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, period);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="103" endline="109" pcid="1705">
    function setPriceDeviationThresholdFactor(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _priceDeviationThresholdFactor
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _priceDeviationThresholdFactor);
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="208" endline="214" pcid="1714">
    function setDebtSnapshotStaleTime(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        uint _seconds
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);
    }
</source>
</class>

<class classid="216" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="251" endline="262" pcid="1719">
    function setWrapperMaxTokenAmount(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        address _wrapper,
        uint _maxTokenAmount
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _wrapper)),
            _maxTokenAmount
        );
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="316" endline="327" pcid="1723">
    function setCollapseFeeRate(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        address _collateral,
        uint _collapseFeeRate
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _collateral)),
            _collapseFeeRate
        );
    }
</source>
</class>

<class classid="217" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemSettingsLib.sol" startline="399" endline="410" pcid="1729">
    function setAtomicVolatilityUpdateThreshold(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        bytes32 _currencyKey,
        uint _threshold
    ) external {
        flexibleStorage.setUIntValue(
            SETTINGS_CONTRACT_NAME,
            keccak256(abi.encodePacked(settingName, _currencyKey)),
            _threshold
        );
    }
</source>
<source file="systems/source-code/SystemSettingsLib.sol" startline="425" endline="432" pcid="1731">
    function setCrossChainSynthTransferEnabled(
        IFlexibleStorage flexibleStorage,
        bytes32 settingName,
        bytes32 _currencyKey,
        uint _value
    ) external {
        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _currencyKey)), _value);
    }
</source>
</class>

<class classid="218" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="47" endline="53" pcid="1735">
    function requireIssuanceActive() external view {
        // Issuance requires the system be active
        _internalRequireSystemActive();

        // and issuance itself of course
        _internalRequireIssuanceActive();
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="55" endline="61" pcid="1736">
    function requireExchangeActive() external view {
        // Exchanging requires the system be active
        _internalRequireSystemActive();

        // and exchanging itself of course
        _internalRequireExchangeActive();
    }
</source>
</class>

<class classid="219" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="63" endline="67" pcid="1737">
    function requireSynthExchangeActive(bytes32 currencyKey) external view {
        // Synth exchange and transfer requires the system be active
        _internalRequireSystemActive();
        _internalRequireSynthExchangeActive(currencyKey);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="87" endline="91" pcid="1741">
    function requireSynthActive(bytes32 currencyKey) external view {
        // Synth exchange and transfer requires the system be active
        _internalRequireSystemActive();
        _internalRequireSynthActive(currencyKey);
    }
</source>
</class>

<class classid="220" nclones="3" nlines="8" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="120" endline="132" pcid="1745">
    function getSynthExchangeSuspensions(bytes32[] calldata synths)
        external
        view
        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)
    {
        exchangeSuspensions = new bool[](synths.length);
        reasons = new uint256[](synths.length);

        for (uint i = 0; i < synths.length; i++) {
            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;
            reasons[i] = synthExchangeSuspension[synths[i]].reason;
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="149" endline="161" pcid="1747">
    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)
        external
        view
        returns (bool[] memory suspensions, uint256[] memory reasons)
    {
        suspensions = new bool[](marketKeys.length);
        reasons = new uint256[](marketKeys.length);

        for (uint i = 0; i < marketKeys.length; i++) {
            suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended;
            reasons[i] = futuresMarketSuspension[marketKeys[i]].reason;
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="134" endline="146" pcid="1746">
    function getSynthSuspensions(bytes32[] calldata synths)
        external
        view
        returns (bool[] memory suspensions, uint256[] memory reasons)
    {
        suspensions = new bool[](synths.length);
        reasons = new uint256[](synths.length);

        for (uint i = 0; i < synths.length; i++) {
            suspensions[i] = synthSuspension[synths[i]].suspended;
            reasons[i] = synthSuspension[synths[i]].reason;
        }
    }
</source>
</class>

<class classid="221" nclones="4" nlines="6" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="197" endline="202" pcid="1751">
    function resumeSystem() external {
        _requireAccessToResume(SECTION_SYSTEM);
        systemSuspension.suspended = false;
        emit SystemResumed(uint256(systemSuspension.reason));
        systemSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="225" endline="230" pcid="1755">
    function resumeExchange() external {
        _requireAccessToResume(SECTION_EXCHANGE);
        exchangeSuspension.suspended = false;
        emit ExchangeResumed(uint256(exchangeSuspension.reason));
        exchangeSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="211" endline="216" pcid="1753">
    function resumeIssuance() external {
        _requireAccessToResume(SECTION_ISSUANCE);
        issuanceSuspension.suspended = false;
        emit IssuanceResumed(uint256(issuanceSuspension.reason));
        issuanceSuspension.reason = 0;
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="239" endline="244" pcid="1757">
    function resumeFutures() external {
        _requireAccessToResume(SECTION_FUTURES);
        futuresSuspension.suspended = false;
        emit FuturesResumed(uint256(futuresSuspension.reason));
        futuresSuspension.reason = 0;
    }
</source>
</class>

<class classid="222" nclones="3" nlines="6" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="204" endline="209" pcid="1752">
    function suspendIssuance(uint256 reason) external {
        _requireAccessToSuspend(SECTION_ISSUANCE);
        issuanceSuspension.suspended = true;
        issuanceSuspension.reason = uint248(reason);
        emit IssuanceSuspended(reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="218" endline="223" pcid="1754">
    function suspendExchange(uint256 reason) external {
        _requireAccessToSuspend(SECTION_EXCHANGE);
        exchangeSuspension.suspended = true;
        exchangeSuspension.reason = uint248(reason);
        emit ExchangeSuspended(reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="232" endline="237" pcid="1756">
    function suspendFutures(uint256 reason) external {
        _requireAccessToSuspend(SECTION_FUTURES);
        futuresSuspension.suspended = true;
        futuresSuspension.reason = uint248(reason);
        emit FuturesSuspended(reason);
    }
</source>
</class>

<class classid="223" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="247" endline="251" pcid="1758">
    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external {
        bytes32[] memory marketKeys = new bytes32[](1);
        marketKeys[0] = marketKey;
        _internalSuspendFuturesMarkets(marketKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="270" endline="274" pcid="1762">
    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalSuspendSynthExchange(currencyKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="290" endline="294" pcid="1766">
    function suspendSynth(bytes32 currencyKey, uint256 reason) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalSuspendSynths(currencyKeys, reason);
    }
</source>
</class>

<class classid="224" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="254" endline="256" pcid="1759">
    function suspendFuturesMarkets(bytes32[] calldata marketKeys, uint256 reason) external {
        _internalSuspendFuturesMarkets(marketKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="296" endline="298" pcid="1767">
    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {
        _internalSuspendSynths(currencyKeys, reason);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="276" endline="278" pcid="1763">
    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {
        _internalSuspendSynthExchange(currencyKeys, reason);
    }
</source>
</class>

<class classid="225" nclones="3" nlines="5" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="259" endline="263" pcid="1760">
    function resumeFuturesMarket(bytes32 marketKey) external {
        bytes32[] memory marketKeys = new bytes32[](1);
        marketKeys[0] = marketKey;
        _internalResumeFuturesMarkets(marketKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="280" endline="284" pcid="1764">
    function resumeSynthExchange(bytes32 currencyKey) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalResumeSynthsExchange(currencyKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="300" endline="304" pcid="1768">
    function resumeSynth(bytes32 currencyKey) external {
        bytes32[] memory currencyKeys = new bytes32[](1);
        currencyKeys[0] = currencyKey;
        _internalResumeSynths(currencyKeys);
    }
</source>
</class>

<class classid="226" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="266" endline="268" pcid="1761">
    function resumeFuturesMarkets(bytes32[] calldata marketKeys) external {
        _internalResumeFuturesMarkets(marketKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="306" endline="308" pcid="1769">
    function resumeSynths(bytes32[] calldata currencyKeys) external {
        _internalResumeSynths(currencyKeys);
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="286" endline="288" pcid="1765">
    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {
        _internalResumeSynthsExchange(currencyKeys);
    }
</source>
</class>

<class classid="227" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="312" endline="314" pcid="1770">
    function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="316" endline="318" pcid="1771">
    function _requireAccessToResume(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canResume, "Restricted to access control list");
    }
</source>
</class>

<class classid="228" nclones="3" nlines="9" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="353" endline="361" pcid="1779">
    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_SYNTH);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            synthSuspension[currencyKey].suspended = true;
            synthSuspension[currencyKey].reason = uint248(reason);
            emit SynthSuspended(currencyKey, reason);
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="391" endline="399" pcid="1783">
    function _internalSuspendFuturesMarkets(bytes32[] memory marketKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_FUTURES);
        for (uint i = 0; i < marketKeys.length; i++) {
            bytes32 marketKey = marketKeys[i];
            futuresMarketSuspension[marketKey].suspended = true;
            futuresMarketSuspension[marketKey].reason = uint248(reason);
            emit FuturesMarketSuspended(marketKey, reason);
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="372" endline="380" pcid="1781">
    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {
        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            synthExchangeSuspension[currencyKey].suspended = true;
            synthExchangeSuspension[currencyKey].reason = uint248(reason);
            emit SynthExchangeSuspended(currencyKey, reason);
        }
    }
</source>
</class>

<class classid="229" nclones="3" nlines="8" similarity="100">
<source file="systems/source-code/SystemStatus.sol" startline="363" endline="370" pcid="1780">
    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {
        _requireAccessToResume(SECTION_SYNTH);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));
            delete synthSuspension[currencyKey];
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="382" endline="389" pcid="1782">
    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {
        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);
        for (uint i = 0; i < currencyKeys.length; i++) {
            bytes32 currencyKey = currencyKeys[i];
            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));
            delete synthExchangeSuspension[currencyKey];
        }
    }
</source>
<source file="systems/source-code/SystemStatus.sol" startline="401" endline="408" pcid="1784">
    function _internalResumeFuturesMarkets(bytes32[] memory marketKeys) internal {
        _requireAccessToResume(SECTION_FUTURES);
        for (uint i = 0; i < marketKeys.length; i++) {
            bytes32 marketKey = marketKeys[i];
            emit FuturesMarketResumed(marketKey, uint256(futuresMarketSuspension[marketKey].reason));
            delete futuresMarketSuspension[marketKey];
        }
    }
</source>
</class>

<class classid="230" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="18" endline="20" pcid="1792">
    function add(address element) public {
        set.add(element);
    }
</source>
<source file="systems/source-code/TestableAddressSet.sol" startline="22" endline="24" pcid="1793">
    function remove(address element) public {
        set.remove(element);
    }
</source>
</class>

<class classid="231" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="30" endline="32" pcid="1795">
    function element(uint index) public view returns (address) {
        return set.elements[index];
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="30" endline="32" pcid="1802">
    function element(uint index) public view returns (bytes32) {
        return set.elements[index];
    }
</source>
</class>

<class classid="232" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableBytes32Set.sol" startline="18" endline="20" pcid="1799">
    function add(bytes32 element) public {
        set.add(element);
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="22" endline="24" pcid="1800">
    function remove(bytes32 element) public {
        set.remove(element);
    }
</source>
</class>

<class classid="233" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="28" endline="44" pcid="1810">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxMarketValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="28" endline="44" pcid="1820">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxMarketValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
</class>

<class classid="234" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="52" endline="56" pcid="1811">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="52" endline="56" pcid="1821">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
</class>

<class classid="235" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="61" endline="66" pcid="1812">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="61" endline="66" pcid="1822">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
</class>

<class classid="236" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TokenExchanger.sol" startline="27" endline="29" pcid="1827">
    function checkBalance(address account) public view synthetixProxyIsSet returns (uint) {
        return IERC20(integrationProxy).balanceOf(account);
    }
</source>
<source file="systems/source-code/TokenExchanger.sol" startline="35" endline="37" pcid="1829">
    function checkBalanceSNXDirect(address account) public view synthetixProxyIsSet returns (uint) {
        return IERC20(synthetix).balanceOf(account);
    }
</source>
</class>

<class classid="237" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/TradingRewards.sol" startline="94" endline="96" pcid="1842">
    function getPeriodIsClaimable(uint periodID) external view returns (bool) {
        return _periods[periodID].isFinalized;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="98" endline="100" pcid="1843">
    function getPeriodIsFinalized(uint periodID) external view returns (bool) {
        return _periods[periodID].isFinalized;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="102" endline="104" pcid="1844">
    function getPeriodRecordedFees(uint periodID) external view returns (uint) {
        return _periods[periodID].recordedFees;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="106" endline="108" pcid="1845">
    function getPeriodTotalRewards(uint periodID) external view returns (uint) {
        return _periods[periodID].totalRewards;
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="110" endline="112" pcid="1846">
    function getPeriodAvailableRewards(uint periodID) external view returns (uint) {
        return _periods[periodID].availableRewards;
    }
</source>
</class>

</clones>
