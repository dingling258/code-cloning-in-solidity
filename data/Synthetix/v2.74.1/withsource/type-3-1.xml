<clones>
<systeminfo processor="nicad6" system="source-code" granularity="functions" threshold="30%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="2031" npairs="897"/>
<runinfo ncompares="646688" cputime="33509"/>
<classinfo nclasses="205"/>

<class classid="1" nclones="2" nlines="7" similarity="80">
<source file="systems/source-code/AddressSetLib.sol" startline="10" endline="16" pcid="7">
    function contains(AddressSet storage set, address candidate) internal view returns (bool) {
        if (set.elements.length == 0) {
            return false;
        }
        uint index = set.indices[candidate];
        return index != 0 || set.elements[0] == candidate;
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="10" endline="16" pcid="169">
    function contains(Bytes32Set storage set, bytes32 candidate) internal view returns (bool) {
        if (set.elements.length == 0) {
            return false;
        }
        uint index = set.indices[candidate];
        return index != 0 || set.elements[0] == candidate;
    }
</source>
</class>

<class classid="2" nclones="2" nlines="15" similarity="72">
<source file="systems/source-code/AddressSetLib.sol" startline="18" endline="40" pcid="8">
    function getPage(
        AddressSet storage set,
        uint index,
        uint pageSize
    ) internal view returns (address[] memory) {
        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+
        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.

        // If the page extends past the end of the list, truncate it.
        if (endIndex > set.elements.length) {
            endIndex = set.elements.length;
        }
        if (endIndex <= index) {
            return new address[](0);
        }

        uint n = endIndex - index; // We already checked for negative overflow.
        address[] memory page = new address[](n);
        for (uint i; i < n; i++) {
            page[i] = set.elements[i + index];
        }
        return page;
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="18" endline="40" pcid="170">
    function getPage(
        Bytes32Set storage set,
        uint index,
        uint pageSize
    ) internal view returns (bytes32[] memory) {
        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+
        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.

        // If the page extends past the end of the list, truncate it.
        if (endIndex > set.elements.length) {
            endIndex = set.elements.length;
        }
        if (endIndex <= index) {
            return new bytes32[](0);
        }

        uint n = endIndex - index; // We already checked for negative overflow.
        bytes32[] memory page = new bytes32[](n);
        for (uint i; i < n; i++) {
            page[i] = set.elements[i + index];
        }
        return page;
    }
</source>
</class>

<class classid="3" nclones="2" nlines="6" similarity="75">
<source file="systems/source-code/AddressSetLib.sol" startline="42" endline="48" pcid="9">
    function add(AddressSet storage set, address element) internal {
        // Adding to a set is an idempotent operation.
        if (!contains(set, element)) {
            set.indices[element] = set.elements.length;
            set.elements.push(element);
        }
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="42" endline="48" pcid="171">
    function add(Bytes32Set storage set, bytes32 element) internal {
        // Adding to a set is an idempotent operation.
        if (!contains(set, element)) {
            set.indices[element] = set.elements.length;
            set.elements.push(element);
        }
    }
</source>
</class>

<class classid="4" nclones="2" nlines="12" similarity="80">
<source file="systems/source-code/AddressSetLib.sol" startline="50" endline="63" pcid="10">
    function remove(AddressSet storage set, address element) internal {
        require(contains(set, element), "Element not in set.");
        // Replace the removed element with the last element of the list.
        uint index = set.indices[element];
        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.
        if (index != lastIndex) {
            // No need to shift the last element if it is the one we want to delete.
            address shiftedElement = set.elements[lastIndex];
            set.elements[index] = shiftedElement;
            set.indices[shiftedElement] = index;
        }
        set.elements.pop();
        delete set.indices[element];
    }
</source>
<source file="systems/source-code/Bytes32SetLib.sol" startline="50" endline="63" pcid="172">
    function remove(Bytes32Set storage set, bytes32 element) internal {
        require(contains(set, element), "Element not in set.");
        // Replace the removed element with the last element of the list.
        uint index = set.indices[element];
        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.
        if (index != lastIndex) {
            // No need to shift the last element if it is the one we want to delete.
            bytes32 shiftedElement = set.elements[lastIndex];
            set.elements[index] = shiftedElement;
            set.indices[shiftedElement] = index;
        }
        set.elements.pop();
        delete set.indices[element];
    }
</source>
</class>

<class classid="5" nclones="13" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="71" endline="73" pcid="12">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/SynthRedeemer.sol" startline="32" endline="34" pcid="1739">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="66" endline="68" pcid="153">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="66" endline="68" pcid="901">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/SynthetixBridgeToOptimism.sol" startline="40" endline="42" pcid="1676">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="89" endline="91" pcid="423">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="145" endline="147" pcid="595">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="97" endline="99" pcid="447">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="72" endline="74" pcid="93">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="77" endline="79" pcid="61">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="146" endline="148" pcid="461">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="70" endline="72" pcid="928">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="212" endline="214" pcid="1641">
    function issuer() internal view returns (IIssuer) {
        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));
    }
</source>
</class>

<class classid="6" nclones="6" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="75" endline="77" pcid="13">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="70" endline="72" pcid="1977">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="137" endline="139" pcid="593">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="68" endline="70" pcid="92">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="208" endline="210" pcid="1640">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="135" endline="137" pcid="816">
    function exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
</class>

<class classid="7" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="79" endline="81" pcid="14">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="85" endline="87" pcid="422">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="42" endline="44" pcid="1512">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="70" endline="72" pcid="902">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="139" endline="141" pcid="817">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="122" endline="124" pcid="455">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/Depot.sol" startline="515" endline="517" pcid="361">
    function exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
</class>

<class classid="8" nclones="9" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="83" endline="85" pcid="15">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="125" endline="127" pcid="590">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="114" endline="116" pcid="453">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="64" endline="66" pcid="91">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="179" endline="181" pcid="827">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/RewardEscrowV2.sol" startline="46" endline="48" pcid="1534">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="93" endline="95" pcid="446">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="200" endline="202" pcid="1638">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="62" endline="64" pcid="900">
    function systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
</class>

<class classid="9" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="87" endline="89" pcid="16">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="141" endline="143" pcid="594">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="36" endline="38" pcid="1320">
    function collateralManager() internal view returns (ICollateralManager) {
        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));
    }
</source>
</class>

<class classid="10" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="91" endline="93" pcid="17">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/NativeEtherWrapper.sol" startline="33" endline="35" pcid="1328">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="40" endline="42" pcid="1321">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="161" endline="163" pcid="599">
    function etherWrapper() internal view returns (IEtherWrapper) {
        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));
    }
</source>
</class>

<class classid="11" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="95" endline="97" pcid="18">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="216" endline="218" pcid="1642">
    function futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
</class>

<class classid="12" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="99" endline="101" pcid="19">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="169" endline="171" pcid="601">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
<source file="systems/source-code/MultiCollateralSynth.sol" startline="44" endline="46" pcid="1322">
    function wrapperFactory() internal view returns (IWrapperFactory) {
        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));
    }
</source>
</class>

<class classid="13" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseDebtCache.sol" startline="103" endline="105" pcid="20">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="156" endline="158" pcid="1776">
    function debtSnapshotStaleTime() external view returns (uint) {
        return getDebtSnapshotStaleTime();
    }
</source>
</class>

<class classid="14" nclones="7" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="69" endline="71" pcid="59">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="134" endline="136" pcid="458">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="70" endline="72" pcid="154">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/EtherWrapper.sol" startline="81" endline="83" pcid="421">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Synth.sol" startline="204" endline="206" pcid="1639">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="44" endline="46" pcid="2026">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="147" endline="149" pcid="819">
    function feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
</class>

<class classid="15" nclones="5" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="73" endline="75" pcid="60">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="58" endline="60" pcid="899">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="131" endline="133" pcid="815">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="58" endline="60" pcid="151">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="130" endline="132" pcid="457">
    function synthetix() internal view returns (ISynthetix) {
        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
</class>

<class classid="16" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="81" endline="83" pcid="62">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/ExchangeRates.sol" startline="526" endline="529" pcid="546">
    function _notImplemented() internal pure {
        // slither-disable-next-line dead-code
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/BaseSynthetix.sol" startline="436" endline="438" pcid="138">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="1032" endline="1034" pcid="506">
    function _notImplemented() internal pure {
        revert("Cannot be run on this layer");
    }
</source>
</class>

<class classid="17" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseRewardEscrowV2.sol" startline="98" endline="100" pcid="64">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
<source file="systems/source-code/RewardEscrow.sol" startline="79" endline="81" pcid="1517">
    function balanceOf(address account) public view returns (uint) {
        return totalEscrowedAccountBalance[account];
    }
</source>
</class>

<class classid="18" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="76" endline="78" pcid="94">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="157" endline="159" pcid="598">
    function rewardsDistribution() internal view returns (IRewardsDistribution) {
        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));
    }
</source>
</class>

<class classid="19" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="84" endline="86" pcid="96">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="151" endline="153" pcid="820">
    function liquidator() internal view returns (ILiquidator) {
        return ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR));
    }
</source>
</class>

<class classid="20" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="206" endline="216" pcid="115">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="123" endline="133" pcid="1658">
    function settle(bytes32 currencyKey)
        external
        optionalProxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numEntriesSettled
        )
    {
        return exchanger().settle(messageSender, currencyKey);
    }
</source>
</class>

<class classid="21" nclones="2" nlines="11" similarity="100">
<source file="systems/source-code/BaseSynthetix.sol" startline="483" endline="493" pcid="143">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
<source file="systems/source-code/Synth.sol" startline="278" endline="288" pcid="1647">
    function _onlyProxyOrInternal() internal {
        if (msg.sender == address(proxy)) {
            // allow proxy through, messageSender should be already set correctly
            return;
        } else if (_isInternalTransferCaller(msg.sender)) {
            // optionalProxy behaviour only for the internal legacy contracts
            messageSender = msg.sender;
        } else {
            revert("Only the proxy can call");
        }
    }
</source>
</class>

<class classid="22" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/BaseSynthetixBridge.sol" startline="74" endline="76" pcid="155">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="79" endline="81" pcid="1224">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/WrapperFactory.sol" startline="40" endline="42" pcid="2025">
    function flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
</class>

<class classid="23" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="112" endline="114" pcid="174">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="213" endline="215" pcid="676">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="167" endline="169" pcid="1361">
    function _systemStatus() internal view returns (ISystemStatus) {
        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));
    }
</source>
</class>

<class classid="24" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="116" endline="118" pcid="175">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="145" endline="147" pcid="231">
    function _synth(bytes32 synthName) internal view returns (ISynth) {
        return ISynth(requireAndGetAddress(synthName));
    }
</source>
</class>

<class classid="25" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="124" endline="126" pcid="177">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="89" endline="91" pcid="445">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
<source file="systems/source-code/CollateralManager.sol" startline="141" endline="143" pcid="230">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));
    }
</source>
</class>

<class classid="26" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="128" endline="130" pcid="178">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FuturesMarketBase.sol" startline="209" endline="211" pcid="675">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="77" endline="79" pcid="755">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="163" endline="165" pcid="1360">
    function _exchanger() internal view returns (IExchanger) {
        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));
    }
</source>
</class>

<class classid="27" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Collateral.sol" startline="132" endline="134" pcid="179">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
<source file="systems/source-code/FuturesMarketManager.sol" startline="73" endline="75" pcid="754">
    function _feePool() internal view returns (IFeePool) {
        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));
    }
</source>
</class>

<class classid="28" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="83" endline="89" pcid="214">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="53" endline="59" pcid="290">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="43" endline="49" pcid="223">
    function repay(
        address borrower,
        uint id,
        uint amount
    ) external returns (uint principal, uint collateral) {
        (principal, collateral) = _repay(borrower, msg.sender, id, amount);
    }
</source>
</class>

<class classid="29" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/CollateralErc20.sol" startline="91" endline="93" pcid="215">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralShort.sol" startline="82" endline="84" pcid="294">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
<source file="systems/source-code/CollateralEth.sol" startline="51" endline="53" pcid="224">
    function draw(uint id, uint amount) external returns (uint principal, uint collateral) {
        (principal, collateral) = _draw(id, amount);
    }
</source>
</class>

<class classid="30" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/CollateralUtil.sol" startline="27" endline="32" pcid="298">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PurgeableSynth.sol" startline="35" endline="40" pcid="1511">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_EXRATES;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="31" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Depot.sol" startline="511" endline="513" pcid="360">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/TradingRewards.sol" startline="66" endline="68" pcid="1976">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="78" endline="80" pcid="930">
    function synthetix() internal view returns (IERC20) {
        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));
    }
</source>
</class>

<class classid="32" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeCircuitBreaker.sol" startline="76" endline="78" pcid="442">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="39" endline="41" pcid="1757">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
<source file="systems/source-code/Exchanger.sol" startline="166" endline="168" pcid="466">
    function priceDeviationThresholdFactor() external view returns (uint) {
        return getPriceDeviationThresholdFactor();
    }
</source>
</class>

<class classid="33" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="142" endline="144" pcid="460">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="159" endline="161" pcid="822">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
<source file="systems/source-code/FeePool.sol" startline="153" endline="155" pcid="597">
    function delegateApprovals() internal view returns (IDelegateApprovals) {
        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));
    }
</source>
</class>

<class classid="34" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="158" endline="160" pcid="464">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="32" endline="34" pcid="1756">
    function waitingPeriodSecs() external view returns (uint) {
        return getWaitingPeriodSecs();
    }
</source>
</class>

<class classid="35" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Exchanger.sol" startline="162" endline="164" pcid="465">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="166" endline="168" pcid="1778">
    function tradingRewardsEnabled() external view returns (bool) {
        return getTradingRewardsEnabled();
    }
</source>
</class>

<class classid="36" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="84" endline="86" pcid="510">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="116" endline="118" pcid="1769">
    function rateStalePeriod() external view returns (uint) {
        return getRateStalePeriod();
    }
</source>
</class>

<class classid="37" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRates.sol" startline="88" endline="90" pcid="511">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="160" endline="162" pcid="1777">
    function aggregatorWarningFlags() external view returns (address) {
        return getAggregatorWarningFlags();
    }
</source>
</class>

<class classid="38" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="35" endline="37" pcid="549">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="226" endline="228" pcid="1789">
    function atomicTwapWindow() external view returns (uint) {
        return getAtomicTwapWindow();
    }
</source>
</class>

<class classid="39" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="39" endline="41" pcid="550">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="232" endline="234" pcid="1790">
    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {
        return getAtomicEquivalentForDexPricing(currencyKey);
    }
</source>
</class>

<class classid="40" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="43" endline="45" pcid="551">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="244" endline="246" pcid="1792">
    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityConsiderationWindow(currencyKey);
    }
</source>
</class>

<class classid="41" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangeRatesWithDexPricing.sol" startline="47" endline="49" pcid="552">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="250" endline="252" pcid="1793">
    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {
        return getAtomicVolatilityUpdateThreshold(currencyKey);
    }
</source>
</class>

<class classid="42" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ExchangerWithFeeRecAlternatives.sol" startline="49" endline="51" pcid="560">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="220" endline="222" pcid="1788">
    function atomicMaxVolumePerBlock() external view returns (uint) {
        return getAtomicMaxVolumePerBlock();
    }
</source>
</class>

<class classid="43" nclones="3" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="129" endline="131" pcid="591">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="143" endline="145" pcid="818">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="66" endline="68" pcid="927">
    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {
        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));
    }
</source>
</class>

<class classid="44" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="149" endline="151" pcid="596">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/LiquidatorRewards.sol" startline="74" endline="76" pcid="929">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Synthetix.sol" startline="45" endline="47" pcid="1653">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="163" endline="165" pcid="823">
    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {
        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));
    }
</source>
</class>

<class classid="45" nclones="4" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="173" endline="175" pcid="602">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="45" endline="47" pcid="1758">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Issuer.sol" startline="205" endline="207" pcid="829">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
<source file="systems/source-code/Liquidator.sol" startline="74" endline="76" pcid="903">
    function issuanceRatio() external view returns (uint) {
        return getIssuanceRatio();
    }
</source>
</class>

<class classid="46" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="177" endline="179" pcid="603">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="53" endline="55" pcid="1759">
    function feePeriodDuration() external view returns (uint) {
        return getFeePeriodDuration();
    }
</source>
</class>

<class classid="47" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FeePool.sol" startline="181" endline="183" pcid="604">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="58" endline="60" pcid="1760">
    function targetThreshold() external view returns (uint) {
        return getTargetThreshold();
    }
</source>
</class>

<class classid="48" nclones="2" nlines="10" similarity="77">
<source file="systems/source-code/FuturesMarketBase.sol" startline="194" endline="203" pcid="673">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_FUTURESMARKETSETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="148" endline="157" pcid="1358">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = PerpsV2SettingsMixin.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](5);
        newAddresses[0] = CONTRACT_EXCHANGER;
        newAddresses[1] = CONTRACT_CIRCUIT_BREAKER;
        newAddresses[2] = CONTRACT_FUTURESMARKETMANAGER;
        newAddresses[3] = CONTRACT_PERPSV2SETTINGS;
        newAddresses[4] = CONTRACT_SYSTEMSTATUS;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="49" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="205" endline="207" pcid="674">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="159" endline="161" pcid="1359">
    function _exchangeCircuitBreaker() internal view returns (IExchangeCircuitBreaker) {
        return IExchangeCircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER));
    }
</source>
</class>

<class classid="50" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="217" endline="219" pcid="677">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="171" endline="173" pcid="1362">
    function _manager() internal view returns (IFuturesMarketManagerInternal) {
        return IFuturesMarketManagerInternal(requireAndGetAddress(CONTRACT_FUTURESMARKETMANAGER));
    }
</source>
</class>

<class classid="51" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="232" endline="238" pcid="679">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="186" endline="192" pcid="1364">
    function _proportionalSkew(uint price) internal view returns (int) {
        // marketSize is in baseAsset units so we need to convert from USD units
        require(price > 0, "price can't be zero");
        uint skewScaleBaseAsset = _skewScaleUSD(marketKey).divideDecimal(price);
        require(skewScaleBaseAsset != 0, "skewScale is zero"); // don't divide by zero
        return int(marketSkew).divideDecimal(int(skewScaleBaseAsset));
    }
</source>
</class>

<class classid="52" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="240" endline="244" pcid="680">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="194" endline="198" pcid="1365">
    function _currentFundingRate(uint price) internal view returns (int) {
        int maxFundingRate = int(_maxFundingRate(marketKey));
        // Note the minus sign: funding flows in the opposite direction to the skew.
        return _min(_max(-_UNIT, -_proportionalSkew(price)), _UNIT).multiplyDecimal(maxFundingRate);
    }
</source>
</class>

<class classid="53" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="246" endline="251" pcid="681">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="200" endline="205" pcid="1366">
    function _unrecordedFunding(uint price) internal view returns (int funding) {
        int elapsed = int(block.timestamp.sub(fundingLastRecomputed));
        // The current funding rate, rescaled to a percentage per second.
        int currentFundingRatePerSecond = _currentFundingRate(price) / 1 days;
        return currentFundingRatePerSecond.multiplyDecimal(int(price)).mul(elapsed);
    }
</source>
</class>

<class classid="54" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="257" endline="259" pcid="682">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="211" endline="213" pcid="1367">
    function _nextFundingEntry(uint price) internal view returns (int funding) {
        return int(fundingSequence[_latestFundingIndex()]).add(_unrecordedFunding(price));
    }
</source>
</class>

<class classid="55" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="261" endline="264" pcid="683">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="215" endline="218" pcid="1368">
    function _netFundingPerUnit(uint startIndex, uint price) internal view returns (int) {
        // Compute the net difference between start and end indices.
        return _nextFundingEntry(price).sub(fundingSequence[startIndex]);
    }
</source>
</class>

<class classid="56" nclones="2" nlines="18" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="271" endline="305" pcid="684">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="225" endline="259" pcid="1369">
    function _orderSizeTooLarge(
        uint maxSize,
        int oldSize,
        int newSize
    ) internal view returns (bool) {
        // Allow users to reduce an order no matter the market conditions.
        if (_sameSide(oldSize, newSize) && _abs(newSize) <= _abs(oldSize)) {
            return false;
        }

        // Either the user is flipping sides, or they are increasing an order on the same side they're already on;
        // we check that the side of the market their order is on would not break the limit.
        int newSkew = int(marketSkew).sub(oldSize).add(newSize);
        int newMarketSize = int(marketSize).sub(_signedAbs(oldSize)).add(_signedAbs(newSize));

        int newSideSize;
        if (0 < newSize) {
            // long case: marketSize + skew
            //            = (|longSize| + |shortSize|) + (longSize + shortSize)
            //            = 2 * longSize
            newSideSize = newMarketSize.add(newSkew);
        } else {
            // short case: marketSize - skew
            //            = (|longSize| + |shortSize|) - (longSize + shortSize)
            //            = 2 * -shortSize
            newSideSize = newMarketSize.sub(newSkew);
        }

        // newSideSize still includes an extra factor of 2 here, so we will divide by 2 in the actual condition
        if (maxSize < _abs(newSideSize.div(2))) {
            return true;
        }

        return false;
    }
</source>
</class>

<class classid="57" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="307" endline="309" pcid="685">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="261" endline="263" pcid="1370">
    function _notionalValue(int positionSize, uint price) internal pure returns (int value) {
        return positionSize.multiplyDecimal(int(price));
    }
</source>
</class>

<class classid="58" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="311" endline="314" pcid="686">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="265" endline="268" pcid="1371">
    function _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {
        int priceShift = int(price).sub(int(position.lastPrice));
        return int(position.size).multiplyDecimal(priceShift);
    }
</source>
</class>

<class classid="59" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="316" endline="323" pcid="687">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="270" endline="277" pcid="1372">
    function _accruedFunding(Position memory position, uint price) internal view returns (int funding) {
        uint lastModifiedIndex = position.lastFundingIndex;
        if (lastModifiedIndex == 0) {
            return 0; // The position does not exist -- no funding.
        }
        int net = _netFundingPerUnit(lastModifiedIndex, price);
        return int(position.size).multiplyDecimal(net);
    }
</source>
</class>

<class classid="60" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="328" endline="331" pcid="688">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="282" endline="285" pcid="1373">
    function _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {
        int funding = _accruedFunding(position, price);
        return int(position.margin).add(_profitLoss(position, price)).add(funding);
    }
</source>
</class>

<class classid="61" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="339" endline="358" pcid="689">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="293" endline="312" pcid="1374">
    function _recomputeMarginWithDelta(
        Position memory position,
        uint price,
        int marginDelta
    ) internal view returns (uint margin, Status statusCode) {
        int newMargin = _marginPlusProfitFunding(position, price).add(marginDelta);
        if (newMargin < 0) {
            return (0, Status.InsufficientMargin);
        }

        uint uMargin = uint(newMargin);
        int positionSize = int(position.size);
        // minimum margin beyond which position can be liquidated
        uint lMargin = _liquidationMargin(positionSize, price);
        if (positionSize != 0 && uMargin <= lMargin) {
            return (uMargin, Status.CanLiquidate);
        }

        return (uMargin, Status.Ok);
    }
</source>
</class>

<class classid="62" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="360" endline="365" pcid="690">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="314" endline="319" pcid="1375">
    function _remainingMargin(Position memory position, uint price) internal view returns (uint) {
        int remaining = _marginPlusProfitFunding(position, price);

        // If the margin went past zero, the position should have been liquidated - return zero remaining margin.
        return uint(_max(0, remaining));
    }
</source>
</class>

<class classid="63" nclones="2" nlines="17" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="367" endline="390" pcid="691">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="321" endline="344" pcid="1376">
    function _accessibleMargin(Position memory position, uint price) internal view returns (uint) {
        // Ugly solution to rounding safety: leave up to an extra tenth of a cent in the account/leverage
        // This should guarantee that the value returned here can always been withdrawn, but there may be
        // a little extra actually-accessible value left over, depending on the position size and margin.
        uint milli = uint(_UNIT / 1000);
        int maxLeverage = int(_maxLeverage(marketKey).sub(milli));
        uint inaccessible = _abs(_notionalValue(position.size, price).divideDecimal(maxLeverage));

        // If the user has a position open, we'll enforce a min initial margin requirement.
        if (0 < inaccessible) {
            uint minInitialMargin = _minInitialMargin();
            if (inaccessible < minInitialMargin) {
                inaccessible = minInitialMargin;
            }
            inaccessible = inaccessible.add(milli);
        }

        uint remaining = _remainingMargin(position, price);
        if (remaining <= inaccessible) {
            return 0;
        }

        return remaining.sub(inaccessible);
    }
</source>
</class>

<class classid="64" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="400" endline="406" pcid="692">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="354" endline="360" pcid="1377">
    function _liquidationFee(int positionSize, uint price) internal view returns (uint lFee) {
        // size * price * fee-ratio
        uint proportionalFee = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationFeeRatio());
        uint minFee = _minKeeperFee();
        // max(proportionalFee, minFee) - to prevent not incentivising liquidations enough
        return proportionalFee > minFee ? proportionalFee : minFee; // not using _max() helper because it's for signed ints
    }
</source>
</class>

<class classid="65" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="418" endline="421" pcid="693">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="372" endline="375" pcid="1378">
    function _liquidationMargin(int positionSize, uint price) internal view returns (uint lMargin) {
        uint liquidationBuffer = _abs(positionSize).multiplyDecimal(price).multiplyDecimal(_liquidationBufferRatio());
        return liquidationBuffer.add(_liquidationFee(positionSize, price));
    }
</source>
</class>

<class classid="66" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="423" endline="430" pcid="694">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="377" endline="384" pcid="1379">
    function _canLiquidate(Position memory position, uint price) internal view returns (bool) {
        // No liquidating empty positions.
        if (position.size == 0) {
            return false;
        }

        return _remainingMargin(position, price) <= _liquidationMargin(int(position.size), price);
    }
</source>
</class>

<class classid="67" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="432" endline="443" pcid="695">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="386" endline="397" pcid="1380">
    function _currentLeverage(
        Position memory position,
        uint price,
        uint remainingMargin_
    ) internal pure returns (int leverage) {
        // No position is open, or it is ready to be liquidated; leverage goes to nil
        if (remainingMargin_ == 0) {
            return 0;
        }

        return _notionalValue(position.size, price).divideDecimal(int(remainingMargin_));
    }
</source>
</class>

<class classid="68" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="462" endline="464" pcid="697">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="411" endline="413" pcid="1382">
    function _dynamicFeeRate() internal view returns (uint feeRate, bool tooVolatile) {
        return _exchanger().dynamicFeeRateForExchange(sUSD, baseAsset);
    }
</source>
</class>

<class classid="69" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="466" endline="468" pcid="698">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="415" endline="417" pcid="1383">
    function _latestFundingIndex() internal view returns (uint) {
        return fundingSequence.length.sub(1); // at least one element is pushed in constructor
    }
</source>
</class>

<class classid="70" nclones="2" nlines="37" similarity="96">
<source file="systems/source-code/FuturesMarketBase.sol" startline="470" endline="563" pcid="699">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxMarketValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="419" endline="512" pcid="1384">
    function _postTradeDetails(Position memory oldPos, TradeParams memory params)
        internal
        view
        returns (
            Position memory newPosition,
            uint fee,
            Status tradeStatus
        )
    {
        // Reverts if the user is trying to submit a size-zero order.
        if (params.sizeDelta == 0) {
            return (oldPos, 0, Status.NilOrder);
        }

        // The order is not submitted if the user's existing position needs to be liquidated.
        if (_canLiquidate(oldPos, params.price)) {
            return (oldPos, 0, Status.CanLiquidate);
        }

        // get the dynamic fee rate SIP-184
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        if (tooVolatile) {
            return (oldPos, 0, Status.PriceTooVolatile);
        }

        // calculate the total fee for exchange
        fee = _orderFee(params, dynamicFeeRate);

        // Deduct the fee.
        // It is an error if the realised margin minus the fee is negative or subject to liquidation.
        (uint newMargin, Status status) = _recomputeMarginWithDelta(oldPos, params.price, -int(fee));
        if (_isError(status)) {
            return (oldPos, 0, status);
        }

        // construct new position
        Position memory newPos =
            Position({
                id: oldPos.id,
                lastFundingIndex: uint64(_latestFundingIndex()),
                margin: uint128(newMargin),
                lastPrice: uint128(params.price),
                size: int128(int(oldPos.size).add(params.sizeDelta))
            });

        // always allow to decrease a position, otherwise a margin of minInitialMargin can never
        // decrease a position as the price goes against them.
        // we also add the paid out fee for the minInitialMargin because otherwise minInitialMargin
        // is never the actual minMargin, because the first trade will always deduct
        // a fee (so the margin that otherwise would need to be transferred would have to include the future
        // fee as well, making the UX and definition of min-margin confusing).
        bool positionDecreasing = _sameSide(oldPos.size, newPos.size) && _abs(newPos.size) < _abs(oldPos.size);
        if (!positionDecreasing) {
            // minMargin + fee <= margin is equivalent to minMargin <= margin - fee
            // except that we get a nicer error message if fee > margin, rather than arithmetic overflow.
            if (uint(newPos.margin).add(fee) < _minInitialMargin()) {
                return (oldPos, 0, Status.InsufficientMargin);
            }
        }

        // check that new position margin is above liquidation margin
        // (above, in _recomputeMarginWithDelta() we checked the old position, here we check the new one)
        // Liquidation margin is considered without a fee, because it wouldn't make sense to allow
        // a trade that will make the position liquidatable.
        if (newMargin <= _liquidationMargin(newPos.size, params.price)) {
            return (newPos, 0, Status.CanLiquidate);
        }

        // Check that the maximum leverage is not exceeded when considering new margin including the paid fee.
        // The paid fee is considered for the benefit of UX of allowed max leverage, otherwise, the actual
        // max leverage is always below the max leverage parameter since the fee paid for a trade reduces the margin.
        // We'll allow a little extra headroom for rounding errors.
        {
            // stack too deep
            int leverage = int(newPos.size).multiplyDecimal(int(params.price)).divideDecimal(int(newMargin.add(fee)));
            if (_maxLeverage(marketKey).add(uint(_UNIT) / 100) < _abs(leverage)) {
                return (oldPos, 0, Status.MaxLeverageExceeded);
            }
        }

        // Check that the order isn't too large for the market.
        // Allow a bit of extra value in case of rounding errors.
        if (
            _orderSizeTooLarge(
                uint(int(_maxSingleSideValueUSD(marketKey).add(100 * uint(_UNIT))).divideDecimal(int(params.price))),
                oldPos.size,
                newPos.size
            )
        ) {
            return (oldPos, 0, Status.MaxMarketSizeExceeded);
        }

        return (newPos, fee, Status.Ok);
    }
</source>
</class>

<class classid="71" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="570" endline="572" pcid="700">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="519" endline="521" pcid="1385">
    function _signedAbs(int x) internal pure returns (int) {
        return x < 0 ? -x : x;
    }
</source>
</class>

<class classid="72" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="577" endline="579" pcid="701">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="526" endline="528" pcid="1386">
    function _abs(int x) internal pure returns (uint) {
        return uint(_signedAbs(x));
    }
</source>
</class>

<class classid="73" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="581" endline="583" pcid="702">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="530" endline="532" pcid="1387">
    function _max(int x, int y) internal pure returns (int) {
        return x < y ? y : x;
    }
</source>
</class>

<class classid="74" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="585" endline="587" pcid="703">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="534" endline="536" pcid="1388">
    function _min(int x, int y) internal pure returns (int) {
        return x < y ? x : y;
    }
</source>
</class>

<class classid="75" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="591" endline="593" pcid="704">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="540" endline="542" pcid="1389">
    function _sameSide(int a, int b) internal pure returns (bool) {
        return (a >= 0) == (b >= 0);
    }
</source>
</class>

<class classid="76" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="598" endline="600" pcid="705">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="547" endline="549" pcid="1390">
    function _isError(Status status) internal pure returns (bool) {
        return status != Status.Ok;
    }
</source>
</class>

<class classid="77" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="605" endline="609" pcid="706">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="554" endline="558" pcid="1391">
    function _revertIfError(bool isError, Status status) internal view {
        if (isError) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="78" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="614" endline="618" pcid="707">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="563" endline="567" pcid="1392">
    function _revertIfError(Status status) internal view {
        if (_isError(status)) {
            revert(_errorMessages[uint8(status)]);
        }
    }
</source>
</class>

<class classid="79" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/FuturesMarketBase.sol" startline="624" endline="629" pcid="708">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        // Ensure we catch uninitialised rates or suspended state / synth
        invalid = invalid || price == 0 || _systemStatus().synthSuspended(baseAsset);
        return (price, invalid);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="573" endline="576" pcid="1393">
    function assetPrice() public view returns (uint price, bool invalid) {
        (price, invalid) = _exchangeCircuitBreaker().rateWithInvalid(baseAsset);
        return (price, invalid);
    }
</source>
</class>

<class classid="80" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="658" endline="667" pcid="710">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="622" endline="631" pcid="1396">
    function _recomputeFunding(uint price) internal returns (uint lastIndex) {
        uint sequenceLengthBefore = fundingSequence.length;

        int funding = _nextFundingEntry(price);
        fundingSequence.push(int128(funding));
        fundingLastRecomputed = uint32(block.timestamp);
        emit FundingRecomputed(funding, sequenceLengthBefore, fundingLastRecomputed);

        return sequenceLengthBefore;
    }
</source>
</class>

<class classid="81" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="676" endline="689" pcid="711">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method is the only mutative method that uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="640" endline="653" pcid="1397">
    function recomputeFunding() external returns (uint lastIndex) {
        // only FuturesMarketSettings is allowed to use this method
        _revertIfError(msg.sender != _settings(), Status.NotPermitted);
        // This method uses the view _assetPrice()
        // and not the mutative _assetPriceRequireSystemChecks() that reverts on system flags.
        // This is because this method is used by system settings when changing funding related
        // parameters, so needs to function even when system / market is paused. E.g. to facilitate
        // market migration.
        (uint price, bool invalid) = assetPrice();
        // A check for a valid price is still in place, to ensure that a system settings action
        // doesn't take place when the price is invalid (e.g. some oracle issue).
        require(!invalid, "Invalid price");
        return _recomputeFunding(price);
    }
</source>
</class>

<class classid="82" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="694" endline="724" pcid="712">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="658" endline="688" pcid="1398">
    function _positionDebtCorrection(Position memory position) internal view returns (int) {
        /**
        This method only returns the correction term for the debt calculation of the position, and not it's 
        debt. This is needed for keeping track of the _marketDebt() in an efficient manner to allow O(1) marketDebt
        calculation in _marketDebt().

        Explanation of the full market debt calculation from the SIP https://sips.synthetix.io/sips/sip-80/:

        The overall market debt is the sum of the remaining margin in all positions. The intuition is that
        the debt of a single position is the value withdrawn upon closing that position.

        single position remaining margin = initial-margin + profit-loss + accrued-funding =
            = initial-margin + q * (price - last-price) + q * funding-accrued-per-unit
            = initial-margin + q * price - q * last-price + q * (funding - initial-funding)

        Total debt = sum ( position remaining margins )
            = sum ( initial-margin + q * price - q * last-price + q * (funding - initial-funding) )
            = sum( q * price ) + sum( q * funding ) + sum( initial-margin - q * last-price - q * initial-funding )
            = skew * price + skew * funding + sum( initial-margin - q * ( last-price + initial-funding ) )
            = skew (price + funding) + sum( initial-margin - q * ( last-price + initial-funding ) )

        The last term: sum( initial-margin - q * ( last-price + initial-funding ) ) being the position debt correction
            that is tracked with each position change using this method. 
        
        The first term and the full debt calculation using current skew, price, and funding is calculated globally in _marketDebt().
         */
        return
            int(position.margin).sub(
                int(position.size).multiplyDecimal(int(position.lastPrice).add(fundingSequence[position.lastFundingIndex]))
            );
    }
</source>
</class>

<class classid="83" nclones="2" nlines="8" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="726" endline="736" pcid="713">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="690" endline="700" pcid="1399">
    function _marketDebt(uint price) internal view returns (uint) {
        // short circuit and also convenient during setup
        if (marketSkew == 0 && _entryDebtCorrection == 0) {
            // if these are 0, the resulting calculation is necessarily zero as well
            return 0;
        }
        // see comment explaining this calculation in _positionDebtCorrection()
        int priceWithFunding = int(price).add(_nextFundingEntry(price));
        int totalDebt = int(marketSkew).multiplyDecimal(priceWithFunding).add(_entryDebtCorrection);
        return uint(_max(totalDebt, 0));
    }
</source>
</class>

<class classid="84" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="741" endline="745" pcid="714">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="705" endline="709" pcid="1400">
    function _applyDebtCorrection(Position memory newPosition, Position memory oldPosition) internal {
        int newCorrection = _positionDebtCorrection(newPosition);
        int oldCorrection = _positionDebtCorrection(oldPosition);
        _entryDebtCorrection = int128(int(_entryDebtCorrection).add(newCorrection).sub(oldCorrection));
    }
</source>
</class>

<class classid="85" nclones="2" nlines="20" similarity="93">
<source file="systems/source-code/FuturesMarketBase.sol" startline="747" endline="779" pcid="715">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="711" endline="748" pcid="1401">
    function _transferMargin(
        int marginDelta,
        uint price,
        address sender
    ) internal {
        // Transfer no tokens if marginDelta is 0
        uint absDelta = _abs(marginDelta);
        if (marginDelta > 0) {
            // A positive margin delta corresponds to a deposit, which will be burnt from their
            // sUSD balance and credited to their margin account.

            // Ensure we handle reclamation when burning tokens.
            uint postReclamationAmount = _manager().burnSUSD(sender, absDelta);
            if (postReclamationAmount != absDelta) {
                // If balance was insufficient, the actual delta will be smaller
                marginDelta = int(postReclamationAmount);
            }
        } else if (marginDelta < 0) {
            // A negative margin delta corresponds to a withdrawal, which will be minted into
            // their sUSD balance, and debited from their margin account.
            _manager().issueSUSD(sender, absDelta);
        } else {
            // Zero delta is a no-op
            return;
        }

        Position storage position = positions[sender];

        // initialise id if not initialised and store update id=>account mapping
        _initPosition(sender, position);

        // add the margin
        _updatePositionMargin(position, price, marginDelta);

        emit MarginTransferred(sender, marginDelta);

        emit PositionModified(position.id, sender, position.margin, position.size, 0, price, _latestFundingIndex(), 0);
    }
</source>
</class>

<class classid="86" nclones="2" nlines="16" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="782" endline="820" pcid="716">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);
        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="761" endline="800" pcid="1403">
    function _updatePositionMargin(
        Position storage position,
        uint price,
        int marginDelta
    ) internal {
        Position memory oldPosition = position;
        // Determine new margin, ensuring that the result is positive.
        (uint margin, Status status) = _recomputeMarginWithDelta(oldPosition, price, marginDelta);
        _revertIfError(status);

        // Update the debt correction.
        int positionSize = position.size;
        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), uint128(margin), uint128(price), int128(positionSize)),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Update the account's position with the realised margin.
        position.margin = uint128(margin);

        // We only need to update their funding/PnL details if they actually have a position open
        if (positionSize != 0) {
            position.lastPrice = uint128(price);
            position.lastFundingIndex = uint64(fundingIndex);

            // The user can always decrease their margin if they have no position, or as long as:
            //     * they have sufficient margin to do so
            //     * the resulting margin would not be lower than the liquidation margin or min initial margin
            //     * the resulting leverage is lower than the maximum leverage
            if (marginDelta < 0) {
                _revertIfError(
                    (margin < _minInitialMargin()) ||
                        (margin <= _liquidationMargin(position.size, price)) ||
                        (_maxLeverage(marketKey) < _abs(_currentLeverage(position, price, margin))),
                    Status.InsufficientMargin
                );
            }
        }
    }
</source>
</class>

<class classid="87" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="838" endline="844" pcid="718">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="821" endline="827" pcid="1405">
    function withdrawAllMargin() external {
        address sender = msg.sender;
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        int marginDelta = -int(_accessibleMargin(positions[sender], price));
        _transferMargin(marginDelta, price, sender);
    }
</source>
</class>

<class classid="88" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="908" endline="910" pcid="720">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="878" endline="880" pcid="1407">
    function modifyPosition(int sizeDelta) external {
        _modifyPosition(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="89" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="916" endline="918" pcid="721">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="886" endline="888" pcid="1408">
    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _modifyPosition(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="90" nclones="2" nlines="5" similarity="75">
<source file="systems/source-code/FuturesMarketBase.sol" startline="920" endline="933" pcid="722">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="890" endline="897" pcid="1409">
    function _modifyPosition(int sizeDelta, bytes32 trackingCode) internal {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: trackingCode})
        );
    }
</source>
</class>

<class classid="91" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="938" endline="940" pcid="723">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="902" endline="904" pcid="1410">
    function closePosition() external {
        _closePosition(bytes32(0));
    }
</source>
</class>

<class classid="92" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="943" endline="945" pcid="724">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="907" endline="909" pcid="1411">
    function closePositionWithTracking(bytes32 trackingCode) external {
        _closePosition(trackingCode);
    }
</source>
</class>

<class classid="93" nclones="2" nlines="7" similarity="83">
<source file="systems/source-code/FuturesMarketBase.sol" startline="947" endline="962" pcid="725">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({
                sizeDelta: -size,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: trackingCode
            })
        );
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="911" endline="920" pcid="1412">
    function _closePosition(bytes32 trackingCode) internal {
        int size = positions[msg.sender].size;
        _revertIfError(size == 0, Status.NoPositionOpen);
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);
        _trade(
            msg.sender,
            TradeParams({sizeDelta: -size, price: price, baseFee: _baseFee(marketKey), trackingCode: trackingCode})
        );
    }
</source>
</class>

<class classid="94" nclones="2" nlines="19" similarity="82">
<source file="systems/source-code/FuturesMarketBase.sol" startline="964" endline="1000" pcid="726">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position itself.
        delete positions[account];

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee));
        }
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="922" endline="959" pcid="1413">
    function _liquidatePosition(
        address account,
        address liquidator,
        uint price
    ) internal {
        Position storage position = positions[account];

        // get remaining margin for sending any leftover buffer to fee pool
        uint remMargin = _remainingMargin(position, price);

        // Record updates to market size and debt.
        int positionSize = position.size;
        uint positionId = position.id;
        marketSkew = int128(int(marketSkew).sub(positionSize));
        marketSize = uint128(uint(marketSize).sub(_abs(positionSize)));

        uint fundingIndex = _latestFundingIndex();
        _applyDebtCorrection(
            Position(0, uint64(fundingIndex), 0, uint128(price), 0),
            Position(0, position.lastFundingIndex, position.margin, position.lastPrice, int128(positionSize))
        );

        // Close the position size and margin
        delete positions[account].size;
        delete positions[account].margin;

        // Issue the reward to the liquidator.
        uint liqFee = _liquidationFee(positionSize, price);
        _manager().issueSUSD(liquidator, liqFee);

        emit PositionModified(positionId, account, 0, 0, 0, price, fundingIndex, 0);
        emit PositionLiquidated(positionId, account, liquidator, positionSize, price, liqFee);

        // Send any positive margin buffer to the fee pool
        if (remMargin > liqFee) {
            _manager().payFee(remMargin.sub(liqFee), bytes32(0));
        }
    }
</source>
</class>

<class classid="95" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/FuturesMarketBase.sol" startline="1007" endline="1014" pcid="727">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
<source file="systems/source-code/PerpsV2MarketBase.sol" startline="966" endline="973" pcid="1414">
    function liquidatePosition(address account) external {
        uint price = _assetPriceRequireSystemChecks();
        _recomputeFunding(price);

        _revertIfError(!_canLiquidate(positions[account], price), Status.CannotLiquidate);

        _liquidatePosition(account, msg.sender, price);
    }
</source>
</class>

<class classid="96" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="26" endline="31" pcid="776">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = MixinFuturesMarketSettings.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="29" endline="34" pcid="1423">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        bytes32[] memory existingAddresses = PerpsV2SettingsMixin.resolverAddressesRequired();
        bytes32[] memory newAddresses = new bytes32[](1);
        newAddresses[0] = CONTRACT_FUTURES_MARKET_MANAGER;
        addresses = combineArrays(existingAddresses, newAddresses);
    }
</source>
</class>

<class classid="97" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="33" endline="35" pcid="777">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="36" endline="38" pcid="1424">
    function _futuresMarketManager() internal view returns (IFuturesMarketManager) {
        return IFuturesMarketManager(requireAndGetAddress(CONTRACT_FUTURES_MARKET_MANAGER));
    }
</source>
</class>

<class classid="98" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="70" endline="72" pcid="782">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="59" endline="61" pcid="1427">
    function nextPriceConfirmWindow(bytes32 _marketKey) public view returns (uint) {
        return _nextPriceConfirmWindow(_marketKey);
    }
</source>
</class>

<class classid="99" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="77" endline="79" pcid="783">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="66" endline="68" pcid="1428">
    function maxLeverage(bytes32 _marketKey) public view returns (uint) {
        return _maxLeverage(_marketKey);
    }
</source>
</class>

<class classid="100" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="91" endline="93" pcid="785">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="80" endline="82" pcid="1430">
    function maxFundingRate(bytes32 _marketKey) public view returns (uint) {
        return _maxFundingRate(_marketKey);
    }
</source>
</class>

<class classid="101" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="98" endline="100" pcid="786">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="87" endline="89" pcid="1431">
    function skewScaleUSD(bytes32 _marketKey) public view returns (uint) {
        return _skewScaleUSD(_marketKey);
    }
</source>
</class>

<class classid="102" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="132" endline="134" pcid="788">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="117" endline="119" pcid="1433">
    function minKeeperFee() external view returns (uint) {
        return _minKeeperFee();
    }
</source>
</class>

<class classid="103" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="140" endline="142" pcid="789">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="125" endline="127" pcid="1434">
    function liquidationFeeRatio() external view returns (uint) {
        return _liquidationFeeRatio();
    }
</source>
</class>

<class classid="104" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="147" endline="149" pcid="790">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="132" endline="134" pcid="1435">
    function liquidationBufferRatio() external view returns (uint) {
        return _liquidationBufferRatio();
    }
</source>
</class>

<class classid="105" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="155" endline="157" pcid="791">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="140" endline="142" pcid="1436">
    function minInitialMargin() external view returns (uint) {
        return _minInitialMargin();
    }
</source>
</class>

<class classid="106" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="163" endline="170" pcid="792">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="148" endline="155" pcid="1437">
    function _setParameter(
        bytes32 _marketKey,
        bytes32 key,
        uint value
    ) internal {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)), value);
        emit ParameterUpdated(_marketKey, key, value);
    }
</source>
</class>

<class classid="107" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="192" endline="194" pcid="797">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="167" endline="169" pcid="1440">
    function setNextPriceConfirmWindow(bytes32 _marketKey, uint _nextPriceConfirmWindow) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW, _nextPriceConfirmWindow);
    }
</source>
</class>

<class classid="108" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="196" endline="198" pcid="798">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="171" endline="173" pcid="1441">
    function setMaxLeverage(bytes32 _marketKey, uint _maxLeverage) public onlyOwner {
        _setParameter(_marketKey, PARAMETER_MAX_LEVERAGE, _maxLeverage);
    }
</source>
</class>

<class classid="109" nclones="2" nlines="6" similarity="75">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="207" endline="213" pcid="800">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IFuturesMarket market = IFuturesMarket(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="182" endline="188" pcid="1443">
    function _recomputeFunding(bytes32 _marketKey) internal {
        IPerpsV2Market market = IPerpsV2Market(_futuresMarketManager().marketForKey(_marketKey));
        if (market.marketSize() > 0) {
            // only recompute funding when market has positions, this check is important for initial setup
            market.recomputeFunding();
        }
    }
</source>
</class>

<class classid="110" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="215" endline="218" pcid="801">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="190" endline="193" pcid="1444">
    function setMaxFundingRate(bytes32 _marketKey, uint _maxFundingRate) public onlyOwner {
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MAX_FUNDING_RATE, _maxFundingRate);
    }
</source>
</class>

<class classid="111" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="220" endline="224" pcid="802">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="195" endline="199" pcid="1445">
    function setSkewScaleUSD(bytes32 _marketKey, uint _skewScaleUSD) public onlyOwner {
        require(_skewScaleUSD > 0, "cannot set skew scale 0");
        _recomputeFunding(_marketKey);
        _setParameter(_marketKey, PARAMETER_MIN_SKEW_SCALE, _skewScaleUSD);
    }
</source>
</class>

<class classid="112" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="250" endline="254" pcid="804">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="221" endline="225" pcid="1447">
    function setMinKeeperFee(uint _sUSD) external onlyOwner {
        require(_sUSD <= _minInitialMargin(), "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE, _sUSD);
        emit MinKeeperFeeUpdated(_sUSD);
    }
</source>
</class>

<class classid="113" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="256" endline="259" pcid="805">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="227" endline="230" pcid="1448">
    function setLiquidationFeeRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO, _ratio);
        emit LiquidationFeeRatioUpdated(_ratio);
    }
</source>
</class>

<class classid="114" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="261" endline="264" pcid="806">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="232" endline="235" pcid="1449">
    function setLiquidationBufferRatio(uint _ratio) external onlyOwner {
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO, _ratio);
        emit LiquidationBufferRatioUpdated(_ratio);
    }
</source>
</class>

<class classid="115" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/FuturesMarketSettings.sol" startline="266" endline="270" pcid="807">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
<source file="systems/source-code/PerpsV2Settings.sol" startline="237" endline="241" pcid="1450">
    function setMinInitialMargin(uint _minMargin) external onlyOwner {
        require(_minKeeperFee() <= _minMargin, "min margin < liquidation fee");
        _flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN, _minMargin);
        emit MinInitialMarginUpdated(_minMargin);
    }
</source>
</class>

<class classid="116" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Issuer.sol" startline="370" endline="372" pcid="843">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="152" endline="154" pcid="1775">
    function minimumStakeTime() external view returns (uint) {
        return getMinimumStakeTime();
    }
</source>
</class>

<class classid="117" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/LegacyOwned.sol" startline="16" endline="21" pcid="894">
    function acceptOwnership() external {
        require(msg.sender == nominatedOwner);
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
</source>
<source file="systems/source-code/Owned.sol" startline="19" endline="24" pcid="1341">
    function acceptOwnership() external {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
</source>
</class>

<class classid="118" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="22" endline="25" pcid="895">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
<source file="systems/source-code/State.sol" startline="23" endline="26" pcid="1618">
    function setAssociatedContract(address _associatedContract) external onlyOwner {
        associatedContract = _associatedContract;
        emit AssociatedContractUpdated(_associatedContract);
    }
</source>
</class>

<class classid="119" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="27" endline="33" pcid="896">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="25" endline="31" pcid="1973">
    function setAllowance(
        address tokenOwner,
        address spender,
        uint value
    ) external onlyAssociatedContract {
        allowance[tokenOwner][spender] = value;
    }
</source>
</class>

<class classid="120" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/LegacyTokenState.sol" startline="35" endline="37" pcid="897">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
<source file="systems/source-code/TokenState.sol" startline="39" endline="41" pcid="1974">
    function setBalanceOf(address account, uint value) external onlyAssociatedContract {
        balanceOf[account] = value;
    }
</source>
</class>

<class classid="121" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="78" endline="80" pcid="904">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="64" endline="66" pcid="1761">
    function liquidationDelay() external view returns (uint) {
        return getLiquidationDelay();
    }
</source>
</class>

<class classid="122" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="82" endline="84" pcid="905">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="71" endline="73" pcid="1762">
    function liquidationRatio() external view returns (uint) {
        return getLiquidationRatio();
    }
</source>
</class>

<class classid="123" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="86" endline="88" pcid="906">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="91" endline="93" pcid="1765">
    function liquidationEscrowDuration() external view returns (uint) {
        return getLiquidationEscrowDuration();
    }
</source>
</class>

<class classid="124" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="90" endline="92" pcid="907">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="77" endline="79" pcid="1763">
    function liquidationPenalty() external view returns (uint) {
        return getLiquidationPenalty();
    }
</source>
</class>

<class classid="125" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="94" endline="96" pcid="908">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="97" endline="99" pcid="1766">
    function selfLiquidationPenalty() external view returns (uint) {
        return getSelfLiquidationPenalty();
    }
</source>
</class>

<class classid="126" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="98" endline="100" pcid="909">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="109" endline="111" pcid="1768">
    function liquidateReward() external view returns (uint) {
        return getLiquidateReward();
    }
</source>
</class>

<class classid="127" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/Liquidator.sol" startline="102" endline="104" pcid="910">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
<source file="systems/source-code/SystemSettings.sol" startline="103" endline="105" pcid="1767">
    function flagReward() external view returns (uint) {
        return getFlagReward();
    }
</source>
</class>

<class classid="128" nclones="2" nlines="61" similarity="72">
<source file="systems/source-code/MigrationLib_Diphda.sol" startline="199" endline="322" pcid="936">
    function migrate2() external {
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUSD();
        // Ensure the sUSD synth can write to its TokenState;
        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);
        // Ensure the sUSD synth Proxy is correctly connected to the Synth;
        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sEUR();
        // Ensure the sEUR synth can write to its TokenState;
        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);
        // Ensure the sEUR synth Proxy is correctly connected to the Synth;
        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));
        // Ensure the ExchangeRates contract has the feed for sEUR;
        exchangerates_i.addAggregator("sEUR", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sJPY();
        // Ensure the sJPY synth can write to its TokenState;
        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);
        // Ensure the sJPY synth Proxy is correctly connected to the Synth;
        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));
        // Ensure the ExchangeRates contract has the feed for sJPY;
        exchangerates_i.addAggregator("sJPY", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAUD();
        // Ensure the sAUD synth can write to its TokenState;
        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);
        // Ensure the sAUD synth Proxy is correctly connected to the Synth;
        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));
        // Ensure the ExchangeRates contract has the feed for sAUD;
        exchangerates_i.addAggregator("sAUD", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sGBP();
        // Ensure the sGBP synth can write to its TokenState;
        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);
        // Ensure the sGBP synth Proxy is correctly connected to the Synth;
        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));
        // Ensure the ExchangeRates contract has the feed for sGBP;
        exchangerates_i.addAggregator("sGBP", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sCHF();
        // Ensure the sCHF synth can write to its TokenState;
        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);
        // Ensure the sCHF synth Proxy is correctly connected to the Synth;
        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));
        // Ensure the ExchangeRates contract has the feed for sCHF;
        exchangerates_i.addAggregator("sCHF", 0x449d117117838fFA61263B61dA6301AA2a88B13A);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sKRW();
        // Ensure the sKRW synth can write to its TokenState;
        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);
        // Ensure the sKRW synth Proxy is correctly connected to the Synth;
        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));
        // Ensure the ExchangeRates contract has the feed for sKRW;
        exchangerates_i.addAggregator("sKRW", 0x01435677FB11763550905594A16B645847C1d0F3);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sBTC();
        // Ensure the sBTC synth can write to its TokenState;
        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);
        // Ensure the sBTC synth Proxy is correctly connected to the Synth;
        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));
        // Ensure the ExchangeRates contract has the feed for sBTC;
        exchangerates_i.addAggregator("sBTC", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETH();
        // Ensure the sETH synth can write to its TokenState;
        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);
        // Ensure the sETH synth Proxy is correctly connected to the Synth;
        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));
        // Ensure the ExchangeRates contract has the feed for sETH;
        exchangerates_i.addAggregator("sETH", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sLINK();
        // Ensure the sLINK synth can write to its TokenState;
        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);
        // Ensure the sLINK synth Proxy is correctly connected to the Synth;
        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));
        // Ensure the ExchangeRates contract has the feed for sLINK;
        exchangerates_i.addAggregator("sLINK", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sADA();
        // Ensure the sADA synth can write to its TokenState;
        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);
        // Ensure the sADA synth Proxy is correctly connected to the Synth;
        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));
        // Ensure the ExchangeRates contract has the feed for sADA;
        exchangerates_i.addAggregator("sADA", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAAVE();
        // Ensure the sAAVE synth can write to its TokenState;
        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);
        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;
        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));
        // Ensure the ExchangeRates contract has the feed for sAAVE;
        exchangerates_i.addAggregator("sAAVE", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDOT();
        // Ensure the sDOT synth can write to its TokenState;
        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);
        // Ensure the sDOT synth Proxy is correctly connected to the Synth;
        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));
        // Ensure the ExchangeRates contract has the feed for sDOT;
        exchangerates_i.addAggregator("sDOT", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETHBTC();
        // Ensure the sETHBTC synth can write to its TokenState;
        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);
        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;
        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));
        // Ensure the ExchangeRates contract has the feed for sETHBTC;
        exchangerates_i.addAggregator("sETHBTC", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDEFI();
        // Ensure the sDEFI synth can write to its TokenState;
        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);
        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;
        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));
        // Ensure the ExchangeRates contract has the feed for sDEFI;
        exchangerates_i.addAggregator("sDEFI", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_96();
        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);
        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="232" endline="348" pcid="1128">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sUSD();
        // Ensure the sUSD synth can write to its TokenState;
        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);
        // Ensure the sUSD synth Proxy is correctly connected to the Synth;
        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sEUR();
        // Ensure the sEUR synth can write to its TokenState;
        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);
        // Ensure the sEUR synth Proxy is correctly connected to the Synth;
        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sJPY();
        // Ensure the sJPY synth can write to its TokenState;
        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);
        // Ensure the sJPY synth Proxy is correctly connected to the Synth;
        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAUD();
        // Ensure the sAUD synth can write to its TokenState;
        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);
        // Ensure the sAUD synth Proxy is correctly connected to the Synth;
        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sGBP();
        // Ensure the sGBP synth can write to its TokenState;
        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);
        // Ensure the sGBP synth Proxy is correctly connected to the Synth;
        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sCHF();
        // Ensure the sCHF synth can write to its TokenState;
        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);
        // Ensure the sCHF synth Proxy is correctly connected to the Synth;
        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sKRW();
        // Ensure the sKRW synth can write to its TokenState;
        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);
        // Ensure the sKRW synth Proxy is correctly connected to the Synth;
        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sBTC();
        // Ensure the sBTC synth can write to its TokenState;
        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);
        // Ensure the sBTC synth Proxy is correctly connected to the Synth;
        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETH();
        // Ensure the sETH synth can write to its TokenState;
        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);
        // Ensure the sETH synth Proxy is correctly connected to the Synth;
        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sLINK();
        // Ensure the sLINK synth can write to its TokenState;
        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);
        // Ensure the sLINK synth Proxy is correctly connected to the Synth;
        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sADA();
        // Ensure the sADA synth can write to its TokenState;
        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);
        // Ensure the sADA synth Proxy is correctly connected to the Synth;
        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sAAVE();
        // Ensure the sAAVE synth can write to its TokenState;
        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);
        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;
        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDOT();
        // Ensure the sDOT synth can write to its TokenState;
        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);
        // Ensure the sDOT synth Proxy is correctly connected to the Synth;
        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sETHBTC();
        // Ensure the sETHBTC synth can write to its TokenState;
        tokenstatesethbtc_i.setAssociatedContract(new_SynthsETHBTC_contract);
        // Ensure the sETHBTC synth Proxy is correctly connected to the Synth;
        proxysethbtc_i.setTarget(Proxyable(new_SynthsETHBTC_contract));
        // Ensure the new synth has the totalSupply from the previous one;
        copyTotalSupplyFrom_sDEFI();
        // Ensure the sDEFI synth can write to its TokenState;
        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);
        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;
        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_70();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="129" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="43" endline="49" pcid="967">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="43" endline="49" pcid="975">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](4);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
        contracts[3] = address(systemsettings_i);
    }
</source>
</class>

<class classid="130" nclones="5" nlines="10" similarity="72">
<source file="systems/source-code/Migration_Algol.sol" startline="51" endline="71" pcid="968">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Set the penalty amount of SNX from a liquidated account;
        systemsettings_i.setSnxLiquidationPenalty(300000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="55" endline="79" pcid="1042">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Ensure the CollateralManager has all Collateral contracts added;
        collateralmanager_addCollaterals_8();
        // Ensure the CollateralShort contract has all associated synths added;
        collateralshort_addSynths_9();
        // Ensure the CollateralShort contract has its issue fee rate set;
        collateralshort_i.setIssueFeeRate(4000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="45" endline="68" pcid="1099">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="45" endline="68" pcid="1091">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_5();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="51" endline="73" pcid="976">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_6();
        // Set the penalty amount of SNX from a liquidated account;
        systemsettings_i.setSnxLiquidationPenalty(300000000000000000);
        // Set the penalty amount of Collateral from a liquidated account;
        systemsettings_i.setLiquidationPenalty(100000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="131" nclones="22" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="73" endline="78" pcid="969">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="337" endline="342" pcid="1027">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="122" endline="127" pcid="995">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="177" endline="182" pcid="1060">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="70" endline="75" pcid="1123">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="118" endline="123" pcid="1004">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="70" endline="75" pcid="1079">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="118" endline="123" pcid="1012">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="75" endline="80" pcid="977">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="70" endline="75" pcid="1092">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="93" endline="98" pcid="1037">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="81" endline="86" pcid="1043">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="274" endline="279" pcid="1152">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="143" endline="148" pcid="1053">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="211" endline="216" pcid="1068">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="70" endline="75" pcid="1100">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="167" endline="172" pcid="1108">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="142" endline="147" pcid="985">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="76" endline="81" pcid="1117">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="394" endline="399" pcid="1021">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="350" endline="355" pcid="1129">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="68" endline="73" pcid="1086">
    function acceptAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            Owned(contracts[i]).acceptOwnership();
        }
    }
</source>
</class>

<class classid="132" nclones="22" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="80" endline="85" pcid="970">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="129" endline="134" pcid="996">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirach.sol" startline="184" endline="189" pcid="1061">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_NunkiOptimism.sol" startline="174" endline="179" pcid="1109">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Saiph.sol" startline="357" endline="362" pcid="1130">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Alpheratz.sol" startline="125" endline="130" pcid="1005">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_KochabOptimism.sol" startline="88" endline="93" pcid="1044">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Hamal.sol" startline="100" endline="105" pcid="1038">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mirzam.sol" startline="77" endline="82" pcid="1080">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="77" endline="82" pcid="1124">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_DiphdaOptimism.sol" startline="344" endline="349" pcid="1028">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Alphard.sol" startline="149" endline="154" pcid="986">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="83" endline="88" pcid="1118">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="75" endline="80" pcid="1087">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Diphda.sol" startline="401" endline="406" pcid="1022">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="82" endline="87" pcid="978">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_Mizar.sol" startline="77" endline="82" pcid="1093">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MenkentOptimism.sol" startline="150" endline="155" pcid="1054">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="77" endline="82" pcid="1101">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_MirachOptimism.sol" startline="218" endline="223" pcid="1069">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="125" endline="130" pcid="1013">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
<source file="systems/source-code/Migration_SaiphOptimism.sol" startline="281" endline="286" pcid="1153">
    function nominateAll() internal {
        address[] memory contracts = contractsRequiringOwnership();
        for (uint i = 0; i < contracts.length; i++) {
            returnOwnership(contracts[i]);
        }
    }
</source>
</class>

<class classid="133" nclones="2" nlines="9" similarity="100">
<source file="systems/source-code/Migration_Algol.sol" startline="87" endline="98" pcid="971">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlgolOptimism.sol" startline="89" endline="100" pcid="979">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="134" nclones="2" nlines="21" similarity="72">
<source file="systems/source-code/Migration_Alphard.sol" startline="85" endline="140" pcid="984">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_SynthetixDebtShare_contract).CONTRACT_NAME() == "SynthetixDebtShare",
            "Invalid contract supplied for SynthetixDebtShare"
        );
        require(
            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == "FeePool",
            "Invalid contract supplied for FeePool"
        );
        require(
            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == "Synthetix",
            "Invalid contract supplied for Synthetix"
        );
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the ProxyFeePool contract has the correct FeePool target set;
        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));
        // Ensure the FeePool contract can write to its EternalStorage;
        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);
        // Ensure the FeePool contract can write to its State;
        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure that Synthetix can write to its State contract;
        synthetixstate_i.setAssociatedContract(new_Issuer_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the legacy RewardEscrow contract is connected to the FeePool contract;
        rewardescrow_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Import fee period from existing fee pool at index 0;
        importFeePeriod_0();
        // Import fee period from existing fee pool at index 1;
        importFeePeriod_1();
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_19();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="77" endline="120" pcid="994">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_SynthetixDebtShare_contract).CONTRACT_NAME() == "SynthetixDebtShare",
            "Invalid contract supplied for SynthetixDebtShare"
        );
        require(
            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == "FeePool",
            "Invalid contract supplied for FeePool"
        );
        require(
            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == "Issuer",
            "Invalid contract supplied for Issuer"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the ProxyFeePool contract has the correct FeePool target set;
        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));
        // Ensure the FeePool contract can write to its EternalStorage;
        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);
        // Ensure the FeePool contract can write to its State;
        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Import fee period from existing fee pool at index 0;
        importFeePeriod_0();
        // Import fee period from existing fee pool at index 1;
        importFeePeriod_1();
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_16();

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="135" nclones="2" nlines="13" similarity="100">
<source file="systems/source-code/Migration_Alphard.sol" startline="156" endline="171" pcid="987">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlphardOptimism.sol" startline="136" endline="151" pcid="997">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](4);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SynthetixDebtShare");
        addressresolver_importAddresses_names_0_0[1] = bytes32("FeePool");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](4);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SynthetixDebtShare_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_FeePool_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="136" nclones="2" nlines="19" similarity="73">
<source file="systems/source-code/Migration_Alpheratz.sol" startline="80" endline="116" pcid="1003">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_15();
        // Set the penalty for self liquidation of an account;
        systemsettings_i.setSelfLiquidationPenalty(200000000000000000);
        // Set the duration of how long liquidation rewards are escrowed for;
        systemsettings_i.setLiquidationEscrowDuration(31536000);
        // Set the reward amount for flagging an account for liquidation;
        systemsettings_i.setFlagReward(10000000000000000000);
        // Set the reward amount for peforming a liquidation;
        systemsettings_i.setLiquidateReward(20000000000000000000);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="76" endline="116" pcid="1011">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 3;
        addressresolver_rebuildCaches_3();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure Issuer contract can suspend issuance - see SIP-165;
        systemstatus_i.updateAccessControl("Issuance", new_Issuer_contract, true, false);
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);
        // Add synths to the Issuer contract - batch 1;
        issuer_addSynths_15();
        // Set the penalty for self liquidation of an account;
        systemsettings_i.setSelfLiquidationPenalty(200000000000000000);
        // Set the duration of how long liquidation rewards are escrowed for;
        systemsettings_i.setLiquidationEscrowDuration(31536000);
        // Set the reward amount for flagging an account for liquidation;
        systemsettings_i.setFlagReward(1000000000000000000);
        // Set the reward amount for peforming a liquidation;
        systemsettings_i.setLiquidateReward(2000000000000000000);
        // Set the amount for the liquidation c-ratio;
        systemsettings_i.setLiquidationRatio(666666666666666666);
        // Set the duration for the liquidation delay;
        systemsettings_i.setLiquidationDelay(43200);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="137" nclones="2" nlines="17" similarity="75">
<source file="systems/source-code/Migration_Alpheratz.sol" startline="132" endline="151" pcid="1006">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](6);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("LiquidatorRewards");
        addressresolver_importAddresses_names_0_0[2] = bytes32("Liquidator");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Exchanger");
        addressresolver_importAddresses_names_0_0[4] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[5] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](6);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_LiquidatorRewards_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_Liquidator_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);
        addressresolver_importAddresses_destinations_0_1[4] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[5] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_AlpheratzOptimism.sol" startline="132" endline="151" pcid="1014">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](6);
        addressresolver_importAddresses_names_0_0[0] = bytes32("SystemSettings");
        addressresolver_importAddresses_names_0_0[1] = bytes32("Liquidator");
        addressresolver_importAddresses_names_0_0[2] = bytes32("LiquidatorRewards");
        addressresolver_importAddresses_names_0_0[3] = bytes32("Exchanger");
        addressresolver_importAddresses_names_0_0[4] = bytes32("Synthetix");
        addressresolver_importAddresses_names_0_0[5] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](6);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);
        addressresolver_importAddresses_destinations_0_1[1] = address(new_Liquidator_contract);
        addressresolver_importAddresses_destinations_0_1[2] = address(new_LiquidatorRewards_contract);
        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);
        addressresolver_importAddresses_destinations_0_1[4] = address(new_Synthetix_contract);
        addressresolver_importAddresses_destinations_0_1[5] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="138" nclones="3" nlines="11" similarity="75">
<source file="systems/source-code/Migration_Hamal.sol" startline="60" endline="91" pcid="1036">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == "Synthetix",
            "Invalid contract supplied for Synthetix"
        );
        require(
            ISynthetixNamedContract(new_SupplySchedule_contract).CONTRACT_NAME() == "SupplySchedule",
            "Invalid contract supplied for SupplySchedule"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the SupplySchedule is connected to the SNX proxy for reading;
        supplyschedule_i.setSynthetixProxy(ISynthetix(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_Rasalhague.sol" startline="54" endline="74" pcid="1116">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;
        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="50" endline="68" pcid="1122">
    function migrate() external onlyOwner {
        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the SNX proxy has the correct Synthetix target set;
        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));
        // Ensure the Synthetix contract can write to its TokenState contract;
        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);
        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;
        rewardsdistribution_i.setAuthority(new_Synthetix_contract);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="139" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="38" endline="43" pcid="1077">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="38" endline="43" pcid="1084">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(exchangestate_i);
        contracts[2] = address(systemstatus_i);
    }
</source>
</class>

<class classid="140" nclones="2" nlines="10" similarity="77">
<source file="systems/source-code/Migration_Mirzam.sol" startline="45" endline="68" pcid="1078">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == "ExchangerWithFeeRecAlternatives",
            "Invalid contract supplied for Exchanger"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;
        addressresolver_rebuildCaches_2();
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure the Exchanger contract can suspend synths - see SIP-65;
        systemstatus_i.updateAccessControl("Synth", new_Exchanger_contract, true, false);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="45" endline="66" pcid="1085">
    function migrate() external onlyOwner {
        require(
            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == "Exchanger",
            "Invalid contract supplied for Exchanger"
        );

        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes
        acceptAll();

        // MIGRATION
        // Import all new contracts into the address resolver;
        addressresolver_importAddresses_0();
        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;
        addressresolver_rebuildCaches_1();
        // Ensure the Exchanger contract can write to its State;
        exchangestate_i.setAssociatedContract(new_Exchanger_contract);
        // Ensure the Exchanger contract can suspend synths - see SIP-65;
        systemstatus_i.updateAccessControl("Synth", new_Exchanger_contract, true, false);

        // NOMINATE OWNERSHIP back to owner for aforementioned contracts
        nominateAll();
    }
</source>
</class>

<class classid="141" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mirzam.sol" startline="84" endline="93" pcid="1081">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MirzamOptimism.sol" startline="82" endline="91" pcid="1088">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Exchanger");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Exchanger_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="142" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="38" endline="43" pcid="1090">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="38" endline="43" pcid="1098">
    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {
        contracts = new address[](3);
        contracts[0] = address(addressresolver_i);
        contracts[1] = address(systemstatus_i);
        contracts[2] = address(issuer_i);
    }
</source>
</class>

<class classid="143" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Mizar.sol" startline="84" endline="93" pcid="1094">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_MizarOptimism.sol" startline="84" endline="93" pcid="1102">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Issuer");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="144" nclones="2" nlines="7" similarity="100">
<source file="systems/source-code/Migration_Rasalhague.sol" startline="90" endline="99" pcid="1119">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
<source file="systems/source-code/Migration_RasalhagueOptimism.sol" startline="84" endline="93" pcid="1125">
    function addressresolver_importAddresses_0() internal {
        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](1);
        addressresolver_importAddresses_names_0_0[0] = bytes32("Synthetix");
        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](1);
        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);
        addressresolver_i.importAddresses(
            addressresolver_importAddresses_names_0_0,
            addressresolver_importAddresses_destinations_0_1
        );
    }
</source>
</class>

<class classid="145" nclones="3" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="46" endline="49" pcid="1178">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="44" endline="47" pcid="1451">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
<source file="systems/source-code/MixinSystemSettings.sol" startline="74" endline="77" pcid="1223">
    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {
        addresses = new bytes32[](1);
        addresses[0] = CONTRACT_FLEXIBLESTORAGE;
    }
</source>
</class>

<class classid="146" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="51" endline="53" pcid="1179">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="49" endline="51" pcid="1452">
    function _flexibleStorage() internal view returns (IFlexibleStorage) {
        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));
    }
</source>
</class>

<class classid="147" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="57" endline="59" pcid="1180">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="55" endline="57" pcid="1453">
    function _parameter(bytes32 _marketKey, bytes32 key) internal view returns (uint value) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, keccak256(abi.encodePacked(_marketKey, key)));
    }
</source>
</class>

<class classid="148" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="77" endline="79" pcid="1185">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="67" endline="69" pcid="1456">
    function _nextPriceConfirmWindow(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_NEXT_PRICE_CONFIRM_WINDOW);
    }
</source>
</class>

<class classid="149" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="81" endline="83" pcid="1186">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="71" endline="73" pcid="1457">
    function _maxLeverage(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_LEVERAGE);
    }
</source>
</class>

<class classid="150" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="89" endline="91" pcid="1188">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="79" endline="81" pcid="1459">
    function _skewScaleUSD(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MIN_SKEW_SCALE);
    }
</source>
</class>

<class classid="151" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="93" endline="95" pcid="1189">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="83" endline="85" pcid="1460">
    function _maxFundingRate(bytes32 _marketKey) internal view returns (uint) {
        return _parameter(_marketKey, PARAMETER_MAX_FUNDING_RATE);
    }
</source>
</class>

<class classid="152" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="97" endline="99" pcid="1190">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="87" endline="89" pcid="1461">
    function _minKeeperFee() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_KEEPER_FEE);
    }
</source>
</class>

<class classid="153" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="101" endline="103" pcid="1191">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="91" endline="93" pcid="1462">
    function _liquidationFeeRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_FEE_RATIO);
    }
</source>
</class>

<class classid="154" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="105" endline="107" pcid="1192">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="95" endline="97" pcid="1463">
    function _liquidationBufferRatio() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_BUFFER_RATIO);
    }
</source>
</class>

<class classid="155" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesMarketSettings.sol" startline="109" endline="111" pcid="1193">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
<source file="systems/source-code/PerpsV2SettingsMixin.sol" startline="99" endline="101" pcid="1464">
    function _minInitialMargin() internal view returns (uint) {
        return _flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MIN_INITIAL_MARGIN);
    }
</source>
</class>

<class classid="156" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="31" endline="33" pcid="1194">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="31" endline="33" pcid="1415">
    function submitNextPriceOrder(int sizeDelta) external {
        _submitNextPriceOrder(sizeDelta, bytes32(0));
    }
</source>
</class>

<class classid="157" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="37" endline="39" pcid="1195">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="37" endline="39" pcid="1416">
    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external {
        _submitNextPriceOrder(sizeDelta, trackingCode);
    }
</source>
</class>

<class classid="158" nclones="2" nlines="17" similarity="93">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="41" endline="91" pcid="1196">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="41" endline="90" pcid="1417">
    function _submitNextPriceOrder(int sizeDelta, bytes32 trackingCode) internal {
        // check that a previous order doesn't exist
        require(nextPriceOrders[msg.sender].sizeDelta == 0, "previous order exists");

        // storage position as it's going to be modified to deduct commitFee and keeperFee
        Position storage position = positions[msg.sender];

        // to prevent submitting bad orders in good faith and being charged commitDeposit for them
        // simulate the order with current price and market and check that the order doesn't revert
        uint price = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(price);
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                baseFee: _baseFeeNextPrice(marketKey),
                trackingCode: trackingCode
            });
        (, , Status status) = _postTradeDetails(position, params);
        _revertIfError(status);

        // deduct fees from margin
        uint commitDeposit = _nextPriceCommitDeposit(params);
        uint keeperDeposit = _minKeeperFee();
        _updatePositionMargin(position, price, -int(commitDeposit + keeperDeposit));
        // emit event for modifying the position (subtracting the fees from margin)
        emit PositionModified(position.id, msg.sender, position.margin, position.size, 0, price, fundingIndex, 0);

        // create order
        uint targetRoundId = _exchangeRates().getCurrentRoundId(baseAsset) + 1; // next round
        NextPriceOrder memory order =
            NextPriceOrder({
                sizeDelta: int128(sizeDelta),
                targetRoundId: uint128(targetRoundId),
                commitDeposit: uint128(commitDeposit),
                keeperDeposit: uint128(keeperDeposit),
                trackingCode: trackingCode
            });
        // emit event
        emit NextPriceOrderSubmitted(
            msg.sender,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
        // store order
        nextPriceOrders[msg.sender] = order;
    }
</source>
</class>

<class classid="159" nclones="2" nlines="19" similarity="93">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="105" endline="149" pcid="1197">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="104" endline="148" pcid="1418">
    function cancelNextPriceOrder(address account) external {
        // important!! order of the account, not the msg.sender
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);

        if (account == msg.sender) {
            // this is account owner
            // refund keeper fee to margin
            Position storage position = positions[account];
            uint price = _assetPriceRequireSystemChecks();
            uint fundingIndex = _recomputeFunding(price);
            _updatePositionMargin(position, price, int(order.keeperDeposit));

            // emit event for modifying the position (add the fee to margin)
            emit PositionModified(position.id, account, position.margin, position.size, 0, price, fundingIndex, 0);
        } else {
            // this is someone else (like a keeper)
            // cancellation by third party is only possible when execution cannot be attempted any longer
            // otherwise someone might try to grief an account by cancelling for the keeper fee
            require(_confirmationWindowOver(currentRoundId, order.targetRoundId), "cannot be cancelled by keeper yet");

            // send keeper fee to keeper
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        // pay the commitDeposit as fee to the FeePool
        _manager().payFee(order.commitDeposit, order.trackingCode);

        // remove stored order
        // important!! position of the account, not the msg.sender
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="160" nclones="2" nlines="23" similarity="95">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="164" endline="226" pcid="1198">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise future knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                takerFee: _takerFeeNextPrice(marketKey),
                makerFee: _makerFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="163" endline="224" pcid="1419">
    function executeNextPriceOrder(address account) external {
        // important!: order  of the account, not the sender!
        NextPriceOrder memory order = nextPriceOrders[account];
        // check that a previous order exists
        require(order.sizeDelta != 0, "no previous order");

        // check round-Id
        uint currentRoundId = _exchangeRates().getCurrentRoundId(baseAsset);
        require(order.targetRoundId <= currentRoundId, "target roundId not reached");

        // check order is not too old to execute
        // we cannot allow executing old orders because otherwise perps knowledge
        // can be used to trigger failures of orders that are more profitable
        // then the commitFee that was charged, or can be used to confirm
        // orders that are more profitable than known then (which makes this into a "cheap option").
        require(!_confirmationWindowOver(currentRoundId, order.targetRoundId), "order too old, use cancel");

        // handle the fees and refunds according to the mechanism rules
        uint toRefund = order.commitDeposit; // refund the commitment deposit

        // refund keeperFee to margin if it's the account holder
        if (msg.sender == account) {
            toRefund += order.keeperDeposit;
        } else {
            _manager().issueSUSD(msg.sender, order.keeperDeposit);
        }

        Position storage position = positions[account];
        uint currentPrice = _assetPriceRequireSystemChecks();
        uint fundingIndex = _recomputeFunding(currentPrice);
        // refund the commitFee (and possibly the keeperFee) to the margin before executing the order
        // if the order later fails this is reverted of course
        _updatePositionMargin(position, currentPrice, int(toRefund));
        // emit event for modifying the position (refunding fee/s)
        emit PositionModified(position.id, account, position.margin, position.size, 0, currentPrice, fundingIndex, 0);

        // the correct price for the past round
        (uint pastPrice, ) = _exchangeRates().rateAndTimestampAtRound(baseAsset, order.targetRoundId);
        // execute or revert
        _trade(
            account,
            TradeParams({
                sizeDelta: order.sizeDelta, // using the pastPrice from the target roundId
                price: pastPrice, // the funding is applied only from order confirmation time
                baseFee: _baseFeeNextPrice(marketKey),
                trackingCode: order.trackingCode
            })
        );

        // remove stored order
        delete nextPriceOrders[account];
        // emit event
        emit NextPriceOrderRemoved(
            account,
            currentRoundId,
            order.sizeDelta,
            order.targetRoundId,
            order.commitDeposit,
            order.keeperDeposit,
            order.trackingCode
        );
    }
</source>
</class>

<class classid="161" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="232" endline="234" pcid="1199">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="230" endline="232" pcid="1420">
    function _confirmationWindowOver(uint currentRoundId, uint targetRoundId) internal view returns (bool) {
        return (currentRoundId > targetRoundId) && (currentRoundId - targetRoundId > _nextPriceConfirmWindow(marketKey)); // don't underflow
    }
</source>
</class>

<class classid="162" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesNextPriceOrders.sol" startline="238" endline="240" pcid="1200">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
<source file="systems/source-code/PerpsV2NextPriceMixin.sol" startline="236" endline="238" pcid="1421">
    function _exchangeRates() internal view returns (IExchangeRates) {
        return IExchangeRates(_exchangeCircuitBreaker().exchangeRates());
    }
</source>
</class>

<class classid="163" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="14" endline="18" pcid="1202">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="14" endline="18" pcid="1465">
    function marketSizes() public view returns (uint long, uint short) {
        int size = int(marketSize);
        int skew = marketSkew;
        return (_abs(size.add(skew).div(2)), _abs(size.sub(skew).div(2)));
    }
</source>
</class>

<class classid="164" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="24" endline="27" pcid="1203">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="24" endline="27" pcid="1466">
    function marketDebt() external view returns (uint debt, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_marketDebt(price), isInvalid);
    }
</source>
</class>

<class classid="165" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="33" endline="36" pcid="1204">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="33" endline="36" pcid="1467">
    function currentFundingRate() external view returns (int) {
        (uint price, ) = assetPrice();
        return _currentFundingRate(price);
    }
</source>
</class>

<class classid="166" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="42" endline="45" pcid="1205">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="42" endline="45" pcid="1468">
    function unrecordedFunding() external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_unrecordedFunding(price), isInvalid);
    }
</source>
</class>

<class classid="167" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="50" endline="52" pcid="1206">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="50" endline="52" pcid="1469">
    function fundingSequenceLength() external view returns (uint) {
        return fundingSequence.length;
    }
</source>
</class>

<class classid="168" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="57" endline="60" pcid="1207">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="57" endline="60" pcid="1470">
    function notionalValue(address account) external view returns (int value, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_notionalValue(positions[account].size, price), isInvalid);
    }
</source>
</class>

<class classid="169" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="65" endline="68" pcid="1208">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="65" endline="68" pcid="1471">
    function profitLoss(address account) external view returns (int pnl, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_profitLoss(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="170" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="73" endline="76" pcid="1209">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="73" endline="76" pcid="1472">
    function accruedFunding(address account) external view returns (int funding, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accruedFunding(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="171" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="81" endline="84" pcid="1210">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="81" endline="84" pcid="1473">
    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_remainingMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="172" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="90" endline="93" pcid="1211">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="90" endline="93" pcid="1474">
    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        return (_accessibleMargin(positions[account], price), isInvalid);
    }
</source>
</class>

<class classid="173" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="130" endline="133" pcid="1214">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="121" endline="124" pcid="1476">
    function canLiquidate(address account) external view returns (bool) {
        (uint price, bool invalid) = assetPrice();
        return !invalid && _canLiquidate(positions[account], price);
    }
</source>
</class>

<class classid="174" nclones="2" nlines="6" similarity="80">
<source file="systems/source-code/MixinFuturesViews.sol" startline="143" endline="155" pcid="1215">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="134" endline="140" pcid="1477">
    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        (uint dynamicFeeRate, bool tooVolatile) = _dynamicFeeRate();
        TradeParams memory params =
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: bytes32(0)});
        return (_orderFee(params, dynamicFeeRate), isInvalid || tooVolatile);
    }
</source>
</class>

<class classid="175" nclones="2" nlines="11" similarity="88">
<source file="systems/source-code/MixinFuturesViews.sol" startline="160" endline="190" pcid="1216">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({
                sizeDelta: sizeDelta,
                price: price,
                takerFee: _takerFee(marketKey),
                makerFee: _makerFee(marketKey),
                trackingCode: bytes32(0)
            });
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="145" endline="169" pcid="1478">
    function postTradeDetails(int sizeDelta, address sender)
        external
        view
        returns (
            uint margin,
            int size,
            uint price,
            uint liqPrice,
            uint fee,
            Status status
        )
    {
        bool invalid;
        (price, invalid) = assetPrice();
        if (invalid) {
            return (0, 0, 0, 0, 0, Status.InvalidPrice);
        }

        TradeParams memory params =
            TradeParams({sizeDelta: sizeDelta, price: price, baseFee: _baseFee(marketKey), trackingCode: bytes32(0)});
        (Position memory newPosition, uint fee_, Status status_) = _postTradeDetails(positions[sender], params);

        liqPrice = _approxLiquidationPrice(newPosition, newPosition.lastPrice);
        return (newPosition.margin, newPosition.size, newPosition.lastPrice, liqPrice, fee_, status_);
    }
</source>
</class>

<class classid="176" nclones="2" nlines="10" similarity="100">
<source file="systems/source-code/MixinFuturesViews.sol" startline="193" endline="223" pcid="1217">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
<source file="systems/source-code/PerpsV2ViewsMixin.sol" startline="172" endline="202" pcid="1479">
    function _approxLiquidationPrice(Position memory position, uint currentPrice) internal view returns (uint) {
        int positionSize = int(position.size);

        // short circuit
        if (positionSize == 0) {
            return 0;
        }

        // price = lastPrice + (liquidationMargin - margin) / positionSize - netAccrued
        int fundingPerUnit = _netFundingPerUnit(position.lastFundingIndex, currentPrice);

        // minimum margin beyond which position can be liqudiated
        uint liqMargin = _liquidationMargin(positionSize, currentPrice);

        // A position can be liquidated whenever:
        //     remainingMargin <= liquidationMargin
        // Hence, expanding the definition of remainingMargin the exact price
        // at which a position can first be liquidated is:
        //     margin + profitLoss + funding =  liquidationMargin
        //     substitute with: profitLoss = (price - last-price) * positionSize
        //     and also with: funding = netFundingPerUnit * positionSize
        //     we get: margin + (price - last-price) * positionSize + netFundingPerUnit * positionSize =  liquidationMargin
        //     moving around: price  = lastPrice + (liquidationMargin - margin) / positionSize - netFundingPerUnit
        int result =
            int(position.lastPrice).add(int(liqMargin).sub(int(position.margin)).divideDecimal(positionSize)).sub(
                fundingPerUnit
            );

        // If the user has leverage less than 1, their liquidation price may actually be negative; return 0 instead.
        return uint(_max(0, result));
    }
</source>
</class>

<class classid="177" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/MockEtherWrapper.sol" startline="13" endline="15" pcid="1279">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
<source file="systems/source-code/MockWrapperFactory.sol" startline="13" endline="15" pcid="1319">
    function setTotalIssuedSynths(uint value) external {
        totalIssuedSynths = value;
    }
</source>
</class>

<class classid="178" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/OwnerRelayOnEthereum.sol" startline="24" endline="26" pcid="1343">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
<source file="systems/source-code/OwnerRelayOnOptimism.sol" startline="28" endline="30" pcid="1349">
    function _messenger() private view returns (iAbs_BaseCrossDomainMessenger) {
        return iAbs_BaseCrossDomainMessenger(requireAndGetAddress(CONTRACT_EXT_MESSENGER));
    }
</source>
</class>

<class classid="179" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="17" endline="19" pcid="1494">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="17" endline="19" pcid="1497">
    function transfer(address to, uint value) external optionalProxy returns (bool) {
        return _transferByProxy(messageSender, to, value);
    }
</source>
</class>

<class classid="180" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="21" endline="27" pcid="1495">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="21" endline="27" pcid="1498">
    function transferFrom(
        address from,
        address to,
        uint value
    ) external optionalProxy returns (bool) {
        return _transferFromByProxy(messageSender, from, to, value);
    }
</source>
</class>

<class classid="181" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/PublicEST.sol" startline="32" endline="34" pcid="1496">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
<source file="systems/source-code/PublicEST8Decimals.sol" startline="32" endline="34" pcid="1499">
    function somethingToBeProxied(uint256 inputA, bytes32 inputB) external {
        emit Received(messageSender, inputA, inputB);
    }
</source>
</class>

<class classid="182" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="60" endline="63" pcid="1515">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="46" endline="49" pcid="1716">
    function setSynthetix(ISynthetix _synthetix) external onlyOwner {
        synthetix = _synthetix;
        emit SynthetixUpdated(address(_synthetix));
    }
</source>
</class>

<class classid="183" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="98" endline="100" pcid="1520">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="71" endline="73" pcid="1719">
    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {
        return vestingSchedules[account][index];
    }
</source>
</class>

<class classid="184" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="105" endline="107" pcid="1521">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="78" endline="80" pcid="1720">
    function getVestingTime(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[TIME_INDEX];
    }
</source>
</class>

<class classid="185" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="112" endline="114" pcid="1522">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="85" endline="87" pcid="1721">
    function getVestingQuantity(address account, uint index) public view returns (uint) {
        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="186" nclones="2" nlines="9" similarity="83">
<source file="systems/source-code/RewardEscrow.sol" startline="119" endline="127" pcid="1523">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = _numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="92" endline="100" pcid="1722">
    function getNextVestingIndex(address account) public view returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
</source>
</class>

<class classid="187" nclones="2" nlines="7" similarity="80">
<source file="systems/source-code/RewardEscrow.sol" startline="132" endline="138" pcid="1524">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == _numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="105" endline="111" pcid="1723">
    function getNextVestingEntry(address account) public view returns (uint[2] memory) {
        uint index = getNextVestingIndex(account);
        if (index == numVestingEntries(account)) {
            return [uint(0), 0];
        }
        return getVestingScheduleEntry(account, index);
    }
</source>
</class>

<class classid="188" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="143" endline="145" pcid="1525">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="116" endline="118" pcid="1724">
    function getNextVestingTime(address account) external view returns (uint) {
        return getNextVestingEntry(account)[TIME_INDEX];
    }
</source>
</class>

<class classid="189" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/RewardEscrow.sol" startline="150" endline="152" pcid="1526">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="123" endline="125" pcid="1725">
    function getNextVestingQuantity(address account) external view returns (uint) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }
</source>
</class>

<class classid="190" nclones="2" nlines="22" similarity="76">
<source file="systems/source-code/RewardEscrow.sol" startline="224" endline="247" pcid="1530">
    function vest() external {
        uint numEntries = _numVestingEntries(msg.sender);
        uint total;
        for (uint i = 0; i < numEntries; i++) {
            uint time = getVestingTime(msg.sender, i);
            /* The list is sorted; when we reach the first future time, bail out. */
            if (time > now) {
                break;
            }
            uint qty = getVestingQuantity(msg.sender, i);
            if (qty > 0) {
                vestingSchedules[msg.sender][i] = [0, 0];
                total = total.add(qty);
            }
        }

        if (total != 0) {
            totalEscrowedBalance = totalEscrowedBalance.sub(total);
            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);
            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);
            IERC20(address(synthetix)).transfer(msg.sender, total);
            emit Vested(msg.sender, now, total);
        }
    }
</source>
<source file="systems/source-code/SynthetixEscrow.sol" startline="206" endline="228" pcid="1729">
    function vest() external {
        uint numEntries = numVestingEntries(msg.sender);
        uint total;
        for (uint i = 0; i < numEntries; i++) {
            uint time = getVestingTime(msg.sender, i);
            /* The list is sorted; when we reach the first future time, bail out. */
            if (time > now) {
                break;
            }
            uint qty = getVestingQuantity(msg.sender, i);
            if (qty > 0) {
                vestingSchedules[msg.sender][i] = [0, 0];
                total = total.add(qty);
            }
        }

        if (total != 0) {
            totalVestedBalance = totalVestedBalance.sub(total);
            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].sub(total);
            IERC20(address(synthetix)).transfer(msg.sender, total);
            emit Vested(msg.sender, now, total);
        }
    }
</source>
</class>

<class classid="191" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="65" endline="67" pcid="1575">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="49" endline="51" pcid="1603">
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }
</source>
</class>

<class classid="192" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="69" endline="71" pcid="1576">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="53" endline="55" pcid="1604">
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }
</source>
</class>

<class classid="193" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="73" endline="75" pcid="1577">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="57" endline="59" pcid="1605">
    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }
</source>
</class>

<class classid="194" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="77" endline="85" pcid="1578">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="61" endline="69" pcid="1606">
    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }
</source>
</class>

<class classid="195" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="87" endline="89" pcid="1579">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="71" endline="73" pcid="1607">
    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }
</source>
</class>

<class classid="196" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="91" endline="93" pcid="1580">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="75" endline="77" pcid="1608">
    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }
</source>
</class>

<class classid="197" nclones="2" nlines="15" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="125" endline="144" pcid="1584">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="113" endline="132" pcid="1613">
    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }
</source>
</class>

<class classid="198" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/ShortingRewards.sol" startline="146" endline="153" pcid="1585">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
<source file="systems/source-code/StakingRewards.sol" startline="141" endline="148" pcid="1615">
    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }
</source>
</class>

<class classid="199" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableAddressSet.sol" startline="26" endline="28" pcid="1935">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
<source file="systems/source-code/TestableBytes32Set.sol" startline="26" endline="28" pcid="1942">
    function size() public view returns (uint) {
        return set.elements.length;
    }
</source>
</class>

<class classid="200" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="12" endline="14" pcid="1948">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="12" endline="14" pcid="1958">
    function entryDebtCorrection() external view returns (int) {
        return _entryDebtCorrection;
    }
</source>
</class>

<class classid="201" nclones="2" nlines="4" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="16" endline="19" pcid="1949">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="16" endline="19" pcid="1959">
    function proportionalSkew() external view returns (int) {
        (uint price, ) = assetPrice();
        return _proportionalSkew(price);
    }
</source>
</class>

<class classid="202" nclones="2" nlines="3" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="21" endline="23" pcid="1950">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="21" endline="23" pcid="1960">
    function maxFundingRate() external view returns (uint) {
        return _maxFundingRate(marketKey);
    }
</source>
</class>

<class classid="203" nclones="2" nlines="9" similarity="87">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="28" endline="44" pcid="1951">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxMarketValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="28" endline="44" pcid="1961">
    function maxOrderSizes()
        external
        view
        returns (
            uint long,
            uint short,
            bool invalid
        )
    {
        uint price;
        (price, invalid) = assetPrice();
        int sizeLimit = int(_maxSingleSideValueUSD(marketKey)).divideDecimal(int(price));
        (uint longSize, uint shortSize) = marketSizes();
        long = uint(sizeLimit.sub(_min(int(longSize), sizeLimit)));
        short = uint(sizeLimit.sub(_min(int(shortSize), sizeLimit)));
        return (long, short, invalid);
    }
</source>
</class>

<class classid="204" nclones="2" nlines="5" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="52" endline="56" pcid="1952">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="52" endline="56" pcid="1962">
    function liquidationMargin(address account) external view returns (uint lMargin) {
        require(positions[account].size != 0, "0 size position"); // reverts because otherwise minKeeperFee is returned
        (uint price, ) = assetPrice();
        return _liquidationMargin(int(positions[account].size), price);
    }
</source>
</class>

<class classid="205" nclones="2" nlines="6" similarity="100">
<source file="systems/source-code/TestableFuturesMarket.sol" startline="61" endline="66" pcid="1953">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
<source file="systems/source-code/TestablePerpsV2Market.sol" startline="61" endline="66" pcid="1963">
    function currentLeverage(address account) external view returns (int leverage, bool invalid) {
        (uint price, bool isInvalid) = assetPrice();
        Position storage position = positions[account];
        uint remainingMargin_ = _remainingMargin(position, price);
        return (_currentLeverage(position, price, remainingMargin_), isInvalid);
    }
</source>
</class>

</clones>
