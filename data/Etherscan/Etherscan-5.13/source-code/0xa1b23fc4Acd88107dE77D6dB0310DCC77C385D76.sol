{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "shanghai",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/Structs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { DCSProduct, DCSVault } from \"./cega-strategies/dcs/DCSStructs.sol\";\nimport { FCNProduct, FCNVault } from \"./cega-strategies/fcn/FCNStructs.sol\";\nimport { IOracleEntry } from \"./oracle-entry/interfaces/IOracleEntry.sol\";\n\nuint32 constant DCS_STRATEGY_ID = 1;\nuint32 constant FCN_STRATEGY_ID = 2;\n\nstruct DepositQueue {\n    uint128 queuedDepositsTotalAmount;\n    uint128 processedIndex;\n    mapping(address => uint128) amounts;\n    address[] depositors;\n    mapping(address => bool) depositorExists;\n}\n\nstruct Withdrawer {\n    address account;\n    uint32 nextProductId;\n}\n\nstruct ProductMetadata {\n    string name;\n    string tradeWinnerNftImage;\n}\n\nstruct WithdrawalQueue {\n    uint128 queuedWithdrawalSharesAmount;\n    uint128 processedIndex;\n    mapping(address => mapping(uint32 => uint256)) amounts;\n    Withdrawer[] withdrawers;\n    mapping(address => bool) withdrawingWithProxy;\n}\n\nstruct CegaGlobalStorage {\n    // Global information\n    uint32 strategyIdCounter;\n    uint32 productIdCounter;\n    uint32[] strategyIds;\n    mapping(uint32 => uint32) strategyOfProduct;\n    mapping(uint32 => ProductMetadata) productMetadata;\n    mapping(address => Vault) vaults;\n    // DCS information\n    mapping(uint32 => DCSProduct) dcsProducts;\n    // Shared\n    mapping(uint32 => DepositQueue) depositQueues;\n    // DCS information\n    mapping(address => DCSVault) dcsVaults;\n    // Shared\n    mapping(address => WithdrawalQueue) withdrawalQueues;\n    // vaultAddress => (asset/s hash => timestamp => price)\n    mapping(address => mapping(bytes32 => mapping(uint40 => uint128))) oraclePriceOverride;\n    // this will be a bitmap that has all the configs for pausing\n    uint256 protocolPauseConfig;\n    // FCN information\n    mapping(uint32 => FCNProduct) fcnProducts;\n    mapping(address => FCNVault) fcnVaults;\n    mapping(address => bool) fcnBondAllowList;\n}\n\nstruct Vault {\n    uint128 totalAssets;\n    uint64 auctionWinnerTokenId;\n    uint16 yieldFeeBps;\n    uint16 managementFeeBps;\n    uint32 productId;\n    address auctionWinner;\n    uint40 tradeStartDate;\n    VaultStatus vaultStatus;\n    IOracleEntry.DataSource dataSource;\n    bool isInDispute;\n    bool isDefaulted;\n}\n\nenum OldVaultStatus {\n    DepositsClosed,\n    DepositsOpen,\n    NotTraded,\n    Traded,\n    TradeExpired,\n    FeesCollected,\n    WithdrawalQueueProcessed,\n    Zombie\n}\n\nenum VaultStatus {\n    DepositsClosed,\n    DepositsOpen,\n    PreAuction,\n    Auctioned,\n    Traded,\n    AwaitingSettlement,\n    Settled,\n    FeesCollected,\n    WithdrawalQueueProcessed,\n    Zombie\n}\n\nstruct MMNFTMetadata {\n    address vaultAddress;\n    uint40 tradeStartDate;\n    uint40 tradeEndDate;\n    uint16 aprBps;\n    uint128 notional;\n    uint128 initialSpotPrice;\n    uint128 strikePrice;\n}\n\nstruct VaultCreationParams {\n    string tokenName;\n    string tokenSymbol;\n    uint16 yieldFeeBps;\n    uint16 managementFeeBps;\n}\n"
    },
    "contracts/cega-strategies/common/interfaces/ICommonEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { VaultStatus, OldVaultStatus } from \"../../../Structs.sol\";\n\ninterface ICommonEvents {\n    event DepositQueued(\n        uint32 indexed productId,\n        address sender,\n        address receiver,\n        uint128 amount\n    );\n\n    event DepositRemoved(\n        uint32 indexed productId,\n        address depositor,\n        uint128 amount\n    );\n\n    event DepositProcessed(\n        address indexed vaultAddress,\n        address receiver,\n        uint128 amount\n    );\n\n    event WithdrawalQueued(\n        address indexed vaultAddress,\n        uint256 sharesAmount,\n        address owner,\n        uint32 nextProductId,\n        bool withProxy\n    );\n\n    event WithdrawalProcessed(\n        address indexed vaultAddress,\n        uint256 sharesAmount,\n        address owner,\n        uint32 nextProductId\n    );\n\n    event CommonVaultStatusUpdated(\n        address indexed vaultAddress,\n        VaultStatus vaultStatus\n    );\n\n    event VaultDefaultUpdated(address indexed vaultAddress, bool value);\n\n    event OraclePriceOverriden(\n        address indexed vaultAddress,\n        address indexed asset,\n        uint256 timestamp,\n        uint256 newPrice\n    );\n\n    event ManagementFeeUpdated(address indexed vaultAddress, uint16 value);\n\n    event YieldFeeUpdated(address indexed vaultAddress, uint16 value);\n\n    event ProductNameUpdated(uint32 indexed productId, string name);\n\n    event TradeWinnerNftImageUpdated(uint32 indexed productId, string imageUrl);\n\n    // Legacy event, left for compatibility\n\n    event VaultStatusUpdated(\n        address indexed vaultAddress,\n        OldVaultStatus vaultStatus\n    );\n}\n"
    },
    "contracts/cega-strategies/dcs/DCSStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nenum DCSOptionType {\n    BuyLow,\n    SellHigh\n}\n\nenum SettlementStatus {\n    NotAuctioned,\n    Auctioned,\n    InitialPremiumPaid,\n    AwaitingSettlement,\n    Settled,\n    Defaulted\n}\n\nstruct DCSProductCreationParams {\n    uint128 maxUnderlyingAmountLimit;\n    uint128 minDepositAmount;\n    uint128 minWithdrawalAmount;\n    address quoteAssetAddress;\n    address baseAssetAddress;\n    DCSOptionType dcsOptionType;\n    uint8 daysToStartLateFees;\n    uint8 daysToStartAuctionDefault;\n    uint8 daysToStartSettlementDefault;\n    uint16 lateFeeBps;\n    uint16 strikeBarrierBps;\n    uint40 tenorInSeconds;\n    uint8 disputePeriodInHours;\n    uint8 disputeGraceDelayInHours;\n    string name;\n    string tradeWinnerNftImage;\n}\n\nstruct DCSProduct {\n    uint128 maxUnderlyingAmountLimit;\n    uint128 minDepositAmount;\n    uint128 minWithdrawalAmount;\n    uint128 sumVaultUnderlyingAmounts; //revisit later\n    address quoteAssetAddress; // should be immutable\n    uint40 tenorInSeconds;\n    uint16 lateFeeBps;\n    uint8 daysToStartLateFees;\n    address baseAssetAddress; // should be immutable\n    uint16 strikeBarrierBps;\n    uint8 daysToStartAuctionDefault;\n    uint8 daysToStartSettlementDefault;\n    uint8 disputePeriodInHours;\n    DCSOptionType dcsOptionType;\n    bool isDepositQueueOpen;\n    address[] vaults;\n    uint8 disputeGraceDelayInHours;\n}\n\nstruct DCSVault {\n    uint128 initialSpotPrice;\n    uint128 strikePrice;\n    uint128 totalYield;\n    uint16 aprBps;\n    SettlementStatus settlementStatus; // DEPRECATED\n    bool isPayoffInDepositAsset;\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSBulkActionsEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { Withdrawer, VaultStatus } from \"../../../Structs.sol\";\nimport { DCSProductCreationParams, DCSProduct } from \"../DCSStructs.sol\";\nimport {\n    IOracleEntry\n} from \"../../../oracle-entry/interfaces/IOracleEntry.sol\";\n\ninterface IDCSBulkActionsEntry {\n    /**\n     * @dev Starts trading for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to start trading for.\n     */\n    function dcsBulkStartTrades(\n        address[] calldata vaultAddresses\n    ) external payable;\n\n    /**\n     * @dev Processes the deposit queues for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to process deposit queues for.\n     * @param maxProcessCount The maximum number of deposits to process for each vault.\n     */\n    function dcsBulkProcessDepositQueues(\n        address[] calldata vaultAddresses,\n        uint256 maxProcessCount\n    ) external;\n\n    /**\n     * @dev Processes the withdrawal queues for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to process withdrawal queues for.\n     * @param maxProcessCount The maximum number of withdrawals to process for each vault.\n     */\n    function dcsBulkProcessWithdrawalQueues(\n        address[] calldata vaultAddresses,\n        uint256 maxProcessCount\n    ) external;\n\n    /**\n     * @dev Rolls over multiple vaults to the next cycle in bulk.\n     * @param vaultAddresses Array of vault addresses to roll over.\n     */\n    function dcsBulkRolloverVaults(address[] calldata vaultAddresses) external;\n\n    /**\n     * @dev Checks and handles trade expiry for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to check for trade expiry.\n     */\n    function dcsBulkCheckTradesExpiry(\n        address[] calldata vaultAddresses\n    ) external;\n\n    /**\n     * @dev Checks and handles auction default for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to check for auction default.\n     */\n    function dcsBulkCheckAuctionDefault(\n        address[] calldata vaultAddresses\n    ) external;\n\n    /**\n     * @dev Checks and handles settlement default for multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to check for settlement default.\n     */\n    function dcsBulkCheckSettlementDefault(\n        address[] calldata vaultAddresses\n    ) external;\n\n    /**\n     * @dev Settles multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to settle.\n     */\n    function dcsBulkSettleVaults(\n        address[] calldata vaultAddresses\n    ) external payable;\n\n    /**\n     * @dev Collects fees from multiple vaults in bulk.\n     * @param vaultAddresses Array of vault addresses to collect fees from.\n     */\n    function dcsBulkCollectFees(address[] calldata vaultAddresses) external;\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSConfigurationEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IDCSConfigurationEntry {\n    /**\n     * @dev Sets the late fee basis points for a specific product.\n     * @param lateFeeBps The late fee in basis points.\n     * @param productId The ID of the product.\n     */\n    function dcsSetLateFeeBps(uint16 lateFeeBps, uint32 productId) external;\n\n    /**\n     * @dev Sets the minimum deposit amount for a specific product.\n     * @param minDepositAmount The minimum deposit amount.\n     * @param productId The ID of the product.\n     */\n    function dcsSetMinDepositAmount(\n        uint128 minDepositAmount,\n        uint32 productId\n    ) external;\n\n    /**\n     * @dev Sets the minimum withdrawal amount for a specific product.\n     * @param minWithdrawalAmount The minimum withdrawal amount.\n     * @param productId The ID of the product.\n     */\n    function dcsSetMinWithdrawalAmount(\n        uint128 minWithdrawalAmount,\n        uint32 productId\n    ) external;\n\n    /**\n     * @dev Sets whether the deposit queue is open for a specific product.\n     * @param isDepositQueueOpen True if the deposit queue is open.\n     * @param productId The ID of the product.\n     */\n    function dcsSetIsDepositQueueOpen(\n        bool isDepositQueueOpen,\n        uint32 productId\n    ) external;\n\n    /**\n     * @dev Sets the number of days to start charging late fees for a specific product.\n     * @param productId The ID of the product.\n     * @param daysToStartLateFees The number of days to start late fees.\n     */\n    function dcsSetDaysToStartLateFees(\n        uint32 productId,\n        uint8 daysToStartLateFees\n    ) external;\n\n    /**\n     * @dev Sets the number of days to start auction default for a specific product.\n     * @param productId The ID of the product.\n     * @param daysToStartAuctionDefault The number of days to start auction default.\n     */\n    function dcsSetDaysToStartAuctionDefault(\n        uint32 productId,\n        uint8 daysToStartAuctionDefault\n    ) external;\n\n    /**\n     * @dev Sets the number of days to start settlement default for a specific product.\n     * @param productId The ID of the product.\n     * @param daysToStartSettlementDefault The number of days to start settlement default.\n     */\n    function dcsSetDaysToStartSettlementDefault(\n        uint32 productId,\n        uint8 daysToStartSettlementDefault\n    ) external;\n\n    /**\n     * @dev Sets the maximum underlying amount for a specific product.\n     * @param maxUnderlyingAmountLimit The maximum underlying amount limit.\n     * @param productId The ID of the product.\n     */\n    function dcsSetMaxUnderlyingAmount(\n        uint128 maxUnderlyingAmountLimit,\n        uint32 productId\n    ) external;\n\n    /**\n     * @dev Sets the dispute period in hours for a specific product.\n     * @param productId The ID of the product.\n     * @param disputePeriodInHours The dispute period in hours.\n     */\n    function dcsSetDisputePeriodInHours(\n        uint32 productId,\n        uint8 disputePeriodInHours\n    ) external;\n\n    /**\n     * @notice Sets dispute grace period for the product\n     * @param productId ID of the product\n     * @param disputeGraceDelayInHours Dispute period in hours\n     */\n    function dcsSetDisputeGraceDelayInHours(\n        uint32 productId,\n        uint8 disputeGraceDelayInHours\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { IDCSEvents } from \"./IDCSEvents.sol\";\nimport { IDCSProductEntry } from \"./IDCSProductEntry.sol\";\nimport { IDCSVaultEntry } from \"./IDCSVaultEntry.sol\";\nimport { IDCSConfigurationEntry } from \"./IDCSConfigurationEntry.sol\";\nimport { IDCSBulkActionsEntry } from \"./IDCSBulkActionsEntry.sol\";\nimport { IDCSViewEntry } from \"./IDCSViewEntry.sol\";\nimport {\n    IProductViewEntry\n} from \"../../../common/interfaces/IProductViewEntry.sol\";\nimport {\n    IVaultViewEntry\n} from \"../../../common/interfaces/IVaultViewEntry.sol\";\nimport {\n    IVaultConfigurationEntry\n} from \"../../../common/interfaces/IVaultConfigurationEntry.sol\";\nimport {\n    IConfigurationEntry\n} from \"../../../common/interfaces/IConfigurationEntry.sol\";\nimport { IProductEntry } from \"../../../common/interfaces/IProductEntry.sol\";\n\ninterface IDCSEntry is\n    IDCSEvents,\n    IDCSProductEntry,\n    IDCSVaultEntry,\n    IDCSConfigurationEntry,\n    IDCSBulkActionsEntry,\n    IDCSViewEntry,\n    IProductViewEntry,\n    IVaultViewEntry,\n    IVaultConfigurationEntry,\n    IConfigurationEntry,\n    IProductEntry\n{}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { ICommonEvents } from \"../../common/interfaces/ICommonEvents.sol\";\nimport { VaultCreationParams } from \"../../../Structs.sol\";\nimport { SettlementStatus } from \"../DCSStructs.sol\";\n\ninterface IDCSEvents is ICommonEvents {\n    event DCSProductCreated(uint32 indexed productId);\n\n    event DCSVaultFeesCollected(\n        address indexed vaultAddress,\n        uint128 totalFees,\n        uint128 managementFee,\n        uint128 yieldFee\n    );\n\n    event DCSVaultCreated(\n        uint32 indexed productId,\n        address indexed vaultAddress,\n        VaultCreationParams params\n    );\n\n    event DCSAuctionEnded(\n        address indexed vaultAddress,\n        address indexed auctionWinner,\n        uint40 tradeStartDate,\n        uint16 aprBps,\n        uint128 initialSpotPrice,\n        uint128 strikePrice\n    );\n\n    event DCSTradeStarted(\n        address indexed vaultAddress,\n        address auctionWinner,\n        uint128 notionalAmount,\n        uint128 yieldAmount\n    );\n\n    event DCSLateFeePaid(address indexed vaultAddress, uint128 feeAmount);\n\n    event DCSVaultSettled(\n        address indexed vaultAddress,\n        address settler,\n        uint128 depositedAmount,\n        uint128 withdrawnAmount\n    );\n\n    event DCSVaultRolledOver(address indexed vaultAddress);\n\n    event DCSIsPayoffInDepositAssetUpdated(\n        address indexed vaultAddress,\n        bool isPayoffInDepositAsset\n    );\n\n    event DCSLateFeeBpsUpdated(uint32 indexed productId, uint16 lateFeeBps);\n\n    event DCSMinDepositAmountUpdated(\n        uint32 indexed productId,\n        uint128 minDepositAmount\n    );\n\n    event DCSMinWithdrawalAmountUpdated(\n        uint32 indexed productId,\n        uint128 minWithdrawalAmount\n    );\n\n    event DCSIsDepositQueueOpenUpdated(\n        uint32 indexed productId,\n        bool isDepositQueueOpen\n    );\n\n    event DCSMaxUnderlyingAmountLimitUpdated(\n        uint32 indexed productId,\n        uint128 maxUnderlyingAmountLimit\n    );\n\n    event DCSManagementFeeUpdated(address indexed vaultAddress, uint16 value);\n\n    event DCSYieldFeeUpdated(address indexed vaultAddress, uint16 value);\n\n    event DCSDisputeSubmitted(address indexed vaultAddress);\n\n    event DCSDisputeProcessed(\n        address indexed vaultAddress,\n        bool isDisputeAccepted,\n        uint40 timestamp,\n        uint128 newPrice\n    );\n\n    event DCSDisputePeriodInHoursUpdated(\n        uint32 indexed productId,\n        uint8 disputePeriodInHours\n    );\n\n    event DCSDisputeGraceDelayInHoursUpdated(\n        uint32 indexed productId,\n        uint8 disputeGraceDelayInHours\n    );\n\n    event DCSDaysToStartLateFeesUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartLateFees\n    );\n\n    event DCSDaysToStartAuctionDefaultUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartAuctionDefault\n    );\n\n    event DCSDaysToStartSettlementDefaultUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartSettlementDefault\n    );\n\n    // Legacy events, left for compatibility\n\n    event VaultCreated(\n        uint32 indexed productId,\n        address indexed vaultAddress,\n        string _tokenSymbol,\n        string _tokenName\n    );\n\n    event DCSSettlementStatusUpdated(\n        address indexed vaultAddress,\n        SettlementStatus settlementStatus\n    );\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSProductEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { Withdrawer, VaultStatus } from \"../../../Structs.sol\";\nimport { DCSProductCreationParams, DCSProduct } from \"../DCSStructs.sol\";\nimport {\n    IOracleEntry\n} from \"../../../oracle-entry/interfaces/IOracleEntry.sol\";\n\ninterface IDCSProductEntry {\n    // FUNCTIONS\n\n    /**\n     * @dev Creates a new DCS product with the given parameters.\n     * @param creationParams The parameters required for creating a new DCS product.\n     * @return uint32 The ID of the newly created product.\n     */\n    function dcsCreateProduct(\n        DCSProductCreationParams calldata creationParams\n    ) external returns (uint32);\n\n    /**\n     * @dev Adds an amount to the deposit queue for a specified product.\n     * @param productId The ID of the product for which the deposit is being made.\n     * @param amount The amount to be deposited.\n     * @param receiver The address that will receive the deposit.\n     */\n    function dcsAddToDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external payable;\n\n    function dcsRemoveFromDepositQueue(\n        uint32 productId,\n        uint128 amount\n    ) external;\n\n    /**\n     * @dev Processes the deposit queue for a specific vault, up to a maximum count of deposits.\n     * @param vault The address of the vault for which to process deposits.\n     * @param maxProcessCount The maximum number of deposits to process.\n     */\n    function dcsProcessDepositQueue(\n        address vault,\n        uint256 maxProcessCount\n    ) external;\n\n    /**\n     * @dev Adds a request to the withdrawal queue for a specific vault.\n     * @param vault The address of the vault.\n     * @param sharesAmount The amount of shares to withdraw.\n     * @param nextProductId The product ID for the next investment cycle, if applicable.\n     */\n    function dcsAddToWithdrawalQueue(\n        address vault,\n        uint128 sharesAmount,\n        uint32 nextProductId\n    ) external;\n\n    /**\n     * @dev Adds a request to the withdrawal queue with proxy for a specific vault.\n     * @param vaultAddress The address of the vault.\n     * @param sharesAmount The amount of shares to withdraw.\n     */\n    function dcsAddToWithdrawalQueueWithProxy(\n        address vaultAddress,\n        uint128 sharesAmount\n    ) external;\n\n    /**\n     * @dev Processes the withdrawal queue for a specific vault, up to a maximum count of withdrawals.\n     * @param vault The address of the vault for which to process withdrawals.\n     * @param maxProcessCount The maximum number of withdrawals to process.\n     */\n    function dcsProcessWithdrawalQueue(\n        address vault,\n        uint256 maxProcessCount\n    ) external;\n\n    /**\n     * @dev Checks and handles trade expiry for a specific vault.\n     * @param vaultAddress The address of the vault to check for trade expiry.\n     */\n    function dcsCheckTradeExpiry(address vaultAddress) external;\n\n    /**\n     * @dev Checks and handles settlement default for a specific vault.\n     * @param vaultAddress The address of the vault to check for settlement default.\n     */\n    function dcsCheckSettlementDefault(address vaultAddress) external;\n\n    /**\n     * @dev Collects fees from a specific vault.\n     * @param vaultAddress The address of the vault from which to collect fees.\n     */\n    function dcsCollectVaultFees(address vaultAddress) external;\n\n    /**\n     * @dev Submits a dispute for a specific vault.\n     * @param vaultAddress The address of the vault for which to submit a dispute.\n     */\n    function dcsSubmitDispute(address vaultAddress) external;\n\n    /**\n     * @dev Processes a trade dispute for a specific vault, potentially adjusting the price.\n     * @param vaultAddress The address of the vault for which to process the dispute.\n     * @param newPrice The new price to be considered in resolving the dispute.\n     */\n    function dcsProcessTradeDispute(\n        address vaultAddress,\n        uint128 newPrice\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSVaultEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { VaultStatus, Vault, VaultCreationParams } from \"../../../Structs.sol\";\nimport { DCSVault } from \"../DCSStructs.sol\";\nimport {\n    IOracleEntry\n} from \"../../../oracle-entry/interfaces/IOracleEntry.sol\";\nimport { ISwapManager } from \"../../../swaps/interfaces/ISwapManager.sol\";\n\ninterface IDCSVaultEntry {\n    // FUNCTIONS\n\n    /**\n     * @notice Creates a new vault with specified parameters.\n     * @param _productId The product ID associated with the vault.\n     * @param creationParams The params of the vault.\n     * @return vaultAddress The address of the newly created vault.\n     */\n    function dcsCreateVault(\n        uint32 _productId,\n        VaultCreationParams calldata creationParams\n    ) external returns (address vaultAddress);\n\n    /**\n     * @notice Ends the auction for a vault and sets it up for trading.\n     * @param vaultAddress The address of the vault.\n     * @param _auctionWinner The address of the auction winner.\n     * @param _tradeStartDate The start date of the trade.\n     * @param _aprBps The annual percentage rate in basis points.\n     * @param dataSource The data source for the oracle.\n     */\n    function dcsEndAuction(\n        address vaultAddress,\n        address _auctionWinner,\n        uint40 _tradeStartDate,\n        uint16 _aprBps,\n        IOracleEntry.DataSource dataSource\n    ) external;\n\n    /**\n     * @notice Starts trading for a vault.\n     * @param vaultAddress The address of the vault to start trading.\n     */\n    function dcsStartTrade(address vaultAddress) external payable;\n\n    /**\n     * @notice Settles a vault.\n     * @param vaultAddress The address of the vault to settle.\n     */\n    function dcsSettleVault(address vaultAddress) external payable;\n\n    /**\n     * @notice Swaps vaults funds on DEX and settles trade\n     * @param vaultAddress Address of the vault to settle\n     * @param swapProtocol Protocol to use for swap\n     * @param swapData Swap params\n     */\n    function dcsSwapAndSettleVault(\n        address vaultAddress,\n        ISwapManager.SwapProtocol swapProtocol,\n        ISwapManager.SwapData calldata swapData\n    ) external payable;\n\n    /**\n     * @notice Rolls over a vault to a new period.\n     * @param vaultAddress The address of the vault to roll over.\n     */\n    function dcsRolloverVault(address vaultAddress) external;\n\n    /**\n     * @notice Sets whether the payoff for a vault is in the deposit asset.\n     * @param vaultAddress The address of the vault.\n     * @param newState True if the payoff is in the deposit asset, false otherwise.\n     */\n    function dcsSetIsPayoffInDepositAsset(\n        address vaultAddress,\n        bool newState\n    ) external;\n\n    /**\n     * @notice Checks if an auction default has occurred for a specific vault.\n     * @param vaultAddress The address of the vault to check.\n     */\n    function dcsCheckAuctionDefault(address vaultAddress) external;\n}\n"
    },
    "contracts/cega-strategies/dcs/interfaces/IDCSViewEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { Withdrawer } from \"../../../Structs.sol\";\nimport { DCSProduct, DCSVault } from \"../DCSStructs.sol\";\n\ninterface IDCSViewEntry {\n    /**\n     * @dev Retrieves detailed information about a specific DCS product.\n     * @param productId The product ID.\n     * @return DCSProduct Struct containing detailed information about the product.\n     */\n    function dcsGetProduct(\n        uint32 productId\n    ) external view returns (DCSProduct memory);\n\n    /**\n     * @dev Retrieves the deposit asset address for a specific product.\n     * @param productId The product ID.\n     * @return address Address of the deposit asset.\n     */\n    function dcsGetProductDepositAsset(\n        uint32 productId\n    ) external view returns (address);\n\n    /**\n     * @dev Calculates the final payoff for a specific vault.\n     * @param vaultAddress The vault address.\n     * @return uint128 The calculated final payoff amount.\n     */\n    function dcsCalculateVaultFinalPayoff(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    /**\n     * @notice Retrieves the details of a specific vault.\n     * @param vaultAddress The address of the vault to retrieve.\n     * @return A struct containing details of the vault.\n     */\n    function dcsGetVault(\n        address vaultAddress\n    ) external view returns (DCSVault memory);\n\n    /**\n     * @notice Calculates the late fee for a specific vault.\n     * @param vaultAddress The address of the vault.\n     * @return The calculated late fee.\n     */\n    function dcsCalculateLateFee(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    /**\n     * @notice Retrieves the coupon payment for a specific vault.\n     * @param vaultAddress The address of the vault.\n     * @return The amount of the coupon payment.\n     */\n    function dcsGetCouponPayment(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    /**\n     * @notice Retrieves the settlement asset for a specific vault.\n     * @param vaultAddress The address of the vault.\n     * @return The address of the settlement asset.\n     */\n    function dcsGetVaultSettlementAsset(\n        address vaultAddress\n    ) external view returns (address);\n}\n"
    },
    "contracts/cega-strategies/fcn/FCNStructs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { IOracleEntry } from \"../../oracle-entry/interfaces/IOracleEntry.sol\";\n\nstruct FCNProductCreationParams {\n    uint128 minDepositAmount;\n    uint128 minWithdrawalAmount;\n    uint128 maxUnderlyingAmountLimit;\n    address underlyingAsset;\n    uint64 leverage;\n    uint40 tenorInSeconds;\n    uint8 daysToStartLateFees;\n    uint8 daysToStartAuctionDefault;\n    uint8 daysToStartSettlementDefault;\n    uint8 disputePeriodInHours;\n    uint8 disputeGraceDelayInHours;\n    uint16 lateFeeBps;\n    string name;\n    string tradeWinnerNftImage;\n    bool isBondOption;\n    uint24 observationIntervalInSeconds;\n    FCNOptionBarrier[] optionBarriers;\n}\n\nstruct FCNProduct {\n    uint128 minDepositAmount;\n    uint128 minWithdrawalAmount;\n    uint128 maxUnderlyingAmountLimit;\n    uint128 sumVaultUnderlyingAmounts;\n    address underlyingAsset;\n    uint64 leverage;\n    uint40 tenorInSeconds;\n    uint8 daysToStartLateFees;\n    uint8 daysToStartAuctionDefault;\n    uint8 daysToStartSettlementDefault;\n    uint8 disputePeriodInHours;\n    uint8 disputeGraceDelayInHours;\n    uint16 lateFeeBps;\n    bool isDepositQueueOpen;\n    bool isBondOption;\n    uint24 observationIntervalInSeconds;\n    FCNOptionBarrier[] optionBarriers;\n    address[] vaults;\n}\n\nstruct FCNVaultCreationParams {\n    string tokenName;\n    string tokenSymbol;\n    uint16 yieldFeeBps;\n    uint16 managementFeeBps;\n}\n\nstruct FCNVaultBarrierData {\n    uint128 initialSpotPrice;\n    IOracleEntry.DataSource dataSource;\n}\n\nstruct FCNVault {\n    uint128 notional;\n    uint128 totalYield;\n    uint16 aprBps;\n    bool isKnockedIn;\n    uint16 observationsDone;\n    uint96 buffer; // buffer if we need to add any more data\n    FCNVaultBarrierData[] barrierData;\n}\n\nstruct FCNOptionBarrier {\n    uint16 barrierBps;\n    FCNOptionBarrierType barrierType;\n    address asset;\n    uint8 exponent;\n}\n\nenum FCNOptionBarrierType {\n    None,\n    KnockIn\n}\n\nenum FCNVaultStatus {\n    DepositsClosed,\n    DepositsOpen,\n    PreAuction,\n    Auctioned,\n    Traded,\n    AwaitingSettlement,\n    Settled,\n    FeesCollected,\n    WithdrawalQueueProcessed,\n    Zombie\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNBulkActionsEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IFCNBulkActionsEntry {\n    function fcnBulkProcessDepositQueues(\n        address[] calldata vaultAddresses,\n        uint256 maxProcessCount\n    ) external;\n\n    function fcnBulkProcessWithdrawalQueues(\n        address[] calldata vaultAddresses,\n        uint256 maxProcessCount\n    ) external;\n\n    function fcnBulkStartTrades(\n        address[] calldata vaultAddresses\n    ) external payable;\n\n    function fcnBulkCheckBarriers(\n        address[] calldata vaultAddresses,\n        uint16 maxObservations\n    ) external;\n\n    function fcnBulkCheckTradesExpiry(\n        address[] calldata vaultAddresses\n    ) external;\n\n    function fcnBulkRepayBonds(\n        address[] calldata vaultAddresses,\n        uint128[] calldata amounts\n    ) external payable;\n\n    function fcnBulkSettleVaults(\n        address[] calldata vaultAddresses\n    ) external payable;\n\n    function fcnBulkCollectFees(address[] calldata vaultAddresses) external;\n\n    function fcnBulkRolloverVaults(address[] calldata vaultAddresses) external;\n\n    function fcnBulkCheckSettlementDefault(\n        address[] calldata vaultAddresses\n    ) external;\n\n    function fcnBulkCheckAuctionDefault(\n        address[] calldata vaultAddresses\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNConfigurationEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IFCNConfigurationEntry {\n    function fcnSetLateFeeBps(uint32 productId, uint16 lateFeeBps) external;\n\n    function fcnSetMinDepositAmount(\n        uint32 productId,\n        uint128 minDepositAmount\n    ) external;\n\n    function fcnSetMinWithdrawalAmount(\n        uint32 productId,\n        uint128 minWithdrawalAmount\n    ) external;\n\n    function fcnSetIsDepositQueueOpen(\n        uint32 productId,\n        bool isDepositQueueOpen\n    ) external;\n\n    function fcnSetDaysToStartLateFees(\n        uint32 productId,\n        uint8 daysToStartLateFees\n    ) external;\n\n    function fcnSetDaysToStartAuctionDefault(\n        uint32 productId,\n        uint8 daysToStartAuctionDefault\n    ) external;\n\n    function fcnSetDaysToStartSettlementDefault(\n        uint32 productId,\n        uint8 daysToStartSettlementDefault\n    ) external;\n\n    function fcnSetMaxUnderlyingAmountLimit(\n        uint32 productId,\n        uint128 maxUnderlyingAmountLimit\n    ) external;\n\n    function fcnSetDisputePeriodInHours(\n        uint32 productId,\n        uint8 disputePeriodInHours\n    ) external;\n\n    function fcnSetBondAllowList(address receiver, bool value) external;\n\n    function fcnSetDisputeGraceDelayInHours(\n        uint32 productId,\n        uint8 disputeGraceDelayInHours\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { IFCNEvents } from \"./IFCNEvents.sol\";\nimport { IFCNConfigurationEntry } from \"./IFCNConfigurationEntry.sol\";\nimport { IFCNProductEntry } from \"./IFCNProductEntry.sol\";\nimport { IFCNVaultEntry } from \"./IFCNVaultEntry.sol\";\nimport { IFCNBulkActionsEntry } from \"./IFCNBulkActionsEntry.sol\";\nimport { IFCNViewEntry } from \"./IFCNViewEntry.sol\";\nimport {\n    IProductViewEntry\n} from \"../../../common/interfaces/IProductViewEntry.sol\";\nimport {\n    IVaultViewEntry\n} from \"../../../common/interfaces/IVaultViewEntry.sol\";\nimport {\n    IVaultConfigurationEntry\n} from \"../../../common/interfaces/IVaultConfigurationEntry.sol\";\nimport {\n    IConfigurationEntry\n} from \"../../../common/interfaces/IConfigurationEntry.sol\";\nimport { IProductEntry } from \"../../../common/interfaces/IProductEntry.sol\";\n\ninterface IFCNEntry is\n    IFCNEvents,\n    IFCNConfigurationEntry,\n    IFCNProductEntry,\n    IFCNVaultEntry,\n    IFCNViewEntry,\n    IFCNBulkActionsEntry,\n    IProductViewEntry,\n    IVaultViewEntry,\n    IVaultConfigurationEntry,\n    IConfigurationEntry,\n    IProductEntry\n{}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNEvents.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { ICommonEvents } from \"../../common/interfaces/ICommonEvents.sol\";\nimport { FCNVaultCreationParams } from \"../FCNStructs.sol\";\n\ninterface IFCNEvents is ICommonEvents {\n    event FCNProductCreated(uint32 indexed productId);\n\n    event FCNVaultCreated(\n        uint32 indexed productId,\n        address indexed vaultAddress,\n        FCNVaultCreationParams creationParams\n    );\n\n    event FCNLateFeeBpsUpdated(uint32 indexed productId, uint16 lateFeeBps);\n\n    event FCNMinDepositAmountUpdated(\n        uint32 indexed productId,\n        uint128 minDepositAmount\n    );\n\n    event FCNMinWithdrawalAmountUpdated(\n        uint32 indexed productId,\n        uint128 minWithdrawalAmount\n    );\n\n    event FCNIsDepositQueueOpenUpdated(\n        uint32 indexed productId,\n        bool isDepositQueueOpen\n    );\n\n    event FCNMaxUnderlyingAmountLimitUpdated(\n        uint32 indexed productId,\n        uint128 maxUnderlyingAmountLimit\n    );\n\n    event FCNDisputePeriodInHoursUpdated(\n        uint32 indexed productId,\n        uint8 disputePeriodInHours\n    );\n\n    event FCNDisputeGraceDelayInHoursUpdated(\n        uint32 indexed productId,\n        uint8 disputeGraceDelayInHours\n    );\n\n    event FCNDaysToStartLateFeesUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartLateFees\n    );\n\n    event FCNDaysToStartAuctionDefaultUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartAuctionDefault\n    );\n\n    event FCNDaysToStartSettlementDefaultUpdated(\n        uint32 indexed productId,\n        uint8 daysToStartSettlementDefault\n    );\n\n    event FCNAuctionEnded(\n        address indexed vaultAddress,\n        address indexed auctionWinner,\n        uint40 tradeStartDate,\n        uint16 aprBps,\n        uint128[] initialSpotPrices\n    );\n\n    event FCNTradeStarted(\n        address indexed vaultAddress,\n        address auctionWinner,\n        uint128 notionalAmount,\n        uint128 yieldAmount\n    );\n\n    event FCNIsKnockedInUpdated(address indexed vaultAddress, bool isKnockedIn);\n\n    event FCNLateFeePaid(address indexed vaultAddress, uint128 feeAmount);\n\n    event FCNBondRepaid(address indexed vaultAddress, uint128 amount);\n\n    event FCNVaultRolledOver(address indexed vaultAddress);\n\n    event FCNBondAllowListUpdated(address indexed receiver, bool value);\n\n    event FCNVaultFeesCollected(\n        address indexed vaultAddress,\n        uint128 totalFees,\n        uint128 managementFee,\n        uint128 yieldFee\n    );\n\n    event FCNDisputeProcessed(\n        address indexed vaultAddress,\n        bool isDisputeAccepted,\n        uint8 barrierIndex,\n        uint40 timestamp,\n        uint128 newPrice\n    );\n\n    event FCNDisputeSubmitted(\n        address indexed vaultAddress,\n        uint8 barrierIndex,\n        uint40 timestamp\n    );\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNProductEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {\n    FCNProductCreationParams,\n    FCNVaultCreationParams\n} from \"../FCNStructs.sol\";\n\ninterface IFCNProductEntry {\n    function fcnCreateProduct(\n        FCNProductCreationParams calldata creationParams\n    ) external returns (uint32);\n\n    function fcnCreateVault(\n        uint32 productId,\n        FCNVaultCreationParams calldata creationParams\n    ) external returns (address vaultAddress);\n\n    function fcnAddToDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external payable;\n\n    function fcnRemoveFromDepositQueue(\n        uint32 productId,\n        uint128 amount\n    ) external;\n\n    function fcnProcessDepositQueue(\n        address vaultAddress,\n        uint256 maxProcessCount\n    ) external;\n\n    function fcnAddToWithdrawalQueue(\n        address vaultAddress,\n        uint128 sharesAmount,\n        uint32 nextProductId\n    ) external;\n\n    function fcnAddToWithdrawalQueueWithProxy(\n        address vaultAddress,\n        uint128 sharesAmount\n    ) external;\n\n    function fcnProcessWithdrawalQueue(\n        address vaultAddress,\n        uint256 maxProcessCount\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNVaultEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport {\n    IOracleEntry\n} from \"../../../oracle-entry/interfaces/IOracleEntry.sol\";\n\ninterface IFCNVaultEntry {\n    function fcnEndAuction(\n        address vaultAddress,\n        address auctionWinner,\n        uint40 tradeStartDate,\n        uint16 aprBps,\n        IOracleEntry.DataSource[] calldata dataSources\n    ) external;\n\n    function fcnStartTrade(address vaultAddress) external payable;\n\n    function fcnCheckBarriers(\n        address vaultAddress,\n        uint16 maxObservations\n    ) external;\n\n    function fcnCheckTradeExpiry(address vaultAddress) external;\n\n    function fcnRepayBond(\n        address vaultAddress,\n        uint128 amount\n    ) external payable;\n\n    function fcnSettleVault(address vaultAddress) external payable;\n\n    function fcnCollectVaultFees(address vaultAddress) external;\n\n    function fcnRolloverVault(address vaultAddress) external;\n\n    function fcnCheckSettlementDefault(address vaultAddress) external;\n\n    function fcnCheckAuctionDefault(address vaultAddress) external;\n\n    function fcnSubmitDispute(\n        address vaultAddress,\n        uint8 barrierIndex,\n        uint40 timestamp\n    ) external;\n\n    function fcnProcessTradeDispute(\n        address vaultAddress,\n        uint8 barrierIndex,\n        uint40 timestamp,\n        uint128 newPrice\n    ) external;\n}\n"
    },
    "contracts/cega-strategies/fcn/interfaces/IFCNViewEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { FCNProduct, FCNVault } from \"../FCNStructs.sol\";\n\ninterface IFCNViewEntry {\n    function fcnGetProduct(\n        uint32 productId\n    ) external view returns (FCNProduct memory);\n\n    function fcnGetProductDepositAsset(\n        uint32 productId\n    ) external view returns (address);\n\n    function fcnGetVault(\n        address vaultAddress\n    ) external view returns (FCNVault memory);\n\n    function fcnGetCouponPayment(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    function fcnCalculateVaultFinalPayoff(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    function fcnCalculateRepaidBond(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    function fcnCalculateVaultSettlementAmount(\n        address vaultAddress\n    ) external view returns (uint128);\n\n    function fcnGetBondAllowList(address receiver) external view returns (bool);\n\n    function fcnCalculateLateFee(\n        address vaultAddress\n    ) external view returns (uint128);\n}\n"
    },
    "contracts/common/interfaces/IConfigurationEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IConfigurationEntry {\n    // FUNCTIONS\n\n    function setManagementFee(address vaultAddress, uint16 value) external;\n\n    function setYieldFee(address vaultAddress, uint16 value) external;\n\n    function setProductName(uint32 productId, string calldata name) external;\n\n    function setTradeWinnerNftImage(\n        uint32 productId,\n        string calldata imageUrl\n    ) external;\n\n    function setIsDefaulted(address vaultAddress, bool newState) external;\n}\n"
    },
    "contracts/common/interfaces/IProductEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\ninterface IProductEntry {\n    function addToDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external payable;\n\n    function removeFromDepositQueue(uint32 productId, uint128 amount) external;\n\n    function addToWithdrawalQueue(\n        address vaultAddress,\n        uint128 sharesAmount,\n        uint32 nextProductId\n    ) external;\n\n    function addToWithdrawalQueueWithProxy(\n        address vaultAddress,\n        uint128 sharesAmount\n    ) external;\n}\n"
    },
    "contracts/common/interfaces/IProductViewEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\nimport { ProductMetadata } from \"../../Structs.sol\";\n\npragma solidity ^0.8.24;\n\ninterface IProductViewEntry {\n    function getStrategyOfProduct(\n        uint32 productId\n    ) external view returns (uint32);\n\n    function getLatestProductId() external view returns (uint32);\n\n    function getProductMetadata(\n        uint32 productId\n    ) external view returns (ProductMetadata memory);\n\n    function getIsProtocolPaused() external view returns (bool);\n\n    /**\n     * @dev Gets the deposit queue for a specific product, including depositors and their amounts.\n     * @param productId The product ID.\n     * @return depositors Array of depositor addresses.\n     * @return amounts Array of deposit amounts.\n     * @return totalAmount Total amount in the deposit queue.\n     */\n    function getDepositQueue(\n        uint32 productId\n    )\n        external\n        view\n        returns (\n            address[] memory depositors,\n            uint128[] memory amounts,\n            uint128 totalAmount\n        );\n}\n"
    },
    "contracts/common/interfaces/IVaultConfigurationEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { VaultStatus } from \"../../Structs.sol\";\n\ninterface IVaultConfigurationEntry {\n    /**\n     * @notice Opens a vault for deposits.\n     * @param vaultAddress The address of the vault to open.\n     */\n    function openVaultDeposits(address vaultAddress) external;\n\n    /**\n     * @notice Opens batch of vaults for deposits\n     * @param vaultAddresses Aaddresses of vaults to open\n     */\n    function bulkOpenVaultDeposits(address[] calldata vaultAddresses) external;\n\n    /**\n     * @notice Sets the status of a vault.\n     * @param vaultAddress The address of the vault.\n     * @param _vaultStatus The new status to set for the vault.\n     */\n    function setVaultStatus(\n        address vaultAddress,\n        VaultStatus _vaultStatus\n    ) external;\n\n    /**\n     * @notice Overrides the oracle price for a specific timestamp in a vault.\n     * @param vaultAddress The address of the vault.\n     * @param timestamp The timestamp for which to override the price.\n     * @param newPrice The new price to set.\n     */\n    function overrideOraclePrice(\n        address vaultAddress,\n        address asset,\n        uint40 timestamp,\n        uint128 newPrice\n    ) external;\n\n    /**\n     * @notice Set if the whole protocol is paused\n     * @param value The boolean value\n     */\n    function setIsProtocolPaused(bool value) external;\n}\n"
    },
    "contracts/common/interfaces/IVaultViewEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nimport { Vault, Withdrawer } from \"../../Structs.sol\";\n\ninterface IVaultViewEntry {\n    function getOraclePriceOverride(\n        address vaultAddress,\n        uint40 timestamp\n    ) external view returns (uint128);\n\n    function getVault(\n        address vaultAddress\n    ) external view returns (Vault memory);\n\n    function getVaultProductId(address vault) external view returns (uint32);\n\n    function getIsAuctionDefaulted(\n        address vaultAddress\n    ) external view returns (bool);\n\n    function getDaysLate(address vaultAddress) external view returns (uint256);\n\n    function totalAssets(address vaultAddress) external view returns (uint256);\n\n    function convertToAssets(\n        address vaultAddress,\n        uint256 shares\n    ) external view returns (uint128);\n\n    function convertToShares(\n        address vaultAddress,\n        uint128 assets\n    ) external view returns (uint256);\n\n    /**\n     * @dev Gets the withdrawal queue for a specific vault, including withdrawers and their amounts.\n     * @param vaultAddress The vault address.\n     * @return withdrawers Array of withdrawer data.\n     * @return amounts Array of withdrawal amounts.\n     * @return withProxy Array indicating if withdrawals are with proxy.\n     * @return totalAmount Total amount in the withdrawal queue.\n     */\n    function getWithdrawalQueue(\n        address vaultAddress\n    )\n        external\n        view\n        returns (\n            Withdrawer[] memory withdrawers,\n            uint256[] memory amounts,\n            bool[] memory withProxy,\n            uint256 totalAmount\n        );\n\n    /**\n     * @dev Checks if withdrawal is possible for a specific vault.\n     * @param vaultAddress The vault address.\n     * @return bool True if withdrawal is possible, false otherwise.\n     */\n    function isWithdrawalPossible(\n        address vaultAddress\n    ) external view returns (bool);\n}\n"
    },
    "contracts/oracle-entry/interfaces/IOracleEntry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\ninterface IOracleEntry {\n    enum DataSource {\n        None,\n        Pyth\n    }\n\n    /**\n     * @dev Emitted when a data source adapter is set.\n     * @param dataSource The data source for which the adapter is set.\n     * @param adapter The address of the adapter.\n     */\n    event DataSourceAdapterSet(DataSource dataSource, address adapter);\n\n    /**\n     * @notice Gets the price of an asset at a specific timestamp using a data source.\n     * @param asset The address of the asset.\n     * @param timestamp The timestamp for which the price is required.\n     * @param dataSource The data source to use for fetching the price.\n     * @return The price of the asset at the specified timestamp.\n     */\n    function getSinglePrice(\n        address asset,\n        uint40 timestamp,\n        DataSource dataSource\n    ) external view returns (uint128);\n\n    /**\n     * @notice Gets the price of a base asset in terms of a quote asset at a specific timestamp using a data source.\n     * @param baseAsset The address of the base asset.\n     * @param quoteAsset The address of the quote asset.\n     * @param timestamp The timestamp for which the price is required.\n     * @param dataSource The data source to use for fetching the price.\n     * @return The price of the base asset in terms of the quote asset at the specified timestamp.\n     */\n    function getPrice(\n        address baseAsset,\n        address quoteAsset,\n        uint40 timestamp,\n        DataSource dataSource\n    ) external view returns (uint128);\n\n    /**\n     * @notice Sets the adapter for a specific data source.\n     * @param dataSource The data source for which to set the adapter.\n     * @param adapter The address of the adapter.\n     */\n    function setDataSourceAdapter(\n        DataSource dataSource,\n        address adapter\n    ) external;\n\n    /**\n     * @notice Returns the target number of decimals for price values.\n     * @return The number of decimals.\n     */\n    function getTargetDecimals() external pure returns (uint8);\n}\n"
    },
    "contracts/proxies/StETHWrappingProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { DCS_STRATEGY_ID, FCN_STRATEGY_ID } from \"../Structs.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\nimport { IDCSEntry } from \"../cega-strategies/dcs/interfaces/IDCSEntry.sol\";\nimport { IFCNEntry } from \"../cega-strategies/fcn/interfaces/IFCNEntry.sol\";\nimport { IProductViewEntry } from \"../common/interfaces/IProductViewEntry.sol\";\nimport { IWrappingProxy } from \"./interfaces/IWrappingProxy.sol\";\nimport { IWstETH } from \"./interfaces/IWstETH.sol\";\n\ncontract StETHWrappingProxy is IWrappingProxy {\n    using SafeCast for uint256;\n\n    address public immutable cegaEntry;\n\n    IERC20 public immutable stETH;\n\n    IWstETH public immutable wstETH;\n\n    constructor(address _cegaEntry, IERC20 _stETH, IWstETH _wstETH) {\n        cegaEntry = _cegaEntry;\n        stETH = _stETH;\n        wstETH = _wstETH;\n\n        // stETH and wstETH support infinite approval, so it's enough to approve once\n        _stETH.approve(address(_wstETH), type(uint256).max);\n        _wstETH.approve(_cegaEntry, type(uint256).max);\n    }\n\n    function unwrapAndTransfer(address receiver, uint256 amount) external {\n        uint256 stETHAmount = wstETH.unwrap(amount);\n        stETH.transfer(receiver, stETHAmount);\n    }\n\n    function wrapAndAddToDCSDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) public {\n        _wrapAndAddToDCSDepositQueue(productId, amount, receiver);\n    }\n\n    function wrapAndAddToFCNDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) public {\n        _wrapAndAddToFCNDepositQueue(productId, amount, receiver);\n    }\n\n    function wrapAndAddToDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external {\n        uint32 strategyId = IProductViewEntry(cegaEntry).getStrategyOfProduct(\n            productId\n        );\n\n        if (strategyId == DCS_STRATEGY_ID) {\n            _wrapAndAddToDCSDepositQueue(productId, amount, receiver);\n        } else if (strategyId == FCN_STRATEGY_ID) {\n            _wrapAndAddToFCNDepositQueue(productId, amount, receiver);\n        } else {\n            revert(Errors.WRONG_STRATEGY);\n        }\n    }\n\n    function _wrapAndAddToDCSDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) internal {\n        stETH.transferFrom(msg.sender, address(this), amount);\n        uint128 wstETHAmount = wstETH.wrap(amount).toUint128();\n        IDCSEntry(cegaEntry).dcsAddToDepositQueue(\n            productId,\n            wstETHAmount,\n            receiver\n        );\n    }\n\n    function _wrapAndAddToFCNDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) internal {\n        stETH.transferFrom(msg.sender, address(this), amount);\n        uint128 wstETHAmount = wstETH.wrap(amount).toUint128();\n        IFCNEntry(cegaEntry).fcnAddToDepositQueue(\n            productId,\n            wstETHAmount,\n            receiver\n        );\n    }\n}\n"
    },
    "contracts/proxies/interfaces/IWrappingProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\ninterface IWrappingProxy {\n    /**\n     * @notice Unwraps the wrapped token and transfers the underlying token to the receiver.\n     * @param receiver The address to receive the unwrapped tokens.\n     * @param amount The amount of wrapped tokens to unwrap.\n     */\n    function unwrapAndTransfer(address receiver, uint256 amount) external;\n\n    /**\n     * @notice Wraps the token and adds it to the DCS deposit queue.\n     * @param productId The product ID for the DCS deposit.\n     * @param amount The amount of tokens to wrap.\n     * @param receiver The address that will receive the deposit queue shares.\n     */\n    function wrapAndAddToDCSDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external;\n\n    /**\n     * @notice Wraps the token and adds it to the FCN deposit queue.\n     * @param productId The product ID for the FCN deposit.\n     * @param amount The amount of tokens to wrap.\n     * @param receiver The address that will receive the deposit queue shares.\n     */\n    function wrapAndAddToFCNDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external;\n\n    /**\n     * @notice Wraps the token and adds it to the generic deposit queue.\n     * @param productId The product ID for the deposit.\n     * @param amount The amount of tokens to wrap.\n     * @param receiver The address that will receive the deposit queue shares.\n     */\n    function wrapAndAddToDepositQueue(\n        uint32 productId,\n        uint128 amount,\n        address receiver\n    ) external;\n}\n"
    },
    "contracts/proxies/interfaces/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWstETH is IERC20 {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/swaps/interfaces/ISwapManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\ninterface ISwapManager {\n    enum SwapProtocol {\n        None,\n        UniswapV3\n    }\n\n    struct SwapData {\n        uint256 deadline;\n        uint128 minOutputAmount;\n        bytes extraData;\n    }\n\n    event SwapProtocolAdapterUpdated(\n        SwapProtocol swapProtocol,\n        address adapter\n    );\n\n    event Swapped(\n        address fromAsset,\n        address toAsset,\n        uint128 amount,\n        address receiver,\n        SwapProtocol swapProtocol,\n        SwapData swapData\n    );\n\n    /**\n     * @notice Gets adapter address for swap protocol\n     * @param swapProtocol Swap protocol\n     * @return Address of the adapter\n     */\n    function swapProtocolAdapters(\n        SwapProtocol swapProtocol\n    ) external view returns (address);\n\n    /**\n     * @notice Sets (or resets) adapter for swap protocol\n     * @param swapProtocol Swap protocol\n     * @param adapter Address of the adapter contract\n     */\n    function setSwapProtocolAdapter(\n        SwapProtocol swapProtocol,\n        address adapter\n    ) external;\n\n    /**\n     * @notice Swaps with given params\n     * @param fromAsset Input asset\n     * @param toAsset Output asset\n     * @param amount Amount to swap\n     * @param receiver Address to receive the swap\n     * @param swapProtocol Protocol to use for the swap\n     * @param swapData Other data for the swap\n     */\n    function swap(\n        address fromAsset,\n        address toAsset,\n        uint128 amount,\n        address receiver,\n        SwapProtocol swapProtocol,\n        SwapData calldata swapData\n    ) external returns (uint128 outputAmount);\n}\n"
    },
    "contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.24;\n\nlibrary Errors {\n    string public constant NOT_CEGA_ENTRY = \"1\";\n    string public constant NOT_CEGA_ADMIN = \"2\";\n    string public constant NOT_TRADER_ADMIN = \"3\";\n    string public constant NOT_TRADE_WINNER = \"4\";\n    string public constant INVALID_VAULT = \"5\";\n    string public constant INVALID_VAULT_STATUS = \"6\";\n    string public constant VAULT_IN_ZOMBIE_STATE = \"7\";\n    string public constant TRADE_DEFAULTED = \"8\";\n    string public constant INVALID_SETTLEMENT_STATUS = \"9\";\n    string public constant VAULT_IN_DISPUTE = \"10\";\n    string public constant VAULT_NOT_IN_DISPUTE = \"11\";\n    string public constant OUTSIDE_DISPUTE_PERIOD = \"12\";\n    string public constant TRADE_HAS_NO_WINNER = \"13\";\n    string public constant TRADE_NOT_CONVERTED = \"14\";\n    string public constant TRADE_CONVERTED = \"15\";\n    string public constant INVALID_TRADE_END_DATE = \"16\";\n    string public constant INVALID_PRICE = \"17\";\n    string public constant VALUE_TOO_SMALL = \"18\";\n    string public constant VALUE_TOO_LARGE = \"19\";\n    string public constant VALUE_IS_ZERO = \"20\";\n    string public constant MAX_DEPOSIT_LIMIT_REACHED = \"21\";\n    string public constant DEPOSIT_QUEUE_NOT_OPEN = \"22\";\n    string public constant INVALID_QUOTE_OR_BASE_ASSETS = \"23\";\n    string public constant INVALID_MIN_DEPOSIT_AMOUNT = \"24\";\n    string public constant INVALID_MIN_WITHDRAWAL_AMOUNT = \"25\";\n    string public constant INVALID_STRIKE_PRICE = \"26\";\n    string public constant TRANSFER_FAILED = \"27\";\n    string public constant NOT_AVAILABLE_DATA_SOURCE = \"28\";\n    string public constant NO_PRICE_AVAILABLE = \"29\";\n    string public constant NO_PRICE_FEED_SET = \"30\";\n    string public constant INCOMPATIBLE_PRICE = \"31\";\n    string public constant NOT_CEGA_ENTRY_OR_REDEPOSIT_MANAGER = \"32\";\n    string public constant NO_PROXY_FOR_REDEPOSIT = \"33\";\n    string public constant NOT_TRADE_WINNER_OR_TRADER_ADMIN = \"34\";\n    string public constant TRADE_NOT_STARTED = \"35\";\n    string public constant NOT_AVAILABLE_SWAP_TYPE = \"36\";\n    string public constant NOT_AVAILABLE_SWAP_PATH = \"37\";\n    string public constant PROTOCOL_PAUSED = \"38\";\n    string public constant WRONG_STRATEGY = \"39\";\n    string public constant INVALID_ARRAY_LENGTH = \"40\";\n    string public constant UNKNOWN_BARRIER_TYPE = \"41\";\n    string public constant NOT_BOND_OPTION = \"42\";\n    string public constant UNAUTHORIZED_BOND_RECEIVER = \"43\";\n    string public constant REMAINING_VALUE_TOO_SMALL = \"44\";\n    string public constant VALUE_IN_DISPUTE_GRACE_DELAY = \"45\";\n}\n"
    }
  }
}}