{{
  "language": "Solidity",
  "sources": {
    "src/main/zones/signed-zone/signed-zone-sub-1/SignedZone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ZoneParameters,\n    Schema\n} from \"../../../../types/lib/ConsiderationStructs.sol\";\n\nimport { ZoneInterface } from \"../../../interfaces/ZoneInterface.sol\";\n\nimport {\n    SignedZoneEventsAndErrors\n} from \"../interfaces/SignedZoneEventsAndErrors.sol\";\n\nimport { SIP5Interface } from \"../../interfaces/SIP5Interface.sol\";\n\nimport {\n    SignedZoneControllerInterface\n} from \"../interfaces/SignedZoneControllerInterface.sol\";\n\nimport {\n    IAuthorizedTransferSecurityRegistry\n} from \"lib/erc721c-seaport/src/interfaces/IAuthorizedTransferSecurityRegistry.sol\";\n\nimport \"./lib/SignedZoneConstants.sol\";\n\n/**\n * @title  SignedZone\n * @author ryanio, BCLeFevre\n * @notice SignedZone is an implementation of SIP-7 that requires orders\n *         to be signed by an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n */\ncontract SignedZone is SignedZoneEventsAndErrors, ZoneInterface, SIP5Interface {\n    /// @dev The zone's controller that is set during deployment.\n    address private immutable _controller;\n\n    /// @dev The authorized signers, and if they are active.\n    mapping(address => bool) private _signers;\n\n    /// @dev The EIP-712 digest parameters.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH = keccak256(bytes(\"2.0\"));\n    // prettier-ignore\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH = keccak256(\n          abi.encodePacked(\n            \"EIP712Domain(\",\n                \"string name,\",\n                \"string version,\",\n                \"uint256 chainId,\",\n                \"address verifyingContract\",\n            \")\"\n          )\n        );\n    // prettier-ignore\n    bytes32 internal immutable _SIGNED_ORDER_TYPEHASH = keccak256(\n          abi.encodePacked(\n            \"SignedOrder(\",\n                \"address fulfiller,\",\n                \"uint64 expiration,\",\n                \"bytes32 orderHash,\",\n                \"bytes context\",\n            \")\"\n          )\n        );\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    address private immutable SEAPORT =\n        0x0000000000000068F116a894984e2DB1123eB395;\n\n    /**\n     * @notice Constructor to deploy the contract.\n     *\n     * @param zoneName The name for the zone used in the domain separator\n     *                 derivation.\n     */\n    constructor(string memory zoneName) {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n\n        // Set the name hash.\n        _NAME_HASH = keccak256(bytes(zoneName));\n\n        // Derive and set the domain separator.\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n\n        // Emit an event to signal a SIP-5 contract has been deployed.\n        emit SeaportCompatibleContractDeployed();\n    }\n\n    /**\n     * @notice The fallback function is used as a dispatcher for the\n     *         `updateSigner`, `isActiveSigner`, `getActiveSigners` and\n     *         `supportsInterface` functions.\n     */\n    // prettier-ignore\n    fallback(bytes calldata) external returns (bytes memory output) {\n        // Get the function selector.\n        bytes4 selector = msg.sig;\n\n        if (selector == UPDATE_SIGNER_SELECTOR) {\n            // abi.encodeWithSignature(\"updateSigner(address,bool)\", signer,\n            // active)\n          \n            // Get the signer, and active status.\n            address signer = abi.decode(msg.data[4:], (address));\n            bool active = abi.decode(msg.data[36:], (bool));\n\n            // Call to update the signer.\n            _updateSigner(signer, active);\n        } else if (selector == GET_ACTIVE_SIGNERS_SELECTOR) {\n            // abi.encodeWithSignature(\"getActiveSigners()\")\n        \n            // Call the internal function to get the active signers.\n            return abi.encode(_getActiveSigners());\n        } else if (selector == IS_ACTIVE_SIGNER_SELECTOR) {\n            // abi.encodeWithSignature(\"isActiveSigner(address)\", signer)\n\n            // Get the signer.\n            address signer = abi.decode(msg.data[4:], (address));\n\n            // Call the internal function to determine if the signer is active.\n            return abi.encode(_isActiveSigner(signer));\n        }\n        else {\n             // Revert if the function selector is not supported.\n            assembly {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, UnsupportedFunctionSelector_error_selector)\n                // revert(abi.encodeWithSignature(\n                //  \"UnsupportedFunctionSelector()\"\n                // ))\n                revert(0x1c, UnsupportedFunctionSelector_error_length)\n            }\n        }\n    }\n\n    /**\n     * @notice Check if a given order including extraData is currently valid.\n     *\n     * @dev This function is called by Seaport whenever any extraData is\n     *      provided by the caller.\n     *\n     * @return authorizedOrderMagicValue A magic value indicating if the order\n     *                                   is currently valid.\n     */\n    function authorizeOrder(\n        ZoneParameters calldata zoneParameters\n    ) external override returns (bytes4 authorizedOrderMagicValue) {\n        if (msg.sender != SEAPORT) {\n            // Revert if the caller is not Seaport.\n            revert CallerNotSeaport();\n        }\n\n        // Check Zone Parameters validity.\n        _assertValidZoneParameters();\n\n        // Put the extraData and orderHash on the stack for cheaper access.\n        bytes calldata extraData = zoneParameters.extraData;\n        bytes32 orderHash = zoneParameters.orderHash;\n\n        // Declare a variable to hold the expiration.\n        uint64 expiration;\n\n        // Declare a variable to hold the substandard version byte.\n        uint256 subStandardVersionByte;\n\n        // Validate the extraData.\n        assembly {\n            // Get the length of the extraData.\n            let extraDataPtr := add(0x24, calldataload(Zone_extraData_cdPtr))\n            let extraDataLength := calldataload(extraDataPtr)\n\n            // Validate the extra data length.\n            if lt(\n                extraDataLength,\n                InvalidExtraDataLength_expected_length_substandard_1\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidExtraDataLength_error_selector)\n                mstore(InvalidExtraDataLength_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidExtraDataLength(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidExtraDataLength_error_length)\n            }\n\n            // extraData bytes 0-1: SIP-6 version byte (MUST be 0x00)\n            let versionByte := shr(248, calldataload(add(extraDataPtr, 0x20)))\n\n            // Validate the SIP6 Version byte.\n            if iszero(eq(versionByte, 0x00)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidSIP6Version_error_selector)\n                mstore(InvalidSIP6Version_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidSIP6Version(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidSIP6Version_error_length)\n            }\n\n            // extraData bytes 93-94: Substandard #1\n            // (MUST be 0x00, 0x01, 0x07, 0x08, or 0x09)\n            subStandardVersionByte := shr(\n                248,\n                calldataload(\n                    add(extraDataPtr, ExtraData_substandard_version_byte_offset)\n                )\n            )\n\n            // Validate the substandard version byte.\n            if or(\n                gt(subStandardVersionByte, 0x09),\n                and(\n                    gt(subStandardVersionByte, 0x01),\n                    lt(subStandardVersionByte, 0x07)\n                )\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidSubstandardVersion_error_selector)\n                mstore(InvalidSubstandardVersion_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidSubstandardVersion(bytes32)\", orderHash)\n                // )\n                revert(0x1c, InvalidSubstandardVersion_error_length)\n            }\n\n            // extraData bytes 21-29: expiration timestamp (uint64)\n            expiration := shr(\n                192,\n                calldataload(add(extraDataPtr, ExtraData_expiration_offset))\n            )\n\n            // Revert if expired.\n            if lt(expiration, timestamp()) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, SignatureExpired_error_selector)\n                mstore(SignatureExpired_error_expiration_ptr, expiration)\n                mstore(SignatureExpired_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //   \"SignatureExpired(uint256,bytes32)\", expiration, orderHash)\n                // )\n                revert(0x1c, SignatureExpired_error_length)\n            }\n\n            // Get the length of the consideration array.\n            let considerationLength := calldataload(\n                add(0x24, calldataload(Zone_consideration_head_cdPtr))\n            )\n\n            // Revert if the order does not have any consideration items due to\n            // the Substandard #1 requirement.\n            if iszero(considerationLength) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidSubstandardSupport_error_selector)\n                mstore(InvalidSubstandardSupport_error_reason_offset_ptr, 0x60)\n                mstore(\n                    InvalidSubstandardSupport_error_substandard_version_ptr,\n                    1\n                )\n                mstore(InvalidSubstandardSupport_error_orderHash_ptr, orderHash)\n                mstore(InvalidSubstandardSupport_error_reason_length_ptr, 0x2a)\n                mstore(\n                    InvalidSubstandardSupport_error_reason_ptr,\n                    \"Consideration must have at least\"\n                )\n                mstore(\n                    InvalidSubstandardSupport_error_reason_2_ptr,\n                    \" one item.\"\n                )\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidSubstandardSupport(string,uint256,bytes32)\",\n                //     reason,\n                //     substandardVersion,\n                //     orderHash\n                // ))\n                revert(0x1c, InvalidSubstandardSupport_error_length)\n            }\n        }\n\n        // Check the validity of the Substandard #1 extraData and get the\n        // expected fulfiller address.\n        address expectedFulfiller = (\n            _assertValidSubstandardAndGetExpectedFulfiller(orderHash)\n        );\n\n        // extraData bytes 29-93: signature\n        // (strictly requires 64 byte compact sig, EIP-2098)\n        bytes calldata signature = extraData[29:93];\n\n        // extraData bytes 93-126: context (fixed length, 32 bytes + 1 byte)\n        bytes calldata context;\n\n        if (subStandardVersionByte < 2) {\n            context = extraData[93:126];\n        } else if (subStandardVersionByte == 7) {\n            if (extraData.length < 166) {\n                assembly {\n                    // Store left-padded selector with push4, mem[28:32] = selector\n                    mstore(0, InvalidExtraDataLength_error_selector)\n                    mstore(\n                        InvalidExtraDataLength_error_orderHash_ptr,\n                        orderHash\n                    )\n                    // revert(abi.encodeWithSignature(\n                    //   \"InvalidExtraDataLength(bytes32)\", orderHash)\n                    // )\n                    revert(0x1c, InvalidExtraDataLength_error_length)\n                }\n            }\n            context = extraData[93:166];\n        } else {\n            if (extraData.length < 146) {\n                assembly {\n                    // Store left-padded selector with push4, mem[28:32] = selector\n                    mstore(0, InvalidExtraDataLength_error_selector)\n                    mstore(\n                        InvalidExtraDataLength_error_orderHash_ptr,\n                        orderHash\n                    )\n                    // revert(abi.encodeWithSignature(\n                    //   \"InvalidExtraDataLength(bytes32)\", orderHash)\n                    // )\n                    revert(0x1c, InvalidExtraDataLength_error_length)\n                }\n            }\n            context = extraData[93:146];\n        }\n\n        // Derive the signedOrder hash.\n        bytes32 signedOrderHash = _deriveSignedOrderHash(\n            expectedFulfiller,\n            expiration,\n            orderHash,\n            context\n        );\n\n        // Derive the EIP-712 digest using the domain separator and signedOrder\n        // hash.\n        bytes32 digest = _deriveEIP712Digest(\n            _domainSeparator(),\n            signedOrderHash\n        );\n\n        // Recover the signer address from the digest and signature.\n        address recoveredSigner = _recoverSigner(digest, signature);\n\n        // Revert if the signer is not active.\n        if (!_signers[recoveredSigner]) {\n            revert SignerNotActive(recoveredSigner, orderHash);\n        }\n\n        // Set the transfer status of the tokens to true.\n        _setTransferStatus(zoneParameters, true);\n\n        // Return the selector of authorizeOrder as the magic value.\n        authorizedOrderMagicValue = ZoneInterface.authorizeOrder.selector;\n    }\n\n    /**\n     * @notice Check if a given order including extraData is currently valid.\n     *\n     * @dev This function is called by Seaport whenever any extraData is\n     *      provided by the caller.\n     *\n     * @return validOrderMagicValue A magic value indicating if the order is\n     *                              currently valid.\n     */\n    function validateOrder(\n        ZoneParameters calldata zoneParameters\n    ) external override returns (bytes4 validOrderMagicValue) {\n        if (msg.sender != SEAPORT) {\n            // Revert if the caller is not Seaport.\n            revert CallerNotSeaport();\n        }\n\n        // Set the transfer status of the tokens to false.\n        _setTransferStatus(zoneParameters, false);\n\n        // Return the selector of validateOrder as the magic value.\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\n    }\n\n    /**\n     * @dev Returns Seaport metadata for this contract, returning the\n     *      contract name and supported schemas.\n     *\n     * @return name     The contract name\n     * @return schemas  The supported SIPs\n     */\n    function getSeaportMetadata()\n        external\n        view\n        override(SIP5Interface, ZoneInterface)\n        returns (string memory name, Schema[] memory schemas)\n    {\n        // Return the supported SIPs.\n        schemas = new Schema[](1);\n        schemas[0].id = 7;\n\n        // Get the SIP-7 information.\n        (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        ) = _sip7Information();\n\n        // Return the zone name.\n        name = zoneName;\n\n        // Encode the SIP-7 information.\n        schemas[0].metadata = abi.encode(\n            domainSeparator,\n            apiEndpoint,\n            substandards,\n            documentationURI\n        );\n    }\n\n    /**\n     * @dev Returns if the zone supports the interfaceId.\n     *\n     * @param interfaceId The interface identifier, as specified in ERC-165.\n     *\n     * @return supportsInterface True if the zone supports interfaceId, false\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view override returns (bool) {\n        // Call the internal function to determine if the interface is supported.\n        return _supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Sets the transfer status of the token based on the consideration\n     *      items or offer items.\n     *\n     * @param zoneParameters The zone parameters.\n     * @param active The transfer status of the token.\n     */\n    function _setTransferStatus(\n        ZoneParameters calldata zoneParameters,\n        bool active\n    ) internal {\n        uint8 subStandardVersionByte = uint8(\n            bytes1(zoneParameters.extraData[93])\n        );\n\n        if (subStandardVersionByte < 2) {\n            return;\n        }\n\n        address registry = address(bytes20(zoneParameters.extraData[126:146]));\n\n        address token;\n        uint256 identifier;\n        uint256 amount;\n\n        if (uint256(zoneParameters.consideration[0].itemType) > 1) {\n            // Call on first consideration\n            token = zoneParameters.consideration[0].token;\n            identifier = zoneParameters.consideration[0].identifier;\n            amount = zoneParameters.consideration[0].amount;\n        } else {\n            // Call on first offer\n            token = zoneParameters.offer[0].token;\n            identifier = zoneParameters.offer[0].identifier;\n            amount = zoneParameters.offer[0].amount;\n        }\n\n        if (subStandardVersionByte == 7) {\n            address operator = address(\n                bytes20(zoneParameters.extraData[146:166])\n            );\n            if (active) {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .beforeAuthorizedTransfer(operator, token);\n            } else {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .afterAuthorizedTransfer(token);\n            }\n        } else if (subStandardVersionByte == 8) {\n            if (active) {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .beforeAuthorizedTransfer(token, identifier);\n            } else {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .afterAuthorizedTransfer(token, identifier);\n            }\n        }\n        /* subStandardVersionByte == 9 */\n        else {\n            if (active) {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .beforeAuthorizedTransferWithAmount(\n                        token,\n                        identifier,\n                        amount\n                    );\n            } else {\n                IAuthorizedTransferSecurityRegistry(registry)\n                    .afterAuthorizedTransferWithAmount(token, identifier);\n            }\n        }\n    }\n\n    /**\n     * @notice Add or remove a signer to the zone.\n     *         Only the controller can call this function.\n     *\n     * @param signer The signer address to add or remove.\n     */\n    function _updateSigner(address signer, bool active) internal {\n        // Only the controller can call this function.\n        _assertCallerIsController();\n        // Add or remove the signer.\n        active ? _addSigner(signer) : _removeSigner(signer);\n    }\n\n    /**\n     * @notice Add a new signer to the zone.\n     *         Only the controller or an active signer can call this function.\n     *\n     * @param signer The new signer address to add.\n     */\n    function _addSigner(address signer) internal {\n        // Set the signer's active status to true.\n        _signers[signer] = true;\n\n        // Emit an event that the signer was added.\n        emit SignerAdded(signer);\n    }\n\n    /**\n     * @notice Remove an active signer from the zone.\n     *         Only the controller or an active signer can call this function.\n     *\n     * @param signer The signer address to remove.\n     */\n    function _removeSigner(address signer) internal {\n        // Set the signer's active status to false.\n        _signers[signer] = false;\n\n        // Emit an event that the signer was removed.\n        emit SignerRemoved(signer);\n    }\n\n    /**\n     * @notice Returns the active signers for the zone. Note that the array of\n     *         active signers could grow to a size that this function could not\n     *         return, the array of active signers is  expected to be small,\n     *         and is managed by the controller.\n     *\n     * @return signers The active signers.\n     */\n    function _getActiveSigners()\n        internal\n        view\n        returns (address[] memory signers)\n    {\n        // Return the active signers for the zone by calling the controller.\n        signers = SignedZoneControllerInterface(_controller).getActiveSigners(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice Returns if the given address is an active signer for the zone.\n     *\n     * @param signer The address to check if it is an active signer.\n     *\n     * @return The address is an active signer, false otherwise.\n     */\n    function _isActiveSigner(address signer) internal view returns (bool) {\n        // Return the active status of the caller.\n        return _signers[signer];\n    }\n\n    /**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal pure returns (bool) {\n        // Determine if the interface is supported.\n        return (interfaceId == type(SIP5Interface).interfaceId || // SIP-5\n            interfaceId == type(ZoneInterface).interfaceId || // ZoneInterface\n            interfaceId == 0x01ffc9a7); // ERC-165\n    }\n\n    /**\n     * @notice Internal call to return the signing information, substandards,\n     *         and documentation about the zone.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The zone name.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function _sip7Information()\n        internal\n        view\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        )\n    {\n        // Return the SIP-7 information.\n        domainSeparator = _domainSeparator();\n\n        // Get the SIP-7 information from the controller.\n        (\n            ,\n            zoneName,\n            apiEndpoint,\n            substandards,\n            documentationURI\n        ) = SignedZoneControllerInterface(_controller)\n            .getAdditionalZoneInformation(address(this));\n    }\n\n    /**\n     * @dev Derive the signedOrder hash from the orderHash and expiration.\n     *\n     * @param fulfiller  The expected fulfiller address.\n     * @param expiration The signature expiration timestamp.\n     * @param orderHash  The order hash.\n     * @param context    The optional variable-length context.\n     *\n     * @return signedOrderHash The signedOrder hash.\n     *\n     */\n    function _deriveSignedOrderHash(\n        address fulfiller,\n        uint64 expiration,\n        bytes32 orderHash,\n        bytes calldata context\n    ) internal view returns (bytes32 signedOrderHash) {\n        // Derive the signed order hash.\n        signedOrderHash = keccak256(\n            abi.encode(\n                _SIGNED_ORDER_TYPEHASH,\n                fulfiller,\n                expiration,\n                orderHash,\n                keccak256(context)\n            )\n        );\n    }\n\n    /**\n     * @dev Internal view function to return the signer of a signature.\n     *\n     * @param digest    The digest to verify the signature against.\n     * @param signature A signature from the signer indicating that the order\n     *                  has been approved.\n     *\n     * @return recoveredSigner The recovered signer.\n     */\n    function _recoverSigner(\n        bytes32 digest,\n        bytes memory signature\n    ) internal view returns (address recoveredSigner) {\n        // Utilize assembly to perform optimized signature verification check.\n        assembly {\n            // Ensure that first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Declare value for v signature parameter.\n            let v\n\n            // Get the length of the signature.\n            let signatureLength := mload(signature)\n\n            // Get the pointer to the value preceding the signature length.\n            // This will be used for temporary memory overrides - either the\n            // signature head for isValidSignature or the digest for ecrecover.\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\n\n            // Cache the current value behind the signature to restore it later.\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\n\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\n            {\n                // Take the difference between the max ECDSA signature length\n                // and the actual signature length. Overflow desired for any\n                // values > 65. If the diff is not 0 or 1, it is not a valid\n                // ECDSA signature - move on to EIP1271 check.\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\n\n                // If diff is 0 or 1, it may be an ECDSA signature.\n                // Try to recover signer.\n                if iszero(gt(lenDiff, 1)) {\n                    // Read the signature `s` value.\n                    let originalSignatureS := mload(\n                        add(signature, ECDSA_signature_s_offset)\n                    )\n\n                    // Read the first byte of the word after `s`. If the\n                    // signature is 65 bytes, this will be the real `v` value.\n                    // If not, it will need to be modified - doing it this way\n                    // saves an extra condition.\n                    v := byte(\n                        0,\n                        mload(add(signature, ECDSA_signature_v_offset))\n                    )\n\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\n                    if lenDiff {\n                        // Extract yParity from highest bit of vs and add 27 to\n                        // get v.\n                        v := add(\n                            shr(MaxUint8, originalSignatureS),\n                            Signature_lower_v\n                        )\n\n                        // Extract canonical s from vs, all but the highest bit.\n                        // Temporarily overwrite the original `s` value in the\n                        // signature.\n                        mstore(\n                            add(signature, ECDSA_signature_s_offset),\n                            and(\n                                originalSignatureS,\n                                EIP2098_allButHighestBitMask\n                            )\n                        )\n                    }\n                    // Temporarily overwrite the signature length with `v` to\n                    // conform to the expected input for ecrecover.\n                    mstore(signature, v)\n\n                    // Temporarily overwrite the word before the length with\n                    // `digest` to conform to the expected input for ecrecover.\n                    mstore(wordBeforeSignaturePtr, digest)\n\n                    // Attempt to recover the signer for the given signature. Do\n                    // not check the call status as ecrecover will return a null\n                    // address if the signature is invalid.\n                    pop(\n                        staticcall(\n                            gas(),\n                            Ecrecover_precompile, // Call ecrecover precompile.\n                            wordBeforeSignaturePtr, // Use data memory location.\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\n                            0, // Write result to scratch space.\n                            OneWord // Provide size of returned result.\n                        )\n                    )\n\n                    // Restore cached word before signature.\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n\n                    // Restore cached signature length.\n                    mstore(signature, signatureLength)\n\n                    // Restore cached signature `s` value.\n                    mstore(\n                        add(signature, ECDSA_signature_s_offset),\n                        originalSignatureS\n                    )\n\n                    // Read the recovered signer from the buffer given as return\n                    // space for ecrecover.\n                    recoveredSigner := mload(0)\n                }\n            }\n\n            // Restore the cached values overwritten by selector, digest and\n            // signature head.\n            mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n        }\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator() internal view returns (bytes32) {\n        // prettier-ignore\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(OneWord, nameHash)\n            mstore(TwoWords, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(ThreeWords, chainid())\n\n            // Place the address of this contract in the next memory location.\n            mstore(FourWords, address())\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, FiveWords)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param signedOrderHash The signedOrder hash.\n     *\n     * @return digest The digest hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 domainSeparator,\n        bytes32 signedOrderHash\n    ) internal pure returns (bytes32 digest) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the signed order hash in scratch space, spilling into the\n            // first two bytes of the free memory pointer — this should never be\n            // set as memory cannot be expanded to that size, and will be\n            // zeroed out after the hash is performed.\n            mstore(EIP712_SignedOrderHash_offset, signedOrderHash)\n\n            // Hash the relevant region\n            digest := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_SignedOrderHash_offset, 0)\n        }\n    }\n\n    /**\n     * @dev Internal view function to revert if the caller is not the\n     *      controller.\n     */\n    function _assertCallerIsController() internal view {\n        // Get the controller address to use in the assembly block.\n        address controller = _controller;\n\n        assembly {\n            // Revert if the caller is not the controller.\n            if iszero(eq(caller(), controller)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidController_error_selector)\n                // revert(abi.encodeWithSignature(\n                //   \"InvalidController()\")\n                // )\n                revert(0x1c, InvalidController_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for the\n     *      dyanamic type in ZoneParameters. This ensures that functions using\n     *      the calldata object normally will be using the same data as the\n     *      assembly functions and that values that are bound to a given range\n     *      are within that range.\n     */\n    function _assertValidZoneParameters() internal pure {\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Zone parameters struct offset == 0x20\n             */\n\n            // Zone parameters at calldata 0x04 must have offset of 0x20.\n            if iszero(\n                eq(calldataload(Zone_parameters_cdPtr), Zone_parameters_ptr)\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, InvalidZoneParameterEncoding_error_selector)\n                // revert(abi.encodeWithSignature(\n                //  \"InvalidZoneParameterEncoding()\"\n                // ))\n                revert(0x1c, InvalidZoneParameterEncoding_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the context argument for the\n     *      supplied extra data follows the substandard #1 format. Returns the\n     *      expected fulfiller of the order for deriving the signed order hash.\n     *\n     * @param orderHash The order hash.\n     *\n     * @return expectedFulfiller The expected fulfiller of the order.\n     */\n    function _assertValidSubstandardAndGetExpectedFulfiller(\n        bytes32 orderHash\n    ) internal pure returns (address expectedFulfiller) {\n        // Revert if the expected fulfiller is not the zero address and does\n        // not match the actual fulfiller or if the expected received\n        // identifier does not match the actual received identifier.\n        assembly {\n            // Get the actual fulfiller.\n            let actualFulfiller := calldataload(Zone_parameters_fulfiller_cdPtr)\n            let extraDataPtr := calldataload(Zone_extraData_cdPtr)\n            let considerationPtr := calldataload(Zone_consideration_head_cdPtr)\n\n            // Get the expected fulfiller.\n            expectedFulfiller := shr(\n                96,\n                calldataload(add(expectedFulfiller_offset, extraDataPtr))\n            )\n\n            // Get the actual received identifier.\n            let actualReceivedIdentifier := calldataload(\n                add(actualReceivedIdentifier_offset, considerationPtr)\n            )\n\n            // Get the expected received identifier.\n            let expectedReceivedIdentifier := calldataload(\n                add(expectedReceivedIdentifier_offset, extraDataPtr)\n            )\n\n            // Revert if expected fulfiller is not the zero address and does\n            // not match the actual fulfiller.\n            if and(\n                iszero(iszero(expectedFulfiller)),\n                iszero(eq(expectedFulfiller, actualFulfiller))\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidFulfiller_error_selector)\n                mstore(\n                    InvalidFulfiller_error_expectedFulfiller_ptr,\n                    expectedFulfiller\n                )\n                mstore(\n                    InvalidFulfiller_error_actualFulfiller_ptr,\n                    actualFulfiller\n                )\n                mstore(InvalidFulfiller_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidFulfiller(address,address,bytes32)\",\n                //     expectedFulfiller,\n                //     actualFulfiller,\n                //     orderHash\n                // ))\n                revert(0x1c, InvalidFulfiller_error_length)\n            }\n\n            // Revert if expected received item does not match the actual\n            // received item.\n            if iszero(\n                eq(expectedReceivedIdentifier, actualReceivedIdentifier)\n            ) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InvalidReceivedItem_error_selector)\n                mstore(\n                    InvalidReceivedItem_error_expectedReceivedItem_ptr,\n                    expectedReceivedIdentifier\n                )\n                mstore(\n                    InvalidReceivedItem_error_actualReceivedItem_ptr,\n                    actualReceivedIdentifier\n                )\n                mstore(InvalidReceivedItem_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidReceivedItem(uint256,uint256,bytes32)\",\n                //     expectedReceivedIdentifier,\n                //     actualReceievedIdentifier,\n                //     orderHash\n                // ))\n                revert(0x1c, InvalidReceivedItem_error_length)\n            }\n        }\n    }\n}\n"
    },
    "src/types/lib/ConsiderationStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BasicOrderType, ItemType, OrderType, Side\n} from \"./ConsiderationEnums.sol\";\n\nimport { CalldataPointer, MemoryPointer } from \"../helpers/PointerLibraries.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n        // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n        // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n\nusing StructPointers for OrderComponents global;\nusing StructPointers for OfferItem global;\nusing StructPointers for ConsiderationItem global;\nusing StructPointers for SpentItem global;\nusing StructPointers for ReceivedItem global;\nusing StructPointers for BasicOrderParameters global;\nusing StructPointers for AdditionalRecipient global;\nusing StructPointers for OrderParameters global;\nusing StructPointers for Order global;\nusing StructPointers for AdvancedOrder global;\nusing StructPointers for OrderStatus global;\nusing StructPointers for CriteriaResolver global;\nusing StructPointers for Fulfillment global;\nusing StructPointers for FulfillmentComponent global;\nusing StructPointers for Execution global;\nusing StructPointers for ZoneParameters global;\n\n/**\n * @dev This library provides a set of functions for converting structs to\n *      pointers.\n */\nlibrary StructPointers {\n    /**\n     * @dev Get a MemoryPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(OrderComponents memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(OrderComponents calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(OfferItem memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(OfferItem calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(ConsiderationItem memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(ConsiderationItem calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(SpentItem memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(SpentItem calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(ReceivedItem memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(ReceivedItem calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(BasicOrderParameters memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(BasicOrderParameters calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(AdditionalRecipient memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(AdditionalRecipient calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(OrderParameters memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(OrderParameters calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(Order memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(Order calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(AdvancedOrder memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(AdvancedOrder calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(OrderStatus memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(OrderStatus calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(CriteriaResolver memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(CriteriaResolver calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(Fulfillment memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(Fulfillment calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(FulfillmentComponent memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(FulfillmentComponent calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(Execution memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(Execution calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(ZoneParameters memory obj)\n        internal\n        pure\n        returns (MemoryPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(ZoneParameters calldata obj)\n        internal\n        pure\n        returns (CalldataPointer ptr)\n    {\n        assembly {\n            ptr := obj\n        }\n    }\n}\n"
    },
    "src/main/interfaces/ZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ZoneInterface } from \"seaport-types/src/interfaces/ZoneInterface.sol\";\n\ninterface LocalZoneInterface is ZoneInterface { }\n"
    },
    "src/main/zones/signed-zone/interfaces/SignedZoneEventsAndErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @notice SignedZoneEventsAndErrors contains errors and events\n *         related to zone interaction.\n */\ninterface SignedZoneEventsAndErrors {\n    /**\n     * @dev Emit an event when a new signer is added.\n     */\n    event SignerAdded(address signer);\n\n    /**\n     * @dev Emit an event when a signer is removed.\n     */\n    event SignerRemoved(address signer);\n\n    /**\n     * @dev Revert with an error when the signature has expired.\n     */\n    error SignatureExpired(uint256 expiration, bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when the caller is not seaport.\n     */\n    error CallerNotSeaport();\n\n    /**\n     * @dev Revert with an error when attempting to update the signers of a\n     *      the zone from a caller that is not the zone's controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Revert with an error if supplied order extraData is an invalid\n     *      length.\n     */\n    error InvalidExtraDataLength(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's SIP6 version.\n     */\n    error InvalidSIP6Version(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's substandard requirements.\n     */\n    error InvalidSubstandardSupport(\n        string reason,\n        uint256 substandardVersion,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the supplied order extraData does not\n     *      support the zone's substandard version.\n     */\n    error InvalidSubstandardVersion(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error if the fulfiller does not match.\n     */\n    error InvalidFulfiller(\n        address expectedFulfiller,\n        address actualFulfiller,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the received item does not match.\n     */\n    error InvalidReceivedItem(\n        uint256 expectedReceivedIdentifier,\n        uint256 actualReceievedIdentifier,\n        bytes32 orderHash\n    );\n\n    /**\n     * @dev Revert with an error if the zone parameter encoding is invalid.\n     */\n    error InvalidZoneParameterEncoding();\n\n    /**\n     * @dev Revert with an error when an order is signed with a signer\n     *      that is not active.\n     */\n    error SignerNotActive(address signer, bytes32 orderHash);\n\n    /**\n     * @dev Revert when an unsupported function selector is found.\n     */\n    error UnsupportedFunctionSelector();\n}\n"
    },
    "src/main/zones/interfaces/SIP5Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Schema } from \"../../../types/lib/ConsiderationStructs.sol\";\n\n/**\n * @dev SIP-5: Contract Metadata Interface for Seaport Contracts\n *      https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-5.md\n */\ninterface SIP5Interface {\n    /**\n     * @dev An event that is emitted when a SIP-5 compatible contract is deployed.\n     */\n    event SeaportCompatibleContractDeployed();\n\n    /**\n     * @dev Returns Seaport metadata for this contract, returning the\n     *      contract name and supported schemas.\n     *\n     * @return name    The contract name\n     * @return schemas The supported SIPs\n     */\n    function getSeaportMetadata()\n        external\n        view\n        returns (string memory name, Schema[] memory schemas);\n}\n"
    },
    "src/main/zones/signed-zone/interfaces/SignedZoneControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title  SignedZoneControllerInterface\n * @author BCLeFevre\n * @notice SignedZoneControllerInterface enables the deploying of SignedZones.\n *         SignedZones are an implementation of SIP-7 that requires orders\n *         to be signed by an approved signer.\n *         https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md\n *\n */\ninterface SignedZoneControllerInterface {\n    /**\n     * @notice Returns the active signers for the zone.\n     *\n     * @param signedZone The signed zone to get the active signers for.\n     *\n     * @return signers The active signers.\n     */\n    function getActiveSigners(\n        address signedZone\n    ) external view returns (address[] memory signers);\n\n    /**\n     * @notice Returns additional information about the zone.\n     *\n     * @param zone The zone to get the additional information for.\n     *\n     * @return domainSeparator  The domain separator used for signing.\n     * @return zoneName         The name of the zone.\n     * @return apiEndpoint      The API endpoint for the zone.\n     * @return substandards     The substandards supported by the zone.\n     * @return documentationURI The documentation URI for the zone.\n     */\n    function getAdditionalZoneInformation(\n        address zone\n    )\n        external\n        view\n        returns (\n            bytes32 domainSeparator,\n            string memory zoneName,\n            string memory apiEndpoint,\n            uint256[] memory substandards,\n            string memory documentationURI\n        );\n\n    /**\n     * @notice Update the API endpoint returned by the supplied zone.\n     *         Only the owner or an active signer can call this function.\n     *\n     * @param signedZone     The signed zone to update the API endpoint for.\n     * @param newApiEndpoint The new API endpoint.\n     */\n    function updateAPIEndpoint(\n        address signedZone,\n        string calldata newApiEndpoint\n    ) external;\n\n    /**\n     * @notice Update the documentationURI returned by a zone.\n     *         Only the owner or an active signer of the supplied zone can call\n     *         this function.\n     *\n     * @param zone             The signed zone to update the API endpoint for.\n     * @param documentationURI The new documentation URI.\n     */\n    function updateDocumentationURI(\n        address zone,\n        string calldata documentationURI\n    ) external;\n\n    /**\n     * @notice Update the signer for a given signed zone.\n     *\n     * @param signedZone The signed zone to update the signer for.\n     * @param signer     The signer to update.\n     * @param active     If the signer should be active or not.\n     */\n    function updateSigner(\n        address signedZone,\n        address signer,\n        bool active\n    ) external;\n\n    /**\n     * @notice Initiate zone ownership transfer by assigning a new potential\n     *         owner for the given zone. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone              The zone for which to initiate ownership\n     *                          transfer.\n     * @param newPotentialOwner The new potential owner of the zone.\n     */\n    function transferOwnership(\n        address zone,\n        address newPotentialOwner\n    ) external;\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a zone.\n     *         Only the owner of the zone in question may call this function.\n     *\n     * @param zone The zone for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address zone) external;\n\n    /**\n     * @notice Accept ownership of a supplied zone. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param zone The zone for which to accept ownership.\n     */\n    function acceptOwnership(address zone) external;\n\n    /**\n     * @notice Retrieve the current owner of a deployed zone.\n     *\n     * @param zone The zone for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied zone.\n     */\n    function ownerOf(address zone) external view returns (address owner);\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given zone. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the zone in question via `acceptOwnership`.\n     *\n     * @param zone The zone for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the zone.\n     */\n    function getPotentialOwner(\n        address zone\n    ) external view returns (address potentialOwner);\n\n    /**\n     * @notice Returns whether or not the supplied address is an active signer\n     *         for the supplied zone.\n     *\n     * @param zone   The zone to check if the supplied address is an active\n     *               signer for.\n     * @param signer The address to check if it is an active signer for\n     *\n     * @return active If the supplied address is an active signer for the\n     *                supplied zone.\n     */\n    function isActiveSigner(\n        address zone,\n        address signer\n    ) external view returns (bool);\n}\n"
    },
    "lib/erc721c-seaport/src/interfaces/IAuthorizedTransferSecurityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nenum ListTypes {\n    AuthorizerList,\n    OperatorList\n}\n\n/// @title IAuthorizedTransferSecurityRegistry\n/// @dev Interface for the Authorized Transfer Security Registry, a simplified version of the Transfer\n///      Security Registry that only supports authorizers and whitelisted operators, and assumes a\n///      security level of OperatorWhitelistEnableOTC + authorizers for all collections that use it.\n///      Note that a number of view functions on collections that add this validator will not work.\ninterface IAuthorizedTransferSecurityRegistry {\n    event CreatedList(uint256 indexed id, string name);\n    event AppliedListToCollection(address indexed collection, uint120 indexed id);\n    event ReassignedListOwnership(uint256 indexed id, address indexed newOwner);\n    event AddedAccountToList(ListTypes indexed kind, uint256 indexed id, address indexed account);\n    event RemovedAccountFromList(ListTypes indexed kind, uint256 indexed id, address indexed account);\n\n    error AuthorizedTransferSecurityRegistry__ListDoesNotExist();\n    error AuthorizedTransferSecurityRegistry__CallerDoesNotOwnList();\n    error AuthorizedTransferSecurityRegistry__ArrayLengthCannotBeZero();\n    error AuthorizedTransferSecurityRegistry__CallerMustHaveElevatedPermissionsForSpecifiedNFT();\n    error AuthorizedTransferSecurityRegistry__ListOwnershipCannotBeTransferredToZeroAddress();\n    error AuthorizedTransferSecurityRegistry__ZeroAddressNotAllowed();\n    error AuthorizedTransferSecurityRegistry__UnauthorizedTransfer();\n    error AuthorizedTransferSecurityRegistry__CallerIsNotValidAuthorizer();\n\n    /// Manage lists of authorizers & operators that can be applied to collections\n    function createList(string calldata name) external returns (uint120);\n    function createListCopy(string calldata name, uint120 sourceListId) external returns (uint120);\n    function reassignOwnershipOfList(uint120 id, address newOwner) external;\n    function renounceOwnershipOfList(uint120 id) external;\n    function applyListToCollection(address collection, uint120 id) external;\n    function listOwners(uint120 id) external view returns (address);\n\n    /// Manage and query for authorizers on lists\n    function addAuthorizers(uint120 id, address[] calldata accounts) external;\n    function removeAuthorizers(uint120 id, address[] calldata accounts) external;\n    function getAuthorizers(uint120 id) external view returns (address[] memory);\n    function isAuthorizer(uint120 id, address account) external view returns (bool);\n    function getAuthorizersByCollection(address collection) external view returns (address[] memory);\n    function isAuthorizerByCollection(address collection, address account) external view returns (bool);\n\n    /// Manage and query for operators on lists\n    function addOperators(uint120 id, address[] calldata accounts) external;\n    function removeOperators(uint120 id, address[] calldata accounts) external;\n    function getOperators(uint120 id) external view returns (address[] memory);\n    function isOperator(uint120 id, address account) external view returns (bool);\n    function getOperatorsByCollection(address collection) external view returns (address[] memory);\n    function isOperatorByCollection(address collection, address account) external view returns (bool);\n\n    /// Ensure that a specific operator has been authorized to transfer tokens\n    function validateTransfer(address caller, address from, address to) external view;\n\n    /// Ensure that a transfer has been authorized for a specific tokenId\n    function validateTransfer(address caller, address from, address to, uint256 tokenId) external view;\n\n    /// Ensure that a transfer has been authorized for a specific amount of a specific tokenId, and\n    /// reduce the transferable amount remaining\n    function validateTransfer(address caller, address from, address to, uint256 tokenId, uint256 amount) external;\n\n    /// Legacy alias for validateTransfer (address caller, address from, address to)\n    function applyCollectionTransferPolicy(address caller, address from, address to) external view;\n\n    /// Temporarily assign a specific allowed operator for a given collection\n    function beforeAuthorizedTransfer(address operator, address token) external;\n\n    /// Clear assignment of a specific allowed operator for a given collection\n    function afterAuthorizedTransfer(address token) external;\n\n    /// Temporarily allow a specific tokenId from a given collection to be transferred\n    function beforeAuthorizedTransfer(address token, uint256 tokenId) external;\n\n    /// Clear assignment of an specific tokenId's transfer allowance\n    function afterAuthorizedTransfer(address token, uint256 tokenId) external;\n\n    /// Temporarily allow a specific amount of a specific tokenId from a given collection to be transferred\n    function beforeAuthorizedTransferWithAmount(address token, uint256 tokenId, uint256 amount) external;\n\n    /// Clear assignment of a tokenId's transfer allowance for a specific amount\n    function afterAuthorizedTransferWithAmount(address token, uint256 tokenId) external;\n}"
    },
    "src/main/zones/signed-zone/signed-zone-sub-1/lib/SignedZoneConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @dev ECDSA signature offsets.\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\n/// @dev Helpers for memory offsets.\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\nuint256 constant Signature_lower_v = 27;\nuint256 constant MaxUint8 = 0xff;\nbytes32 constant EIP2098_allButHighestBitMask = (\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n);\nuint256 constant Ecrecover_precompile = 1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant Slot0x80 = 0x80;\n\n/// @dev The EIP-712 digest offsets.\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_SignedOrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\nuint256 constant EIP_712_PREFIX = (\n    0x1901000000000000000000000000000000000000000000000000000000000000\n);\n\n// @dev Function selectors used in the fallback function..\nbytes4 constant UPDATE_SIGNER_SELECTOR = 0xf460590b;\nbytes4 constant GET_ACTIVE_SIGNERS_SELECTOR = 0xa784b80c;\nbytes4 constant IS_ACTIVE_SIGNER_SELECTOR = 0x7dff5a79;\nbytes4 constant SUPPORTS_INTERFACE_SELECTOR = 0x01ffc9a7;\n\n/*\n *  error InvalidController()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidController_error_selector = 0x6d5769be;\nuint256 constant InvalidController_error_length = 0x04;\n\n/*\n *  error InvalidFulfiller(address expectedFulfiller, address actualFulfiller, bytes32 orderHash)\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: expectedFulfiller\n *    - 0x40: actualFullfiller\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant InvalidFulfiller_error_selector = 0x1bcf9bb7;\nuint256 constant InvalidFulfiller_error_expectedFulfiller_ptr = 0x20;\nuint256 constant InvalidFulfiller_error_actualFulfiller_ptr = 0x40;\nuint256 constant InvalidFulfiller_error_orderHash_ptr = 0x60;\nuint256 constant InvalidFulfiller_error_length = 0x64;\n\n/*\n *  error InvalidReceivedItem(uint256 expectedReceivedIdentifier, uint256 actualReceievedIdentifier, bytes32 orderHash)\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: expectedReceivedIdentifier\n *    - 0x40: actualReceievedIdentifier\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant InvalidReceivedItem_error_selector = 0xb36c03e8;\nuint256 constant InvalidReceivedItem_error_expectedReceivedItem_ptr = 0x20;\nuint256 constant InvalidReceivedItem_error_actualReceivedItem_ptr = 0x40;\nuint256 constant InvalidReceivedItem_error_orderHash_ptr = 0x60;\nuint256 constant InvalidReceivedItem_error_length = 0x64;\n\n/*\n *  error InvalidZoneParameterEncoding()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidZoneParameterEncoding_error_selector = 0x46d5d895;\nuint256 constant InvalidZoneParameterEncoding_error_length = 0x04;\n\n/*\n * error InvalidExtraDataLength()\n *   - Defined in SignedZoneEventsAndErrors.sol\n * Memory layout:\n *   - 0x00: Left-padded selector (data begins at 0x1c)\n *   - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidExtraDataLength_error_selector = 0xd232fd2c;\nuint256 constant InvalidExtraDataLength_error_orderHash_ptr = 0x20;\nuint256 constant InvalidExtraDataLength_error_length = 0x24;\nuint256 constant InvalidExtraDataLength_expected_length_substandard_1 = 0x7e; // 126\nuint256 constant InvalidExtraDataLength_expected_length_substandard_7 = 0xa6; // 166\nuint256 constant InvalidExtraDataLength_expected_length_substandard_8_or_9 = 0x92; // 146\n\nuint256 constant ExtraData_expiration_offset = 0x35;\nuint256 constant ExtraData_substandard_version_byte_offset = 0x7d;\n/*\n *  error InvalidSIP6Version()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidSIP6Version_error_selector = 0x64115774;\nuint256 constant InvalidSIP6Version_error_orderHash_ptr = 0x20;\nuint256 constant InvalidSIP6Version_error_length = 0x24;\n\n/*\n *  error InvalidSubstandardVersion()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidSubstandardVersion_error_selector = 0x26787999;\nuint256 constant InvalidSubstandardVersion_error_orderHash_ptr = 0x20;\nuint256 constant InvalidSubstandardVersion_error_length = 0x24;\n\n/*\n *  error InvalidSubstandardSupport()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: reason\n *    - 0x40: substandardVersion\n *    - 0x60: orderHash\n * Revert buffer is memory[0x1c:0xe0]\n */\nuint256 constant InvalidSubstandardSupport_error_selector = 0x2be76224;\nuint256 constant InvalidSubstandardSupport_error_reason_offset_ptr = 0x20;\nuint256 constant InvalidSubstandardSupport_error_substandard_version_ptr = 0x40;\nuint256 constant InvalidSubstandardSupport_error_orderHash_ptr = 0x60;\nuint256 constant InvalidSubstandardSupport_error_reason_length_ptr = 0x80;\nuint256 constant InvalidSubstandardSupport_error_reason_ptr = 0xa0;\nuint256 constant InvalidSubstandardSupport_error_reason_2_ptr = 0xc0;\nuint256 constant InvalidSubstandardSupport_error_length = 0xc4;\n\n/*\n * error SignatureExpired()\n *   - Defined in SignedZoneEventsAndErrors.sol\n * Memory layout:\n *   - 0x00: Left-padded selector (data begins at 0x1c)\n *   - 0x20: expiration\n *   - 0x40: orderHash\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant SignatureExpired_error_selector = 0x16546071;\nuint256 constant SignatureExpired_error_expiration_ptr = 0x20;\nuint256 constant SignatureExpired_error_orderHash_ptr = 0x40;\nuint256 constant SignatureExpired_error_length = 0x44;\n\n/*\n *  error UnsupportedFunctionSelector()\n *    - Defined in SignedZoneEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant UnsupportedFunctionSelector_error_selector = 0x54c91b87;\nuint256 constant UnsupportedFunctionSelector_error_length = 0x04;\n\n// Zone parameter calldata pointers\nuint256 constant Zone_parameters_cdPtr = 0x04;\nuint256 constant Zone_parameters_fulfiller_cdPtr = 0x44;\nuint256 constant Zone_consideration_head_cdPtr = 0xa4;\nuint256 constant Zone_extraData_cdPtr = 0xc4;\n\n// Zone parameter memory pointers\nuint256 constant Zone_parameters_ptr = 0x20;\n\n// Zone parameter offsets\nuint256 constant Zone_parameters_offset = 0x24;\nuint256 constant expectedFulfiller_offset = 0x45;\nuint256 constant actualReceivedIdentifier_offset = 0x84;\nuint256 constant expectedReceivedIdentifier_offset = 0xa2;\n\n// Spent Item Size\nuint256 constant SpentItem_size = 0x80;\n\n// Received Item Size\nuint256 constant ReceivedItem_size = 0xa0;\n"
    },
    "src/types/lib/ConsiderationEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum OrderType\n// 0: no partial fills, anyone can execute\n{\n    FULL_OPEN,\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n    // 4: contract order type\n    CONTRACT\n}\n\nenum BasicOrderType\n// 0: no partial fills, anyone can execute\n{\n    ETH_TO_ERC721_FULL_OPEN,\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\nenum BasicOrderRouteType\n// 0: provide Ether (or other native token) to receive offered ERC721 item.\n{\n    ETH_TO_ERC721,\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\nenum ItemType\n// 0: ETH on mainnet, MATIC on polygon, etc.\n{\n    NATIVE,\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n    // 2: ERC721 items\n    ERC721,\n    // 3: ERC1155 items\n    ERC1155,\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\nenum Side\n// 0: Items that can be spent\n{\n    OFFER,\n    // 1: Items that must be received\n    CONSIDERATION\n}\n"
    },
    "src/types/helpers/PointerLibraries.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype CalldataPointer is uint256;\n\ntype ReturndataPointer is uint256;\n\ntype MemoryPointer is uint256;\n\nusing CalldataPointerLib for CalldataPointer global;\nusing MemoryPointerLib for MemoryPointer global;\nusing ReturndataPointerLib for ReturndataPointer global;\n\nusing CalldataReaders for CalldataPointer global;\nusing ReturndataReaders for ReturndataPointer global;\nusing MemoryReaders for MemoryPointer global;\nusing MemoryWriters for MemoryPointer global;\n\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\nMemoryPointer constant ZeroSlotPtr = MemoryPointer.wrap(0x60);\nuint256 constant IdentityPrecompileAddress = 0x4;\nuint256 constant OffsetOrLengthMask = 0xffffffff;\nuint256 constant _OneWord = 0x20;\nuint256 constant _FreeMemoryPointerSlot = 0x40;\n\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\n///    and returns the memory pointer to the first byte of the allocated region.\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\n    assembly {\n        mPtr := mload(_FreeMemoryPointerSlot)\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\n    }\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\n    FreeMemoryPPtr.write(mPtr);\n}\n\nlibrary CalldataPointerLib {\n    function lt(CalldataPointer a, CalldataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(CalldataPointer a, CalldataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(CalldataPointer a, CalldataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `cdPtr + headOffset`.\n    function pptrOffset(CalldataPointer cdPtr, uint256 headOffset)\n        internal\n        pure\n        returns (CalldataPointer cdPtrChild)\n    {\n        cdPtrChild = cdPtr.offset(\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\n    ///      first member, e.g. `struct { bytes data; }`\n    function pptr(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (CalldataPointer cdPtrChild)\n    {\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\n    function next(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (CalldataPointer cdPtrNext)\n    {\n        assembly {\n            cdPtrNext := add(cdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\n    function offset(CalldataPointer cdPtr, uint256 _offset)\n        internal\n        pure\n        returns (CalldataPointer cdPtrNext)\n    {\n        assembly {\n            cdPtrNext := add(cdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\n    ///      `dst`.\n    function copy(CalldataPointer src, MemoryPointer dst, uint256 size)\n        internal\n        pure\n    {\n        assembly {\n            calldatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary ReturndataPointerLib {\n    function lt(ReturndataPointer a, ReturndataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(ReturndataPointer a, ReturndataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(ReturndataPointer a, ReturndataPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `rdPtr + headOffset`.\n    function pptrOffset(ReturndataPointer rdPtr, uint256 headOffset)\n        internal\n        pure\n        returns (ReturndataPointer rdPtrChild)\n    {\n        rdPtrChild = rdPtr.offset(\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (ReturndataPointer rdPtrChild)\n    {\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\n    function next(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (ReturndataPointer rdPtrNext)\n    {\n        assembly {\n            rdPtrNext := add(rdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\n    function offset(ReturndataPointer rdPtr, uint256 _offset)\n        internal\n        pure\n        returns (ReturndataPointer rdPtrNext)\n    {\n        assembly {\n            rdPtrNext := add(rdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\n    /// `dst`.\n    function copy(ReturndataPointer src, MemoryPointer dst, uint256 size)\n        internal\n        pure\n    {\n        assembly {\n            returndatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary MemoryPointerLib {\n    function copy(MemoryPointer src, MemoryPointer dst, uint256 size)\n        internal\n        view\n    {\n        assembly {\n            let success :=\n                staticcall(gas(), IdentityPrecompileAddress, src, size, dst, size)\n            if or(iszero(returndatasize()), iszero(success)) { revert(0, 0) }\n        }\n    }\n\n    function lt(MemoryPointer a, MemoryPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(MemoryPointer a, MemoryPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(MemoryPointer a, MemoryPointer b)\n        internal\n        pure\n        returns (bool c)\n    {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    function hash(MemoryPointer ptr, uint256 length)\n        internal\n        pure\n        returns (bytes32 _hash)\n    {\n        assembly {\n            _hash := keccak256(ptr, length)\n        }\n    }\n\n    /// @dev Returns the memory pointer one word after `mPtr`.\n    function next(MemoryPointer mPtr)\n        internal\n        pure\n        returns (MemoryPointer mPtrNext)\n    {\n        assembly {\n            mPtrNext := add(mPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\n    function offset(MemoryPointer mPtr, uint256 _offset)\n        internal\n        pure\n        returns (MemoryPointer mPtrNext)\n    {\n        assembly {\n            mPtrNext := add(mPtr, _offset)\n        }\n    }\n\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\n    ///    type's pointer stored at `mPtr + headOffset`.\n    function pptrOffset(MemoryPointer mPtr, uint256 headOffset)\n        internal\n        pure\n        returns (MemoryPointer mPtrChild)\n    {\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\n    }\n\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\n    ///    `mPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(MemoryPointer mPtr)\n        internal\n        pure\n        returns (MemoryPointer mPtrChild)\n    {\n        mPtrChild = mPtr.readMemoryPointer();\n    }\n}\n\nlibrary CalldataReaders {\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\n    ///    last 4 bytes.\n    function readMaskedUint256(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `cdPtr` in calldata.\n    function readBool(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bool value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the address at `cdPtr` in calldata.\n    function readAddress(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (address value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\n    function readBytes1(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes1 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\n    function readBytes2(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes2 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\n    function readBytes3(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes3 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\n    function readBytes4(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes4 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\n    function readBytes5(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes5 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\n    function readBytes6(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes6 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\n    function readBytes7(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes7 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\n    function readBytes8(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes8 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\n    function readBytes9(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes9 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\n    function readBytes10(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes10 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\n    function readBytes11(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes11 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\n    function readBytes12(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes12 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\n    function readBytes13(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes13 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\n    function readBytes14(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes14 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\n    function readBytes15(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes15 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\n    function readBytes16(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes16 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\n    function readBytes17(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes17 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\n    function readBytes18(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes18 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\n    function readBytes19(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes19 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\n    function readBytes20(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes20 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\n    function readBytes21(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes21 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\n    function readBytes22(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes22 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\n    function readBytes23(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes23 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\n    function readBytes24(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes24 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\n    function readBytes25(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes25 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\n    function readBytes26(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes26 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\n    function readBytes27(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes27 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\n    function readBytes28(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes28 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\n    function readBytes29(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes29 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\n    function readBytes30(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes30 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\n    function readBytes31(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes31 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\n    function readBytes32(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (bytes32 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\n    function readUint8(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint8 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\n    function readUint16(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint16 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\n    function readUint24(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint24 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\n    function readUint32(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint32 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\n    function readUint40(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint40 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\n    function readUint48(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint48 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\n    function readUint56(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint56 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\n    function readUint64(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint64 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\n    function readUint72(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint72 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\n    function readUint80(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint80 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\n    function readUint88(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint88 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\n    function readUint96(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint96 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\n    function readUint104(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint104 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\n    function readUint112(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint112 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\n    function readUint120(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint120 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\n    function readUint128(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint128 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\n    function readUint136(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint136 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\n    function readUint144(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint144 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\n    function readUint152(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint152 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\n    function readUint160(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint160 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\n    function readUint168(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint168 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\n    function readUint176(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint176 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\n    function readUint184(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint184 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\n    function readUint192(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint192 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\n    function readUint200(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint200 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\n    function readUint208(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint208 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\n    function readUint216(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint216 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\n    function readUint224(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint224 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\n    function readUint232(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint232 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\n    function readUint240(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint240 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\n    function readUint248(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint248 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\n    function readUint256(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `cdPtr` in calldata.\n    function readInt8(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int8 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `cdPtr` in calldata.\n    function readInt16(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int16 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `cdPtr` in calldata.\n    function readInt24(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int24 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `cdPtr` in calldata.\n    function readInt32(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int32 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `cdPtr` in calldata.\n    function readInt40(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int40 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `cdPtr` in calldata.\n    function readInt48(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int48 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `cdPtr` in calldata.\n    function readInt56(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int56 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `cdPtr` in calldata.\n    function readInt64(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int64 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `cdPtr` in calldata.\n    function readInt72(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int72 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `cdPtr` in calldata.\n    function readInt80(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int80 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `cdPtr` in calldata.\n    function readInt88(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int88 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `cdPtr` in calldata.\n    function readInt96(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int96 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `cdPtr` in calldata.\n    function readInt104(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int104 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `cdPtr` in calldata.\n    function readInt112(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int112 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `cdPtr` in calldata.\n    function readInt120(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int120 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `cdPtr` in calldata.\n    function readInt128(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int128 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `cdPtr` in calldata.\n    function readInt136(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int136 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `cdPtr` in calldata.\n    function readInt144(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int144 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `cdPtr` in calldata.\n    function readInt152(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int152 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `cdPtr` in calldata.\n    function readInt160(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int160 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `cdPtr` in calldata.\n    function readInt168(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int168 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `cdPtr` in calldata.\n    function readInt176(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int176 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `cdPtr` in calldata.\n    function readInt184(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int184 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `cdPtr` in calldata.\n    function readInt192(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int192 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `cdPtr` in calldata.\n    function readInt200(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int200 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `cdPtr` in calldata.\n    function readInt208(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int208 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `cdPtr` in calldata.\n    function readInt216(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int216 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `cdPtr` in calldata.\n    function readInt224(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int224 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `cdPtr` in calldata.\n    function readInt232(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int232 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `cdPtr` in calldata.\n    function readInt240(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int240 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `cdPtr` in calldata.\n    function readInt248(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int248 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `cdPtr` in calldata.\n    function readInt256(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (int256 value)\n    {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n}\n\nlibrary ReturndataReaders {\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `rdPtr` in returndata.\n    function readBool(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bool value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the address at `rdPtr` in returndata.\n    function readAddress(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (address value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\n    function readBytes1(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes1 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\n    function readBytes2(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes2 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\n    function readBytes3(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes3 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\n    function readBytes4(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes4 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\n    function readBytes5(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes5 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\n    function readBytes6(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes6 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\n    function readBytes7(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes7 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\n    function readBytes8(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes8 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\n    function readBytes9(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes9 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\n    function readBytes10(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes10 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\n    function readBytes11(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes11 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\n    function readBytes12(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes12 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\n    function readBytes13(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes13 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\n    function readBytes14(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes14 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\n    function readBytes15(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes15 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\n    function readBytes16(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes16 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\n    function readBytes17(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes17 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\n    function readBytes18(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes18 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\n    function readBytes19(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes19 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\n    function readBytes20(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes20 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\n    function readBytes21(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes21 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\n    function readBytes22(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes22 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\n    function readBytes23(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes23 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\n    function readBytes24(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes24 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\n    function readBytes25(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes25 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\n    function readBytes26(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes26 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\n    function readBytes27(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes27 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\n    function readBytes28(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes28 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\n    function readBytes29(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes29 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\n    function readBytes30(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes30 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\n    function readBytes31(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes31 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\n    function readBytes32(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (bytes32 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\n    function readUint8(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint8 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\n    function readUint16(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint16 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\n    function readUint24(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint24 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\n    function readUint32(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint32 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\n    function readUint40(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint40 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\n    function readUint48(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint48 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\n    function readUint56(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint56 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\n    function readUint64(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint64 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\n    function readUint72(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint72 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\n    function readUint80(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint80 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\n    function readUint88(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint88 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\n    function readUint96(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint96 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\n    function readUint104(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint104 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\n    function readUint112(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint112 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\n    function readUint120(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint120 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\n    function readUint128(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint128 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\n    function readUint136(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint136 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\n    function readUint144(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint144 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\n    function readUint152(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint152 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\n    function readUint160(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint160 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\n    function readUint168(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint168 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\n    function readUint176(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint176 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\n    function readUint184(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint184 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\n    function readUint192(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint192 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\n    function readUint200(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint200 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\n    function readUint208(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint208 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\n    function readUint216(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint216 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\n    function readUint224(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint224 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\n    function readUint232(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint232 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\n    function readUint240(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint240 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\n    function readUint248(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint248 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\n    function readUint256(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int8 at `rdPtr` in returndata.\n    function readInt8(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int8 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int16 at `rdPtr` in returndata.\n    function readInt16(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int16 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int24 at `rdPtr` in returndata.\n    function readInt24(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int24 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int32 at `rdPtr` in returndata.\n    function readInt32(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int32 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int40 at `rdPtr` in returndata.\n    function readInt40(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int40 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int48 at `rdPtr` in returndata.\n    function readInt48(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int48 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int56 at `rdPtr` in returndata.\n    function readInt56(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int56 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int64 at `rdPtr` in returndata.\n    function readInt64(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int64 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int72 at `rdPtr` in returndata.\n    function readInt72(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int72 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int80 at `rdPtr` in returndata.\n    function readInt80(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int80 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int88 at `rdPtr` in returndata.\n    function readInt88(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int88 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int96 at `rdPtr` in returndata.\n    function readInt96(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int96 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int104 at `rdPtr` in returndata.\n    function readInt104(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int104 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int112 at `rdPtr` in returndata.\n    function readInt112(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int112 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int120 at `rdPtr` in returndata.\n    function readInt120(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int120 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int128 at `rdPtr` in returndata.\n    function readInt128(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int128 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int136 at `rdPtr` in returndata.\n    function readInt136(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int136 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int144 at `rdPtr` in returndata.\n    function readInt144(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int144 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int152 at `rdPtr` in returndata.\n    function readInt152(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int152 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int160 at `rdPtr` in returndata.\n    function readInt160(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int160 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int168 at `rdPtr` in returndata.\n    function readInt168(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int168 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int176 at `rdPtr` in returndata.\n    function readInt176(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int176 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int184 at `rdPtr` in returndata.\n    function readInt184(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int184 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int192 at `rdPtr` in returndata.\n    function readInt192(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int192 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int200 at `rdPtr` in returndata.\n    function readInt200(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int200 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int208 at `rdPtr` in returndata.\n    function readInt208(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int208 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int216 at `rdPtr` in returndata.\n    function readInt216(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int216 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int224 at `rdPtr` in returndata.\n    function readInt224(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int224 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int232 at `rdPtr` in returndata.\n    function readInt232(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int232 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int240 at `rdPtr` in returndata.\n    function readInt240(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int240 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int248 at `rdPtr` in returndata.\n    function readInt248(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int248 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int256 at `rdPtr` in returndata.\n    function readInt256(ReturndataPointer rdPtr)\n        internal\n        pure\n        returns (int256 value)\n    {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n}\n\nlibrary MemoryReaders {\n    /// @dev Reads the memory pointer at `mPtr` in memory.\n    function readMemoryPointer(MemoryPointer mPtr)\n        internal\n        pure\n        returns (MemoryPointer value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = mPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `mPtr` in memory.\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the address at `mPtr` in memory.\n    function readAddress(MemoryPointer mPtr)\n        internal\n        pure\n        returns (address value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `mPtr` in memory.\n    function readBytes1(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes1 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `mPtr` in memory.\n    function readBytes2(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes2 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `mPtr` in memory.\n    function readBytes3(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes3 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `mPtr` in memory.\n    function readBytes4(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes4 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `mPtr` in memory.\n    function readBytes5(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes5 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `mPtr` in memory.\n    function readBytes6(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes6 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `mPtr` in memory.\n    function readBytes7(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes7 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `mPtr` in memory.\n    function readBytes8(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes8 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `mPtr` in memory.\n    function readBytes9(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes9 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `mPtr` in memory.\n    function readBytes10(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes10 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `mPtr` in memory.\n    function readBytes11(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes11 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `mPtr` in memory.\n    function readBytes12(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes12 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `mPtr` in memory.\n    function readBytes13(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes13 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `mPtr` in memory.\n    function readBytes14(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes14 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `mPtr` in memory.\n    function readBytes15(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes15 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `mPtr` in memory.\n    function readBytes16(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes16 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `mPtr` in memory.\n    function readBytes17(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes17 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `mPtr` in memory.\n    function readBytes18(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes18 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `mPtr` in memory.\n    function readBytes19(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes19 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `mPtr` in memory.\n    function readBytes20(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes20 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `mPtr` in memory.\n    function readBytes21(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes21 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `mPtr` in memory.\n    function readBytes22(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes22 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `mPtr` in memory.\n    function readBytes23(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes23 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `mPtr` in memory.\n    function readBytes24(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes24 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `mPtr` in memory.\n    function readBytes25(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes25 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `mPtr` in memory.\n    function readBytes26(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes26 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `mPtr` in memory.\n    function readBytes27(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes27 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `mPtr` in memory.\n    function readBytes28(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes28 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `mPtr` in memory.\n    function readBytes29(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes29 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `mPtr` in memory.\n    function readBytes30(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes30 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `mPtr` in memory.\n    function readBytes31(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes31 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `mPtr` in memory.\n    function readBytes32(MemoryPointer mPtr)\n        internal\n        pure\n        returns (bytes32 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `mPtr` in memory.\n    function readUint8(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint8 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `mPtr` in memory.\n    function readUint16(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint16 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `mPtr` in memory.\n    function readUint24(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint24 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `mPtr` in memory.\n    function readUint32(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint32 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `mPtr` in memory.\n    function readUint40(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint40 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `mPtr` in memory.\n    function readUint48(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint48 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `mPtr` in memory.\n    function readUint56(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint56 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `mPtr` in memory.\n    function readUint64(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint64 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `mPtr` in memory.\n    function readUint72(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint72 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `mPtr` in memory.\n    function readUint80(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint80 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `mPtr` in memory.\n    function readUint88(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint88 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `mPtr` in memory.\n    function readUint96(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint96 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `mPtr` in memory.\n    function readUint104(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint104 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `mPtr` in memory.\n    function readUint112(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint112 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `mPtr` in memory.\n    function readUint120(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint120 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `mPtr` in memory.\n    function readUint128(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint128 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `mPtr` in memory.\n    function readUint136(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint136 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `mPtr` in memory.\n    function readUint144(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint144 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `mPtr` in memory.\n    function readUint152(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint152 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `mPtr` in memory.\n    function readUint160(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint160 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `mPtr` in memory.\n    function readUint168(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint168 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `mPtr` in memory.\n    function readUint176(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint176 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `mPtr` in memory.\n    function readUint184(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint184 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `mPtr` in memory.\n    function readUint192(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint192 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `mPtr` in memory.\n    function readUint200(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint200 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `mPtr` in memory.\n    function readUint208(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint208 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `mPtr` in memory.\n    function readUint216(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint216 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `mPtr` in memory.\n    function readUint224(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint224 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `mPtr` in memory.\n    function readUint232(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint232 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `mPtr` in memory.\n    function readUint240(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint240 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `mPtr` in memory.\n    function readUint248(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint248 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `mPtr` in memory.\n    function readUint256(MemoryPointer mPtr)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `mPtr` in memory.\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `mPtr` in memory.\n    function readInt16(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int16 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `mPtr` in memory.\n    function readInt24(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int24 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `mPtr` in memory.\n    function readInt32(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int32 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `mPtr` in memory.\n    function readInt40(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int40 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `mPtr` in memory.\n    function readInt48(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int48 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `mPtr` in memory.\n    function readInt56(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int56 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `mPtr` in memory.\n    function readInt64(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int64 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `mPtr` in memory.\n    function readInt72(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int72 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `mPtr` in memory.\n    function readInt80(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int80 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `mPtr` in memory.\n    function readInt88(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int88 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `mPtr` in memory.\n    function readInt96(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int96 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `mPtr` in memory.\n    function readInt104(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int104 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `mPtr` in memory.\n    function readInt112(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int112 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `mPtr` in memory.\n    function readInt120(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int120 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `mPtr` in memory.\n    function readInt128(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int128 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `mPtr` in memory.\n    function readInt136(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int136 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `mPtr` in memory.\n    function readInt144(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int144 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `mPtr` in memory.\n    function readInt152(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int152 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `mPtr` in memory.\n    function readInt160(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int160 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `mPtr` in memory.\n    function readInt168(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int168 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `mPtr` in memory.\n    function readInt176(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int176 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `mPtr` in memory.\n    function readInt184(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int184 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `mPtr` in memory.\n    function readInt192(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int192 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `mPtr` in memory.\n    function readInt200(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int200 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `mPtr` in memory.\n    function readInt208(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int208 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `mPtr` in memory.\n    function readInt216(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int216 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `mPtr` in memory.\n    function readInt224(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int224 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `mPtr` in memory.\n    function readInt232(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int232 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `mPtr` in memory.\n    function readInt240(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int240 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `mPtr` in memory.\n    function readInt248(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int248 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `mPtr` in memory.\n    function readInt256(MemoryPointer mPtr)\n        internal\n        pure\n        returns (int256 value)\n    {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n}\n\nlibrary MemoryWriters {\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\n        assembly {\n            mstore(mPtr, valuePtr)\n        }\n    }\n\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, bool value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an address `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, address value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n}\n"
    },
    "src/types/interfaces/ZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ZoneParameters, Schema } from \"../lib/ConsiderationStructs.sol\";\n\nimport { IERC165 } from \"./IERC165.sol\";\n\n/**\n * @title  ZoneInterface\n * @notice Contains functions exposed by a zone.\n */\ninterface ZoneInterface is IERC165 {\n    /**\n     * @dev Authorizes an order before any token fulfillments from any order have been executed by Seaport.\n     *\n     * @param zoneParameters The context about the order fulfillment and any\n     *                       supplied extraData.\n     *\n     * @return authorizedOrderMagicValue The magic value that indicates a valid\n     *                              order.\n     */\n    function authorizeOrder(ZoneParameters calldata zoneParameters)\n        external\n        returns (bytes4 authorizedOrderMagicValue);\n\n    /**\n     * @dev Validates an order after all token fulfillments for all orders have been executed by Seaport.\n     *\n     * @param zoneParameters The context about the order fulfillment and any\n     *                       supplied extraData.\n     *\n     * @return validOrderMagicValue The magic value that indicates a valid\n     *                              order.\n     */\n    function validateOrder(ZoneParameters calldata zoneParameters)\n        external\n        returns (bytes4 validOrderMagicValue);\n\n    /**\n     * @dev Returns the metadata for this zone.\n     *\n     * @return name The name of the zone.\n     * @return schemas The schemas that the zone implements.\n     */\n    function getSeaportMetadata()\n        external\n        view\n        returns (string memory name, Schema[] memory schemas); // map to Seaport Improvement Proposal IDs\n\n    /**\n    * @dev Returns if the zone supports the interfaceId.\n    *\n    * @param interfaceId The interface identifier, as specified in ERC-165.\n    *\n    * @return supportsInterface True if the zone supports interfaceId, false\n    */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        override\n        returns (bool supportsInterface);\n}\n"
    },
    "src/types/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@rari-capital/solmate/=lib/solmate/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "murky/=lib/murky/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "solarray/=lib/solarray/src/",
      "solady/=lib/solady/",
      "seaport-sol/src/=src/sol/",
      "seaport-sol/=src/sol/",
      "seaport-types/src/=src/types/",
      "seaport-types/=src/types/",
      "seaport-core/src/=src/core/",
      "seaport-core/=src/core/",
      "seaport/=src/main/",
      "@limitbreak/creator-token-standards/=lib/erc721c-seaport/lib/creator-token-standards/src/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ERC721A/=lib/erc721c-seaport/lib/creator-token-standards/lib/ERC721A/contracts/",
      "creator-token-standards/=lib/erc721c-seaport/lib/creator-token-standards/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "erc721a/=lib/erc721c-seaport/lib/creator-token-standards/lib/ERC721A/",
      "erc721c-seaport/=lib/erc721c-seaport/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "seaport-deploy/=lib/erc721c-seaport/lib/seaport-deploy/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}