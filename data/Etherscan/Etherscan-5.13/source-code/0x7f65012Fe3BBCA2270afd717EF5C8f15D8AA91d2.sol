{{
  "language": "Solidity",
  "sources": {
    "src/v0.8/vrf/VRFTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/**\n * @title VRFTypes\n * @notice The VRFTypes library is a collection of types that is required to fulfill VRF requests\n * \ton-chain. They must be ABI-compatible with the types used by the coordinator contracts.\n */\nlibrary VRFTypes {\n  // ABI-compatible with VRF.Proof.\n  // This proof is used for VRF V2 and V2Plus.\n  struct Proof {\n    uint256[2] pk;\n    uint256[2] gamma;\n    uint256 c;\n    uint256 s;\n    uint256 seed;\n    address uWitness;\n    uint256[2] cGammaWitness;\n    uint256[2] sHashWitness;\n    uint256 zInv;\n  }\n\n  // ABI-compatible with VRFCoordinatorV2.RequestCommitment.\n  // This is only used for VRF V2.\n  struct RequestCommitment {\n    uint64 blockNum;\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    address sender;\n  }\n\n  // ABI-compatible with VRFCoordinatorV2Plus.RequestCommitment.\n  // This is only used for VRF V2Plus.\n  struct RequestCommitmentV2Plus {\n    uint64 blockNum;\n    uint256 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    address sender;\n    bytes extraArgs;\n  }\n}\n"
    },
    "src/v0.8/vrf/dev/BatchVRFCoordinatorV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line one-contract-per-file\npragma solidity 0.8.19;\n\nimport {VRFTypes} from \"../VRFTypes.sol\";\n\n/**\n * @title BatchVRFCoordinatorV2Plus\n * @notice The BatchVRFCoordinatorV2Plus contract acts as a proxy to write many random responses to the\n * @notice provided VRFCoordinatorV2Plus contract efficiently in a single transaction.\n */\ncontract BatchVRFCoordinatorV2Plus {\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  IVRFCoordinatorV2PlusFulfill public immutable COORDINATOR;\n\n  event ErrorReturned(uint256 indexed requestId, string reason);\n  event RawErrorReturned(uint256 indexed requestId, bytes lowLevelData);\n\n  constructor(address coordinatorAddr) {\n    COORDINATOR = IVRFCoordinatorV2PlusFulfill(coordinatorAddr);\n  }\n\n  /**\n   * @notice fulfills multiple randomness requests with the provided proofs and commitments.\n   * @param proofs the randomness proofs generated by the VRF provider.\n   * @param rcs the request commitments corresponding to the randomness proofs.\n   */\n  function fulfillRandomWords(VRFTypes.Proof[] memory proofs, VRFTypes.RequestCommitmentV2Plus[] memory rcs) external {\n    // solhint-disable-next-line gas-custom-errors\n    require(proofs.length == rcs.length, \"input array arg lengths mismatch\");\n    for (uint256 i = 0; i < proofs.length; ++i) {\n      try COORDINATOR.fulfillRandomWords(proofs[i], rcs[i], false) returns (uint96 /* payment */) {\n        continue;\n      } catch Error(string memory reason) {\n        uint256 requestId = _getRequestIdFromProof(proofs[i]);\n        emit ErrorReturned(requestId, reason);\n      } catch (bytes memory lowLevelData) {\n        uint256 requestId = _getRequestIdFromProof(proofs[i]);\n        emit RawErrorReturned(requestId, lowLevelData);\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the proving key hash associated with this public key.\n   * @param publicKey the key to return the hash of.\n   */\n  function _hashOfKey(uint256[2] memory publicKey) internal pure returns (bytes32) {\n    return keccak256(abi.encode(publicKey));\n  }\n\n  /**\n   * @notice Returns the request ID of the request associated with the given proof.\n   * @param proof the VRF proof provided by the VRF oracle.\n   */\n  function _getRequestIdFromProof(VRFTypes.Proof memory proof) internal pure returns (uint256) {\n    bytes32 keyHash = _hashOfKey(proof.pk);\n    return uint256(keccak256(abi.encode(keyHash, proof.seed)));\n  }\n}\n\ninterface IVRFCoordinatorV2PlusFulfill {\n  function fulfillRandomWords(\n    VRFTypes.Proof memory proof,\n    VRFTypes.RequestCommitmentV2Plus memory rc,\n    bool onlyPremium\n  ) external returns (uint96);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=foundry-lib/forge-std/lib/ds-test/src/",
      "forge-std/=foundry-lib/forge-std/src/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "hardhat/=node_modules/hardhat/",
      "@eth-optimism/=node_modules/@eth-optimism/",
      "@scroll-tech/=node_modules/@scroll-tech/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}