{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n"},"IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: -- MIT --\r\npragma solidity ^0.8.20;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"IUniswapV2Router01.sol":{"content":"// SPDX-License-Identifier: -- MIT --\r\npragma solidity ^0.8.20;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: -- MIT --\r\npragma solidity ^0.8.20;\r\n\r\nimport \u0027./IUniswapV2Router01.sol\u0027;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"poulette.sol":{"content":"// SPDX-License-Identifier: -- MIT --\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IUniswapV2Router01.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\n\r\ncontract MyContract is IERC20 {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    address payable private owner;\r\n    uint256 private constant ETH_DECIMALS = 18;\r\n    uint256 private _totalSupply = 100_000_000 * 10**18;\r\n    uint256 public constant INITIAL_PRICE = 0.0000001 * 10**18;\r\n    uint256 private constant INITIAL_SUPPLY = 50_000_000 * 10**18;\r\n\r\n    address private WETH_Address;\r\n    address private uniswapFactory;\r\n    address private uniswapRouter;\r\n    address private uniswapPair;\r\n\r\n    mapping(address =\u003e uint256) private _balances;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value, uint256 timestamp);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value, uint256 timestamp);\r\n    event LiquidityAdded(uint256 valueTokenA, uint256 valueTokenB, address indexed owner, uint256 value, uint256 timestamp);\r\n    event CreatePool(address uniswapPair, uint256 timestamp);\r\n\r\n    modifier onlyOwnerOrContract() {\r\n        require(msg.sender == owner || msg.sender == address(this), \"Not the owner or contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n\t\tuint size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(addr)\r\n\t\t}\r\n\t\treturn size \u003e 0;\r\n\t}\r\n\r\n\tmodifier onlyNotContractOrThisContract() {\r\n\t\trequire(!isContract(msg.sender) || (isContract(msg.sender) \u0026\u0026 msg.sender == address(this)), \"This is a contract, but not the good one\");\r\n\t\t_;\r\n\t}\r\n\r\n    constructor(string memory _name, string memory _symbol, address _wethAddress, address _uniswapFactory, address _uniswapRouter) payable {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        owner = payable(msg.sender);\r\n        WETH_Address = _wethAddress;\r\n        uniswapFactory = _uniswapFactory;\r\n        uniswapRouter = _uniswapRouter;\r\n        _balances[address(this)] = INITIAL_SUPPLY;\r\n        _balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    function secureRefund() public onlyOwner {\r\n        uint256 contractBalance = address(this).balance;\r\n        owner.transfer(contractBalance);\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        require(recipient != address(0), \"Invalid recipient\");\r\n        require(_balances[msg.sender] \u003e= amount, \"Insufficient balance to tranfer\");\r\n        _balances[msg.sender] = _balances[msg.sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        emit Transfer(msg.sender, recipient, amount, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        require(sender != address(0), \"Invalid sender\");\r\n        require(recipient != address(0), \"Invalid recipient\");\r\n        require(_balances[sender] \u003e= amount, \"Insufficient balance to transferFrom\");\r\n        require(allowance[sender][msg.sender] \u003e= amount, \"Allowance exceeded\");\r\n        _balances[sender] = _balances[sender] - amount;\r\n        _balances[recipient] = _balances[recipient] + amount;\r\n        emit Transfer(sender, recipient, amount, block.timestamp);\r\n        allowance[sender][msg.sender] = allowance[sender][msg.sender] - amount;\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, (allowance[msg.sender][spender] + addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, (allowance[msg.sender][spender] - subtractedValue));\r\n        return true;\r\n    }\r\n\r\n\tfunction getUniswapPair() external view returns (address) {\r\n        return uniswapPair;\r\n    }\r\n\r\n\tfunction createUniswapPoolInternal() internal onlyNotContractOrThisContract {\r\n        require(uniswapPair == address(0), \"Pair already created\");\r\n        uniswapPair = IUniswapV2Factory(uniswapFactory).createPair(address(this), WETH_Address);\r\n\t\trequire(uniswapPair != address(0), \"Uniswap pair creation failed\");\r\n\t\temit CreatePool(uniswapPair, block.timestamp);\r\n\t\taddLiquidityInternal();\r\n\t}\r\n\r\n    function addLiquidityInternal() internal onlyNotContractOrThisContract {\r\n\r\n        require(uniswapPair != address(0), \"Invalid Uniswap pool address\");\r\n        require(_balances[address(this)] \u003e 0, \"Insufficient supply\");\r\n        uint256 amountETH = address(this).balance;\r\n        uint256 amountToken = _balances[address(this)];\r\n        _approve(address(this), uniswapRouter, amountToken);\r\n        require(IERC20(WETH_Address).approve(uniswapRouter, amountETH), \"ETH Approval failed\");\r\n        uint deadline = block.timestamp + 300;\r\n        (uint256 amountTokenInPool, uint256 amountETHInPool, uint256 liquidity) = IUniswapV2Router02(uniswapRouter).addLiquidityETH{value: amountETH}(\r\n            address(this),\r\n            amountToken,\r\n            0,\r\n            0,\r\n            owner,\r\n            deadline\r\n        );\r\n        require(liquidity \u003e 0, \"Adding liquidity failed\");\r\n        emit LiquidityAdded(amountTokenInPool, amountETHInPool, msg.sender, amountToken, block.timestamp);\r\n    }\r\n\r\n    function initiateUniswapPool() public onlyOwner {\r\n        createUniswapPoolInternal();\r\n    }\r\n\r\n    function _approve(address _owner, address spender, uint256 amount) internal onlyNotContractOrThisContract{\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        allowance[_owner][spender] = amount;\r\n        emit Approval(owner, spender, amount, block.timestamp);\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n}\r\n"}}