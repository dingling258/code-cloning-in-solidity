{{
  "language": "Solidity",
  "sources": {
    "src/queryer/Queryer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Utility contract to batch query ERC20 and ERC721 contracts.\n///\n/// @dev Due to RPC static call gas limits, you might need to\n/// break up large queries into several smaller queries and combine their results.\ncontract Queryer {\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                       CUSTOM ERRORS                        */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev `begin` cannot be greater than `end`.\n    error InvalidRange();\n\n    /// @dev `owner` cannot be the zero address.\n    error OwnerIsZeroAddress();\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                      QUERY OPERATIONS                      */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Returns an array of ownerships on `erc721`,\n    /// for the token IDs in `[begin..end)`.\n    function getERC721Ownerships(address erc721, uint256 begin, uint256 end)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"ownerOf(uint256)\")));\n        _directReturn(_getBatchIn(erc721, fnSelector, begin, end));\n    }\n\n    /// @dev Returns the vaults in the range of `[begin..end)`,\n    /// and their respective ERC20 balances.\n    function getVaultsInAndERC20Balances(\n        address vaultManager,\n        address erc20,\n        uint256 begin,\n        uint256 end\n    ) public view returns (address[] memory, uint256[] memory) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if gt(begin, end) {\n                mstore(0x00, 0x561ce9bb) // `InvalidRange()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            let n := sub(end, begin)\n            mstore(m, 0x40) // Store the offset of `vaults`.\n            mstore(add(m, 0x20), add(0x60, shl(5, n))) // Store the offset of `balances`.\n            mstore(add(m, 0x40), n) // Store the length of `vaults`.\n            mstore(add(add(m, 0x60), shl(5, n)), n) // Store the length of `balances`.\n            mstore(0x00, 0x8c13a453) // `vaultAt(uint256)`.\n            let o := add(m, 0x60)\n            for { let i := begin } iszero(eq(i, end)) { i := add(1, i) } {\n                mstore(0x20, i)\n                mstore(o, mul(mload(0x20), staticcall(gas(), vaultManager, 0x1c, 0x24, 0x20, 0x20)))\n                o := add(o, 0x20)\n            }\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            o := add(o, 0x20)\n            let diff := sub(0, add(0x20, shl(5, n)))\n            for { end := add(o, shl(5, n)) } iszero(eq(o, end)) {} {\n                mstore(0x20, mload(add(o, diff)))\n                mstore(o, mul(mload(0x20), staticcall(gas(), erc20, 0x1c, 0x24, 0x20, 0x20)))\n                o := add(o, 0x20)\n            }\n            return(m, sub(end, m))\n        }\n    }\n\n    /// @dev Returns an array of token IDs on `erc721`, owned by `owner`,\n    /// for the token IDs in `[begin..end)`.\n    function getERC721TokensOfOwnerIn(address erc721, address owner, uint256 begin, uint256 end)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            owner := shr(96, shl(96, owner))\n            if iszero(owner) {\n                mstore(0x00, 0x54a4010f) // `OwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            if gt(begin, end) {\n                mstore(0x00, 0x561ce9bb) // `InvalidRange()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            mstore(0x20, owner)\n            let b := mul(mload(0x00), staticcall(gas(), erc721, 0x1c, 0x24, 0x00, 0x20))\n            let m := mload(0x40)\n            let o := add(m, 0x40)\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\n            if b {\n                for {} iszero(eq(begin, end)) { begin := add(begin, 1) } {\n                    mstore(0x20, begin)\n                    let success := staticcall(gas(), erc721, 0x1c, 0x24, 0x20, 0x20)\n                    if iszero(shl(96, xor(owner, mul(mload(0x20), success)))) {\n                        mstore(o, begin)\n                        o := add(o, 0x20)\n                        b := sub(b, 1)\n                        if iszero(b) { break }\n                    }\n                }\n            }\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), shr(5, sub(o, add(m, 0x40))))\n            return(m, sub(o, m))\n        }\n    }\n\n    /// @dev Returns an array of balances on `erc20` for `owners`.\n    function getERC20Balances(address erc20, address[] calldata owners)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"balanceOf(address)\")));\n        _directReturn(_getBatch(erc20, fnSelector, _toBytes32Array(owners)));\n    }\n\n    /// @dev Returns an array of vault addresses for the `owners`.\n    function getVaultsOf(address vaultManager, address[] calldata owners)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"vaultOf(address)\")));\n        _directReturn(_getBatch(vaultManager, fnSelector, _toBytes32Array(owners)));\n    }\n\n    /// @dev Returns an array of vault owners for the `vaults`.\n    function getVaultOwners(address vaultManager, address[] calldata vaults)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"vaultOwner(address)\")));\n        _directReturn(_getBatch(vaultManager, fnSelector, _toBytes32Array(vaults)));\n    }\n\n    /// @dev Returns an array of vault owners for the `vaults`.\n    function getVaultTokenIds(address vaultManager, address[] calldata vaults)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"vaultTokenId(address)\")));\n        _directReturn(_getBatch(vaultManager, fnSelector, _toBytes32Array(vaults)));\n    }\n\n    /// @dev Returns an array of vault addresses for the token IDs in `[begin..end)`.\n    function getVaultsIn(address vaultManager, uint256 begin, uint256 end)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 fnSelector = uint32(bytes4(keccak256(\"vaultAt(uint256)\")));\n        _directReturn(_getBatchIn(vaultManager, fnSelector, begin, end));\n    }\n\n    /// @dev Returns an array of results by querying `target` with `fnSelector` and\n    /// inputs from the range `[begin..end)`.\n    function getBatchIn(address target, bytes4 fnSelector, uint256 begin, uint256 end)\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        _directReturn(_getBatchIn(target, uint32(fnSelector), begin, end));\n    }\n\n    /// @dev Returns an array of results by querying `target` with `fnSelector` and `inputs`.\n    function getBatch(address target, bytes4 fnSelector, bytes32[] calldata inputs)\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        _directReturn(_getBatch(target, uint32(fnSelector), inputs));\n    }\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                      INTERNAL HELPERS                      */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Casts `inputs` to `bytes32[]`.\n    function _toBytes32Array(uint256[] calldata inputs)\n        internal\n        pure\n        returns (bytes32[] calldata casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.offset := inputs.offset\n            casted.length := inputs.length\n        }\n    }\n\n    /// @dev Casts `inputs` to `bytes32[]`.\n    function _toBytes32Array(address[] calldata inputs)\n        internal\n        pure\n        returns (bytes32[] calldata casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.offset := inputs.offset\n            casted.length := inputs.length\n        }\n    }\n\n    /// @dev Performs a general batch query on `target`, with `fnSelector`, with elements\n    /// in the `[begin..end)` range substituted into the zeroth argument of `fnSelector`.\n    function _getBatchIn(address target, uint256 fnSelector, uint256 begin, uint256 end)\n        internal\n        view\n        returns (bytes32[] memory results)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := add(mload(0x40), 0x40)\n            mstore(results, sub(end, begin))\n            if gt(begin, end) {\n                mstore(0x00, 0x561ce9bb) // `InvalidRange()`.\n                revert(0x1c, 0x04)\n            }\n            let o := add(results, 0x20)\n            mstore(0x00, fnSelector)\n            for { let i := begin } iszero(eq(i, end)) { i := add(1, i) } {\n                mstore(0x20, i)\n                mstore(o, mul(mload(0x20), staticcall(gas(), target, 0x1c, 0x24, 0x20, 0x20)))\n                o := add(o, 0x20)\n            }\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Performs a general batch query on `target`, with `fnSelector`.\n    /// Each element of `inputs` is substituted into the zeroth argument of `fnSelector`.\n    function _getBatch(address target, uint256 fnSelector, bytes32[] calldata inputs)\n        internal\n        view\n        returns (bytes32[] memory results)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := add(mload(0x40), 0x40)\n            mstore(results, inputs.length)\n            let o := add(results, 0x20)\n            mstore(0x00, fnSelector)\n            let end := add(inputs.offset, shl(5, inputs.length))\n            for {} iszero(eq(inputs.offset, end)) { inputs.offset := add(0x20, inputs.offset) } {\n                mstore(0x20, calldataload(inputs.offset))\n                mstore(o, mul(mload(0x20), staticcall(gas(), target, 0x1c, 0x24, 0x20, 0x20)))\n                o := add(o, 0x20)\n            }\n            mstore(0x40, o) // Allocate memory.\n        }\n    }\n\n    /// @dev Directly returns `results`, terminating the call context.\n    function _directReturn(bytes32[] memory results) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(sub(results, 0x20), 0x20)\n            return(sub(results, 0x20), add(0x40, shl(5, mload(results))))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=test/utils/forge-std/",
      "murky/=lib/murky/",
      "dn404/=lib/dn404/src/",
      "solady/=lib/solady/src/",
      "ds-test/=lib/murky/lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/murky/lib/forge-std/src/",
      "murky/=lib/murky/",
      "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/",
      "solady/=lib/solady/src/",
      "soledge/=lib/soledge/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}