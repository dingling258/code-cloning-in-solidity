{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/babyzk/StatefulProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IPublicSignalGetter, IntrinsicSignalName } from \"../interfaces/IPublicSignalGetter.sol\";\nimport { IProofVerifier } from \"../interfaces/IProofVerifier.sol\";\nimport { IIssuerRegistry } from \"../interfaces/IIssuerRegistry.sol\";\nimport { ITypeRegistry } from \"../interfaces/ITypeRegistry.sol\";\nimport { IStatefulVerifier, VerifyResult } from \"../interfaces/IStatefulVerifier.sol\";\n\n/// @title BabyzkVerifier\n/// @notice\n/// @dev BabyzkVerifier is a contract that does on-chain stateful verification of zero-knowledge proofs.\ncontract BabyzkStatefulVerifier is IStatefulVerifier, Ownable {\n    error InvalidArgument(string message);\n\n    // constants\n    uint8 public constant STACK_ID = 1;\n\n    /// @dev type registry\n    ITypeRegistry private _typeRegistry;\n\n    /// @dev issuer registry\n    IIssuerRegistry private _issuerRegistry;\n\n    /// @dev BabyzkVerifier constructor\n    /// @param typeRegistry type registry contract\n    /// @param issuerRegistry issuer registry contract\n    constructor(ITypeRegistry typeRegistry, IIssuerRegistry issuerRegistry, address admin) {\n        _typeRegistry = typeRegistry;\n        _issuerRegistry = issuerRegistry;\n        transferOwnership(admin);\n    }\n\n    /// @dev static verification of zero-knowledge proofs that only checks if the proof is valid.\n    /// @dev Code duplication is deliberate for clear separation of concerns.\n    function verifyProofStatic(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 keyId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view override returns (VerifyResult) {\n        if (!_typeRegistry.isTypeFullyInitializedForStack(typeId, STACK_ID)) {\n            return VerifyResult.TYPE_UNINITIALIZED;\n        }\n\n        // static validation\n        {\n            IPublicSignalGetter psGetter = _typeRegistry.getPublicSignalGetter(typeId, STACK_ID);\n\n            // type matches\n            if (typeId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.TYPE), publicSignals)) {\n                return VerifyResult.TYPE_ID_MISMATCH;\n            }\n\n            // context matches\n            if (contextId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.CONTEXT), publicSignals)) {\n                return VerifyResult.CONTEXT_ID_MISMATCH;\n            }\n\n            // keyID matches\n            if (keyId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.KEY_ID), publicSignals)) {\n                return VerifyResult.PUBKEY_INACTIVE;\n            }\n\n            // proof is valid only if its expiration lower bound is not exceeded.\n            {\n                uint256 expiration = psGetter.getPublicSignal(uint8(IntrinsicSignalName.EXPIRATION_LB), publicSignals);\n                if (expiration < block.timestamp) {\n                    return VerifyResult.EXPIRED;\n                }\n            }\n        }\n\n        IProofVerifier verifier = _typeRegistry.getVerifier(typeId, STACK_ID);\n        // zk-SNARK proof verification\n        if (!verifier.verifyProof(proofs, publicSignals)) {\n            return VerifyResult.PROOF_INVALID;\n        }\n        // signal alias check must be done within the verifier.verifyProof.\n        // // signal alias check\n        // if (verifier.isAliased(publicSignals)) {\n        //     return VerifyResult.ALIASED_SIGNAL;\n        // }\n        return VerifyResult.OK;\n    }\n\n    /// @dev Stateful verification of zero-knowledge proofs that checks\n    ///      if the proof is valid and the issuer public key is active, and\n    ///      for revocation checks if the the smt root matches.\n    /// @dev The trust relationship between the credential and issuer is binded by\n    ///      the public key ID:\n    ///      credential <--- signed by ---- publikc key <--- authroized by ---- issuer\n    ///      As long as the issuer set the public key ID to be active, the credential is trusted by the issuer,\n    ///      However, note that it does not mean that the credential is directly generated by the issuer.\n    function verifyProofFull(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view override returns (VerifyResult) {\n        if (!_typeRegistry.isTypeFullyInitializedForStack(typeId, STACK_ID)) {\n            return VerifyResult.TYPE_UNINITIALIZED;\n        }\n\n        // full input validation\n        {\n            IPublicSignalGetter psGetter = _typeRegistry.getPublicSignalGetter(typeId, STACK_ID);\n\n            // type matches\n            if (typeId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.TYPE), publicSignals)) {\n                return VerifyResult.TYPE_ID_MISMATCH;\n            }\n\n            // context matches\n            if (contextId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.CONTEXT), publicSignals)) {\n                return VerifyResult.CONTEXT_ID_MISMATCH;\n            }\n\n            // proof is valid only if the issuer public key is still active.\n            {\n                uint256 keyId = psGetter.getPublicSignal(uint8(IntrinsicSignalName.KEY_ID), publicSignals);\n                if (!_issuerRegistry.isPublicKeyActiveForStack(issuerId, keyId, STACK_ID)) {\n                    return VerifyResult.PUBKEY_INACTIVE;\n                }\n            }\n\n            // proof is valid only if its expiration lower bound is not exceeded.\n            {\n                uint256 expiration = psGetter.getPublicSignal(uint8(IntrinsicSignalName.EXPIRATION_LB), publicSignals);\n                if (expiration < block.timestamp) {\n                    return VerifyResult.EXPIRED;\n                }\n            }\n\n            // proof is valid only if the smt root matches for revocable credentials.\n            if (_typeRegistry.isRevocable(typeId)) {\n                uint256 root = psGetter.getPublicSignal(\n                    uint8(IntrinsicSignalName.SIG_REVOCATION_SMT_ROOT),\n                    publicSignals\n                );\n                uint256 currentRoot = uint256(_issuerRegistry.getSignatureStateRoot(typeId, contextId, issuerId));\n                if (currentRoot != root) {\n                    return VerifyResult.SIG_REVOCATION_SMT_ROOT_MISMATCH;\n                }\n            }\n        }\n\n        IProofVerifier verifier = _typeRegistry.getVerifier(typeId, STACK_ID);\n        // zk-SNARK proof verification\n        if (!verifier.verifyProof(proofs, publicSignals)) {\n            return VerifyResult.PROOF_INVALID;\n        }\n        // signal alias check must be done within the verifier.verifyProof.\n        // // signal alias check\n        // if (verifier.isAliased(publicSignals)) {\n        //     return VerifyResult.ALIASED_SIGNAL;\n        // }\n        return VerifyResult.OK;\n    }\n\n    /// @dev return the type registry\n    function getTypeRegistry() external view override returns (ITypeRegistry) {\n        return _typeRegistry;\n    }\n\n    /// @dev update the type registry\n    function updateTypeRegistry(ITypeRegistry typeRegistry) external onlyOwner {\n        if (typeRegistry == ITypeRegistry(address(0))) {\n            revert InvalidArgument(\"typeRegistry is zero address\");\n        }\n        emit TypeRegistryUpdated(_typeRegistry, typeRegistry);\n        _typeRegistry = typeRegistry;\n    }\n\n    /// @dev return the issuer registry\n    function getIssuerRegistry() external view override returns (IIssuerRegistry) {\n        return _issuerRegistry;\n    }\n\n    /// @dev update the issuer registry\n    function updateIssuerRegistry(IIssuerRegistry issuerRegistry) external onlyOwner {\n        if (issuerRegistry == IIssuerRegistry(address(0))) {\n            revert InvalidArgument(\"issuerRegistry is zero address\");\n        }\n        emit IssuerRegistryUpdated(_issuerRegistry, issuerRegistry);\n        _issuerRegistry = issuerRegistry;\n    }\n}\n"
    },
    "contracts/interfaces/IIssuerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @dev The status of the public key, only active public key can be used for verification.\nenum PublicKeyStatus {\n    UNINITIALIZED,\n    REVOKED,\n    ACTIVE\n}\n\n/// @dev The public key struct\nstruct PublicKey {\n    /// @dev the verification stack id that the public key is enabled for.\n    mapping(uint8 => bool) enabledVerificationStacks;\n    /// @dev the status of the public key\n    PublicKeyStatus status;\n    /// @dev the raw bytes of the public key. Not used in the contract, only for off-chain usage.\n    /// The spec for marshalling the public key is defined by the issuer.\n    bytes raw;\n}\n\n/// @dev The revoked signature ID in a sparsed merkle tree.\nstruct SignatureState {\n    /// @dev the root hash of the sparsed merkle tree.\n    bytes32 root;\n    /// @dev uri to the sparsed merkle tree, representing the revoked signature ids.\n    string treeURI;\n}\n\n/// @dev The issuer struct\nstruct Issuer {\n    /// @dev the name of the issuer\n    string name;\n    /// @dev the admin of the issuer, who can add or revoke public keys.\n    address admin;\n}\n\n/// @title IIssuerRegistry\n/// @dev The interface for the issuer registry contract.\ninterface IIssuerRegistry {\n    /// @notice Emitted when a new issuer is registered in the registry.\n    /// @param issuerId Unique identifier for the newly registered issuer.\n    /// @param name Name of the issuer registered.\n    event IssuerRegistered(uint256 indexed issuerId, string name);\n\n    /// @notice Emitted when an issuer's administrative role is transferred to a new address.\n    /// @param issuerId ID of issuer whose admin is being transferred.\n    /// @param oldAdmin Address of the current admin being replaced.\n    /// @param newAdmin Address of the new admin taking over.\n    event IssuerAdminTransferred(uint256 indexed issuerId, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Emitted when the status of a public key is updated.\n    /// @param issuerId ID for the issuer to whom the public key belongs.\n    /// @param publicKeyId ID for the public key being updated.\n    /// @param status New status of the public key.\n    event PublicKeyStatusUpdated(uint256 indexed issuerId, uint256 indexed publicKeyId, PublicKeyStatus status);\n\n    /// @notice Emitted when the verification stack for a public key is updated.\n    /// @param issuerId Unique identifier for the issuer to whom the public key belongs.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack being updated.\n    /// @param enabled Boolean indicating whether the stack is enabled or disabled for the public key.\n    event PublicKeyVerificationStackUpdated(\n        uint256 indexed issuerId,\n        uint256 indexed publicKeyId,\n        uint256 indexed verificationStackId,\n        bool enabled\n    );\n\n    /// @notice Emitted when the signature state URI is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newTreeURI New URI for the signature state tree.\n    event SignatureStateURIUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        string newTreeURI\n    );\n\n    /// @notice Emitted when the signature state root is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newRoot New root hash for the signature state tree.\n    event SignatureStateRootUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        bytes32 newRoot\n    );\n\n    /// @dev Registers a new issuer along with their first public key and enabled verification stack.\n    /// @param name Name of the issuer to register.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId  Identifier for the issuer's public key.\n    /// @param publicKeyRaw The raw public key data.\n    /// @return The unique identifier for the newly registered issuer.\n    function registerIssuer(\n        string calldata name,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external returns (uint256);\n\n    /// @dev Transfers the administrative role of an issuer to a new owner.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param newOwner Address of the new administrator.\n    function transferIssuerAdmin(uint256 issuerId, address newOwner) external;\n\n    /// @dev Adds a new public key for an issuer and enables it for a specified verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId Unique identifier for the new public key.\n    /// @param publicKeyRaw The raw public key data.\n    function addPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external;\n\n    /// @dev Updates the status (active/revoked) of an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param status New status for the public key.\n    // only the issuer admin can call this function\n    function updatePublicKeyStatus(uint256 issuerId, uint256 publicKeyId, PublicKeyStatus status) external;\n\n    /// @dev Updates the verification stack association for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId New verification stack identifier for the public key.\n    /// @param enabled Boolean indicating whether the stack is enabled for the public key.\n    function updatePublicKeyVerificationStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId,\n        bool enabled\n    ) external;\n\n    /// @dev Updates the signature state URI for a given type and context.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    function updateSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI\n    ) external;\n\n    /// @dev Updates the signature SMT root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param root New root hash for the revoked SMT.\n    function updateSignatureState(uint160 typeId, uint160 contextId, uint256 issuerId, bytes32 root) external;\n\n    /// @dev Sets both the signature SMT URI and root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    /// @param root New root hash for the signature state.\n    function setSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI,\n        bytes32 root\n    ) external;\n\n    /// @dev Retrieves the issuer data, reverts if the issuer does not exist.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return Issuer data structure containing issuer details.\n    function getIssuer(uint256 issuerId) external view returns (Issuer memory);\n\n    /// @dev Retrieves the raw public key data for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return The raw public key data.\n    function getPublicKeyRaw(uint256 issuerId, uint256 publicKeyId) external view returns (bytes memory);\n\n    /// @dev Checks if an issuer's public key is active.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return True if the public key is active, false otherwise.\n    function isPublicKeyActive(uint256 issuerId, uint256 publicKeyId) external view returns (bool);\n\n    /// @dev Checks if an issuer's public key is active and enabled for a specific verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @return True if the public key is active and enabled for the stack, false otherwise.\n    function isPublicKeyActiveForStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId\n    ) external view returns (bool);\n\n    /// @dev Retrieves the signature state for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The signature state.\n    function getSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (SignatureState memory);\n\n    /// @dev Retrieves the signature state URI for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The URI of the signature state.\n    function getSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (string memory);\n\n    /// @dev Retrieves the signature state root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The root hash of the signature state.\n    function getSignatureStateRoot(uint160 typeId, uint160 contextId, uint256 issuerId) external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title IProofVerifier\n/// @dev Interface for static verification of zero-knowledge proofs.\ninterface IProofVerifier {\n    /// @notice Retrieves the verification keys.\n    /// @dev This function is used to get the verification keys that are necessary for verifying proofs.\n    /// @return An array of `uint` representing the verification keys.\n    function getVerificationKeys() external view returns (uint256[] memory);\n\n    /// @dev Checks if the public signals are aliased. Aliased signals should never be used in proofs.\n    ///      This is useful when using proof aggregators that does not check for signal aliasing.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating if any public signal is aliased (`true`) or not (`false`).\n    function isAliased(uint256[] calldata _pubSignals) external view returns (bool);\n\n    /// @dev This function takes a cryptographic proof and public signals to verify the proof's validity.\n    /// @notice It verifies the proof and check if public signals were aliased.\n    /// @param _proofs An array of `uint` representing the proof.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating whether the proof is valid (`true`) or not (`false`).\n    function verifyProof(uint256[] calldata _proofs, uint256[] calldata _pubSignals) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPublicSignalGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title Intrinsic Signal enum\nenum IntrinsicSignalName {\n    TYPE,\n    CONTEXT,\n    NULLIFIER,\n    EXTERNAL_NULLIFIER,\n    REVEAL_IDENTITY,\n    EXPIRATION_LB,\n    KEY_ID,\n    ID_EQUALS_TO,\n    SIG_REVOCATION_SMT_ROOT\n}\n\n/// @title Public Signal Getter Interface\n/// @dev Public signals (inputs) are represented as an array of uints in galxe identity protocol.\n///      To find the public signal for a given signal name, type designer should set a contract\n///      in the type registry that implements this interface.\ninterface IPublicSignalGetter {\n    /// @dev get the public signal for the signal name, represented as the given enum (represented as uint8), based on the public signals.\n    /// @notice Implementation must be able to handle intrinsic signals, defiend in IntrinsicSignalName enum.\n    ///         Type-specific signals support is optional.\n    /// @param name The signal name, represented as the given enum (converted to uint8).\n    /// @param publicSignals The public signals.\n    function getPublicSignal(uint8 name, uint256[] calldata publicSignals) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStatefulVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IIssuerRegistry } from \"../interfaces/IIssuerRegistry.sol\";\nimport { ITypeRegistry } from \"../interfaces/ITypeRegistry.sol\";\n\n/// @title VerifyResult\n/// @notice Enum representing the possible results of a proof verification.\n/// Only the OK result indicates a successful verification.\nenum VerifyResult {\n    OK,\n    TYPE_UNINITIALIZED,\n    TYPE_ID_MISMATCH,\n    CONTEXT_ID_MISMATCH,\n    PUBKEY_INACTIVE,\n    SIG_REVOCATION_SMT_ROOT_MISMATCH,\n    PROOF_INVALID,\n    EXPIRED,\n    UNKNOWN_ERROR\n}\n\n/// @title IBabyzkStatefulVerifier\n/// @notice Interface for the BabyzkStatefulVerifier contract which handles on-chain stateful verification of zero-knowledge proofs.\ninterface IStatefulVerifier {\n    /// @notice Emitted when the TypeRegistry is updated.\n    /// @param oldTypeRegistry The address of the old TypeRegistry.\n    /// @param newTypeRegistry The address of the new TypeRegistry.\n    event TypeRegistryUpdated(ITypeRegistry oldTypeRegistry, ITypeRegistry newTypeRegistry);\n\n    /// @notice Emitted when the IssuerRegistry is updated.\n    /// @param oldIssuerRegistry The address of the old IssuerRegistry.\n    /// @param newIssuerRegistry The address of the new IssuerRegistry.\n    event IssuerRegistryUpdated(IIssuerRegistry oldIssuerRegistry, IIssuerRegistry newIssuerRegistry);\n\n    /// @notice Performs static verification of zero-knowledge proofs.\n    /// @param typeId The type ID of the proof to verify.\n    /// @param contextId The context ID of the proof to verify.\n    /// @param keyId The key ID associated with the proof.\n    /// @param proofs An array containing the proof data.\n    /// @param publicSignals An array containing the public signals data.\n    /// @return A value from the VerifyResult enum representing the verification result.\n    function verifyProofStatic(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 keyId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view returns (VerifyResult);\n\n    /// @notice Performs full verification of zero-knowledge proofs, including issuer public key activity and revocation checks.\n    /// @param typeId The type ID of the proof to verify.\n    /// @param contextId The context ID of the proof to verify.\n    /// @param issuerId The issuer ID associated with the proof.\n    /// @param proofs An array containing the proof data.\n    /// @param publicSignals An array containing the public signals data.\n    /// @return A value from the VerifyResult enum representing the verification result.\n    function verifyProofFull(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view returns (VerifyResult);\n\n    /// @notice Returns the current TypeRegistry address.\n    /// @return The address of the TypeRegistry.\n    function getTypeRegistry() external view returns (ITypeRegistry);\n\n    /// @notice Returns the current IssuerRegistry address.\n    /// @return The address of the IssuerRegistry.\n    function getIssuerRegistry() external view returns (IIssuerRegistry);\n}\n"
    },
    "contracts/interfaces/ITypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { IPublicSignalGetter } from \"./IPublicSignalGetter.sol\";\n\n/// @title Credential Type\n/// @dev Defines the structure of a credential type.\nstruct CredentialType {\n    // @dev This flag indicates if the credential type support revocation.\n    bool revocable;\n    // @dev The address of the admin of the credential type, initially set to the creator.\n    address admin;\n    // @dev Provides a human-readable identifier for the credential.\n    string name;\n    // @dev The type specification of Galxe Identity Credential Type Schema.\n    string definition;\n    // @dev Additional context or information about the type.\n    string description;\n    // @dev A URI to an external JSON file of more information about the credential.\n    // See whitepaper for the JSON schema specification.\n    string resourceURI;\n}\n\n/// @title Credential Type Config, miscellanous.\n/// @notice To save stack space, we use this struct to store the verifier and public signal getter.\nstruct CredentialTypeMiscConfig {\n    bool revocable;\n    uint8 verificationStackId;\n    IProofVerifier verifier;\n    IPublicSignalGetter publicSignalGetter;\n}\n\n/// @title Interface for Type Registration Contract\n/// @notice This interface defines the functions for registering and managing types by users.\ninterface ITypeRegistry {\n    /// @dev Emitted when a new type is registered\n    /// @param typeID Unique identifier for the registered type\n    /// @param admin Address of the admin of the type.\n    /// @param name Name of the type\n    /// @param definition Immutable definition of the type\n    /// @param description Immutable description of the type\n    /// @param resourceURI Mutable resource URI for the type\n    event TypeRegistered(\n        uint160 indexed typeID,\n        address indexed admin,\n        string name,\n        string definition,\n        string description,\n        string resourceURI\n    );\n\n    /// @dev Emitted when the resource URI of a type is updated\n    /// @param typeID Unique identifier for the type being updated\n    /// @param oldResourceURI The previous resource URI\n    /// @param newResourceURI The new resource URI\n    event TypeResourceURIUpdated(uint160 indexed typeID, string oldResourceURI, string newResourceURI);\n\n    /// @dev Emitted when a proof verifier is updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param verifier address of the verifier\n    event TypeVerifierUpdated(uint160 indexed typeID, uint8 indexed verificationStackID, address indexed verifier);\n\n    /// @dev Emitted when the intrinsic signal indexes are updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param publicSignalGetter  address of the public signal getter\n    event TypePublicSignalGetterUpdated(\n        uint160 indexed typeID,\n        uint8 indexed verificationStackID,\n        address indexed publicSignalGetter\n    );\n\n    /// @dev Emitted when the admin of a type is transferred\n    /// @param typeID type id\n    /// @param oldAdmin address of the old admin\n    /// @param newAdmin address of the new admin\n    event TypeAdminTransferred(uint160 indexed typeID, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @dev transfer the ownership of a type.\n    /// @param typeId type id of the type\n    /// @param newAdmin address of the new admin\n    function transferTypeAdmin(uint160 typeId, address newAdmin) external;\n\n    /// @notice set a primitive type, only callable by the admin.\n    /// @param typeId the type id of the primitive type\n    /// @param name name of the type\n    /// @param definition definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param config revocable, verifier and public signal getter.\n    function setPrimitiveType(\n        uint160 typeId,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        CredentialTypeMiscConfig calldata config\n    ) external;\n\n    /// @notice Register a new type by `msg.sender`\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) external returns (uint160);\n\n    /// @notice Register a new type by `msg.sender` with verifier and public signal getter set for a specific verification stack.\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param verifier verifier for the type\n    /// @param publicSignalGetter public signal getter for the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType1Step(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        uint8 verificationStackId,\n        IProofVerifier verifier,\n        IPublicSignalGetter publicSignalGetter\n    ) external returns (uint160);\n\n    /// @notice Update the resource URI of a type\n    /// @dev Can only be called by the type owner (`msg.sender`)\n    /// @param _id ID of the type to update\n    /// @param _resourceURI New resource URI for the type\n    function updateTypeResourceURI(uint160 _id, string calldata _resourceURI) external;\n\n    /// @dev update the verifier for a type\n    function updateTypeVerifier(uint160 typeId, uint8 verificationStackId, IProofVerifier verifier) external;\n\n    /// @dev update the verifier for a type\n    function updateTypePublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IPublicSignalGetter getter\n    ) external;\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getVerifier(uint160 typeId, uint8 verificationStackId) external view returns (IProofVerifier);\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getPublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view returns (IPublicSignalGetter);\n\n    /// @dev check if the type is fully initialized for the given verification stack.\n    /// @param typeId id of the type\n    /// @param verificationStackId id the verification stack\n    function isTypeFullyInitializedForStack(uint160 typeId, uint8 verificationStackId) external view returns (bool);\n\n    /// @dev Retrieve details of a type for the given typeID\n    /// @param _id ID of the type to retrieve\n    /// @return A `CredentialType` struct containing details of the type\n    function getType(uint160 _id) external view returns (CredentialType memory);\n\n    /// @dev Retrieve the admin of a type\n    /// @param typeId type id of the type\n    /// @return address of the admin of the type\n    function getTypeAdmin(uint160 typeId) external view returns (address);\n\n    /// @dev check if the type is revocable\n    function isRevocable(uint160 typeId) external view returns (bool);\n\n    /// @notice Calculate the typeID of a type, typeID is keccak256(creator, name) in uint160.\n    /// @param creator Address of the type creator\n    /// @param name Name of the type\n    /// @return The calculated typeID based on the creator address and type name\n    function calcTypeID(address creator, string calldata name) external pure returns (uint160);\n}\n"
    }
  }
}}