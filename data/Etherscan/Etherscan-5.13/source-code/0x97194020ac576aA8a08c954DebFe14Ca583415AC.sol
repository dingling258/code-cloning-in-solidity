{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/primitive/property_verifier.sol": {
      "content": "\n// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright (c) 2021 0KIMS association.\n    Copyright (c) [2024] Galxe.com.\n\n    Modifications to this file are part of the Galxe Identity Protocol SDK,\n    which is built using the snarkJS template and is subject to the GNU\n    General Public License v3.0.\n\n    snarkJS is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.8.4 <0.9.0;\n\ncontract BabyZKGroth16PropertyVerifier {\n    error AliasedPublicSignal();\n\n    // Scalar field size\n    uint256 constant r   = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 11414308741845866070085426566452317103435919953372480741769117942559358064929;\n    uint256 constant deltax2 = 17374122188591355265489391850630525848516844913531328314518114624786540918774;\n    uint256 constant deltay1 = 4805943426435892795193533207491585471028169447506182975505804821707709387402;\n    uint256 constant deltay2 = 3779852072385966186983736777112504712320379578988346798663720253445993794904;\n\n    uint256 constant IC0x = 21282914606544504841446672183548976667336734118384326986872441490213100233198;\n    uint256 constant IC0y = 7244048437405094008788643878823791229689413336569675755260786565615017673008;\n    uint256 constant IC1x = 21763052119897271951546724350030855801695388906317992478303308144361455108360;\n    uint256 constant IC1y = 1608872978305347168059657251469436932629356088876393997410585169556277214185;\n    uint256 constant IC2x = 8003254435902758560853985611657072128887881951452160772919242672441473611036;\n    uint256 constant IC2y = 15242606809601150172252505741824596697604315081038945113202486841786263119977;\n    uint256 constant IC3x = 18715776049104124383839709405670487216213184446656248593352020123074988458716;\n    uint256 constant IC3y = 7887753228505704161087653224279922305694581204716337599935911852199096742082;\n    uint256 constant IC4x = 7028110773054326845365750137080078100350298258694196533394851493040606284105;\n    uint256 constant IC4y = 8877289167867341027725747071299324574174288751192044206896596093060066561123;\n    uint256 constant IC5x = 18260458696454177334207880249354179258160632746613408803694682950372458468206;\n    uint256 constant IC5y = 10126634442774700961252304838128483126544953720700398087547427995192566709086;\n    uint256 constant IC6x = 9841956294051706864891709641279649298130727235403428423642298228287728688465;\n    uint256 constant IC6y = 17527792556901344875361897616626915647320681218054984845236097073487992050734;\n    uint256 constant IC7x = 5534428345459510038894105382957122802917358379136265058504320326972661342047;\n    uint256 constant IC7y = 6766275239836979735121846401420445341184822174372517830008145522949992864758;\n    uint256 constant IC8x = 11113242123452701361566984741890081046161278831617575462222796064073948004605;\n    uint256 constant IC8y = 642831114213191244891766047504367930246914717751276308143851811549806736860;\n    uint256 constant IC9x = 18527281753934920101755634341734088616055121926321307995214486570920284521957;\n    uint256 constant IC9y = 1195297180455881505551214113785314370379730340976398177208182758359244249907;\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    uint16 constant proofLength = 8;\n    uint32 constant pubSignalLength = 9;\n\n    /// @dev returns the verification keys in the order that the verifier expects them:\n    /// alpha, beta, gamma, delta, ICs..\n    function getVerificationKeys() public pure returns (uint[] memory) {\n        uint[] memory vks = new uint[](16 + pubSignalLength * 2);\n        vks[0] = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n        vks[1] = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n        vks[2] = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n        vks[3] = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n        vks[4] = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n        vks[5] = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n        vks[6] = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n        vks[7] = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n        vks[8] = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n        vks[9] = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n        vks[10] = 11414308741845866070085426566452317103435919953372480741769117942559358064929;\n        vks[11] = 17374122188591355265489391850630525848516844913531328314518114624786540918774;\n        vks[12] = 4805943426435892795193533207491585471028169447506182975505804821707709387402;\n        vks[13] = 3779852072385966186983736777112504712320379578988346798663720253445993794904;\n        vks[14] = 21282914606544504841446672183548976667336734118384326986872441490213100233198;\n        vks[15] = 7244048437405094008788643878823791229689413336569675755260786565615017673008;\n        vks[16] = 21763052119897271951546724350030855801695388906317992478303308144361455108360;\n        vks[17] = 1608872978305347168059657251469436932629356088876393997410585169556277214185;\n        vks[18] = 8003254435902758560853985611657072128887881951452160772919242672441473611036;\n        vks[19] = 15242606809601150172252505741824596697604315081038945113202486841786263119977;\n        vks[20] = 18715776049104124383839709405670487216213184446656248593352020123074988458716;\n        vks[21] = 7887753228505704161087653224279922305694581204716337599935911852199096742082;\n        vks[22] = 7028110773054326845365750137080078100350298258694196533394851493040606284105;\n        vks[23] = 8877289167867341027725747071299324574174288751192044206896596093060066561123;\n        vks[24] = 18260458696454177334207880249354179258160632746613408803694682950372458468206;\n        vks[25] = 10126634442774700961252304838128483126544953720700398087547427995192566709086;\n        vks[26] = 9841956294051706864891709641279649298130727235403428423642298228287728688465;\n        vks[27] = 17527792556901344875361897616626915647320681218054984845236097073487992050734;\n        vks[28] = 5534428345459510038894105382957122802917358379136265058504320326972661342047;\n        vks[29] = 6766275239836979735121846401420445341184822174372517830008145522949992864758;\n        vks[30] = 11113242123452701361566984741890081046161278831617575462222796064073948004605;\n        vks[31] = 642831114213191244891766047504367930246914717751276308143851811549806736860;\n        vks[32] = 18527281753934920101755634341734088616055121926321307995214486570920284521957;\n        vks[33] = 1195297180455881505551214113785314370379730340976398177208182758359244249907;\n        return vks;\n    }\n\n    /// @dev return true if the public signal is aliased\n    function isAliased(uint[] calldata _pubSignals) public pure returns (bool) {\n        // Alias check\n        if (_pubSignals[0] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[1] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[2] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[3] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[4] >= 452312848583266388373324160190187140051835877600158453279131187530910662656) { return true; }\n        if (_pubSignals[5] >= 18446744073709551616) { return true; }\n        if (_pubSignals[6] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[7] >= 904625697166532776746648320380374280103671755200316906558262375061821325312) { return true; }\n        if (_pubSignals[8] >= 904625697166532776746648320380374280103671755200316906558262375061821325312) { return true; }\n        return false;\n    }\n\n    function verifyProof(uint[] calldata _proofs, uint[] calldata _pubSignals) public view returns (bool) {\n        // Check Argument\n        require(_proofs.length == proofLength, \"Invalid proof\");\n        require(_pubSignals.length == pubSignalLength, \"Invalid public signal\");\n        if (isAliased(_pubSignals)) { return false; }\n        assembly {\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination it.vkey.vk_x\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // it.vkey.vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_proofs.offset, add(_proofs.offset, 64), add(_proofs.offset, 192), _pubSignals.offset, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}\n"
    }
  }
}}