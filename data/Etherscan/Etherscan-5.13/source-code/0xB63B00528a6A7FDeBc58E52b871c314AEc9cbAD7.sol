{{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "viaIR": true,
    "remappings": []
  },
  "sources": {
    "contracts/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { Lib } from \"./libraries/Lib.sol\";\nimport {IGenerator} from \"./interfaces/IGenerator.sol\";\nimport {IStake} from \"./interfaces/IStake.sol\";\n\ninterface ITemplate {\n    function initialize(bytes calldata data) external ;\n    function initializePayable(bytes calldata data) external payable;\n}\n\ncontract StakingPoolFactory {\n    address public generator;\n    constructor(address _generator) {\n        generator = _generator;\n    }\n\n    address[] public pools;\n    mapping(address => bool) public isPool;\n    event PoolCreated(address indexed factory, address pool, address indexed stake, address indexed reward, bool mintsRewards);\n\n    function owner() public view returns (address) {\n        return IGenerator(generator).factoryInfo(generator).owner;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == owner(), \"F:NA\");\n        _;\n    }\n\n    struct Template {\n        address template;\n        uint fee;\n        bool shouldPay;\n    }\n    bytes4 constant templateSelector = bytes4(keccak256(\"initialize(bytes)\"));\n    bytes4 constant payableTemplateSelector = bytes4(keccak256(\"initializePayable(bytes)\"));\n    mapping(uint => Template) public templates;\n    uint public totalTemplates;\n    event TemplateAdded(uint i, address template, uint fee);\n    event FeeUpdated(address indexed template, uint fee);\n    function addTemplate(address _templateAddress, uint _fee, bool shouldPay) external onlyOwner {\n        templates[totalTemplates] = Template(_templateAddress, _fee, shouldPay);\n        emit TemplateAdded(totalTemplates, _templateAddress, _fee);\n        totalTemplates++;\n    }\n    function setFee(uint _template, uint _fee) external onlyOwner {\n        templates[_template].fee = _fee;\n        emit FeeUpdated(templates[_template].template, _fee);\n    }\n\n    function createPool(uint _template, bytes calldata _data) external payable returns (address created) {\n        address template = templates[_template].template;\n        require(template != address(0));\n        uint fee = templates[_template].fee;\n        uint v = msg.value;\n        if (v > fee) {\n            uint a = v - fee;\n            payable(msg.sender).transfer(a);\n            v -= a;\n        }\n        require(v >= fee, \"F:IF\");\n        if (v > 0) {\n            payable(owner()).transfer(fee);\n            v -= fee;\n        }\n        bytes32 salt = keccak256(abi.encodePacked(pools.length));\n        created = Lib.cloneDeterministic(template, salt);\n        if (!templates[_template].shouldPay) {\n             (bool success,) = address(created).call(abi.encodeWithSelector(templateSelector, _data));\n             require(success, \"Failed to initialize\");\n        } else{\n             (bool success,) = address(created).call{value: v}(abi.encodeWithSelector(payableTemplateSelector, _data));\n             require(success, \"Failed to initialize\");\n        }\n        pools.push(created);\n        isPool[created] = true;\n        IStake s = IStake(created);\n        address f = s.factory();\n        address stake = s.stakingToken();\n        address reward = s.rewardToken();\n        bool rewardBased = s.rewardBased();\n        emit PoolCreated(f, created, stake, reward, rewardBased);\n    }\n\n    function totalPools() external view returns (uint256) {\n        return pools.length;\n    }\n\n}"
    },
    "contracts/interfaces/IStake.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IStake {\n    function stakingToken() external view returns (address);\n    function rewardToken() external view returns (address);\n    function factory() external view returns (address);\n    function rewardBased() external view returns (bool);\n}"
    },
    "contracts/interfaces/IGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n\ninterface IGenerator {\n    struct Info {\n        address owner;\n        uint16 burnFee;\n        address burnToken;\n        uint16 teamFee;\n        address teamAddress;\n        uint16 lpFee;\n        address referrer;\n        uint16 referFee;\n        uint16 labFee;\n    }\n    function allowLoans() external view returns (bool);\n    function isPair(address) external view returns (bool);\n    function borrowFee() external view returns (uint16);\n    function factoryInfo(address) external view returns (Info memory);\n    function pairFees(address pair) external view returns (Info memory);\n    function LAB_FEE() external view returns (uint16);\n    function FEE_DENOMINATOR() external view returns (uint16);\n    function stables(address) external view returns (bool);\n    function pairs(address factory, address token0, address token1) external view returns (address);\n    function getPairs(address[] calldata path) external  view returns (address[] memory _pairs);\n    function maxSwap2Fee(uint16 f) external view returns (uint16);\n    function swapInternal(\n        address[] calldata _pairs,\n        address caller,\n        address to\n    ) external returns (uint256 amountOut);\n    function WRAPPED_ETH() external view returns (address);\n    function createPair(\n        address tokenA, \n        address tokenB\n    ) external returns (address pair);\n     function createSwap2Pair(\n        address tokenA, \n        address tokenB,\n        address feeTaker,\n        address takeFeeIn\n    ) external returns (address pair);\n    function createPairWithLiquidity(\n        address tokenA, \n        address tokenB,\n        uint amountA,\n        uint amountB,\n        address to,\n        address feeTaker,\n        address takeFeeIn\n    ) external returns (address pair);\n    function isFactory(address) external returns (bool);\n    function tokens(address) external returns (address[] memory);\n}"
    },
    "contracts/libraries/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n// a library for performing various math operations\n\nlibrary Lib {\n    function sortsBefore(address tokenA, address tokenB) internal pure returns (address, address) {\n        return tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n}"
    }
  }
}}