{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "berlin",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@zerolendxyz/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity 0.8.12;\n\nimport {IERC20} from '../../openzeppelin/contracts/IERC20.sol';\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary GPv2SafeERC20 {\n  /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n  /// also when the token returns `false`.\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    bytes4 selector_ = token.transfer.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transfer');\n  }\n\n  /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n  /// reverts also when the token returns `false`.\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    bytes4 selector_ = token.transferFrom.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 68), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transferFrom');\n  }\n\n  /// @dev Verifies that the last return was a successful `transfer*` call.\n  /// This is done by checking that the return data is either empty, or\n  /// is a valid ABI encoded boolean.\n  function getLastTransferResult(IERC20 token) private view returns (bool success) {\n    // NOTE: Inspecting previous return data requires assembly. Note that\n    // we write the return data to memory 0 in the case where the return\n    // data size is 32, this is OK since the first 64 bytes of memory are\n    // reserved by Solidy as a scratch space that can be used within\n    // assembly blocks.\n    // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      /// @dev Revert with an ABI encoded Solidity error with a message\n      /// that fits into 32-bytes.\n      ///\n      /// An ABI encoded Solidity error has the following memory layout:\n      ///\n      /// ------------+----------------------------------\n      ///  byte range | value\n      /// ------------+----------------------------------\n      ///  0x00..0x04 |        selector(\"Error(string)\")\n      ///  0x04..0x24 |      string offset (always 0x20)\n      ///  0x24..0x44 |                    string length\n      ///  0x44..0x64 | string value, padded to 32-bytes\n      function revertWithMessage(length, message) {\n        mstore(0x00, '\\x08\\xc3\\x79\\xa0')\n        mstore(0x04, 0x20)\n        mstore(0x24, length)\n        mstore(0x44, message)\n        revert(0x00, 0x64)\n      }\n\n      switch returndatasize()\n      // Non-standard ERC20 transfer without return.\n      case 0 {\n        // NOTE: When the return data size is 0, verify that there\n        // is code at the address. This is done in order to maintain\n        // compatibility with Solidity calling conventions.\n        // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n        if iszero(extcodesize(token)) {\n          revertWithMessage(20, 'GPv2: not a contract')\n        }\n\n        success := 1\n      }\n      // Standard ERC20 transfer returning boolean success value.\n      case 32 {\n        returndatacopy(0, 0, returndatasize())\n\n        // NOTE: For ABI encoding v1, any non-zero value is accepted\n        // as `true` for a boolean. In order to stay compatible with\n        // OpenZeppelin's `SafeERC20` library which is known to work\n        // with the existing ERC20 implementation we care about,\n        // make sure we return success for any non-zero return value\n        // from the `transfer*` call.\n        success := iszero(iszero(mload(0)))\n      }\n      default {\n        revertWithMessage(31, 'GPv2: malformed transfer result')\n      }\n    }\n  }\n}\n"
    },
    "@zerolendxyz/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@zerolendxyz/periphery-v3/contracts/rewards/interfaces/IPullRewardsTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.12;\n\nimport {ITransferStrategyBase} from './ITransferStrategyBase.sol';\n\n/**\n * @title IPullRewardsTransferStrategy\n * @author Aave\n **/\ninterface IPullRewardsTransferStrategy is ITransferStrategyBase {\n  /**\n   * @return Address of the rewards vault\n   */\n  function getRewardsVault() external view returns (address);\n}\n"
    },
    "@zerolendxyz/periphery-v3/contracts/rewards/interfaces/ITransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.12;\n\ninterface ITransferStrategyBase {\n  event EmergencyWithdrawal(\n    address indexed caller,\n    address indexed token,\n    address indexed to,\n    uint256 amount\n  );\n\n  /**\n   * @dev Perform custom transfer logic via delegate call from source contract to a TransferStrategy implementation\n   * @param to Account to transfer rewards\n   * @param reward Address of the reward token\n   * @param amount Amount to transfer to the \"to\" address parameter\n   * @return Returns true bool if transfer logic succeeds\n   */\n  function performTransfer(address to, address reward, uint256 amount) external returns (bool);\n\n  /**\n   * @return Returns the address of the Incentives Controller\n   */\n  function getIncentivesController() external view returns (address);\n\n  /**\n   * @return Returns the address of the Rewards admin\n   */\n  function getRewardsAdmin() external view returns (address);\n\n  /**\n   * @dev Perform an emergency token withdrawal only callable by the Rewards admin\n   * @param token Address of the token to withdraw funds from this contract\n   * @param to Address of the recipient of the withdrawal\n   * @param amount Amount of the withdrawal\n   */\n  function emergencyWithdrawal(address token, address to, uint256 amount) external;\n}\n"
    },
    "@zerolendxyz/periphery-v3/contracts/rewards/transfer-strategies/PullRewardsTransferStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.12;\n\nimport {IPullRewardsTransferStrategy} from '../interfaces/IPullRewardsTransferStrategy.sol';\nimport {ITransferStrategyBase} from '../interfaces/ITransferStrategyBase.sol';\nimport {TransferStrategyBase} from './TransferStrategyBase.sol';\nimport {GPv2SafeERC20} from '@zerolendxyz/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IERC20} from '@zerolendxyz/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\n\n/**\n * @title PullRewardsTransferStrategy\n * @notice Transfer strategy that pulls ERC20 rewards from an external account to the user address.\n * The external account could be a smart contract or EOA that must approve to the PullRewardsTransferStrategy contract address.\n * @author Aave\n **/\ncontract PullRewardsTransferStrategy is TransferStrategyBase, IPullRewardsTransferStrategy {\n  using GPv2SafeERC20 for IERC20;\n\n  address internal immutable REWARDS_VAULT;\n\n  constructor(\n    address incentivesController,\n    address rewardsAdmin,\n    address rewardsVault\n  ) TransferStrategyBase(incentivesController, rewardsAdmin) {\n    REWARDS_VAULT = rewardsVault;\n  }\n\n  /// @inheritdoc TransferStrategyBase\n  function performTransfer(\n    address to,\n    address reward,\n    uint256 amount\n  )\n    external\n    override(TransferStrategyBase, ITransferStrategyBase)\n    onlyIncentivesController\n    returns (bool)\n  {\n    IERC20(reward).safeTransferFrom(REWARDS_VAULT, to, amount);\n\n    return true;\n  }\n\n  /// @inheritdoc IPullRewardsTransferStrategy\n  function getRewardsVault() external view returns (address) {\n    return REWARDS_VAULT;\n  }\n}\n"
    },
    "@zerolendxyz/periphery-v3/contracts/rewards/transfer-strategies/TransferStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.12;\n\nimport {ITransferStrategyBase} from '../interfaces/ITransferStrategyBase.sol';\nimport {GPv2SafeERC20} from '@zerolendxyz/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IERC20} from '@zerolendxyz/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\n\n/**\n * @title TransferStrategyStorage\n * @author Aave\n **/\nabstract contract TransferStrategyBase is ITransferStrategyBase {\n  using GPv2SafeERC20 for IERC20;\n\n  address internal immutable INCENTIVES_CONTROLLER;\n  address internal immutable REWARDS_ADMIN;\n\n  constructor(address incentivesController, address rewardsAdmin) {\n    INCENTIVES_CONTROLLER = incentivesController;\n    REWARDS_ADMIN = rewardsAdmin;\n  }\n\n  /**\n   * @dev Modifier for incentives controller only functions\n   */\n  modifier onlyIncentivesController() {\n    require(INCENTIVES_CONTROLLER == msg.sender, 'CALLER_NOT_INCENTIVES_CONTROLLER');\n    _;\n  }\n\n  /**\n   * @dev Modifier for reward admin only functions\n   */\n  modifier onlyRewardsAdmin() {\n    require(msg.sender == REWARDS_ADMIN, 'ONLY_REWARDS_ADMIN');\n    _;\n  }\n\n  /// @inheritdoc ITransferStrategyBase\n  function getIncentivesController() external view override returns (address) {\n    return INCENTIVES_CONTROLLER;\n  }\n\n  /// @inheritdoc ITransferStrategyBase\n  function getRewardsAdmin() external view override returns (address) {\n    return REWARDS_ADMIN;\n  }\n\n  /// @inheritdoc ITransferStrategyBase\n  function performTransfer(\n    address to,\n    address reward,\n    uint256 amount\n  ) external virtual returns (bool);\n\n  /// @inheritdoc ITransferStrategyBase\n  function emergencyWithdrawal(\n    address token,\n    address to,\n    uint256 amount\n  ) external onlyRewardsAdmin {\n    IERC20(token).safeTransfer(to, amount);\n\n    emit EmergencyWithdrawal(msg.sender, token, to, amount);\n  }\n}\n"
    }
  }
}}