{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"../access/AccessControl.sol\";\nimport {ERC721Holder} from \"../token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"../token/ERC1155/utils/ERC1155Holder.sol\";\nimport {Address} from \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n */\ncontract TimelockController is AccessControl, ERC721Holder, ERC1155Holder {\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 id => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    enum OperationState {\n        Unset,\n        Waiting,\n        Ready,\n        Done\n    }\n\n    /**\n     * @dev Mismatch between the parameters length for an operation call.\n     */\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\n\n    /**\n     * @dev The schedule operation doesn't meet the minimum delay.\n     */\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\n\n    /**\n     * @dev The current state of an operation is not as required.\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\n     * counting from right to left.\n     *\n     * See {_encodeStateBitmap}.\n     */\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\n\n    /**\n     * @dev The predecessor to an operation not yet done.\n     */\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\n\n    /**\n     * @dev The caller account is not authorized.\n     */\n    error TimelockUnauthorizedCaller(address caller);\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay in seconds for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) {\n        // self administration\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _grantRole(PROPOSER_ROLE, proposers[i]);\n            _grantRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _grantRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id corresponds to a registered operation. This\n     * includes both Waiting, Ready, and Done operations.\n     */\n    function isOperation(bytes32 id) public view returns (bool) {\n        return getOperationState(id) != OperationState.Unset;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view returns (bool) {\n        OperationState state = getOperationState(id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Done;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns operation state.\n     */\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\n        uint256 timestamp = getTimestamp(id);\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == _DONE_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /**\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        if (isOperation(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\n        }\n        uint256 minDelay = getMinDelay();\n        if (delay < minDelay) {\n            revert TimelockInsufficientDelay(delay, minDelay);\n        }\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        if (!isOperationPending(id)) {\n            revert TimelockUnexpectedOperationState(\n                id,\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\n            );\n        }\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\n            revert TimelockUnexecutedPredecessor(predecessor);\n        }\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        address sender = _msgSender();\n        if (sender != address(this)) {\n            revert TimelockUnauthorizedCaller(sender);\n        }\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `OperationState` enum. For example:\n     *\n     * 0x000...1000\n     *   ^^^^^^----- ...\n     *         ^---- Done\n     *          ^--- Ready\n     *           ^-- Waiting\n     *            ^- Unset\n     */\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(operationState));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Not enough balance for performing a CREATE2 deploy.\n     */\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error Create2FailedDeployment();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Create2InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Create2FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/erc/ERC6551AccountProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Proxy} from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n/**\n * @title ERC6551AccountProxy\n * This version of ERC6551AccountProxy is modified to work with the OpenZeppelin Contracts v5\n * The original version (working with OZ v4.9.x) can be found in https://github.com/erc6551/reference\n */\ncontract ERC6551AccountProxy is Proxy {\n  /**\n   * @notice The default implementation of the contract\n   */\n  address public immutable DEFAULT_IMPLEMENTATION;\n\n  /**\n   * @notice Error returned when the implementation is invalid\n   */\n  error InvalidImplementation();\n\n  /**\n   * @notice The function that allows to receive ether and generic calls\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @notice Constructor\n   * @param _defaultImplementation The default implementation of the contract\n   */\n  constructor(address _defaultImplementation) {\n    if (_defaultImplementation == address(0)) revert InvalidImplementation();\n    DEFAULT_IMPLEMENTATION = _defaultImplementation;\n  }\n\n  /**\n   * @notice Returns the implementation of the contract\n   */\n  function _implementation() internal view virtual override returns (address) {\n    address implementation = ERC1967Utils.getImplementation();\n    if (implementation == address(0)) return DEFAULT_IMPLEMENTATION;\n    return implementation;\n  }\n\n  /**\n   * @notice Fallback function that redirect all the calls not in this proxy to the implementation\n   */\n  function _fallback() internal virtual override {\n    if (msg.data.length == 0) {\n      if (ERC1967Utils.getImplementation() == address(0)) {\n        ERC1967Utils.upgradeToAndCall(DEFAULT_IMPLEMENTATION, \"\");\n        _delegate(DEFAULT_IMPLEMENTATION);\n      }\n    } else {\n      super._fallback();\n    }\n  }\n}\n"
    },
    "contracts/erc/ERC7656Contract.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {IERC165, IERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC6551AccountLib} from \"erc6551/lib/ERC6551AccountLib.sol\";\n\nimport {IERC7656Contract} from \"./IERC7656Contract.sol\";\n\n//import \"hardhat/console.sol\";\n\n/**\n * @title ERC7656Contract.sol\n * @notice Abstract contract to link a contract to an NFT\n */\nabstract contract ERC7656Contract is IERC7656Contract, IERC165 {\n  function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n    return interfaceId == type(IERC7656Contract).interfaceId;\n  }\n\n  /**\n   * @notice Returns the token linked to the contract\n   */\n  function token() public view virtual override returns (uint256, address, uint256) {\n    return ERC6551AccountLib.token();\n  }\n\n  /**\n   * @notice Returns the owner of the token\n   */\n  function owner() public view virtual override returns (address) {\n    (uint256 chainId, address tokenContract_, uint256 tokenId_) = ERC6551AccountLib.token();\n    if (chainId != block.chainid) return address(0);\n    return IERC721(tokenContract_).ownerOf(tokenId_);\n  }\n\n  /**\n   * @notice Returns the address of the token contract\n   */\n  function tokenAddress() public view virtual override returns (address) {\n    (, address tokenContract_, ) = ERC6551AccountLib.token();\n    return tokenContract_;\n  }\n\n  /**\n   * @notice Returns the tokenId of the token\n   */\n  function tokenId() public view virtual override returns (uint256) {\n    (, , uint256 tokenId_) = ERC6551AccountLib.token();\n    return tokenId_;\n  }\n\n  /**\n   * @notice Returns the implementation used when creating the contract\n   */\n  function implementation() public view virtual override returns (address) {\n    return ERC6551AccountLib.implementation();\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/erc/ERC7656Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Modified registry based on ERC6551Registry\n// https://github.com/erc6551/reference/blob/main/src/ERC6551Registry.sol\n\nimport {IERC7656Registry} from \"./IERC7656Registry.sol\";\n\ncontract ERC7656Registry is IERC7656Registry {\n  function create(\n    address implementation,\n    bytes32 salt,\n    uint256 /* chainId */,\n    address tokenContract,\n    uint256 tokenId\n  ) external override returns (address) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Memory Layout:\n      // ----\n      // 0x00   0xff                           (1 byte)\n      // 0x01   registry (address)             (20 bytes)\n      // 0x15   salt (bytes32)                 (32 bytes)\n      // 0x35   Bytecode Hash (bytes32)        (32 bytes)\n      // ----\n      // 0x55   ERC-1167 Constructor + Header  (20 bytes)\n      // 0x69   implementation (address)       (20 bytes)\n      // 0x5D   ERC-1167 Footer                (15 bytes)\n      // 0x8C   salt (uint256)                 (32 bytes)\n      // 0xAC   chainId (uint256)              (32 bytes)\n      // 0xCC   tokenContract (address)        (32 bytes)\n      // 0xEC   tokenId (uint256)              (32 bytes)\n\n      // Copy bytecode + constant data to memory\n      calldatacopy(0x8c, 0x24, 0x80) // salt, chainId, tokenContract, tokenId\n      mstore(0x6c, 0x5af43d82803e903d91602b57fd5bf3) // ERC-1167 footer\n      mstore(0x5d, implementation) // implementation\n      mstore(0x49, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73) // ERC-1167 constructor + header\n\n      // Copy create2 computation data to memory\n      mstore8(0x00, 0xff) // 0xFF\n      mstore(0x35, keccak256(0x55, 0xb7)) // keccak256(bytecode)\n      mstore(0x01, shl(96, address())) // registry address\n      mstore(0x15, salt) // salt\n\n      // Compute account address\n      let computed := keccak256(0x00, 0x55)\n\n      // If the account has not yet been deployed\n      if iszero(extcodesize(computed)) {\n        // Deploy account contract\n        let deployed := create2(0, 0x55, 0xb7, salt)\n\n        // Revert if the deployment fails\n        if iszero(deployed) {\n          mstore(0x00, 0xd786d393) // `CreationFailed()`\n          revert(0x1c, 0x04)\n        }\n\n        // Store account address in memory before salt and chainId\n        mstore(0x6c, deployed)\n\n        // Emit the Created event\n        log4(\n          0x6c,\n          0x60,\n          0xc6989e4f290074742210cbd6491de7ded9cfe2cd247932a53d31005007a6341a,\n          implementation,\n          tokenContract,\n          tokenId\n        )\n\n        // Return the account address\n        return(0x6c, 0x20)\n      }\n\n      // Otherwise, return the computed account address\n      mstore(0x00, shr(96, shl(96, computed)))\n      return(0x00, 0x20)\n    }\n  }\n\n  function compute(\n    address implementation,\n    bytes32 salt,\n    uint256 /* chainId */,\n    address /* tokenContract */,\n    uint256 /* tokenId */\n  ) external view override returns (address) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Copy bytecode + constant data to memory\n      calldatacopy(0x8c, 0x24, 0x80) // salt, chainId, tokenContract, tokenId\n      mstore(0x6c, 0x5af43d82803e903d91602b57fd5bf3) // ERC-1167 footer\n      mstore(0x5d, implementation) // implementation\n      mstore(0x49, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73) // ERC-1167 constructor + header\n\n      // Copy create2 computation data to memory\n      mstore8(0x00, 0xff) // 0xFF\n      mstore(0x35, keccak256(0x55, 0xb7)) // keccak256(bytecode)\n      mstore(0x01, shl(96, address())) // registry address\n      mstore(0x15, salt) // salt\n\n      // Store computed account address in memory\n      mstore(0x00, shr(96, shl(96, keccak256(0x00, 0x55))))\n\n      // Return computed account address\n      return(0x00, 0x20)\n    }\n  }\n\n  /// @dev Returns true if interfaceId is IERC7656Registry's interfaceId\n  /// This contract does not explicitly extend IERC165 to keep the bytecode as small as possible\n  function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n    return interfaceId == 0xc6bdc908;\n  }\n}\n"
    },
    "contracts/erc/IERC6454.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title EIP-6454 Minimalistic Non-Transferable interface for NFTs\n * @notice see https://eips.ethereum.org/EIPS/eip-6454\n * @notice Note: the ERC-165 identifier for this interface is 0x91a6262f.\n * @authors Bruno Škvorc (@Swader), Francesco Sullo (@sullof), Steven Pineda (@steven2308), Stevan Bogosavljevic (@stevyhacker), Jan Turk (@ThunderDeliverer)\n */\n\npragma solidity ^0.8.20;\n\ninterface IERC6454 {\n  /**\n   * @notice Used to check whether the given token is transferable or not.\n   * @notice If this function returns `false`, the transfer of the token MUST revert execution.\n   * If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for\n   *  minting.\n   * The `from` parameter MAY be used to also validate the approval of the token for transfer, but anyone\n   *  interacting with this function SHOULD NOT rely on it as it is not mandated by the proposal.\n   * @param tokenId ID of the token being checked\n   * @param from Address from which the token is being transferred\n   * @param to Address to which the token is being transferred\n   * @return Boolean value indicating whether the given token is transferable\n   */\n\n  function isTransferable(uint256 tokenId, address from, address to) external view returns (bool);\n}\n"
    },
    "contracts/erc/IERC6982.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.20;\n\n// ERC165 interfaceId 0x6b61a747\ninterface IERC6982 {\n  /**\n   * @notice MUST be emitted when the contract is deployed to establish the default lock status\n   * for all tokens. Also, MUST be emitted again if the default lock status changes,\n   * to ensure the default status for all tokens (without a specific `Locked` event) is updated.\n   */\n  event DefaultLocked(bool locked);\n\n  /**\n   * @notice MUST be emitted when the lock status of a specific token changes.\n   * This status overrides the default lock status for that specific token.\n   */\n  event Locked(uint256 indexed tokenId, bool locked);\n\n  /**\n   * @notice Returns the current default lock status for tokens.\n   * The returned value MUST reflect the status indicated by the most recent `DefaultLocked` event.\n   */\n  function defaultLocked() external view returns (bool);\n\n  /**\n   * @notice Returns the lock status of a specific token.\n   * If no `Locked` event has been emitted for the token, it MUST return the current default lock status.\n   * The function MUST revert if the token does not exist.\n   */\n  function locked(uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/erc/IERC7656Contract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// this is a reduction of IERC6551Account focusing purely on the bond between the NFT and the contract\n\n/**\n * @title IERC7656Contract.sol\n */\ninterface IERC7656Contract {\n  /**\n   * @notice Returns the token linked to the contract\n   * @return chainId The chainId of the token\n   * @return tokenContract The address of the token contract\n   * @return tokenId The tokenId of the token\n   */\n  function token() external view returns (uint256 chainId, address tokenContract, uint256 tokenId);\n\n  /**\n   * @notice Returns the owner of the token\n   */\n  function owner() external view returns (address);\n\n  /**\n   * @notice Returns the address of the token contract\n   */\n  function tokenAddress() external view returns (address);\n\n  /**\n   * @notice Returns the tokenId of the token\n   */\n  function tokenId() external view returns (uint256);\n\n  /**\n   * @notice Returns the implementation used when creating the contract\n   */\n  function implementation() external view returns (address);\n}\n"
    },
    "contracts/erc/IERC7656Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ERC7656\n * @dev Modified registry based on ERC6551Registry\n * https://github.com/erc6551/reference/blob/main/src/ERC6551Registry.sol\n *\n * The ERC165 interfaceId is 0xc6bdc908\n * @notice Manages the creation of token linked accounts\n */\ninterface IERC7656Registry {\n  /**\n   * @notice The registry MUST emit the Created event upon successful contract creation.\n   * @param contractAddress The address of the created contract\n   * @param implementation The address of the implementation contract\n   * @param salt The salt to use for the create2 operation\n   * @param chainId The chain id of the chain where the contract is being created\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   */\n  event Created(\n    address contractAddress,\n    address indexed implementation,\n    bytes32 salt,\n    uint256 chainId,\n    address indexed tokenContract,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * The registry MUST revert with CreationFailed error if the create2 operation fails.\n   */\n  error CreationFailed();\n\n  /**\n   * @notice Creates a token linked account for a non-fungible token.\n   * If account has already been created, returns the account address without calling create2.\n   * @param implementation The address of the implementation contract\n   * @param salt The salt to use for the create2 operation\n   * @param chainId The chain id of the chain where the account is being created\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * Emits Created event.\n   * @return account The address of the token linked account\n   */\n  function create(\n    address implementation,\n    bytes32 salt,\n    uint256 chainId,\n    address tokenContract,\n    uint256 tokenId\n  ) external returns (address account);\n\n  /**\n   * @notice Returns the computed token linked account address for a non-fungible token.\n   * @param implementation The address of the implementation contract\n   * @param salt The salt to use for the create2 operation\n   * @param chainId The chain id of the chain where the account is being created\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @return account The address of the token linked account\n   */\n  function compute(\n    address implementation,\n    bytes32 salt,\n    uint256 chainId,\n    address tokenContract,\n    uint256 tokenId\n  ) external view returns (address account);\n}\n"
    },
    "contracts/guardian/CrunaGuardian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\nimport {ICrunaGuardian} from \"./ICrunaGuardian.sol\";\nimport {IVersioned} from \"../utils/IVersioned.sol\";\n\n/**\n * @title CrunaGuardian\n * @notice Manages a registry of trusted implementations and their required manager versions\n *\n * It is used by\n * - manager and services to upgrade its own  implementation\n * - manager to trust a new plugin implementation and allow managed transfers\n */\ncontract CrunaGuardian is ICrunaGuardian, IVersioned, TimelockController {\n  bool private _allowUntrusted;\n\n  /**\n   * @notice Error returned when the arguments are invalid\n   */\n  error InvalidArguments();\n\n  /**\n   * @notice Error returned when the function is not called through the TimelockController\n   */\n  error MustCallThroughTimeController();\n\n  /**\n   * @notice Modifier to allow only the TimelockController to call a function.\n   */\n  modifier onlyThroughTimeController() {\n    if (msg.sender != address(this)) revert MustCallThroughTimeController();\n    _;\n  }\n\n  /**\n   * @notice Emitted when a trusted implementation is updated\n   */\n  mapping(bytes32 nameIdAndImplementationAddress => bool trusted) private _trustedImplementations;\n\n  /**\n   * @notice When deployed to production, proposers and executors will be multi-sig wallets owned by the Cruna DAO\n   * @param minDelay The minimum delay for timelock operations\n   * @param proposers The addresses that can propose timelock operations\n   * @param executors The addresses that can execute timelock operations\n   * @param admin The address that can admin the contract. It will renounce to the role, as soon as the\n   *  DAO is stable and there are no risks in doing so.\n   */\n  constructor(\n    uint256 minDelay,\n    address[] memory proposers,\n    address[] memory executors,\n    address admin\n  ) TimelockController(minDelay, proposers, executors, admin) {}\n\n  /// @dev see {IVersioned-version}\n  function version() external pure virtual returns (uint256) {\n    // v1.1.0\n    return 1_002_000;\n  }\n\n  /// @dev see {ICrunaGuardian-setTrustedImplementation}\n  function setTrustedImplementation(\n    bytes4 nameId,\n    address implementation,\n    bool trusted\n  ) external override onlyThroughTimeController {\n    bytes32 _key = bytes32(nameId) | bytes32(uint256(uint160(implementation)));\n    if (trusted) {\n      _trustedImplementations[_key] = true;\n    } else {\n      delete _trustedImplementations[_key];\n    }\n    emit TrustedImplementationUpdated(nameId, implementation, trusted);\n  }\n\n  /// @dev see {ICrunaGuardian-trustedImplementation}\n  function trustedImplementation(bytes4 nameId, address implementation) external view override returns (bool) {\n    return _trustedImplementations[bytes32(nameId) | bytes32(uint256(uint160(implementation)))];\n  }\n}\n"
    },
    "contracts/guardian/ICrunaGuardian.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ICrunaGuardian\n * @notice Manages upgrade and cross-chain execution settings for accounts\n */\ninterface ICrunaGuardian {\n  /**\n   * @notice Emitted when a trusted implementation is updated\n   * @param nameId The bytes4 nameId of the implementation\n   * @param implementation The address of the implementation\n   * @param trusted Whether the implementation is marked as a trusted or marked as no more trusted\n   */\n  event TrustedImplementationUpdated(bytes4 indexed nameId, address indexed implementation, bool trusted);\n\n  /**\n   * @notice Sets a given implementation address as trusted, allowing accounts to upgrade to this implementation.\n   * @param nameId The bytes4 nameId of the implementation\n   * @param implementation The address of the implementation\n   * @param trusted When true, it set the implementation as trusted, when false it removes the implementation from the trusted list\n   * Notice that for managers requires will always be 1\n   */\n  function setTrustedImplementation(bytes4 nameId, address implementation, bool trusted) external;\n\n  /**\n   * @notice Returns the manager version required by a trusted implementation\n   * @param nameId The bytes4 nameId of the implementation\n   * @param implementation The address of the implementation\n   * @return True if a trusted implementation\n   */\n  function trustedImplementation(bytes4 nameId, address implementation) external view returns (bool);\n}\n"
    },
    "contracts/libs/Canonical.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IERC6551Registry} from \"erc6551/interfaces/IERC6551Registry.sol\";\n\nimport {ICrunaGuardian} from \"../guardian/ICrunaGuardian.sol\";\nimport {IERC7656Registry} from \"../erc/IERC7656Registry.sol\";\n\n/**\n * @title Canonical\n * @notice Returns the address where registries and guardian have been deployed\n * @dev There are two set of addresses. In both, the registry are on the same addresses, but\n * the guardian has a different address for testing and deployment to localhost (using the 2nd\n * and 3rd hardhat standard wallets as proposer and executor).\n * This contract is for development and testing purposes only. When the package is published\n * to Npm, the addresses will be replaced by the actual addresses of the deployed contracts.\n */\nlibrary Canonical {\n\n  /**\n   * @notice Returns the ERC7656Registry contract\n   */\n  function erc7656Registry() internal pure returns (IERC7656Registry) {\n    return IERC7656Registry(0x7656CCCC1d93430f4E43A7ea0981C01469c9D6A2);\n  }\n\n  /**\n   * @notice Returns the ERC6551Registry contract\n   */\n  function erc6551Registry() internal pure returns (IERC6551Registry) {\n    return IERC6551Registry(0x000000006551c19487814612e58FE06813775758);\n  }\n\n  /**\n   * @notice Returns the CrunaGuardian contract\n   */\n  function crunaGuardian() internal pure returns (ICrunaGuardian) {\n    return ICrunaGuardian(0x1Dc4c2d07e19edffBAe2822eB6c02E90Fb8fB788);\n  }\n}\n"
    },
    "contracts/libs/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.20;\n\n/**\n * @title ExcessivelySafeCall\n * @notice A library to make calls to untrusted contracts safer\n *\n * The original code is at https://github.com/nomad-xyz/ExcessivelySafeCall\n */\nlibrary ExcessivelySafeCall {\n  uint256 private constant _LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n  error BufLengthOverflow();\n\n  /**\n   * @notice Use when you _really_ really _really_ don't trust the called\n   * contract. This prevents the called contract from causing reversion of\n   * the caller in as many ways as we can.\n   * @dev The main difference between this and a solidity low-level call is\n   * that we limit the number of bytes that the callee can cause to be\n   * copied to caller memory. This prevents stupid things like malicious\n   * contracts returning 10,000,000 bytes causing a local OOG when copying\n   * to memory.\n   * @param _target The address to call\n   * @param _gas The amount of gas to forward to the remote contract\n   * @param _value The value in wei to send to the remote contract\n   * @param _maxCopy The maximum number of bytes of returndata to copy\n   * to memory.\n   * @param _calldata The data to send to the remote contract\n   * @return success and returndata, as `.call()`. Returndata is capped to\n   * `_maxCopy` bytes.\n   */\n  function excessivelySafeCall(\n    address _target,\n    uint256 _gas,\n    uint256 _value,\n    uint16 _maxCopy,\n    bytes memory _calldata\n  ) internal returns (bool, bytes memory) {\n    // set up for assembly call\n    uint256 _toCopy;\n    bool _success;\n    bytes memory _returnData = new bytes(_maxCopy);\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      _success := call(\n        _gas, // gas\n        _target, // recipient\n        _value, // ether value\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    return (_success, _returnData);\n  }\n}\n"
    },
    "contracts/libs/ManagerConstants.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\n/**\n * @title ManagerConstants\n * @notice Constants for the manager. Using functions instead of state variables makes easier to manage future upgrades.\n */\nlibrary ManagerConstants {\n  /**\n   * @notice The maximum number of actors that can be added to the manager\n   */\n  function maxActors() internal pure returns (uint256) {\n    return 16;\n  }\n\n  /**\n   * @notice Equivalent to bytes4(keccak256(\"PROTECTOR\"))\n   */\n  function protectorId() internal pure returns (bytes4) {\n    return 0x245ac14a;\n  }\n\n  /**\n   * @notice Equivalent to bytes4(keccak256(\"SAFE_RECIPIENT\"))\n   */\n  function safeRecipientId() internal pure returns (bytes4) {\n    return 0xb58bf73a;\n  }\n\n  /**\n   * @notice The gas passed to the Protected NFT when asking to emit a Locked event\n   */\n  function gasToEmitLockedEvent() internal pure returns (uint256) {\n    return 10_000;\n  }\n\n  /**\n   * @notice The gas passed to services when asking to them mark the plugin as must-be-reset\n   */\n  function gasToResetPlugin() internal pure returns (uint256) {\n    return 9_000;\n  }\n}\n"
    },
    "contracts/libs/TrustedLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title TrustedLib\n */\nlibrary TrustedLib {\n  /**\n   * @notice Returns if untrusted implementations are allowed\n   * @dev When on those chain, it is possible to skip the requirement that an implementation is trusted.\n   *\n   * To keep this function efficient, we support only the most popular chains at the moment.\n   *\n   * - Goerli (soon to be dismissed)\n   * - BNB Testnet\n   * - Chronos Testnet\n   * - Fantom testnet\n   * - Avalance Fuji\n   * - Celo Alfajores\n   * - Gnosis Testnet\n   * - Polygon Mumbai (deprecated)\n   * - Arbitrum Testnet\n   * - Sepolia\n   * - Base Sepolia\n   */\n  function areUntrustedImplementationsAllowed() internal view returns (bool) {\n    uint256 chainId = block.chainid;\n    return (chainId == 5 || // goerli\n      chainId == 97 || // bsc testnet\n      chainId == 338 || // chronos testnet\n      chainId == 4002 || // fantom testnet\n      chainId == 10200 || // gnosis testnet\n      chainId == 43113 || // avalanche fuji\n      chainId == 44787 || // celo alfajores\n      chainId == 80001 || // polygon mumbai\n      //      chainId == 80002 || // polygon amoy looks very unstable\n      chainId == 84532 || // base sepolia\n      chainId == 421614 || // arbitrum testnet\n      chainId == 11155111); // sepolia\n  }\n}\n"
    },
    "contracts/manager/Actor.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\n/**\n * @title Actor\n * @notice This contract manages actors (protectors, safe recipients, sentinels, etc.)\n */\ncontract Actor {\n  /**\n   * @notice The maximum number of actors that can be set\n   */\n  uint256 private constant _MAX_ACTORS = 16;\n\n  /**\n   * @notice The actors for each role\n   */\n  mapping(bytes4 role => address[] actors) internal _actors;\n\n  /**\n   * @notice Error returned when trying to add a zero address\n   */\n  error ZeroAddress();\n\n  /**\n   * @notice Error returned when trying to add an actor already added\n   */\n  error ActorAlreadyAdded();\n\n  /**\n   * @notice Error returned when trying to add too many actors\n   */\n  error TooManyActors();\n\n  /**\n   * @notice Error returned when an actor is not found\n   */\n  error ActorNotFound();\n\n  /**\n   * @notice Returns the actors for a role\n   * @param role The role\n   * @return The actors\n   */\n  function _getActors(bytes4 role) internal view virtual returns (address[] memory) {\n    return _actors[role];\n  }\n\n  /**\n   * @notice Returns the index of an actor for a role\n   * @param actor_ The actor\n   * @param role The role\n   * @return The index. If the index == _MAX_ACTORS, the actor is not found\n   */\n  function _actorIndex(address actor_, bytes4 role) internal view virtual returns (uint256) {\n    address[] storage actors = _actors[role];\n    // This may go out of gas if there are too many actors\n    uint256 len = actors.length;\n    for (uint256 i; i < len; ) {\n      if (actors[i] == actor_) {\n        return i;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    return _MAX_ACTORS;\n  }\n\n  /**\n   * @notice Returns the number of actors for a role\n   * @param role The role\n   * @return The number of actors\n   */\n  function _actorCount(bytes4 role) internal view virtual returns (uint256) {\n    return _actors[role].length;\n  }\n\n  /**\n   * @notice Returns if an actor is active for a role\n   * @param actor_ The actor\n   * @param role The role\n   * @return If the actor is active\n   */\n  function _isActiveActor(address actor_, bytes4 role) internal view virtual returns (bool) {\n    uint256 i = _actorIndex(actor_, role);\n    return i < _MAX_ACTORS;\n  }\n\n  /**\n   * @notice Removes an actor for a role\n   * @param actor_ The actor\n   * @param role The role\n   */\n  function _removeActor(address actor_, bytes4 role) internal virtual {\n    uint256 i = _actorIndex(actor_, role);\n    _removeActorByIndex(i, role);\n  }\n\n  /**\n   * @notice Removes an actor for a role by index\n   * @param i The index\n   * @param role The role\n   */\n  function _removeActorByIndex(uint256 i, bytes4 role) internal virtual {\n    address[] storage actors = _actors[role];\n    unchecked {\n      uint256 len = actors.length;\n      if (len == 0 || i + 1 > len) revert ActorNotFound();\n      if (i != len - 1) {\n        actors[i] = actors[len - 1];\n      }\n    }\n    actors.pop();\n  }\n\n  /**\n   * @notice Adds an actor for a role\n   * @param actor_ The actor\n   * @param role_ The role\n   */\n  function _addActor(address actor_, bytes4 role_) internal virtual {\n    if (actor_ == address(0)) revert ZeroAddress();\n    // We allow to add up to 16 actors per role per owner to avoid the risk of going out of gas\n    // looping the array. Most likely, the user will set between 1 and 7 actors per role, so,\n    // it should be fine\n    if (_actors[role_].length == _MAX_ACTORS - 1) revert TooManyActors();\n    if (_isActiveActor(actor_, role_)) revert ActorAlreadyAdded();\n    _actors[role_].push(actor_);\n  }\n\n  /**\n   * @notice Deletes all the actors for a role\n   * @param role The role\n   */\n  function _deleteActors(bytes4 role) internal virtual {\n    delete _actors[role];\n  }\n\n  // @notice This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/manager/CrunaManager.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {Actor} from \"./Actor.sol\";\nimport {ManagerConstants, CrunaManagerBase} from \"./CrunaManagerBase.sol\";\nimport {ExcessivelySafeCall} from \"../libs/ExcessivelySafeCall.sol\";\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {CrunaManagedService} from \"../services/CrunaManagedService.sol\";\nimport {Canonical} from \"../libs/Canonical.sol\";\nimport {TrustedLib} from \"../libs/TrustedLib.sol\";\nimport {Deployed} from \"../utils/Deployed.sol\";\n\n//import \"hardhat/console.sol\";\n\n/**\n * @title CrunaManager\n * @notice The manager of the Cruna NFT\n * It is the only contract that can manage the NFT. It sets protectors and safe recipients,\n * plugs and manages services, and has the ability to transfer the NFT if there are protectors.\n */\ncontract CrunaManager is Actor, CrunaManagerBase, Deployed {\n  using ECDSA for bytes32;\n  using Strings for uint256;\n  using ExcessivelySafeCall for address;\n\n  /**\n   * @notice The array of all plugged services. The max length is set to 16 to avoid gas issues.\n   */\n  PluginElement[] private _allPlugins;\n\n  /**\n   * @notice The mapping of all services by key. A key is the combination of the nameId and the salt.\n   */\n  mapping(bytes8 pluginKey => PluginConfig pluginDetails) private _pluginByKey;\n\n  /// @dev see {IVersioned-version}\n  function version() external pure virtual override returns (uint256) {\n    return 1_001_000;\n  }\n\n  /// @dev see {ICrunaManager-pluginByKey}\n  function pluginByKey(bytes8 key) external view returns (PluginConfig memory) {\n    return _pluginByKey[key];\n  }\n\n  /// @dev see {ICrunaManager-allPlugins}\n  function allPlugins() external view returns (PluginElement[] memory) {\n    return _allPlugins;\n  }\n\n  /// @dev see {ICrunaManager-pluginByIndex}\n  function pluginByIndex(uint256 index) external view returns (PluginElement memory) {\n    if (index >= _allPlugins.length) revert IndexOutOfBounds();\n    return _allPlugins[index];\n  }\n\n  /// @dev see {ICrunaManager-migrate}\n  function migrate(uint256 /* version */) external virtual override {\n    if (_msgSender() != address(this)) revert Forbidden();\n    // Nothing, for now, since this is the first version of the manager\n  }\n\n  /// @dev see {ICrunaManager-findProtectorIndex}\n  function findProtectorIndex(address protector_) external view virtual override returns (uint256) {\n    return _actorIndex(protector_, ManagerConstants.protectorId());\n  }\n\n  /// @dev see {ICrunaManager-isProtector}\n  function isProtector(address protector_) external view virtual override returns (bool) {\n    return _isActiveActor(protector_, ManagerConstants.protectorId());\n  }\n\n  /// @dev see {ICrunaManager-hasProtectors}\n  function hasProtectors() external view virtual override returns (bool) {\n    return _actorCount(ManagerConstants.protectorId()) != 0;\n  }\n\n  /// @dev see {ICrunaManager-isTransferable}\n  function isTransferable(address to) external view override returns (bool) {\n    return\n      _actors[ManagerConstants.protectorId()].length == 0 ||\n      _actorIndex(to, ManagerConstants.safeRecipientId()) != ManagerConstants.maxActors();\n  }\n\n  /// @dev see {ICrunaManager-locked}\n  function locked() external view override returns (bool) {\n    return _actors[ManagerConstants.protectorId()].length != 0;\n  }\n\n  /// @dev see {ICrunaManager-countProtectors}\n  function countProtectors() external view virtual override returns (uint256) {\n    return _actorCount(ManagerConstants.protectorId());\n  }\n\n  /// @dev see {ICrunaManager-countSafeRecipients}\n  function countSafeRecipients() external view virtual override returns (uint256) {\n    return _actorCount(ManagerConstants.safeRecipientId());\n  }\n\n  /// @dev see {ICrunaManager-setProtector}\n  function setProtector(\n    address protector_,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override onlyTokenOwner {\n    _setSignedActor(\n      this.setProtector.selector,\n      ManagerConstants.protectorId(),\n      protector_,\n      status,\n      timestamp,\n      validFor,\n      signature,\n      _msgSender()\n    );\n    emit ProtectorChange(protector_, status);\n    _emitLockeEvent(_actors[ManagerConstants.protectorId()].length, status);\n  }\n\n  /// @dev see {ICrunaManager-importProtectorsAndSafeRecipientsFrom}\n  function importProtectorsAndSafeRecipientsFrom(uint256 otherTokenId) external virtual override onlyTokenOwner {\n    if (_actorCount(ManagerConstants.protectorId()) != 0) revert ProtectorsAlreadySet();\n    if (_actorCount(ManagerConstants.safeRecipientId()) != 0) revert SafeRecipientsAlreadySet();\n    if (otherTokenId == tokenId()) revert CannotImportProtectorsAndSafeRecipientsFromYourself();\n    if (_vault().ownerOf(otherTokenId) != owner()) revert NotTheSameOwner(_vault().ownerOf(otherTokenId), owner());\n    CrunaManager otherManager = CrunaManager(_vault().managerOf(otherTokenId));\n    if (otherManager.countProtectors() == 0)\n      if (otherManager.countSafeRecipients() == 0) revert NothingToImport();\n    address[] memory otherProtectors = otherManager.getProtectors();\n    uint256 len = otherProtectors.length;\n    for (uint256 i; i < len; ) {\n      _addActor(otherProtectors[i], ManagerConstants.protectorId());\n      unchecked {\n        ++i;\n      }\n    }\n    address[] memory otherSafeRecipients = otherManager.getSafeRecipients();\n    len = otherSafeRecipients.length;\n    for (uint256 i; i < len; ) {\n      _addActor(otherSafeRecipients[i], ManagerConstants.safeRecipientId());\n      unchecked {\n        ++i;\n      }\n    }\n    emit ProtectorsAndSafeRecipientsImported(otherProtectors, otherSafeRecipients, otherTokenId);\n    _emitLockeEvent(1, true);\n  }\n\n  /// @dev see {ICrunaManager-getProtectors}\n  function getProtectors() external view virtual override returns (address[] memory) {\n    return _getActors(ManagerConstants.protectorId());\n  }\n\n  /// @dev see {ICrunaManager-setSafeRecipient}\n  function setSafeRecipient(\n    address recipient,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override onlyTokenOwner {\n    _setSignedActor(\n      this.setSafeRecipient.selector,\n      ManagerConstants.safeRecipientId(),\n      recipient,\n      status,\n      timestamp,\n      validFor,\n      signature,\n      _msgSender()\n    );\n    emit SafeRecipientChange(recipient, status);\n  }\n\n  /// @dev see {ICrunaManager-isSafeRecipient}\n  function isSafeRecipient(address recipient) external view virtual override returns (bool) {\n    return _actorIndex(recipient, ManagerConstants.safeRecipientId()) != ManagerConstants.maxActors();\n  }\n\n  /// @dev see {ICrunaManager-getSafeRecipients}\n  function getSafeRecipients() external view virtual override returns (address[] memory) {\n    return _getActors(ManagerConstants.safeRecipientId());\n  }\n\n  /**\n   *\n   * PLUGINS\n   *\n   */\n\n  /// @dev see {ICrunaManager-plug}\n  function plug(\n    string memory name,\n    address pluginProxy,\n    bool canManageTransfer,\n    bool isERC6551Account,\n    bytes4 salt,\n    bytes memory data,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override nonReentrant onlyTokenOwner {\n    if (_allPlugins.length == 16) {\n      // We do not allow more than 16 managed services to avoid risks of going out-of-gas while\n      // looping through allPlugins.\n      revert PluginNumberOverflow();\n    }\n    bytes4 nameId_ = _stringToBytes4(name);\n    bytes8 _key = _combineBytes4(nameId_, salt);\n    if (_pluginByKey[_key].proxyAddress != address(0) && !_pluginByKey[_key].unplugged) revert PluginAlreadyPlugged();\n    bool trusted = Canonical.crunaGuardian().trustedImplementation(nameId_, pluginProxy);\n    if (!trusted)\n      if (canManageTransfer)\n        if (!TrustedLib.areUntrustedImplementationsAllowed()) {\n          revert UntrustedImplementationsNotAllowedToMakeTransfers();\n        }\n    _preValidateAndCheckSignature(\n      this.plug.selector,\n      pluginProxy,\n      (canManageTransfer ? 1 : 0) * 1e6 + (isERC6551Account ? 1 : 0),\n      uint256(bytes32(salt)),\n      uint256(_hashBytes(data)),\n      timestamp,\n      validFor,\n      signature\n    );\n    if (_pluginByKey[_key].banned) revert PluginHasBeenMarkedAsNotPluggable();\n    _plug(name, pluginProxy, canManageTransfer, isERC6551Account, nameId_, salt, data, _key, trusted);\n  }\n\n  /// @dev see {ICrunaManager-changePluginStatus}\n  function changePluginStatus(\n    string calldata name,\n    bytes4 salt,\n    PluginChange change,\n    uint256 timeLock_,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override nonReentrant onlyTokenOwner {\n    bytes4 nameId_ = _stringToBytes4(name);\n    (bool plugged_, uint256 i) = _pluginIndex(nameId_, salt);\n    if (!plugged_) revert PluginNotFound();\n    _preValidateAndCheckSignature(\n      this.changePluginStatus.selector,\n      _pseudoAddress(name, salt),\n      uint256(change),\n      timeLock_,\n      0,\n      timestamp,\n      validFor,\n      signature\n    );\n    bytes8 _key = _combineBytes4(nameId_, salt);\n    if (change == PluginChange.Disable) {\n      _disablePlugin(i, _key);\n    } else if (change == PluginChange.ReEnable) {\n      _reEnablePlugin(i, _key);\n    } else if (change == PluginChange.Authorize || change == PluginChange.DeAuthorize) {\n      emit PluginStatusChange(name, salt, _pluginAddress(nameId_, salt), timeLock_ * 1e3 + uint256(change));\n      _authorizePluginToTransfer(nameId_, salt, _key, change, timeLock_);\n      return;\n    } else if (change == PluginChange.Unplug || change == PluginChange.UnplugForever) {\n      emit PluginStatusChange(name, salt, _pluginAddress(nameId_, salt), uint256(change));\n      _unplugPlugin(i, nameId_, salt, _key, change);\n      return;\n    } else if (change == PluginChange.Reset) {\n      _resetPlugin(nameId_, salt);\n    } else revert UnsupportedPluginChange();\n    emit PluginStatusChange(name, salt, _pluginAddress(nameId_, salt), uint256(change));\n  }\n\n  /// @dev see {ICrunaManager-trustPlugin}\n  function trustPlugin(string calldata name, bytes4 salt) external virtual override onlyTokenOwner {\n    bytes4 nameId_ = _stringToBytes4(name);\n    bytes8 _key = _combineBytes4(nameId_, salt);\n    if (_pluginByKey[_key].proxyAddress == address(0)) revert PluginNotFound();\n    if (_pluginByKey[_key].trusted) revert PluginAlreadyTrusted();\n    if (Canonical.crunaGuardian().trustedImplementation(nameId_, _pluginByKey[_key].proxyAddress)) {\n      _pluginByKey[_key].trusted = true;\n      emit PluginTrusted(name, salt);\n    } else revert StillUntrusted();\n  }\n\n  /// @dev see {ICrunaManager-pluginAddress}\n  function pluginAddress(bytes4 nameId_, bytes4 salt) external view virtual override returns (address payable) {\n    return _pluginAddress(nameId_, salt);\n  }\n\n  /// @dev see {ICrunaManager-plugin}\n  function plugin(bytes4 nameId_, bytes4 salt) external view virtual override returns (CrunaManagedService) {\n    return _plugin(nameId_, salt);\n  }\n\n  /// @dev see {ICrunaManager-countPlugins}\n  function countPlugins() external view virtual override returns (uint256, uint256) {\n    return _countPlugins();\n  }\n\n  /// @dev see {ICrunaManager-plugged}\n  function plugged(string calldata name, bytes4 salt) external view virtual returns (bool) {\n    bytes4 nameId_ = _stringToBytes4(name);\n    return\n      _pluginByKey[_combineBytes4(nameId_, salt)].proxyAddress != address(0) &&\n      !_pluginByKey[_combineBytes4(nameId_, salt)].unplugged;\n  }\n\n  /// @dev see {ICrunaManager-pluginIndex}\n  function pluginIndex(string calldata name, bytes4 salt) external view virtual returns (bool, uint256) {\n    return _pluginIndex(_stringToBytes4(name), salt);\n  }\n\n  /// @dev see {ICrunaManager-isPluginActive}\n  function isPluginActive(string calldata name, bytes4 salt) external view virtual returns (bool) {\n    bytes4 nameId_ = _stringToBytes4(name);\n    bytes8 _key = _combineBytes4(nameId_, salt);\n    if (_pluginByKey[_key].proxyAddress == address(0)) revert PluginNotFound();\n    return _pluginByKey[_key].active;\n  }\n\n  /// @dev see {ICrunaManager-listPluginsKeys}\n  function listPluginsKeys(bool active) external view virtual returns (bytes8[] memory) {\n    (uint256 actives, uint256 disabled) = _countPlugins();\n    bytes8[] memory _keys = new bytes8[](active ? actives : disabled);\n    uint256 len = _allPlugins.length;\n    for (uint256 i; i < len; ) {\n      PluginElement storage plugin_ = _allPlugins[i];\n      if (plugin_.active == active) {\n        _keys[i] = _combineBytes4(plugin_.nameId, plugin_.salt);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    return _keys;\n  }\n\n  /// @dev see {ICrunaManager-pseudoAddress}\n  function pseudoAddress(string calldata name, bytes4 _salt) external view virtual returns (address) {\n    return _pseudoAddress(name, _salt);\n  }\n\n  /**\n   * @notice see {IProtectedNFT-managedTransfer}.\n   */\n  function managedTransfer(bytes4 pluginNameId, address to) external virtual override nonReentrant {\n    (bytes8 _key, bytes4 salt) = _getKeyAndSalt(pluginNameId);\n    if (_key == bytes8(0) || !_pluginByKey[_key].active) revert PluginNotFoundOrDisabled();\n    if (_pluginAddress(pluginNameId, salt) != _msgSender()) revert NotTheAuthorizedPlugin(_msgSender());\n    _removeLockIfExpired(pluginNameId, salt);\n    if (!_pluginByKey[_key].canManageTransfer) revert PluginNotAuthorizedToManageTransfer();\n    if (!_pluginByKey[_key].trusted)\n      if (!TrustedLib.areUntrustedImplementationsAllowed()) revert UntrustedImplementationsNotAllowedToMakeTransfers();\n    _resetOnTransfer(pluginNameId, salt);\n    // In theory, the vault may revert, blocking the entire process\n    // We allow it, assuming that the vault implementation has the\n    // right to set up more advanced rules, before allowing the transfer,\n    // despite the plugin has the ability to do so.\n    _vault().managedTransfer(pluginNameId, tokenId(), to);\n  }\n\n  /**\n   * @notice see {IProtectedNFT-protectedTransfer}.\n   */\n  function protectedTransfer(\n    uint256 tokenId_,\n    address to,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external override onlyTokenOwner {\n    if (timestamp == 0) revert ToBeUsedOnlyWhenProtectorsAreActive();\n    _preValidateAndCheckSignature(this.protectedTransfer.selector, to, 0, 0, 0, timestamp, validFor, signature);\n    _resetOnTransfer(bytes4(0), bytes4(0));\n    _vault().managedTransfer(_nameId(), tokenId_, to);\n  }\n\n  // Internal function to get an instance of the plugin\n  function _plugin(bytes4 nameId_, bytes4 salt) internal view virtual returns (CrunaManagedService) {\n    return CrunaManagedService(_pluginAddress(nameId_, salt));\n  }\n\n  /**\n   * @notice returns the address of a deployed plugin\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt of the plugin\n   */\n  function _pluginAddress(bytes4 nameId_, bytes4 salt) internal view virtual returns (address payable) {\n    PluginConfig storage config_ = _pluginByKey[_combineBytes4(nameId_, salt)];\n    return payable(_addressOfDeployed(config_.proxyAddress, salt, tokenAddress(), tokenId(), config_.isERC6551Account));\n  }\n\n  /**\n   * @notice returns the name Id of the manager\n   */\n  function _nameId() internal view virtual override returns (bytes4) {\n    return bytes4(keccak256(\"CrunaManager\"));\n  }\n\n  /**\n   * @notice returns a pseudoaddress composed by the name of the plugin and the salt used\n   * to deploy it. This is needed to pass a valid address as an actor to the SignatureValidator\n   * @param name The name of the plugin\n   * @param _salt The salt used to deploy the plugin\n   * @return The pseudoaddress\n   */\n  function _pseudoAddress(string calldata name, bytes4 _salt) internal view virtual returns (address) {\n    return address(uint160(uint256(keccak256(abi.encodePacked(name, _salt)))));\n  }\n\n  /**\n   * @notice Counts the active and disabled services\n   */\n  function _countPlugins() internal view virtual returns (uint256, uint256) {\n    uint256 active;\n    uint256 disabled;\n    uint256 len = _allPlugins.length;\n    for (uint256 i; i < len; ) {\n      unchecked {\n        if (_allPlugins[i].active) active++;\n        else disabled++;\n        ++i;\n      }\n    }\n    return (active, disabled);\n  }\n\n  /**\n   * @notice Internal function to disable a plugin but index and key\n   * @param i The index of the plugin in the _allPlugins array\n   * @param _key The key of the plugin\n   */\n  function _disablePlugin(uint256 i, bytes8 _key) internal {\n    if (!_allPlugins[i].active) revert PluginAlreadyDisabled();\n    delete _allPlugins[i].active;\n    delete _pluginByKey[_key].active;\n  }\n\n  /**\n   * @notice Internal function to re-enable a plugin but index and key\n   * @param i The index of the plugin in the _allPlugins array\n   * @param _key The key of the plugin\n   */\n  function _reEnablePlugin(uint256 i, bytes8 _key) internal {\n    if (_allPlugins[i].active) revert PluginNotDisabled();\n    _allPlugins[i].active = true;\n    _pluginByKey[_key].active = true;\n  }\n\n  /**\n   * @notice Unplugs a plugin\n   * @param i The index of the plugin in the _allPlugins array\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt used to deploy the plugin\n   * @param _key The key of the plugin\n   * @param change The change to be made (Unplug or UnplugForever)\n   */\n  function _unplugPlugin(uint256 i, bytes4 nameId_, bytes4 salt, bytes8 _key, PluginChange change) internal {\n    if (_pluginByKey[_key].canBeReset) {\n      if (change == PluginChange.UnplugForever) {\n        // The plugin is somehow hostile (for example cause reverts trying to reset it)\n        // We mark it as no not pluggable, to avoid re-plugging it in the future.\n        // Notice that the same type of plugin can still be plugged using a different salt.\n        _pluginByKey[_key].banned = true;\n      } else {\n        // resets the plugin\n        _resetPlugin(nameId_, salt);\n      }\n    }\n    // _allPlugins.length is > 0 because we are unplugging an existing plugin\n    if (i != _allPlugins.length - 1) {\n      _allPlugins[i] = _allPlugins[_allPlugins.length - 1];\n    }\n    _allPlugins.pop();\n    _pluginByKey[_key].unplugged = true;\n  }\n\n  /**\n   * @notice Id removing the authorization, it blocks a plugin for a maximum of 30 days from transferring\n   * the NFT. If the services must be blocked for more time, disable it at your peril of making it useless.\n   */\n  function _authorizePluginToTransfer(\n    bytes4 nameId_,\n    bytes4 salt,\n    bytes8 _key,\n    PluginChange change,\n    uint256 timeLock\n  ) internal virtual {\n    if (!_pluginByKey[_key].trusted)\n      if (!TrustedLib.areUntrustedImplementationsAllowed()) revert UntrustedImplementationsNotAllowedToMakeTransfers();\n    CrunaManagedService plugin_ = _plugin(nameId_, salt);\n    if (!plugin_.requiresToManageTransfer()) revert NotATransferPlugin();\n    if (change == PluginChange.Authorize) {\n      if (timeLock != 0) revert InvalidTimeLock(timeLock);\n      if (_pluginByKey[_key].canManageTransfer) revert PluginAlreadyAuthorized();\n      delete _pluginByKey[_key].timeLock;\n      _pluginByKey[_key].canManageTransfer = true;\n    } else {\n      // more gas efficient than using an || operator\n      if (timeLock == 0) revert InvalidTimeLock(timeLock);\n      if (timeLock > 30 days) revert InvalidTimeLock(timeLock);\n      if (!_pluginByKey[_key].canManageTransfer) revert PluginAlreadyUnauthorized();\n      _pluginByKey[_key].timeLock = uint32(block.timestamp + timeLock);\n      delete _pluginByKey[_key].canManageTransfer;\n    }\n  }\n\n  /**\n   * @notice Override required by SignatureValidator to check if a signer is authorized to pre-approve an operation\n   * @param selector The selector of the called function\n   * @param actor The actor to be approved\n   * @param signer The signer of the operation (the protector)\n   */\n  function _canPreApprove(bytes4 selector, address actor, address signer) internal view virtual override returns (bool) {\n    if (_actors[ManagerConstants.protectorId()].length == 0) {\n      // if there are no protectors, the signer can pre-approve its own candidate\n      return selector == this.setProtector.selector && actor == signer;\n    }\n    return _isActiveActor(signer, ManagerConstants.protectorId());\n  }\n\n  /**\n   * @notice Internal function plug a plugin\n   * @param name The name of the plugin\n   * @param proxyAddress_ The address of the plugin\n   * @param canManageTransfer If the plugin can manage the transfer of the NFT\n   * @param isERC6551Account If the plugin is an ERC6551 account\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt used to deploy the plugin\n   * @param data Optional data to be passed to the service\n   * @param _key The key of the plugin\n   * @param trusted true if the implementation is trusted\n   */\n  function _plug(\n    string memory name,\n    address proxyAddress_,\n    bool canManageTransfer,\n    bool isERC6551Account,\n    bytes4 nameId_,\n    bytes4 salt,\n    bytes memory data,\n    bytes8 _key,\n    bool trusted\n  ) internal {\n    // If the plugin has been plugged before and later unplugged, the proxy won't be deployed again.\n    address pluginAddress_ = _deploy(proxyAddress_, salt, tokenAddress(), tokenId(), isERC6551Account);\n    CrunaManagedService plugin_ = CrunaManagedService(payable(pluginAddress_));\n    if (!plugin_.isManaged()) revert UnmanagedService();\n    uint256 requiredVersion = plugin_.requiresManagerVersion();\n    if (requiredVersion > _version()) revert PluginRequiresUpdatedManager(requiredVersion);\n    if (plugin_.nameId() != nameId_) revert InvalidImplementation(plugin_.nameId(), nameId_);\n    if (plugin_.isERC6551Account() != isERC6551Account) revert InvalidERC6551Status();\n    /**\n     * @dev it is the service responsibility to assure that `init` can be called only one time\n     * The rationale for call `init` anytime is that an hostile agent can use the registry to deploy\n     * a service that later cannot be initiated if the can be initiated only at the deployment.\n     */\n    plugin_.init(data);\n    _allPlugins.push(PluginElement({active: true, salt: salt, nameId: nameId_}));\n    if (_pluginByKey[_key].unplugged) {\n      if (_pluginByKey[_key].proxyAddress != proxyAddress_)\n        revert InconsistentProxyAddresses(_pluginByKey[_key].proxyAddress, proxyAddress_);\n    }\n    _pluginByKey[_key] = PluginConfig({\n      proxyAddress: proxyAddress_,\n      salt: salt,\n      timeLock: 0,\n      canManageTransfer: canManageTransfer,\n      canBeReset: plugin_.requiresResetOnTransfer(),\n      active: true,\n      isERC6551Account: isERC6551Account,\n      trusted: trusted,\n      banned: false,\n      unplugged: false\n    });\n    emit PluginStatusChange(name, salt, pluginAddress_, uint256(PluginChange.Plug));\n  }\n\n  // @dev Adds an actor, validating the data.\n  // @param roleString The scope of the request, i.e., the type of actor.\n  // @param role_ The role of the actor.\n  // @param actor The actor address.\n  // @param status The status of the request.\n  // @param timestamp The timestamp of the request.\n  // @param validFor The validity of the request.\n  // @param signature The signature of the request.\n  function _setSignedActor(\n    bytes4 _functionSelector,\n    bytes4 role_,\n    address actor,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature,\n    address sender\n  ) internal virtual {\n    if (actor == address(0)) revert ZeroAddress();\n    if (actor == sender) revert CannotBeYourself();\n    _preValidateAndCheckSignature(_functionSelector, actor, status ? 1 : 0, 0, 0, timestamp, validFor, signature);\n    if (status) {\n      if (timestamp != 0)\n        if (_functionSelector == this.setProtector.selector)\n          if (_isActiveActor(actor, ManagerConstants.protectorId())) revert ProtectorAlreadySetByYou(actor);\n      _addActor(actor, role_);\n    } else {\n      if (timestamp != 0)\n        if (_functionSelector == this.setProtector.selector)\n          if (!_isActiveActor(actor, ManagerConstants.protectorId()))\n            // setProtector\n            revert ProtectorNotFound(actor);\n      _removeActor(actor, role_);\n    }\n  }\n\n  /**\n   * @notice It asks the NFT to emit a Locked event, according to IERC6982\n   * @param protectorsCount The number of protectors\n   * @param status If latest protector has been added or removed\n   */\n  function _emitLockeEvent(uint256 protectorsCount, bool status) internal virtual {\n    if ((status && protectorsCount == 1) || (!status && protectorsCount == 0)) {\n      // Avoid to revert if the emission of the event fails.\n      // It should never happen, but if it happens, we are\n      // notified by the EmitLockedEventFailed event, instead of reverting\n      // the entire transaction.\n      address vaultAddress = address(_vault());\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool success, ) = vaultAddress.excessivelySafeCall(\n        ManagerConstants.gasToEmitLockedEvent(),\n        0,\n        32,\n        abi.encodeWithSignature(\"emitLockedEvent(uint256,bool)\", tokenId(), status && protectorsCount == 1)\n      );\n      if (!success) {\n        // we emit a local event to alert. Not ideal, but better than reverting\n        emit EmitLockedEventFailed();\n      }\n    }\n  }\n\n  /**\n   * @notice It returns the key and the salt of the current plugin calling the manager\n   * @param pluginNameId The nameId of the plugin\n   */\n  function _getKeyAndSalt(bytes4 pluginNameId) internal view returns (bytes8, bytes4) {\n    uint256 len = _allPlugins.length;\n    for (uint256 i; i < len; ) {\n      PluginElement storage plugin_ = _allPlugins[i];\n      bytes4 nameId_ = plugin_.nameId;\n      if (nameId_ == pluginNameId) {\n        bytes8 key_ = _combineBytes4(nameId_, plugin_.salt);\n        if (_pluginAddress(pluginNameId, plugin_.salt) == _msgSender()) {\n          return (key_, plugin_.salt);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    return (bytes8(0), bytes4(0));\n  }\n\n  /**\n   * @notice It returns the index of the plugin in the _allPlugins array\n   */\n  function _pluginIndex(bytes4 nameId_, bytes4 salt) internal view virtual returns (bool, uint256) {\n    uint256 len = _allPlugins.length;\n    for (uint256 i; i < len; ) {\n      if (nameId_ == _allPlugins[i].nameId)\n        if (_allPlugins[i].salt == salt) {\n          return (true, i);\n        }\n      unchecked {\n        ++i;\n      }\n    }\n    return (false, 0);\n  }\n\n  /**\n   * @notice Util to validate and check the signature\n   * @param selector The selector of the function\n   * @param actor The address of the actor (if a protector/safe recipient) or the pseudoAddress of a plugin\n   * @param extra An extra value to be signed\n   * @param extra2 An extra value to be signed\n   * @param extra3 An extra value to be signed\n   * @param timestamp The timestamp of the request\n   * @param validFor The validity of the request\n   * @param signature The signature of the request\n   */\n  function _preValidateAndCheckSignature(\n    bytes4 selector,\n    address actor,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) internal virtual {\n    if (validFor > _MAX_VALID_FOR) revert InvalidValidity();\n    _validateAndCheckSignature(\n      selector,\n      owner(),\n      actor,\n      tokenAddress(),\n      tokenId(),\n      extra,\n      extra2,\n      extra3,\n      timestamp * _TIMESTAMP_MULTIPLIER + validFor,\n      signature\n    );\n  }\n\n  /**\n   * @notice It resets a plugin\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt of the plugin\n   */\n  function _resetPlugin(bytes4 nameId_, bytes4 salt) internal virtual {\n    CrunaManagedService plugin_ = _plugin(nameId_, salt);\n    plugin_.resetService();\n  }\n\n  /**\n   * @notice It resets a plugin on transfer.\n   * It tries to minimize risks and gas consumption limiting the amount of gas sent to\n   * the plugin. Since the called function should not be overridden, it should be safe.\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt of the plugin\n   */\n  function _resetPluginOnTransfer(bytes4 nameId_, bytes4 salt) internal virtual {\n    address plugin_ = _pluginAddress(nameId_, salt);\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, ) = plugin_.excessivelySafeCall(\n      ManagerConstants.gasToResetPlugin(),\n      0,\n      32,\n      abi.encodeWithSignature(\"resetOnTransfer()\")\n    );\n    if (!success) {\n      // This should never happen. But it can happen if the user replace CrunaManagedService\n      // with its own implementation — not advised to do :-(\n      emit PluginResetAttemptFailed(nameId_, salt);\n    }\n  }\n\n  /**\n   * @notice If a plugin has been temporarily deAuthorized from transferring the tolen, it\n   * removes the lock if the lock is expired\n   * @param nameId_ The nameId of the plugin\n   * @param salt The salt of the plugin\n   */\n  function _removeLockIfExpired(bytes4 nameId_, bytes4 salt) internal virtual {\n    bytes8 _key = _combineBytes4(nameId_, salt);\n    if (_pluginByKey[_key].timeLock < block.timestamp) {\n      delete _pluginByKey[_key].timeLock;\n      _pluginByKey[_key].canManageTransfer = true;\n    }\n  }\n\n  /**\n   * @notice It resets the manager on transfer\n   * @param nameId_ The nameId of the plugin calling the transfer\n   * @param salt The salt of the plugin calling the transfer\n   */\n  function _resetOnTransfer(bytes4 nameId_, bytes4 salt) internal virtual {\n    _deleteActors(ManagerConstants.protectorId());\n    _deleteActors(ManagerConstants.safeRecipientId());\n    // disable all services\n    uint256 len = _allPlugins.length;\n    for (uint256 i; i < len; ) {\n      PluginElement storage plugin_ = _allPlugins[i];\n      bytes4 _nameId_ = plugin_.nameId;\n      if (_nameId_ != nameId_ || plugin_.salt != salt) {\n        if (_pluginByKey[_combineBytes4(_nameId_, plugin_.salt)].canBeReset) _resetPluginOnTransfer(_nameId_, plugin_.salt);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    emit Reset();\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/manager/CrunaManagerBase.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {StorageSlot} from \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {ICrunaManager} from \"./ICrunaManager.sol\";\nimport {CommonBase} from \"../utils/CommonBase.sol\";\nimport {Canonical} from \"../libs/Canonical.sol\";\nimport {INamedAndVersioned} from \"../utils/INamedAndVersioned.sol\";\nimport {SignatureValidator} from \"../utils/SignatureValidator.sol\";\nimport {Actor} from \"../manager/Actor.sol\";\nimport {ManagerConstants} from \"../libs/ManagerConstants.sol\";\n\n/**\n * @title CrunaManagerBase.sol\n * @notice Base contract for managers and services\n */\nabstract contract CrunaManagerBase is ICrunaManager, CommonBase, Actor, SignatureValidator, ReentrancyGuard {\n  /**\n   * @notice Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @notice Upgrade the implementation of the manager\n   * @param implementation_ The new implementation\n   */\n  function upgrade(address implementation_) external virtual override nonReentrant {\n    if (owner() != _msgSender()) revert NotTheTokenOwner();\n    if (implementation_ == address(0)) revert ZeroAddress();\n    if (!Canonical.crunaGuardian().trustedImplementation(bytes4(keccak256(\"CrunaManager\")), implementation_))\n      revert UntrustedImplementation(implementation_);\n    INamedAndVersioned impl = INamedAndVersioned(implementation_);\n    uint256 currentVersion = _version();\n    uint256 newVersion = impl.version();\n    if (newVersion <= _version()) revert InvalidVersion(_version(), newVersion);\n    if (impl.nameId() != _stringToBytes4(\"CrunaManager\")) revert NotAManager(_msgSender());\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = implementation_;\n    emit ImplementationUpgraded(implementation_, currentVersion, newVersion);\n    CrunaManagerBase _newManager = CrunaManagerBase(address(this));\n    _newManager.migrate(currentVersion);\n  }\n\n  /**\n   * @notice Execute actions needed in a new manager based on the previous version\n   * @param previousVersion The previous version\n   */\n  function migrate(uint256 previousVersion) external virtual;\n\n  /**\n   * @notice Utility function to combine two bytes4 into a bytes8\n   */\n  function _combineBytes4(bytes4 a, bytes4 b) internal pure returns (bytes8) {\n    return bytes8(bytes32(a) | (bytes32(b) >> 32));\n  }\n\n  /**\n   * @notice Check if the NFT is protected\n   * Required by SignatureValidator\n   */\n  function _isProtected() internal view override returns (bool) {\n    return _actorCount(ManagerConstants.protectorId()) != 0;\n  }\n\n  /**\n   * @notice Checks if an address is a protector\n   * Required by SignatureValidator\n   * @param protector_ The address to check\n   */\n  function _isProtector(address protector_) internal view override returns (bool) {\n    return _isActiveActor(protector_, ManagerConstants.protectorId());\n  }\n\n  // @notice Returns the version of the manager\n  function _version() internal pure virtual returns (uint256) {\n    return 1_000_000;\n  }\n\n  /**\n   * @notice Returns the keccak256 of a string variable.\n   * It saves gas compared to keccak256(abi.encodePacked(string)).\n   * @param input The string to hash\n   */\n  function _hashString(string memory input) internal pure returns (bytes32 result) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the pointer to the free memory slot\n      let ptr := mload(0x40)\n      // Copy data using Solidity's default encoding, which includes the length\n      mstore(ptr, mload(add(input, 32)))\n      // Calculate keccak256 hash\n      result := keccak256(ptr, mload(input))\n    }\n  }\n\n  /**\n   * @notice Returns the equivalent of bytes4(keccak256(str).\n   * @param str The string to hash\n   */\n  function _stringToBytes4(string memory str) internal pure returns (bytes4) {\n    return bytes4(_hashString(str));\n  }\n\n  // @notice This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/manager/CrunaManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC6551AccountProxy} from \"../erc/ERC6551AccountProxy.sol\";\n\n/**\n * @title CrunaManagerProxy\n * @notice Proxy contract for the CrunaManager\n */\ncontract CrunaManagerProxy is ERC6551AccountProxy {\n  /**\n   * @notice Constructor\n   * @param _initialImplementation Address of the initial implementation\n   */\n  constructor(address _initialImplementation) ERC6551AccountProxy(_initialImplementation) {}\n}\n"
    },
    "contracts/manager/ICrunaManager.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {CrunaManagedService} from \"../services/CrunaManagedService.sol\";\n\nimport {IVersioned} from \"../utils/IVersioned.sol\";\nimport {IERC7656Contract} from \"../erc/IERC7656Contract.sol\";\n\ninterface ICrunaManager is IERC7656Contract, IVersioned {\n  /**\n   * @notice A struct to keep info about plugged and unplugged services\n   * @param proxyAddress The address of the first implementation of the plugin\n   * @param salt The salt used during the deployment of the plugin.\n   * It allows to  have multiple instances of the same plugin\n   * @param timeLock The time lock for when a plugin is temporarily unauthorized from making transfers\n   * @param canManageTransfer True if the plugin can manage transfers\n   * @param canBeReset True if the plugin requires a reset when the vault is transferred\n   * @param active True if the plugin is active\n   * @param isERC6551Account True if the plugin is an ERC6551 account\n   * @param trusted True if the plugin is trusted\n   * @param banned True if the plugin is banned during the unplug process\n   * @param unplugged True if the plugin has been unplugged\n   */\n  struct PluginConfig {\n    address proxyAddress;\n    bytes4 salt;\n    uint32 timeLock;\n    bool canManageTransfer;\n    bool canBeReset;\n    bool active;\n    bool isERC6551Account;\n    bool trusted;\n    bool banned;\n    bool unplugged;\n  }\n\n  /**\n   * @notice The plugin element\n   * @param nameId The bytes4 of the hash of the name of the plugin\n   * All services' names must be unique, as well as their bytes4 Ids\n   * An official registry will be set up to avoid collisions when services\n   * development will be more active. Using the proxy address as a key is\n   * not viable because services can be upgraded and the address can change.\n   * @param salt The salt of the plugin\n   * @param active True if the plugin is active\n   */\n  struct PluginElement {\n    bytes4 nameId;\n    bytes4 salt;\n    // redundant to optimize gas usage\n    bool active;\n  }\n\n  /**\n   * @notice It enumerates the action that can be performed when changing the status of a plugin\n   */\n  enum PluginChange {\n    Plug,\n    Unplug,\n    Disable,\n    ReEnable,\n    Authorize,\n    DeAuthorize,\n    UnplugForever,\n    Reset\n  }\n\n  /**\n   * @notice Event emitted when the manager call to the NFT to emit a Locked event fails.\n   */\n  event EmitLockedEventFailed();\n\n  /**\n   * @notice Event emitted when the `status` of `protector` changes\n   */\n  event ProtectorChange(address indexed protector, bool status);\n\n  /**\n   * @notice Event emitted when protectors and safe recipients are imported from another token\n   */\n  event ProtectorsAndSafeRecipientsImported(address[] protectors, address[] safeRecipients, uint256 fromTokenId);\n\n  /**\n   * @notice Event emitted when the `status` of `recipient` changes\n   */\n  event SafeRecipientChange(address indexed recipient, bool status);\n\n  /**\n   * @notice Event emitted when\n   * the status of plugin identified by `name` and `salt`, and deployed to `pluginAddress` gets a specific `change`\n   */\n  event PluginStatusChange(string indexed name, bytes4 salt, address pluginAddress, uint256 change);\n\n  /**\n   * @notice Emitted when protectors and safe recipients are removed and all services are disabled (if they require it)\n   * This event overrides any specific ProtectorChange, SafeRecipientChange and PluginStatusChange event\n   */\n  event Reset();\n\n  /**\n   * @notice Emitted when a plugin initially plugged despite being not trusted, is trusted by the CrunaGuardian\n   */\n  event PluginTrusted(string indexed name, bytes4 salt);\n\n  /**\n   * @notice Emitted when the implementation of the manager is upgraded\n   * @param implementation_ The address of the new implementation\n   * @param oldVersion The old version of the manager\n   * @param newVersion The new version of the manager\n   */\n  event ImplementationUpgraded(address indexed implementation_, uint256 oldVersion, uint256 newVersion);\n\n  /**\n   * @notice Event emitted when the attempt to reset a plugin fails\n   * When this happens, the token owner can unplug the plugin and mark it as banned to avoid future re-plugs\n   */\n  event PluginResetAttemptFailed(bytes4 _nameId, bytes4 salt);\n\n  /**\n   * @notice Returned when trying to upgrade the manager to an untrusted implementation\n   */\n  error UntrustedImplementation(address implementation);\n\n  /**\n   * @notice Returned when trying to upgrade to an older version of the manager\n   */\n  error InvalidVersion(uint256 oldVersion, uint256 newVersion);\n\n  /**\n   * @notice Returned when trying to plug a plugin that requires a new version of the manager\n   */\n  error PluginRequiresUpdatedManager(uint256 requiredVersion);\n\n  /**\n   * @notice Returned when the sender has no right to execute a function\n   */\n  error Forbidden();\n\n  /**\n   * @notice Returned when the sender is not a manager\n   */\n  error NotAManager(address sender);\n\n  /**\n   * @notice Returned when a protector is not found\n   */\n  error ProtectorNotFound(address protector);\n\n  /**\n   * @notice Returned when a protector is already set by the sender\n   */\n  error ProtectorAlreadySetByYou(address protector);\n\n  /**\n   * @notice Returned when a protector is already set\n   */\n  error ProtectorsAlreadySet();\n\n  /**\n   * @notice Returned when trying to set themself as a protector\n   */\n  error CannotBeYourself();\n\n  /**\n   * @notice Returned when the managed transfer is called not by the right plugin\n   */\n  error NotTheAuthorizedPlugin(address callingPlugin);\n\n  /**\n   * @notice Returned when the pluggin service is not a managed service\n   */\n  error UnmanagedService();\n\n  /**\n   * @notice Returned when there is no more space for services\n   */\n  error PluginNumberOverflow();\n\n  /**\n   * @notice Returned when the plugin has been banned and marked as not pluggable\n   */\n  error PluginHasBeenMarkedAsNotPluggable();\n\n  /**\n   * @notice Returned when a plugin has already been plugged\n   */\n  error PluginAlreadyPlugged();\n\n  /**\n   * @notice Returned when a plugin is not found\n   */\n  error PluginNotFound();\n\n  /**\n   * @notice Returned when trying to plug an unplugged plugin and the address of the implementation differ\n   */\n  error InconsistentProxyAddresses(address currentAddress, address proposedAddress);\n\n  /**\n   * @notice Returned when a plugin is not found or is disabled\n   */\n  error PluginNotFoundOrDisabled();\n\n  /**\n   * @dev Returned when tryng to re-enable a not-disabled plugin\n   */\n  error PluginNotDisabled();\n\n  /**\n   * @dev Returned when trying to disable a plugin that is already disabled\n   */\n  error PluginAlreadyDisabled();\n\n  /**\n   * @dev Returned when a plugin tries to transfer the NFT without authorization\n   */\n  error PluginNotAuthorizedToManageTransfer();\n\n  /**\n   * @dev Returned when a plugin has already been authorized\n   */\n  error PluginAlreadyAuthorized();\n\n  /**\n   * @dev Returned when a plugin has already been unauthorized\n   */\n  error PluginAlreadyUnauthorized();\n\n  /**\n   * @dev Returned when a plugin is not authorized to make transfers\n   */\n  error NotATransferPlugin();\n\n  /**\n   * @dev Returned when trying to plug a plugin that responds to a different nameId\n   */\n  error InvalidImplementation(bytes4 nameIdReturnedByPlugin, bytes4 proposedNameId);\n\n  /**\n   * @dev Returned when setting an invalid TimeLock when temporarily de-authorizing a plugin\n   */\n  error InvalidTimeLock(uint256 timeLock);\n\n  /**\n   * @dev Returned when calling a function with a validity overflowing the maximum value\n   */\n  error InvalidValidity();\n\n  /**\n   * @dev Returned when plugging plugin as ERC6551 while the plugin is not an ERC6551 account, or vice versa\n   */\n  error InvalidERC6551Status();\n\n  /**\n   * @dev Returned when trying to make a transfer with an untrusted plugin, when the NFT accepts only trusted ones\n   */\n  error UntrustedImplementationsNotAllowedToMakeTransfers();\n\n  /**\n   * @dev Returned if trying to trust a plugin that is still untrusted\n   */\n  error StillUntrusted();\n\n  /**\n   * @dev Returned if a plugin has already been trusted\n   */\n  error PluginAlreadyTrusted();\n\n  /**\n   * @dev Returned when trying to import protectors and safe recipients from the token itself\n   */\n  error CannotImportProtectorsAndSafeRecipientsFromYourself();\n\n  /**\n   * @dev Returned when the owner of the exporter token is different from the owner of the importer token\n   */\n  error NotTheSameOwner(address originSOwner, address owner);\n\n  /**\n   * @dev Returned when some safe recipients have already been set\n   */\n  error SafeRecipientsAlreadySet();\n\n  /**\n   * @dev Returned when the origin token has no protectors and no safe recipients\n   */\n  error NothingToImport();\n\n  /**\n   * @dev Returned when trying to change the status of a plugin to an unsupported mode\n   */\n  error UnsupportedPluginChange();\n\n  /**\n   * @dev Returned when trying to get the index of a plugin in the allPlugins array, but that index is out of bounds\n   */\n  error IndexOutOfBounds();\n\n  /**\n   * @dev Returned when trying to use a function that requires protectors, but no protectors are set\n   */\n  error ToBeUsedOnlyWhenProtectorsAreActive();\n\n  /**\n   * @dev It returns the configuration of a plugin by key\n   * @param key The key of the plugin\n   */\n  function pluginByKey(bytes8 key) external view returns (PluginConfig memory);\n\n  /**\n   * @dev It returns the configuration of all currently plugged services\n   */\n  function allPlugins() external view returns (PluginElement[] memory);\n\n  /**\n   * @dev It returns an element of the array of all plugged services\n   * @param index The index of the plugin in the array\n   */\n  function pluginByIndex(uint256 index) external view returns (PluginElement memory);\n\n  /**\n   * @dev During an upgrade allows the manager to perform adjustments if necessary.\n   * The parameter is the version of the manager being replaced. This will allow the\n   * new manager to know what to do to adjust the state of the new manager.\n   */\n  function migrate(uint256 /* version */) external;\n\n  /**\n   * @dev Find a specific protector\n   */\n  function findProtectorIndex(address protector_) external view returns (uint256);\n\n  /**\n   * @dev Returns true if the address is a protector.\n   * @param protector_ The protector address.\n   */\n  function isProtector(address protector_) external view returns (bool);\n\n  /**\n   * @dev Returns true if there are protectors.\n   */\n  function hasProtectors() external view returns (bool);\n\n  /**\n   * @dev Returns true if the token is transferable (since the NFT is ERC6454)\n   * @param to The address of the recipient.\n   * If the recipient is a safe recipient, it returns true.\n   */\n  function isTransferable(address to) external view returns (bool);\n\n  /**\n   * @dev Returns true if the token is locked (since the NFT is ERC6982)\n   */\n  function locked() external view returns (bool);\n\n  /**\n   * @dev Counts how many protectors have been set\n   */\n  function countProtectors() external view returns (uint256);\n\n  /**\n   * @dev Counts the safe recipients\n   */\n  function countSafeRecipients() external view returns (uint256);\n\n  /**\n   * @dev Set a protector for the token\n   * @param protector_ The protector address\n   * @param status True to add a protector, false to remove it\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the protector\n   * If no signature is required, the field timestamp must be 0\n   * If the operations has been pre-approved by the protector, the signature should be replaced\n   * by a shorter (invalid) one, to tell the signature validator to look for a pre-approval.\n   */\n  function setProtector(\n    address protector_,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @dev Imports protectors and safe recipients from another tokenId owned by the same owner\n   * It requires that there are no protectors and no safe recipients in the current token, and\n   * that the origin token has at least one protector or one safe recipient.\n   */\n  function importProtectorsAndSafeRecipientsFrom(uint256 tokenId) external;\n\n  /**\n   * @dev get the list of all protectors\n   */\n  function getProtectors() external view returns (address[] memory);\n\n  /**\n   * @dev Set a safe recipient for the token, i.e., an address that can receive the token without any restriction\n   * even when protectors have been set.\n   * @param recipient The recipient address\n   * @param status True to add a safe recipient, false to remove it\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the protector\n   */\n  function setSafeRecipient(\n    address recipient,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @dev Check if an address is a safe recipient\n   * @param recipient The recipient address\n   * @return True if the recipient is a safe recipient\n   */\n  function isSafeRecipient(address recipient) external view returns (bool);\n\n  /**\n   * @dev Gets all safe recipients\n   * @return An array with the list of all safe recipients\n   */\n  function getSafeRecipients() external view returns (address[] memory);\n\n  /**\n   * @dev It plugs a new plugin\n   * @param name The name of the plugin\n   * @param pluginProxy The address of the plugin implementation\n   * @param canManageTransfer True if the plugin can manage transfers\n   * @param isERC6551Account True if the plugin is an ERC6551 account\n   * @param salt The salt used during the deployment of the plugin\n   * @param data The data to be used during the initialization of the plugin\n   * Notice that data cannot be verified by the Manager since they are used by the plugin\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the protector\n   */\n  function plug(\n    string memory name,\n    address pluginProxy,\n    bool canManageTransfer,\n    bool isERC6551Account,\n    bytes4 salt,\n    bytes memory data,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @dev It changes the status of a plugin\n   * @param name The name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * @param change The type of change\n   * @param timeLock_ The time lock for when a plugin is temporarily unauthorized from making transfers\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the protector\n   */\n  function changePluginStatus(\n    string memory name,\n    bytes4 salt,\n    PluginChange change,\n    uint256 timeLock_,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @dev It trusts a plugin\n   * @param name The name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * No need for a signature by a protector because the safety of the plugin is\n   * guaranteed by the CrunaGuardian.\n   */\n  function trustPlugin(string calldata name, bytes4 salt) external;\n\n  /**\n   * @dev It returns the address of a plugin\n   * @param nameId_ The bytes4 of the hash of the name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * The address is returned even if a plugin has not deployed yet.\n   * @return The plugin address\n   */\n  function pluginAddress(bytes4 nameId_, bytes4 salt) external view returns (address payable);\n\n  /**\n   * @dev It returns a plugin by name and salt\n   * @param nameId_ The bytes4 of the hash of the name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * The plugin is returned even if a plugin has not deployed yet, which means that it will\n   * revert during the execution.\n   * @return The plugin\n   */\n  function plugin(bytes4 nameId_, bytes4 salt) external view returns (CrunaManagedService);\n\n  /**\n   * @dev It returns the number of services\n   */\n  function countPlugins() external view returns (uint256, uint256);\n\n  /**\n   * @dev Says if a plugin is currently plugged\n   */\n  function plugged(string calldata name, bytes4 salt) external view returns (bool);\n\n  /**\n   * @dev Returns the index of a plugin\n   * @param name The name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * @return a tuple with a true if the plugin is found, and the index of the plugin\n   */\n  function pluginIndex(string calldata name, bytes4 salt) external view returns (bool, uint256);\n\n  /**\n   * @dev Checks if a plugin is active\n   * @param name The name of the plugin\n   * @param salt The salt used during the deployment of the plugin\n   * @return True if the plugin is active\n   */\n  function isPluginActive(string calldata name, bytes4 salt) external view returns (bool);\n\n  /**\n   * @dev returns the list of services' keys\n   * Since the names of the services are not saved in the contract, the app calling for this function\n   * is responsible for knowing the names of all the services.\n   * In the future it would be good to have an official registry of all services to be able to reverse\n   * from the nameId to the name as a string.\n   * @param active True to get the list of active services, false to get the list of inactive services\n   * @return The list of services' keys\n   */\n  function listPluginsKeys(bool active) external view returns (bytes8[] memory);\n\n  /**\n   * @dev It returns a pseudo address created from the name of a plugin and the salt used to deploy it.\n   * Notice that abi.encodePacked does not risk to create collisions because the salt has fixed length\n   * in the hashed bytes.\n   * @param name The name of the plugin\n   * @param _salt The salt used during the deployment of the plugin\n   * @return The pseudo address of the plugin\n   */\n  function pseudoAddress(string calldata name, bytes4 _salt) external view returns (address);\n\n  /**\n   * @dev A special function that can be called only by authorized services to transfer the NFT.\n   * @param pluginNameId The bytes4 of the hash of the name of the plugin\n   * The plugin must be searched by the pluginNameId and the salt, and the function must verify that\n   * the current sender is the plugin.\n   * @param to The address of the recipient\n   */\n  function managedTransfer(bytes4 pluginNameId, address to) external;\n\n  /**\n   * @dev Allows the user to transfer the NFT when protectors are set\n   * @param tokenId The id of the token\n   * @param to The address of the recipient\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the protector\n   * The function should revert if no protectors are set, inviting to use the standard\n   * ERC721 transfer functions.\n   */\n  function protectedTransfer(\n    uint256 tokenId,\n    address to,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @dev Upgrades the implementation of the manager\n   * @param implementation_ The address of the new implementation\n   */\n  function upgrade(address implementation_) external;\n}\n"
    },
    "contracts/mocks/erc/RegistryMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ERC7656Registry} from \"../../erc/ERC7656Registry.sol\";\n\ncontract RegistryMock is ERC7656Registry {}\n"
    },
    "contracts/mocks/factory/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Author : Francesco Sullo <francesco@sullo.co>\n\ninterface IVaultFactory {\n  // @notice Emitted when a price is set\n  // @param price the new price\n\n  event PriceSet(uint256 price);\n\n  event StableCoinSet(address indexed stableCoin, bool active);\n\n  // @notice Set the price\n  // @param price the new price\n  //   The price is expressed in points, 1 point = 0.01 USD\n\n  function setPrice(uint256 price) external;\n\n  function getPrice() external view returns (uint256);\n\n  function finalPrice(address stableCoin) external view returns (uint256);\n\n  function setDiscount(uint256 discount) external;\n\n  // @notice Activate/deactivate a stable coin\n  // @param stableCoin the payment token to use for the purchase\n  // @param active true to activate, false to deactivate\n\n  function setStableCoin(address stableCoin, bool active) external;\n\n  // @notice Allow people to buy vaults\n  // @param stableCoin the payment token to use for the purchase\n  // @param amount number to buy\n\n  function buyVaults(address stableCoin, uint256 amount) external;\n\n  function buyVaultsBatch(address stableCoin, address[] memory tos, uint256[] memory amounts) external;\n\n  // @notice Given a payment token, transfers amount or full balance from proceeds to an address\n  // @param beneficiary address of the beneficiary\n  // @param stableCoin the payment token to use for the transfer\n  // @param amount number to transfer\n\n  function withdrawProceeds(address beneficiary, address stableCoin, uint256 amount) external;\n}\n"
    },
    "contracts/mocks/factory/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Author : Francesco Sullo <francesco@sullo.co>\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Initializable, UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport {TimeControlledNFT} from \"../token/TimeControlledNFT.sol\";\nimport {IVaultFactory} from \"./IVaultFactory.sol\";\nimport {IVersioned} from \"../../utils/IVersioned.sol\";\n\ncontract VaultFactory is\n  IVaultFactory,\n  IVersioned,\n  Initializable,\n  PausableUpgradeable,\n  OwnableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  UUPSUpgradeable\n{\n  error ZeroAddress();\n  error InsufficientFunds();\n  error UnsupportedStableCoin();\n  error TransferFailed();\n  error InvalidArguments();\n  error InvalidDiscount();\n\n  TimeControlledNFT public vault;\n  uint256 public price;\n  mapping(address => bool) public stableCoins;\n  uint256 public discount;\n  address[] private _stableCoins;\n\n  /**\n   * @custom:oz-upgrades-unsafe-allow constructor\n   */\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address payable vault_, address owner_) public initializer {\n    __Ownable_init(owner_);\n    __UUPSUpgradeable_init();\n    vault = TimeControlledNFT(vault_);\n  }\n\n  function version() external pure virtual returns (uint256) {\n    return 1_000_000;\n  }\n\n  // solhint-disable-next-line no-empty-blocks\n  function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner {}\n\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  // @notice The price is in points, so that 1 point = 0.01 USD\n  function setPrice(uint256 price_) external virtual override onlyOwner {\n    // it is owner's responsibility to set a reasonable price\n    price = price_;\n    emit PriceSet(price);\n  }\n\n  function setStableCoin(address stableCoin, bool active) external virtual override onlyOwner {\n    if (active) {\n      // We check if less than 6 because TetherUSD has 6 decimals\n      // It should revert if the stableCoin is not an ERC20\n      if (ERC20(stableCoin).decimals() < 6) {\n        revert UnsupportedStableCoin();\n      }\n      if (!stableCoins[stableCoin]) {\n        stableCoins[stableCoin] = true;\n        _stableCoins.push(stableCoin);\n        emit StableCoinSet(stableCoin, active);\n      }\n    } else if (stableCoins[stableCoin]) {\n      delete stableCoins[stableCoin];\n      // no risk of going out of cash because the factory will support just a couple of stable coins\n      uint256 len = _stableCoins.length;\n      for (uint256 i; i < len; ) {\n        if (_stableCoins[i] == stableCoin) {\n          // since if found the stableCoin, len is > 0\n          if (i != len - 1) {\n            _stableCoins[i] = _stableCoins[len - 1];\n          }\n          _stableCoins.pop();\n          emit StableCoinSet(stableCoin, active);\n          break;\n        }\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDiscount(uint256 discount_) external virtual override onlyOwner {\n    if (discount > price) revert InvalidDiscount();\n    discount = discount_;\n  }\n\n  function finalPrice(address stableCoin) public view virtual override returns (uint256) {\n    return (getPrice() * (10 ** ERC20(stableCoin).decimals())) / 100;\n  }\n\n  function getPrice() public view virtual override returns (uint256) {\n    return price - discount;\n  }\n\n  function buyVaults(address stableCoin, uint256 amount) external virtual override nonReentrant whenNotPaused {\n    uint256 payment = finalPrice(stableCoin) * amount;\n    if (payment > ERC20(stableCoin).balanceOf(_msgSender())) revert InsufficientFunds();\n    vault.safeMintAndActivate(_msgSender(), amount);\n    // we manage only trusted stable coins, so no risk of reentrancy\n    if (!ERC20(stableCoin).transferFrom(_msgSender(), address(this), payment)) revert TransferFailed();\n  }\n\n  function buyVaultsBatch(\n    address stableCoin,\n    address[] memory tos,\n    uint256[] memory amounts\n  ) external virtual override nonReentrant whenNotPaused {\n    if (tos.length != amounts.length) revert InvalidArguments();\n    uint256 amount = 0;\n    for (uint256 i; i < tos.length; ) {\n      unchecked {\n        if (tos[i] == address(0)) {\n          revert ZeroAddress();\n        }\n        amount += amounts[i];\n        ++i;\n      }\n    }\n    uint256 payment = finalPrice(stableCoin) * amount;\n    if (payment > ERC20(stableCoin).balanceOf(_msgSender())) revert InsufficientFunds();\n    for (uint256 i; i < tos.length; ) {\n      if (amounts[i] != 0) {\n        vault.safeMintAndActivate(tos[i], amounts[i]);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    // we manage only trusted stable coins, so no risk of reentrancy\n    if (!ERC20(stableCoin).transferFrom(_msgSender(), address(this), payment)) revert TransferFailed();\n  }\n\n  function withdrawProceeds(address beneficiary, address stableCoin, uint256 amount) external virtual override onlyOwner {\n    uint256 balance = ERC20(stableCoin).balanceOf(address(this));\n    if (amount == 0) {\n      amount = balance;\n    }\n    if (amount > balance) revert InsufficientFunds();\n    if (!ERC20(stableCoin).transfer(beneficiary, amount)) revert TransferFailed();\n  }\n\n  function getStableCoins() external view virtual returns (address[] memory) {\n    return _stableCoins;\n  }\n}\n"
    },
    "contracts/mocks/fake-tokens/TetherUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ncontract TetherUSD is ERC20, Ownable2Step {\n  constructor(address initialOwner) ERC20(\"Tether USD\", \"USDT\") Ownable(initialOwner) {}\n\n  function mint(address to, uint256 amount) public onlyOwner {\n    _mint(to, amount);\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return 6;\n  }\n}\n"
    },
    "contracts/mocks/fake-tokens/USDCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ncontract USDCoin is ERC20, Ownable2Step {\n  constructor(address initialOwner) ERC20(\"USD Coin\", \"USDC\") Ownable(initialOwner) {}\n\n  function mint(address to, uint256 amount) public onlyOwner {\n    _mint(to, amount);\n  }\n}\n"
    },
    "contracts/mocks/manager/CrunaManagerProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC6551AccountProxy} from \"../../erc/ERC6551AccountProxy.sol\";\n\ncontract CrunaManagerProxyV2 is ERC6551AccountProxy {\n  constructor(address _initialImplementation) ERC6551AccountProxy(_initialImplementation) {}\n\n  function getImplementation() external view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "contracts/mocks/manager/CrunaManagerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {CrunaManager} from \"../../manager/CrunaManager.sol\";\n\ncontract CrunaManagerV2 is CrunaManager {\n  bool public migrated;\n\n  function version() external pure virtual override returns (uint256) {\n    return 1_002_000;\n  }\n\n  // new function in V2\n  function bytes4ToHexString(bytes4 _bytes) public pure returns (string memory) {\n    bytes memory byteArray = new bytes(8);\n    unchecked {\n      for (uint256 i; i < 4; i++) {\n        uint8 currentByte = uint8(_bytes[i]);\n        byteArray[2 * i] = _nibbleToHexChar(currentByte / 16);\n        byteArray[2 * i + 1] = _nibbleToHexChar(currentByte % 16);\n      }\n    }\n    return string(abi.encodePacked(\"0x\", string(byteArray)));\n  }\n\n  function _nibbleToHexChar(uint8 _nibble) internal pure returns (bytes1) {\n    if (_nibble < 10) {\n      return bytes1(uint8(bytes1(\"0\")) + _nibble);\n    } else {\n      return bytes1(uint8(bytes1(\"a\")) + _nibble - 10);\n    }\n  }\n\n  function migrate(uint256) external virtual override {\n    if (_msgSender() != address(this)) revert Forbidden();\n    migrated = true;\n  }\n}\n"
    },
    "contracts/mocks/services/CrunaManagedServiceMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {CrunaManagedService} from \"../../services/CrunaManagedService.sol\";\n\ncontract CrunaManagedServiceMock is CrunaManagedService {\n  function _nameId() internal pure virtual override returns (bytes4) {\n    return bytes4(keccak256(\"CrunaManagedServiceMock\"));\n  }\n}\n"
    },
    "contracts/mocks/services/FungibleService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.20;\n\nimport {Initializable, ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {CrunaService} from \"../../services/CrunaService.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract FungibleService is CrunaService, Initializable, ERC20Upgradeable, ERC20PermitUpgradeable {\n  using Strings for uint256;\n\n  function mint(address to, uint256 amount) public onlyTokenOwner {\n    _mint(to, amount);\n  }\n\n  function _nameId() internal view virtual override returns (bytes4) {\n    return bytes4(keccak256(\"FungibleService\"));\n  }\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(string memory name, string memory symbol) public initializer {\n    __ERC20_init(name, symbol);\n    __ERC20Permit_init(name);\n  }\n\n  function extraName() external view returns (string memory) {\n    return string(abi.encodePacked(\"FT \", _vault().name(), \" #\", tokenId().toString()));\n  }\n\n  function _onBeforeInit(bytes memory data) internal override {\n    // It ensures that we do not call initialize again, causing a revert\n    if (bytes(name()).length == 0) {\n      (string memory name, string memory symbol) = abi.decode(data, (string, string));\n      initialize(name, symbol);\n    }\n  }\n}\n"
    },
    "contracts/mocks/services/InheritanceCrunaPluginV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {InheritanceCrunaPlugin, ICrunaManagedService, CrunaManagedService} from \"../../services/inheritance/InheritanceCrunaPlugin.sol\";\n\ncontract InheritanceCrunaPluginV2 is InheritanceCrunaPlugin {\n  uint256 public constant SOME_VARIABLE = 3;\n\n  function _version() internal pure virtual override returns (uint256) {\n    return 1_001_002;\n  }\n\n  function requiresManagerVersion() external pure override(CrunaManagedService, ICrunaManagedService) returns (uint256) {\n    return 1_002_000;\n  }\n}\n"
    },
    "contracts/mocks/services/InheritanceCrunaPluginV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {InheritanceCrunaPlugin} from \"../../services/inheritance/InheritanceCrunaPlugin.sol\";\n\ncontract InheritanceCrunaPluginV3 is InheritanceCrunaPlugin {\n  uint256 public constant SOME_VARIABLE = 3;\n  bool public constant SOME_OTHER_VARIABLE = true;\n\n  function _version() internal pure virtual override returns (uint256) {\n    return 1_001_003;\n  }\n\n  // new function in V3\n  function isMock() external pure returns (bool) {\n    return true;\n  }\n}\n"
    },
    "contracts/mocks/services/SomeInheritancePlugin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {InheritanceCrunaPlugin, CrunaManagedService, ICrunaManagedService} from \"../../services/inheritance/InheritanceCrunaPlugin.sol\";\n\ncontract SomeInheritancePlugin is InheritanceCrunaPlugin {\n  function _nameId() internal pure virtual override returns (bytes4) {\n    return bytes4(keccak256(\"SomeInheritancePlugin\"));\n  }\n\n  function isERC6551Account() external pure override(CrunaManagedService, ICrunaManagedService) returns (bool) {\n    return true;\n  }\n}\n"
    },
    "contracts/mocks/token/OwnableNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {CrunaProtectedNFTOwnable} from \"../../token/CrunaProtectedNFTOwnable.sol\";\n\n// This is actually the real Cruna Flexi Vault contract.\n// We put it in mocks because it should not be used loading the package.\n\n// @notice This contract is a simple example of a protected NFT.\ncontract OwnableNFT is CrunaProtectedNFTOwnable {\n  using Strings for uint256;\n\n  error NotTheFactory();\n\n  address public factory;\n\n  // @notice This modifier will only allow the factory to call the function.\n  //   The factory is the contract that manages the sale of the tokens.\n  modifier onlyFactory() {\n    if (factory == address(0) || _msgSender() != factory) revert NotTheFactory();\n    _;\n  }\n\n  // @notice This constructor will initialize the contract with the necessary parameters\n  //   The contracts of whom we pass the addresses in the construction, will be deployed\n  //   using Nick's factory, so we may in theory hardcode them in the code. However,\n  //   if so, we will not be able to test the contract.\n  // @param owner The address of the owner.\n  constructor(address owner_) CrunaProtectedNFTOwnable(\"Cruna Vaults\", \"CRUNA1\", owner_) {}\n\n  // @notice Set factory to 0x0 to disable a factory.\n  // @notice This is the only function that can be called by the owner.\n  //   It does not introduce centralization, because it is related with\n  //   the factory that sells the tokens, not the NFT itself.\n  // @param factory The address of the factory.\n  function setFactory(address factory_) external virtual {\n    _canManage(true);\n    if (factory_ == address(0)) revert ZeroAddress();\n    factory = factory_;\n  }\n\n  // @notice This function will return the base URI of the contract\n  function _baseURI() internal view virtual override returns (string memory) {\n    return string(abi.encodePacked(\"https://meta.cruna.cc/vault/v1/\", block.chainid.toString(), \"/\"));\n  }\n\n  // @notice This function will return the contract URI of the contract\n  function contractURI() public view virtual returns (string memory) {\n    return string(abi.encodePacked(\"https://meta.cruna.cc/vault/v1/\", block.chainid.toString(), \"/info\"));\n  }\n\n  // @notice This function will mint a new token\n  // @param to The address of the recipient\n  function safeMintAndActivate(address to, uint256 amount) public virtual onlyFactory {\n    _mintAndActivateByAmount(to, amount);\n  }\n}\n"
    },
    "contracts/mocks/token/TimeControlledNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {CrunaProtectedNFTTimeControlled} from \"../../token/CrunaProtectedNFTTimeControlled.sol\";\n\n// This is actually the real Cruna Flexi Vault contract.\n// We put it in mocks because it should not be used loading the package.\n\n// @notice This contract is a simple example of a protected NFT.\ncontract TimeControlledNFT is CrunaProtectedNFTTimeControlled {\n  using Strings for uint256;\n\n  error NotTheFactory();\n\n  address public factory;\n\n  // @notice This modifier will only allow the factory to call the function.\n  //   The factory is the contract that manages the sale of the tokens.\n  modifier onlyFactory() {\n    if (factory == address(0) || _msgSender() != factory) revert NotTheFactory();\n    _;\n  }\n\n  // @notice This constructor will initialize the contract with the necessary parameters\n  //   The contracts of whom we pass the addresses in the construction, will be deployed\n  //   using Nick's factory, so we may in theory hardcode them in the code. However,\n  //   if so, we will not be able to test the contract.\n  // @param owner The address of the owner.\n  constructor(\n    uint256 minDelay,\n    address[] memory proposers,\n    address[] memory executors,\n    address admin\n  ) CrunaProtectedNFTTimeControlled(\"Cruna Vaults\", \"CRUNA1\", minDelay, proposers, executors, admin) {}\n\n  // @notice Set factory to 0x0 to disable a factory.\n  // @notice This is the only function that can be called by the owner.\n  //   It does not introduce centralization, because it is related with\n  //   the factory that sells the tokens, not the NFT itself.\n  // @param factory The address of the factory.\n  function setFactory(address factory_) external virtual {\n    _canManage(true);\n    if (factory_ == address(0)) revert ZeroAddress();\n    factory = factory_;\n  }\n\n  // @notice This function will return the base URI of the contract\n  function _baseURI() internal view virtual override returns (string memory) {\n    return string(abi.encodePacked(\"https://meta.cruna.cc/vault/v1/\", block.chainid.toString(), \"/\"));\n  }\n\n  // @notice This function will return the contract URI of the contract\n  function contractURI() public view virtual returns (string memory) {\n    return string(abi.encodePacked(\"https://meta.cruna.cc/vault/v1/\", block.chainid.toString(), \"/info\"));\n  }\n\n  // @notice This function will mint a new token\n  // @param to The address of the recipient\n  function safeMintAndActivate(address to, uint256 amount) public virtual onlyFactory {\n    _mintAndActivateByAmount(to, amount);\n  }\n}\n"
    },
    "contracts/mocks/utils/ERC6551RegistryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC6551Registry} from \"erc6551/ERC6551Registry.sol\";\n\ncontract ERC6551RegistryMock is ERC6551Registry {}\n"
    },
    "contracts/mocks/utils/SignatureValidatorMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {SignatureValidator} from \"../../utils/SignatureValidator.sol\";\n\ncontract SignatureValidatorMock is SignatureValidator {\n  function _canPreApprove(bytes4, address, address) internal pure virtual override returns (bool) {\n    return true;\n  }\n\n  function _isProtected() internal view virtual override returns (bool) {\n    return false;\n  }\n\n  function _isProtector(address) internal view virtual override returns (bool) {\n    return false;\n  }\n\n  function hashData(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation\n  ) external pure returns (bytes32) {\n    return _hashData(selector, owner, actor, tokenAddress, tokenId, extra, extra2, extra3, timeValidation);\n  }\n}\n"
    },
    "contracts/services/CrunaManagedService.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {CrunaManager} from \"../manager/CrunaManager.sol\";\nimport {ICrunaManagedService} from \"./ICrunaManagedService.sol\";\nimport {CommonBase} from \"../utils/CommonBase.sol\";\nimport {SignatureValidator} from \"../utils/SignatureValidator.sol\";\nimport {Actor} from \"../manager/Actor.sol\";\n//import \"hardhat/console.sol\";\n\n/**\n * @title CrunaManagedService\n * @notice Base contract for services\n */\nabstract contract CrunaManagedService is ICrunaManagedService, Actor, CommonBase, SignatureValidator {\n  /**\n   * @notice The internal configuration of the plugin\n   */\n  Conf internal _conf;\n\n  /**\n   * @notice Verifies that the plugin must not be reset\n   */\n  modifier ifMustNotBeReset() {\n    if (_conf.mustBeReset == 1) revert PluginMustBeReset();\n    _;\n  }\n\n  function _onBeforeInit(bytes memory data) internal virtual {\n    // does nothing, override if needed\n  }\n\n  /// @dev see {ICrunaManagedService.sol-init}\n  function init(bytes memory data) external {\n    address managerAddress = _vault().managerOf(tokenId());\n    if (_msgSender() != managerAddress) revert Forbidden();\n    _onBeforeInit(data);\n    if (address(_conf.manager) == address(0)) {\n      _conf.manager = CrunaManager(managerAddress);\n    } // else the service is being plugged again after been plugged and unplugged\n  }\n\n  /// @dev see {ICrunaManagedService.sol-manager}\n  function crunaManager() external view virtual override returns (CrunaManager) {\n    return _conf.manager;\n  }\n\n  /// @dev see {IVersioned-version}\n  function version() external pure virtual override returns (uint256) {\n    return _version();\n  }\n\n  /// @dev see {ICrunaManagedService.sol-resetOnTransfer}\n  function resetOnTransfer() external payable override ifMustNotBeReset {\n    /**\n     * @notice The manager is not a wallet, it is the NFT Manager contract, owned by the token.\n     * Making it payable reduce the gas cost for the manager to call this function.\n     */\n    if (msg.sender != address(_conf.manager)) revert Forbidden();\n    _conf.mustBeReset = 1;\n  }\n\n  /// @dev see {ICrunaManagedService.sol-requiresToManageTransfer}\n  function requiresToManageTransfer() external pure virtual override returns (bool) {\n    return false;\n  }\n\n  /// @dev see {ICrunaManagedService.sol-requiresResetOnTransfer}\n  function requiresResetOnTransfer() external pure virtual override returns (bool) {\n    return false;\n  }\n\n  /// @dev see {ICrunaManagedService.sol-requiresManagerVersion}\n  function requiresManagerVersion() external pure virtual override returns (uint256) {\n    return 1;\n  }\n\n  /// @dev see {ICrunaManagedService.sol-isERC6551Account}\n  function isERC6551Account() external pure virtual returns (bool) {\n    return false;\n  }\n\n  function isManaged() external pure returns (bool) {\n    return true;\n  }\n\n  function resetService() external payable virtual override {\n    // doing nothing\n  }\n\n  /**\n   * @notice Internal function to verify if a signer can pre approve an operation (if the sender is a protector)\n   * The params:\n   * - operation The selector of the called function\n   * - the actor to be approved\n   * - signer The signer of the operation (the protector)\n   */\n  function _canPreApprove(bytes4, address, address signer) internal view virtual override returns (bool) {\n    return _conf.manager.isProtector(signer);\n  }\n\n  /// @dev see {IVersioned-version}\n  function _version() internal pure virtual returns (uint256) {\n    return 1_000_000;\n  }\n\n  /**\n   * @notice internal function to check if the NFT is currently protected\n   */\n  function _isProtected() internal view override returns (bool) {\n    return _conf.manager.hasProtectors();\n  }\n\n  /**\n   * @notice Internal function to check if an address is a protector\n   * @param protector The address to check\n   */\n  function _isProtector(address protector) internal view override returns (bool) {\n    return _conf.manager.isProtector(protector);\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/services/CrunaService.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {ICrunaService} from \"./ICrunaService.sol\";\nimport {CommonBase} from \"../utils/CommonBase.sol\";\n//import \"hardhat/console.sol\";\n\n/**\n * @title CrunaManagedService\n * @notice Base contract for services\n */\nabstract contract CrunaService is ICrunaService, CommonBase {\n  function _onBeforeInit(bytes memory data) internal virtual {\n    // does nothing\n  }\n\n  /// @dev see {ICrunaManagedService.sol-init}\n  function init(bytes memory data) external virtual {\n    if (msg.sender != tokenAddress()) revert Forbidden();\n    _onBeforeInit(data);\n  }\n\n  /// @dev see {IVersioned-version}\n  function version() external pure virtual override returns (uint256) {\n    return _version();\n  }\n\n  /// @dev see {ICrunaManagedService.sol-isERC6551Account}\n  function isERC6551Account() external pure virtual returns (bool) {\n    return false;\n  }\n\n  /// @dev see {IVersioned-version}\n  function _version() internal pure virtual returns (uint256) {\n    return 1_000_000;\n  }\n\n  function isManaged() external pure returns (bool) {\n    return false;\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/services/ICrunaManagedService.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.20;\n\nimport {CrunaManager} from \"../manager/CrunaManager.sol\";\nimport {ICrunaService} from \"./ICrunaService.sol\";\n\n/**\n * @title ICrunaManagedService.sol\n * @notice Interface for services\n * @dev Technically, services are secondary managers, pluggable in\n * the primary manage, which is CrunaManager.sol\n */\ninterface ICrunaManagedService is ICrunaService {\n  /**\n   * @notice The configuration of the plugin\n   */\n  struct Conf {\n    CrunaManager manager;\n    // When mustReset is true, the plugin must be reset before being used again.\n    // This strategy is needed during transfers to avoid gas issues, because actually resetting the\n    // data can be expensive. As a trade-off, the receiver of the protected NFT must reset the plugin.\n    uint32 mustBeReset;\n  }\n\n  /**\n   * @notice Error returned when the plugin is reset\n   * @param implementation The address of the new implementation\n   */\n  error UntrustedImplementation(address implementation);\n\n  /**\n   * @notice Error returned when the plugin is reset\n   * @param oldVersion The version of the current implementation\n   * @param newVersion The version of the new implementation\n   */\n  error InvalidVersion(uint256 oldVersion, uint256 newVersion);\n\n  /**\n   * @notice Error returned when the plugin must be reset before using it\n   */\n  error PluginMustBeReset();\n\n  /**\n   * @notice Initialize the plugin. It must be implemented, but can do nothing is no init is needed.\n   */\n  function init(bytes memory data) external;\n\n  /**\n   * @notice Called by the manager during the plugging to know if the plugin is asking the\n   * right to make a managed transfer of the vault\n   */\n  function requiresToManageTransfer() external pure returns (bool);\n\n  /**\n   * @notice Called by the manager to know it the plugin must be reset when transferring the NFT\n   */\n  function requiresResetOnTransfer() external pure returns (bool);\n\n  /**\n   * @notice Returns the minimum version of the manager required by the plugin\n   */\n  function requiresManagerVersion() external pure returns (uint256);\n\n  /**\n   * @notice Called by the manager to know if the plugin is an ERC721 account\n   */\n  function isERC6551Account() external pure returns (bool);\n\n  /**\n   * @notice Reset the plugin to the factory settings\n   */\n  function resetService() external payable;\n\n  // @dev During transfer, to reduce gas consumption, should set _conf.mustBeReset to 1\n  function resetOnTransfer() external payable;\n\n  /**\n   * @notice Returns the manager\n   */\n  function crunaManager() external view returns (CrunaManager);\n}\n"
    },
    "contracts/services/ICrunaService.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.20;\n\nimport {IERC7656Contract} from \"../erc/IERC7656Contract.sol\";\nimport {IVersioned} from \"../utils/IVersioned.sol\";\n\n/**\n * @title ICrunaService.sol\n * @notice Interface for services\n */\ninterface ICrunaService is IERC7656Contract, IVersioned {\n  /**\n   * @notice Error returned when trying to initialize the service if not authorized\n   */\n  error Forbidden();\n\n  /**\n   * @notice Initialize the plugin. It must be implemented, but can do nothing is no init is needed.\n   */\n  function init(bytes memory data) external;\n\n  /**\n   * @notice Called by the manager to know if the plugin is an ERC721 account\n   */\n  function isERC6551Account() external pure returns (bool);\n\n  /**\n   * @notice Called when deploying the service to check if it must be managed\n   */\n  function isManaged() external pure returns (bool);\n}\n"
    },
    "contracts/services/inheritance/IInheritanceCrunaPlugin.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\n/**\n * @title IInheritanceCrunaPlugin\n * @notice Interface for the inheritance plugin\n */\ninterface IInheritanceCrunaPlugin {\n  /**\n   * @notice Struct to store the configuration for the inheritance\n   * @param beneficiary The beneficiary address\n   * @param quorum The number of sentinels required to approve a request\n   * @param gracePeriodInWeeks The grace period in weeks\n   * @param proofOfLifeDurationInWeeks The duration of the Proof-of-Live, i.e., the number\n   * of days after which the sentinels can start the process to inherit the token if the\n   * owner does not prove to be alive\n   * @param lastProofOfLife The timestamp of the last Proof-of-Life\n   * @param extendedProofOfLife The timestamp of the extended Proof-of-Life\n   */\n  struct InheritanceConf {\n    address beneficiary;\n    uint8 quorum;\n    uint8 gracePeriodInWeeks;\n    uint8 proofOfLifeDurationInWeeks;\n    uint32 lastProofOfLife;\n    uint32 extendedProofOfLife;\n  }\n\n  /**\n   * @notice Struct to store the votes\n   * @param nominations The nominated beneficiaries\n   * @param favorites The favorite beneficiary for each sentinel\n   */\n  struct Votes {\n    address[] nominations;\n    mapping(address voter => address beneficiary) favorites;\n  }\n\n  /**\n   * @notice Emitted when a sentinel is updated\n   * @param owner The owner address\n   * @param sentinel The sentinel address\n   * @param status True if the sentinel is active, false if it is not\n   */\n  event SentinelUpdated(address indexed owner, address indexed sentinel, bool status);\n\n  /**\n   * @notice Emitted when the inheritance is configured\n   * @param owner The owner address\n   * @param quorum The number of sentinels required to approve a request\n   * @param proofOfLifeDurationInWeeks The duration of the Proof-of-Live, i.e., the number\n   * of days after which the sentinels can start the process to inherit the token if the\n   * owner does not prove to be alive\n   * @param gracePeriodInWeeks The grace period in weeks\n   * @param beneficiary The beneficiary address\n   */\n  event InheritanceConfigured(\n    address indexed owner,\n    uint256 quorum,\n    uint256 proofOfLifeDurationInWeeks,\n    uint256 gracePeriodInWeeks,\n    address beneficiary\n  );\n\n  /**\n   * @notice Emitted when a Proof-of-Life is triggered\n   * @param owner The owner address\n   */\n  event ProofOfLife(address indexed owner);\n\n  /**\n   * @notice Emitted when a sentinel votes for a beneficiary\n   * @param sentinel The sentinel address\n   * @param beneficiary The beneficiary address. If the address == address(0), the vote\n   * is to retire the beneficiary\n   */\n  event VotedForBeneficiary(address indexed sentinel, address indexed beneficiary);\n\n  /**\n   * @notice Emitted when a beneficiary is approved\n   * @param beneficiary The beneficiary address\n   */\n  event BeneficiaryApproved(address indexed beneficiary);\n\n  /**\n   * @notice Error returned when the quorum is set to 0\n   */\n  error QuorumCannotBeZero();\n\n  /**\n   * @notice Error returned when the quorum is greater than the number of sentinels\n   */\n  error QuorumCannotBeGreaterThanSentinels();\n\n  /**\n   * @notice Error returned when the inheritance is not set\n   */\n  error InheritanceNotConfigured();\n\n  /**\n   * @notice Error returned when the owner is still alive, i.e., there is a Proof-of-Life event\n   * more recent than the Proof-of-Life duration\n   */\n  error StillAlive();\n\n  /**\n   * @notice Error returned when the sender is not a sentinel\n   */\n  error NotASentinel();\n\n  /**\n   * @notice Error returned when the sender is not the beneficiary\n   */\n  error NotTheBeneficiary();\n\n  /**\n   * @notice Error returned when the beneficiary is not set\n   */\n  error BeneficiaryNotSet();\n\n  /**\n   * @notice Error returned when trying to vote for a beneficiary, while\n   * the grace period for the current beneficiary is not over\n   */\n  error WaitingForBeneficiary();\n\n  /**\n   * @notice Error returned when passing a signature with a validFor > MAX_VALID_FOR\n   */\n  error InvalidValidity();\n\n  /**\n   * @notice Error returned when trying to retire a not-found vote\n   */\n  error NoVoteToRetire();\n\n  /**\n   * @notice Error returned when the parameters are invalid\n   */\n  error InvalidParameters();\n\n  /**\n   * @notice Error returned when the plugin is upgraded if requires an updated manager\n   * @param requiredVersion The version required by the plugin\n   */\n  error PluginRequiresUpdatedManager(uint256 requiredVersion);\n\n  // beneficiaries\n\n  /**\n   * @notice Set a sentinel for the token\n   * @param sentinel The sentinel address\n   * @param status True to activate, false to deactivate\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the tokensOwner\n   */\n  function setSentinel(address sentinel, bool status, uint256 timestamp, uint256 validFor, bytes calldata signature) external;\n\n  /**\n   * @notice Set a list of sentinels for the token\n   * It is a convenience function to set multiple sentinels at once, but it\n   * works only if no protectors have been set up. Useful for initial settings.\n   * @param sentinels The sentinel addresses\n   * @param emptySignature The signature of the tokensOwner\n   */\n  function setSentinels(address[] calldata sentinels, bytes calldata emptySignature) external;\n\n  /**\n   * @notice Configures an inheritance\n   * Some parameters are optional depending on the scenario.\n   * There are three scenarios:\n   *\n   * - The user sets a beneficiary. The beneficiary can inherit the NFT as soon as a Proof-of-Life is missed.\n   * - The user sets more than a single sentinel. The sentinels propose a beneficiary, and when the quorum is reached, the beneficiary can inherit the NFT.\n   * - The user sets a beneficiary and some sentinels. In this case, the beneficiary has a grace period to inherit the NFT. If after that grace period the beneficiary has not inherited the NFT, the sentinels can propose a new beneficiary.\n   *\n   * @param quorum The number of sentinels required to approve a request\n   * @param proofOfLifeDurationInWeeks The duration of the Proof-of-Live, i.e., the number\n   * of days after which the sentinels can start the process to inherit the token if the\n   * owner does not prove to be alive\n   * @param gracePeriodInWeeks The grace period in weeks\n   * @param beneficiary The beneficiary address\n   * @param timestamp The timestamp of the signature\n   * @param validFor The validity of the signature\n   * @param signature The signature of the tokensOwner\n   */\n  function configureInheritance(\n    uint8 quorum,\n    uint8 proofOfLifeDurationInWeeks,\n    uint8 gracePeriodInWeeks,\n    address beneficiary,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external;\n\n  /**\n   * @notice Return all the sentinels and the inheritance data\n   */\n  function getSentinelsAndInheritanceData() external view returns (address[] memory, InheritanceConf memory);\n\n  /**\n   * @notice Return all the votes\n   */\n  function getVotes() external view returns (address[] memory);\n\n  /**\n   * @notice Return the number of sentinels\n   */\n  function countSentinels() external view returns (uint256);\n\n  /**\n   * @notice allows the user to trigger a Proof-of-Live\n   */\n  function proofOfLife() external;\n\n  /**\n   * @notice Allows the sentinels to nominate a beneficiary\n   * @param beneficiary The beneficiary address\n   * If the beneficiary is address(0), the vote is to retire a previously voted beneficiary\n   */\n  function voteForBeneficiary(address beneficiary) external;\n\n  /**\n   * @notice Allows the beneficiary to inherit the token\n   */\n  function inherit() external;\n\n  /**\n   * @notice Upgrades the implementation of the plugin\n   * @param implementation_ The new implementation\n   */\n  function upgrade(address implementation_) external;\n}\n"
    },
    "contracts/services/inheritance/InheritanceCrunaPlugin.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {StorageSlot} from \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IInheritanceCrunaPlugin} from \"./IInheritanceCrunaPlugin.sol\";\nimport {ICrunaManagedService} from \"../ICrunaManagedService.sol\";\nimport {CrunaManagedService} from \"../CrunaManagedService.sol\";\nimport {Canonical} from \"../../libs/Canonical.sol\";\n\n/**\n * @title InheritanceCrunaPlugin\n * @notice This contract manages inheritance\n */\ncontract InheritanceCrunaPlugin is\n  ICrunaManagedService,\n  IInheritanceCrunaPlugin,\n  Context,\n  CrunaManagedService,\n  ReentrancyGuard\n{\n  using ECDSA for bytes32;\n  using Strings for uint256;\n\n  /**\n   * @notice Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @notice The maximum number of actors that can be set\n   */\n  uint256 private constant _MAX_ACTORS = 16;\n\n  /**\n   * @notice It returns a bytes4 identifying a SENTINEL actor.\n   */\n  bytes4 private constant _SENTINEL = 0xd3eedd6d; // bytes4(keccak256(\"SENTINEL\"))\n\n  /**\n   * @notice The object storing the inheritance configuration\n   */\n  InheritanceConf internal _inheritanceConf;\n\n  /**\n   * @notice The object storing the votes\n   */\n  Votes internal _votes;\n\n  /// @dev see {ICrunaManagedService.sol-requiresToManageTransfer}\n  function requiresToManageTransfer() external pure override(CrunaManagedService, ICrunaManagedService) returns (bool) {\n    return true;\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-setSentinel}\n  function setSentinel(\n    address sentinel,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override onlyTokenOwner ifMustNotBeReset {\n    _setSentinel(sentinel, status, timestamp, validFor, signature);\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-setSentinels}\n  function setSentinels(\n    address[] calldata sentinels,\n    bytes calldata emptySignature\n  ) external virtual override onlyTokenOwner ifMustNotBeReset {\n    uint256 len = sentinels.length;\n    for (uint256 i; i < len; ) {\n      // Notice that this will work only if no protector has been set\n      _setSentinel(sentinels[i], true, 0, 0, emptySignature);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-configureInheritance}\n  function configureInheritance(\n    uint8 quorum,\n    uint8 proofOfLifeDurationInWeeks,\n    uint8 gracePeriodInWeeks,\n    address beneficiary,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) external virtual override onlyTokenOwner ifMustNotBeReset {\n    if (validFor > _MAX_VALID_FOR) revert InvalidValidity();\n    _validateAndCheckSignature(\n      this.configureInheritance.selector,\n      owner(),\n      beneficiary,\n      tokenAddress(),\n      tokenId(),\n      quorum,\n      proofOfLifeDurationInWeeks,\n      gracePeriodInWeeks,\n      timestamp * _TIMESTAMP_MULTIPLIER + validFor,\n      signature\n    );\n    _configureInheritance(quorum, proofOfLifeDurationInWeeks, gracePeriodInWeeks, beneficiary);\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-countSentinels}\n  function countSentinels() external view virtual override returns (uint256) {\n    if (_conf.mustBeReset == 1) return 0;\n    return _actorCount(_SENTINEL);\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-getSentinelsAndInheritanceData}\n  function getSentinelsAndInheritanceData() external view virtual override returns (address[] memory, InheritanceConf memory) {\n    if (_conf.mustBeReset == 1) return (new address[](0), InheritanceConf(address(0), 0, 0, 0, 0, 0));\n    return (_getActors(_SENTINEL), _inheritanceConf);\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-getVotes}\n  function getVotes() external view virtual override returns (address[] memory) {\n    address[] memory votes = _conf.mustBeReset == 1 ? new address[](0) : _getActors(_SENTINEL);\n    uint256 len = votes.length;\n    for (uint256 i; i < len; ) {\n      votes[i] = _votes.favorites[votes[i]];\n      unchecked {\n        ++i;\n      }\n    }\n    return votes;\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-proofOfLife}\n  function proofOfLife() external virtual override onlyTokenOwner ifMustNotBeReset {\n    if (0 == _inheritanceConf.proofOfLifeDurationInWeeks) revert InheritanceNotConfigured();\n    // solhint-disable-next-line not-rely-on-time\n    _inheritanceConf.lastProofOfLife = uint32(block.timestamp);\n    // clean nominations and votes, if any\n    _resetNominationsAndVotes();\n    emit ProofOfLife(_msgSender());\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-voteForBeneficiary}\n  function voteForBeneficiary(address beneficiary) external virtual override ifMustNotBeReset {\n    if (0 == _inheritanceConf.proofOfLifeDurationInWeeks) revert InheritanceNotConfigured();\n    if (_inheritanceConf.beneficiary != address(0))\n      if (!_isGracePeriodExpiredForBeneficiary()) revert WaitingForBeneficiary();\n    _checkIfStillAlive();\n    if (!_isASentinel()) revert NotASentinel();\n    if (beneficiary == address(0)) {\n      if (_votes.favorites[_msgSender()] == address(0)) revert NoVoteToRetire();\n      else {\n        _popNominated(_votes.favorites[_msgSender()]);\n        delete _votes.favorites[_msgSender()];\n      }\n    } else if (!_isNominated(beneficiary)) {\n      _votes.nominations.push(beneficiary);\n    }\n    emit VotedForBeneficiary(_msgSender(), beneficiary);\n    _votes.favorites[_msgSender()] = beneficiary;\n    address winner = _quorumReached();\n    if (winner == address(0)) {\n      // here in case there is a previous nominated beneficiary\n      delete _inheritanceConf.beneficiary;\n    } else {\n      emit BeneficiaryApproved(beneficiary);\n      _inheritanceConf.beneficiary = winner;\n      // solhint-disable-next-line not-rely-on-time\n      _inheritanceConf.extendedProofOfLife = uint32(block.timestamp) - _inheritanceConf.lastProofOfLife;\n      _resetNominationsAndVotes();\n    }\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-inherit}\n  function inherit() external virtual override ifMustNotBeReset {\n    if (_inheritanceConf.beneficiary == address(0)) revert BeneficiaryNotSet();\n    if (_inheritanceConf.beneficiary != _msgSender()) revert NotTheBeneficiary();\n    _checkIfStillAlive();\n    _resetService();\n    _conf.manager.managedTransfer(_nameId(), _msgSender());\n  }\n\n  /// @dev see {ICrunaManagedService.sol-reset}\n  function resetService() external payable override(CrunaManagedService, ICrunaManagedService) {\n    if (_msgSender() != address(_conf.manager)) revert Forbidden();\n    delete _conf.mustBeReset;\n    _resetService();\n  }\n\n  function requiresResetOnTransfer() external pure override(CrunaManagedService, ICrunaManagedService) returns (bool) {\n    return true;\n  }\n\n  /// @dev see {IInheritanceCrunaPlugin-upgrade}\n  function upgrade(address implementation_) external virtual nonReentrant {\n    if (owner() != _msgSender()) revert NotTheTokenOwner();\n    if (implementation_ == address(0)) revert ZeroAddress();\n    if (!Canonical.crunaGuardian().trustedImplementation(_nameId(), implementation_))\n      if (Canonical.crunaGuardian().trustedImplementation(_nameId(), implementation()))\n        // If new implementation is untrusted, the current one must be untrusted too\n        revert UntrustedImplementation(implementation_);\n    ICrunaManagedService impl = ICrunaManagedService(implementation_);\n    uint256 version_ = impl.version();\n    if (version_ <= _version()) revert InvalidVersion(_version(), version_);\n    uint256 requiredVersion = impl.requiresManagerVersion();\n    if (_conf.manager.version() < requiredVersion) revert PluginRequiresUpdatedManager(requiredVersion);\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = implementation_;\n  }\n\n  // Internal functions\n\n  function _version() internal pure virtual override returns (uint256) {\n    return 1_001_000;\n  }\n\n  function _nameId() internal pure virtual override returns (bytes4) {\n    return bytes4(keccak256(\"InheritanceCrunaPlugin\"));\n  }\n\n  /**\n   * @notice It sets a sentinel\n   * @param sentinel The sentinel address\n   * @param status True if the sentinel is active, false if it is not\n   * @param timestamp The timestamp\n   * @param validFor The validity of the signature\n   * @param signature The signature\n   */\n  function _setSentinel(\n    address sentinel,\n    bool status,\n    uint256 timestamp,\n    uint256 validFor,\n    bytes calldata signature\n  ) internal virtual onlyTokenOwner ifMustNotBeReset {\n    if (validFor > _MAX_VALID_FOR) revert InvalidValidity();\n    _validateAndCheckSignature(\n      this.setSentinel.selector,\n      owner(),\n      sentinel,\n      tokenAddress(),\n      tokenId(),\n      status ? 1 : 0,\n      0,\n      0,\n      timestamp * _TIMESTAMP_MULTIPLIER + validFor,\n      signature\n    );\n    if (status) {\n      // will revert if more than 16 sentinels\n      _addActor(sentinel, _SENTINEL);\n    } else {\n      _removeActor(sentinel, _SENTINEL);\n      uint256 shares = _actorCount(_SENTINEL);\n      if (_inheritanceConf.quorum > shares) {\n        _inheritanceConf.quorum = uint8(shares);\n      }\n    }\n    emit SentinelUpdated(_msgSender(), sentinel, status);\n  }\n\n  /**\n   * @notice It configures inheritance\n   * @param quorum The quorum\n   * @param proofOfLifeDurationInWeeks The proof of life duration in weeks\n   * @param gracePeriodInWeeks The grace period in weeks\n   * @param beneficiary The beneficiary\n   */\n  function _configureInheritance(\n    uint8 quorum,\n    uint8 proofOfLifeDurationInWeeks,\n    uint8 gracePeriodInWeeks,\n    address beneficiary\n  ) internal virtual {\n    if (0 != _actorCount(_SENTINEL))\n      if (0 == quorum) revert QuorumCannotBeZero();\n    if (quorum > _actorCount(_SENTINEL)) revert QuorumCannotBeGreaterThanSentinels();\n    if (0 == quorum)\n      if (beneficiary == address(0)) revert InvalidParameters();\n    _inheritanceConf.quorum = quorum;\n    _inheritanceConf.proofOfLifeDurationInWeeks = proofOfLifeDurationInWeeks;\n    // solhint-disable-next-line not-rely-on-time\n    _inheritanceConf.lastProofOfLife = uint32(block.timestamp);\n    _inheritanceConf.gracePeriodInWeeks = gracePeriodInWeeks;\n    _inheritanceConf.beneficiary = beneficiary;\n    _resetNominationsAndVotes();\n    emit InheritanceConfigured(_msgSender(), quorum, proofOfLifeDurationInWeeks, gracePeriodInWeeks, beneficiary);\n  }\n\n  /**\n   * @notice Checks if the quorum has been reached\n   * @return The beneficiary if the quorum has been reached, address(0) otherwise\n   */\n  function _quorumReached() internal view virtual returns (address) {\n    address[] memory sentinels = _getActors(_SENTINEL);\n    uint256 len = _votes.nominations.length;\n    for (uint256 i; i < len; ) {\n      unchecked {\n        uint256 votes;\n        uint256 len2 = sentinels.length;\n        for (uint256 j; j < len2; ++j) {\n          if (_votes.favorites[sentinels[j]] == _votes.nominations[i]) {\n            votes++;\n            if (votes == _inheritanceConf.quorum) {\n              return _votes.nominations[i];\n            }\n          }\n        }\n        ++i;\n      }\n    }\n    return address(0);\n  }\n\n  /**\n   * @notice Check is a beneficiary has been nominated\n   * @param beneficiary The beneficiary to check\n   * @return True if the beneficiary has been nominated, false otherwise\n   */\n  function _isNominated(address beneficiary) internal view virtual returns (bool) {\n    uint256 len = _votes.nominations.length;\n    for (uint256 i; i < len; ) {\n      if (beneficiary == _votes.nominations[i]) {\n        return true;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Removes a nominated beneficiary\n   * @param beneficiary The beneficiary to remove\n   */\n  function _popNominated(address beneficiary) internal virtual {\n    uint256 len = _votes.nominations.length;\n    for (uint256 i; i < len; ) {\n      unchecked {\n        if (beneficiary == _votes.nominations[i]) {\n          // len is > 0\n          if (i != len - 1) {\n            _votes.nominations[i] = _votes.nominations[len - 1];\n          }\n          _votes.nominations.pop();\n          break;\n        }\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Resets nominations and votes\n   */\n  function _resetNominationsAndVotes() internal virtual {\n    if (_votes.nominations.length != 0) {\n      delete _votes.nominations;\n      address[] memory _sentinels = _getActors(_SENTINEL);\n      uint256 len = _sentinels.length;\n      for (uint256 i; i < len; ) {\n        delete _votes.favorites[_sentinels[i]];\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Checks if the sender is a sentinel\n   * @return True if the sender is a sentinel, false otherwise\n   */\n  function _isASentinel() internal view virtual returns (bool) {\n    return _actorIndex(_msgSender(), _SENTINEL) != _MAX_ACTORS;\n  }\n\n  /**\n   * @notice Checks if the owner is still alive\n   */\n  function _checkIfStillAlive() internal view virtual {\n    if (\n      // solhint-disable-next-line not-rely-on-time\n      block.timestamp - _inheritanceConf.lastProofOfLife < uint256(_inheritanceConf.proofOfLifeDurationInWeeks) * 7 days\n    ) revert StillAlive();\n  }\n\n  /**\n   * @notice Checks if the grace period has expired\n   * @return True if the grace period has expired, false otherwise\n   */\n  function _isGracePeriodExpiredForBeneficiary() internal virtual returns (bool) {\n    if (\n      // solhint-disable-next-line not-rely-on-time\n      block.timestamp - (_inheritanceConf.lastProofOfLife + _inheritanceConf.extendedProofOfLife) >\n      (uint256(_inheritanceConf.proofOfLifeDurationInWeeks) + _inheritanceConf.gracePeriodInWeeks) * 7 days\n    ) {\n      delete _inheritanceConf.beneficiary;\n      _resetNominationsAndVotes();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Reset the plugin configuration\n   */\n  function _resetService() internal {\n    delete _actors[_SENTINEL];\n    delete _inheritanceConf;\n    delete _votes;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/services/inheritance/InheritanceCrunaPluginProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC6551AccountProxy} from \"../../erc/ERC6551AccountProxy.sol\";\n\n/**\n * @title InheritanceCrunaPluginProxy\n * @notice Proxy contract for the InheritanceCrunaPlugin\n */\ncontract InheritanceCrunaPluginProxy is ERC6551AccountProxy {\n  /**\n   * @notice Constructor\n   * @param _initialImplementation Address of the initial implementation\n   */\n  constructor(address _initialImplementation) ERC6551AccountProxy(_initialImplementation) {}\n}\n"
    },
    "contracts/token/CrunaProtectedNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n//\nimport {IERC165, ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IManagedNFT, ICrunaProtectedNFT} from \"./ICrunaProtectedNFT.sol\";\nimport {IERC6454} from \"../erc/IERC6454.sol\";\nimport {IERC6982} from \"../erc/IERC6982.sol\";\nimport {ICrunaManager} from \"../manager/ICrunaManager.sol\";\nimport {IVersioned} from \"../utils/IVersioned.sol\";\nimport {Deployed} from \"../utils/Deployed.sol\";\nimport {Canonical} from \"../libs/Canonical.sol\";\nimport {ICrunaService} from \"../services/ICrunaService.sol\";\n\n//import \"hardhat/console.sol\";\n\n/**\n * A convenient interface to mix nameId, version and default implementations\n */\ninterface IVersionedManager {\n  // solhint-disable-next-line func-name-mixedcase\n  function DEFAULT_IMPLEMENTATION() external pure returns (address);\n\n  function version() external pure returns (uint256);\n\n  function nameId() external pure returns (bytes4);\n}\n\n/**\n * @title CrunaProtectedNFT\n * @notice This contracts is a base for NFTs with protected transfers. It must be extended implementing\n * the _canManage function to define who can alter the contract. Two versions are provided in this repo,CrunaProtectedNFTTimeControlled.sol and CrunaProtectedNFTOwnable.sol. The first is the recommended one, since it allows a governance aligned with best practices. The second is simpler, and can be used in less critical scenarios. If none of them fits your needs, you can implement your own policy.\n */\nabstract contract CrunaProtectedNFT is ICrunaProtectedNFT, IVersioned, IERC6454, IERC6982, Deployed, ERC721, ReentrancyGuard {\n  using ECDSA for bytes32;\n  using Strings for uint256;\n  using Address for address;\n\n  /**\n   * @notice Set a convenient variable to refer to the contract itself\n   */\n  address internal immutable _SELF = address(this);\n\n  /**\n   * @notice The configuration of the NFT\n   */\n  NftConf internal _nftConf;\n\n  /**\n   * @notice The manager history\n   */\n  ManagerHistory[] internal _managerHistory;\n\n  /**\n   * @notice internal variable used to make protected NFT temporarily transferable.\n   * It is set before the transfer and removed after it, during the manager transfer process.\n   */\n  mapping(uint256 tokenId => uint256 approved) internal _approvedTransfers;\n\n  /**\n   * @notice allows only the manager of a certain tokenId to call the function.\n   * @param tokenId The id of the token.\n   */\n  modifier onlyManagerOf(uint256 tokenId) {\n    if (_managerOf(tokenId) != _msgSender()) revert NotTheManager();\n    _;\n  }\n\n  /// @dev see {ICrunaProtectedNFT-nftConf}\n  function nftConf() external view virtual override returns (NftConf memory) {\n    return _nftConf;\n  }\n\n  /// @dev see {ICrunaProtectedNFT-managerHistory}\n  function managerHistory(uint256 index) external view virtual override returns (ManagerHistory memory) {\n    if (index >= _nftConf.managerHistoryLength) revert InvalidIndex();\n    return _managerHistory[index];\n  }\n\n  /// @dev see {IVersioned-version}\n  function version() external pure virtual returns (uint256) {\n    // semver 1.2.3 => 1002003 = 1e6 + 2e3 + 3\n    return 1_000_000;\n  }\n\n  constructor(string memory name_, string memory symbol_) payable ERC721(name_, symbol_) {\n    emit DefaultLocked(false);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-init}\n  function init(\n    address managerAddress_,\n    bool progressiveTokenIds_,\n    uint96 nextTokenId_,\n    uint96 maxTokenId_\n  ) external virtual override {\n    _canManage(true);\n    if (_nftConf.managerHistoryLength != 0) revert AlreadyInitiated();\n    if (managerAddress_ == address(0)) revert ZeroAddress();\n    _nftConf = NftConf({\n      progressiveTokenIds: progressiveTokenIds_,\n      nextTokenId: nextTokenId_,\n      maxTokenId: maxTokenId_,\n      managerHistoryLength: 1,\n      unusedField: 0\n    });\n    _managerHistory.push(ManagerHistory({managerAddress: managerAddress_, firstTokenId: nextTokenId_, lastTokenId: 0}));\n  }\n\n  /// @dev see {ICrunaProtectedNFT-setMaxTokenId}\n  function setMaxTokenId(uint96 maxTokenId_) external virtual {\n    _canManage(_nftConf.maxTokenId == 0);\n    if (maxTokenId_ == 0) revert InvalidMaxTokenId();\n    if (_nftConf.progressiveTokenIds)\n      if (_nftConf.nextTokenId > maxTokenId_ + 1) revert InvalidMaxTokenId();\n    _nftConf.maxTokenId = maxTokenId_;\n    emit MaxTokenIdChange(maxTokenId_);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-defaultManagerImplementation}\n  function defaultManagerImplementation(uint256 _tokenId) external view virtual override returns (address) {\n    return _defaultManagerImplementation(_tokenId);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-upgradeDefaultManager}\n  function upgradeDefaultManager(address payable newManagerProxy) external virtual nonReentrant {\n    _canManage(false);\n    if (!_nftConf.progressiveTokenIds) revert NotAvailableIfTokenIdsAreNotProgressive();\n    IVersionedManager newManager = IVersionedManager(newManagerProxy);\n    if (!Canonical.crunaGuardian().trustedImplementation(newManager.nameId(), newManager.DEFAULT_IMPLEMENTATION()))\n      revert UntrustedImplementation(newManagerProxy);\n    address lastEmitter = _managerHistory[_nftConf.managerHistoryLength - 1].managerAddress;\n    if (newManager.version() <= IVersionedManager(lastEmitter).version()) revert CannotUpgradeToAnOlderVersion();\n    _managerHistory[_nftConf.managerHistoryLength - 1].lastTokenId = _nftConf.nextTokenId - 1;\n    _managerHistory.push(ManagerHistory({managerAddress: newManagerProxy, firstTokenId: _nftConf.nextTokenId, lastTokenId: 0}));\n    _nftConf.managerHistoryLength++;\n    emit DefaultManagerUpgrade(newManagerProxy);\n  }\n\n  /**\n   * @notice see {ICrunaProtectedNFT-managedTransfer}.\n   */\n  function managedTransfer(\n    bytes4 pluginNameId,\n    uint256 tokenId,\n    address to\n  ) external payable virtual override onlyManagerOf(tokenId) {\n    _approvedTransfers[tokenId] = 1;\n    _approve(_managerOf(tokenId), tokenId, address(0));\n    safeTransferFrom(ownerOf(tokenId), to, tokenId);\n    _approve(address(0), tokenId, address(0));\n    delete _approvedTransfers[tokenId];\n    emit ManagedTransfer(pluginNameId, tokenId);\n  }\n\n  /// @dev see {ERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n    return\n      interfaceId == type(IManagedNFT).interfaceId ||\n      interfaceId == type(IERC6454).interfaceId ||\n      interfaceId == type(IERC6982).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /// @dev see {IERC6454-isTransferable}\n  function isTransferable(uint256 tokenId, address from, address to) external view virtual override returns (bool) {\n    return _isTransferable(tokenId, from, to);\n  }\n\n  /// @dev see {IERC6982-defaultLocked}\n  function defaultLocked() external pure virtual override returns (bool) {\n    return false;\n  }\n\n  /// @dev see {IERC6982-locked}\n  function locked(uint256 tokenId) external view virtual override returns (bool) {\n    return ICrunaManager(_managerOf(tokenId)).locked();\n  }\n\n  /**\n   * @notice Emit a Locked event when a protector is set and the token becomes locked.\n   * This function is not virtual because should not be overridden to avoid issues when\n   * called by the manager (when protectors are set/unset)\n   * Making it payable reduces the gas cost.\n   */\n  function emitLockedEvent(uint256 tokenId, bool locked_) external payable onlyManagerOf(tokenId) {\n    emit Locked(tokenId, locked_);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-plug}\n  function plug(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account,\n    bytes memory data\n  ) external payable virtual override {\n    if (_msgSender() != ownerOf(tokenId)) revert NotTheTokenOwner();\n    ICrunaService service = ICrunaService(implementation);\n    if (service.isManaged()) revert ManagedService();\n    address addr = _deploy(implementation, salt, _SELF, tokenId, isERC6551Account);\n    service = ICrunaService(addr);\n    /**\n     * @dev it is the service responsibility to assure that `init` can be called only one time\n     * The rationale for call `init` anytime is that an hostile agent can use the registry to deploy\n     * a service that later cannot be initiated if the can be initiated only at the deployment.\n     */\n    service.init(data);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-isDeployed}\n  function isDeployed(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) external view virtual returns (bool) {\n    return _isDeployed(implementation, salt, _SELF, tokenId, isERC6551Account);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-managerOf}\n  function managerOf(uint256 tokenId) external view virtual returns (address) {\n    return _managerOf(tokenId);\n  }\n\n  /**\n   * @notice internal function to return the manager (for lesser gas consumption)\n   * @param tokenId the id of the token\n   * @return the address of the manager\n   */\n  function _managerOf(uint256 tokenId) internal view virtual returns (address) {\n    return _addressOfDeployed(_defaultManagerImplementation(tokenId), 0x00, _SELF, tokenId, false);\n  }\n\n  /// @dev see {ICrunaProtectedNFT-addressOfDeployed}\n  function addressOfDeployed(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) external view virtual override returns (address) {\n    return _addressOfDeployed(implementation, salt, _SELF, tokenId, isERC6551Account);\n  }\n\n  /**\n   * @notice Returns the default implementation of the manager for a specific tokenId\n   * @param _tokenId the tokenId\n   * @return The address of the implementation\n   */\n  function _defaultManagerImplementation(uint256 _tokenId) internal view virtual returns (address) {\n    if (_nftConf.managerHistoryLength == 1) return _managerHistory[0].managerAddress;\n    uint256 len = _nftConf.managerHistoryLength;\n    for (uint256 i; i < len; ) {\n      if (\n        _tokenId >= _managerHistory[i].firstTokenId &&\n        (_managerHistory[i].lastTokenId == 0 || _tokenId <= _managerHistory[i].lastTokenId)\n      ) return _managerHistory[i].managerAddress;\n      unchecked {\n        ++i;\n      }\n    }\n    // should never happen\n    return address(0);\n  }\n\n  /**\n   * @notice Specify if the caller can call some function.\n   * Must be overridden to specify who can manage changes during initialization and later\n   * @param isInitializing If true, the function is being called during initialization, if false,\n   * it is supposed to the called later. A time controlled NFT can allow the admin to call some\n   * functions during the initialization, requiring later a standard proposal/execition process.\n   */\n  function _canManage(bool isInitializing) internal view virtual;\n\n  /**\n   * @notice see {ERC721-_update}.\n   */\n  function _update(address to, uint256 tokenId, address auth) internal virtual override(ERC721) returns (address) {\n    if (_isTransferable(tokenId, _ownerOf(tokenId), to)) {\n      return super._update(to, tokenId, auth);\n    }\n    revert NotTransferable();\n  }\n\n  /**\n   * @notice Function to define a token as transferable or not, according to IERC6454\n   * @param tokenId The id of the token.\n   * @param from The address of the sender.\n   * @param to The address of the recipient.\n   * @return true if the token is transferable, false otherwise.\n   */\n  function _isTransferable(uint256 tokenId, address from, address to) internal view virtual returns (bool) {\n    ICrunaManager manager = ICrunaManager(_managerOf(tokenId));\n    // Burnings and self transfers are not allowed\n    if (to == address(0) || from == to) return false;\n    // if from zero, it is minting\n    if (from == address(0)) return true;\n    _requireOwned(tokenId);\n    return manager.isTransferable(to) || _approvedTransfers[tokenId] == 1;\n  }\n\n  /**\n   * @notice Mints tokens by amount.\n   * @dev It works only if nftConf.progressiveTokenIds is true.\n   * @param to The address of the recipient.\n   * @param amount The amount of tokens to mint.\n   */\n  function _mintAndActivateByAmount(address to, uint256 amount) internal virtual {\n    if (!_nftConf.progressiveTokenIds) revert NotAvailableIfTokenIdsAreNotProgressive();\n    if (_nftConf.managerHistoryLength == 0) revert NftNotInitiated();\n    uint256 tokenId = _nftConf.nextTokenId;\n    for (uint256 i; i < amount; ) {\n      unchecked {\n        _mintAndActivate(to, tokenId++);\n        ++i;\n      }\n    }\n    _nftConf.nextTokenId = uint96(tokenId);\n  }\n\n  /**\n   * @notice This function will mint a new token and initialize it.\n   * @dev Use it carefully if nftConf.progressiveTokenIds is true. Usually, you may\n   * want to do so if you reserved some specific token to the project itself, the DAO, etc.\n   * An example:\n   * You reserve 1000 tokens to the DAO, `nextTokenId` will be 1001.\n   * If you have a function the uses directly _mintAndActivate you MUST set a check\n   * to avoid minting tokens with higher id than `nextTokenId`. If than happens, when\n   * you call again _mintAndActivateByAmount, if one of the supposed tokens is already minted,\n   * the function will revert and the error may be unfixable.\n   * @param to The address of the recipient.\n   * @param tokenId The id of the token.\n   */\n  function _mintAndActivate(address to, uint256 tokenId) internal virtual {\n    if (_nftConf.managerHistoryLength == 0) revert NftNotInitiated();\n    if (\n      tokenId > type(uint96).max ||\n      (_nftConf.maxTokenId != 0 && tokenId > _nftConf.maxTokenId) ||\n      (tokenId < _managerHistory[0].firstTokenId)\n    ) revert InvalidTokenId();\n    _deploy(_defaultManagerImplementation(tokenId), 0x00, _SELF, tokenId, false);\n    _safeMint(to, tokenId++);\n  }\n}\n"
    },
    "contracts/token/CrunaProtectedNFTOwnable.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n//\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {CrunaProtectedNFT} from \"./CrunaProtectedNFT.sol\";\n\n/**\n * @title CrunaProtectedNFTOwnable\n * @notice This contract is a base for NFTs with protected transfers.\n * We advise to use CrunaProtectedNFTTimeControlled.sol instead, since it allows\n * a better governance.\n */\nabstract contract CrunaProtectedNFTOwnable is CrunaProtectedNFT, Ownable2Step {\n  /**\n   * @notice Error returned when the caller is not the owner\n   */\n  error NotTheOwner();\n\n  /**\n   * @notice Construct the contract with a given name, symbol, and admin.\n   * @param name_ The name of the token.\n   * @param symbol_ The symbol of the token.\n   * @param admin The owner of the contract\n   */\n  constructor(string memory name_, string memory symbol_, address admin) CrunaProtectedNFT(name_, symbol_) Ownable(admin) {}\n\n  function _canManage(bool) internal view virtual override {\n    if (_msgSender() != owner()) revert NotTheOwner();\n  }\n}\n"
    },
    "contracts/token/CrunaProtectedNFTTimeControlled.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\nimport {CrunaProtectedNFT} from \"./CrunaProtectedNFT.sol\";\n\n/**\n * @title CrunaProtectedNFTTimeControlled\n * @notice This contract is a base for NFTs with protected transfers.\n * It implements best practices for governance and timelock.\n */\nabstract contract CrunaProtectedNFTTimeControlled is CrunaProtectedNFT, TimelockController {\n  /**\n   * @notice Error returned when the caller is not authorized\n   */\n  error NotAuthorized();\n\n  /**\n   * @notice Error returned when the function is not called through the TimelockController\n   */\n  error MustCallThroughTimeController();\n\n  /**\n   * @notice construct the contract with a given name, symbol, minDelay, proposers, executors, and admin.\n   * @param name_ The name of the token.\n   * @param symbol_ The symbol of the token.\n   * @param minDelay The minimum delay for the time lock.\n   * @param proposers The initial proposers.\n   * @param executors The initial executors.\n   * @param admin The admin of the contract (they should later renounce to the role).\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint256 minDelay,\n    address[] memory proposers,\n    address[] memory executors,\n    address admin\n  ) CrunaProtectedNFT(name_, symbol_) TimelockController(minDelay, proposers, executors, admin) {}\n\n  /// @dev see {ERC165-supportsInterface}.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(TimelockController, CrunaProtectedNFT) returns (bool) {\n    return super.supportsInterface(interfaceId);\n  }\n\n  /// @dev see {CrunaProtectedNFT-_canManage}\n  function _canManage(bool isInitializing) internal view virtual override {\n    if (isInitializing) {\n      if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert NotAuthorized();\n    } else if (_msgSender() != address(this)) revert MustCallThroughTimeController();\n  }\n}\n"
    },
    "contracts/token/ICrunaProtectedNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IManagedNFT} from \"./IManagedNFT.sol\";\n\n/**\n * @title ICrunaProtectedNFT\n * @author Francesco Sullo <francesco@sullo.co>\n */\ninterface ICrunaProtectedNFT is IManagedNFT, IERC721 {\n  /**\n   * @notice Optimized configuration structure for the generic NFT\n   *\n   * TokenIds are uint96 for optimization purposes. In particular, having the tokenId as a uint96 allows\n   * to encode the tokenId in the first 12 bytes of the storage slot, leaving the last 20 bytes for the token address\n   * That allows services and other tools to save storage because tokenAddress + tokenId will take a single word.\n   * For example, tokenAddress and tokenId can be encoded as\n   * uint256 tokenAddressAndTokenId = uint256(tokenAddress) << 96 | tokenId;\n   *\n   * Elements:\n   * - progressiveTokenIds is used to allow the upgrade of the default manager implementation. It is used to assure that the manager can be upgraded in a safe way.\n   * - nextTokenId is the next tokenId to be used. It is used to mint new tokens if progressiveTokenIds is true.\n   * - maxTokenId is the maximum tokenId that can be minted. It is used to limit the minting of new tokens.\n   * - managerHistoryLength is the length of the manager history.\n   */\n  struct NftConf {\n    uint96 nextTokenId;\n    uint96 maxTokenId;\n    bool progressiveTokenIds;\n    uint8 managerHistoryLength;\n    // for future changes\n    uint8 unusedField;\n  }\n\n  /**\n   * @notice Manager history structure\n   * Elements:\n   * - firstTokenId is the first tokenId using a specific manager.\n   * - lastTokenId is the last tokenId managed by the same manager.\n   * - managerAddress is the address of the manager.\n   */\n  struct ManagerHistory {\n    uint96 firstTokenId;\n    uint96 lastTokenId;\n    address managerAddress;\n  }\n\n  // events\n\n  /**\n   * @notice Emitted when the default manager is upgraded\n   * @param newManagerProxy The address of the new manager proxy\n   */\n  event DefaultManagerUpgrade(address indexed newManagerProxy);\n\n  /**\n   * @notice Emitted when the maxTokenId is changed\n   * @param maxTokenId The new maxTokenId\n   */\n  event MaxTokenIdChange(uint96 maxTokenId);\n\n  // errors\n\n  /**\n   * @notice Error returned when the caller is not the token owner\n   */\n  error NotTransferable();\n\n  /**\n   * @notice Error returned when the caller is not the manager\n   */\n  error NotTheManager();\n\n  /**\n   * @notice Error returned when the caller is not the token owner\n   */\n  error ZeroAddress();\n\n  /**\n   * @notice Error returned when the token is already initiated\n   */\n  error AlreadyInitiated();\n\n  /**\n   * @notice Error returned when the caller is not the token owner\n   */\n  error NotTheTokenOwner();\n\n  /**\n   * @notice Error returned when trying to upgrade to an older version\n   */\n  error CannotUpgradeToAnOlderVersion();\n\n  /**\n   * @notice Error returned when the new implementation of the manager is not trusted\n   */\n  error UntrustedImplementation(address implementation);\n\n  /**\n   * @notice Error returned when trying to call a function that requires progressive token ids\n   */\n  error NotAvailableIfTokenIdsAreNotProgressive();\n\n  /**\n   * @notice Error returned when the token id is invalid\n   */\n  error InvalidTokenId();\n\n  /**\n   * @notice Error returned when the NFT is not initiated\n   */\n  error NftNotInitiated();\n\n  /**\n   * @notice Error returned when trying too set an invalid MaxTokenId\n   */\n  error InvalidMaxTokenId();\n\n  /**\n   * @notice Error returned when an index is invalid\n   */\n  error InvalidIndex();\n\n  /**\n   * @notice Error returned if the sender is neither the manager nor the token owner\n   */\n  error OnlyTokenOwnerOrManager();\n\n  /**\n   * @notice Error returned when the token owner tries to deploy a service that must be managed\n   */\n  error ManagedService();\n\n  // views\n\n  /**\n   * @notice Returns the configuration of the NFT\n   */\n  function nftConf() external view returns (NftConf memory);\n\n  /**\n   * @notice Returns the manager history for a specific index\n   * @param index The index\n   */\n  function managerHistory(uint256 index) external view returns (ManagerHistory memory);\n\n  /**\n   * @notice set the maximum tokenId that can be minted\n   * @param maxTokenId_ The new maxTokenId\n   */\n  function setMaxTokenId(uint96 maxTokenId_) external;\n\n  /**\n   * @notice Initialize the NFT\n   * @param managerAddress_ The address of the manager\n   * @param progressiveTokenIds_ If true, the tokenIds will be progressive\n   * @param nextTokenId_ The next tokenId to be used.\n   * If progressiveTokenIds_ == true and the project must reserve some tokens to\n   * special addresses, community, etc. You set the nextTokenId_ to the first not reserved token.\n   * Be careful, your function minting by tokenId MUST check that the tokenId is\n   * not higher than nextTokenId. If not, when trying to mint tokens by amount, as soon as\n   * nextTokenId reaches the minted tokenId, the function will revert, blocking any future minting.\n   * If you code may risk so, set a function that allow you to correct the nextTokenId to skip\n   * the token minted by mistake.\n   * @param maxTokenId_ The maximum tokenId that can be minted (it can be 0 if no upper limit)\n   */\n  function init(address managerAddress_, bool progressiveTokenIds_, uint96 nextTokenId_, uint96 maxTokenId_) external;\n\n  /**\n   * @notice Returns the address of the default implementation of the manager for a tokenId\n   * @param _tokenId The tokenId\n   */\n  function defaultManagerImplementation(uint256 _tokenId) external view returns (address);\n\n  /**\n   * @notice Upgrade the default manager for any following tokenId\n   * @param newManagerProxy The address of the new manager proxy\n   */\n  function upgradeDefaultManager(address payable newManagerProxy) external;\n\n  /**\n   * @notice Return the address of the manager of a tokenId\n   * @param tokenId The id of the token.\n   */\n  function managerOf(uint256 tokenId) external view returns (address);\n\n  /**\n   * @notice Returns the address of a deployed manager or plugin\n   * @param implementation The address of the manager or plugin implementation\n   * @param salt The salt\n   * @param tokenId The tokenId\n   * @param isERC6551Account Specifies the registry to use\n   * True if the tokenId was deployed via ERC6551Registry,\n   * false, it was deployed via ERC7656Registry\n   * @return The address of the deployed manager or plugin\n   */\n  function addressOfDeployed(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) external view returns (address);\n\n  /**\n   * @notice Deploys an unmanaged service\n   * @param implementation The address of the service implementation\n   * @param salt The salt\n   * @param tokenId The tokenId\n   * @param isERC6551Account Specifies the registry to use\n   * True if the tokenId must be deployed via ERC6551Registry,\n   * false, it must be deployed via ERC7656Registry\n   */\n  function plug(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account,\n    bytes memory data\n  ) external payable;\n\n  /**\n   * @notice Returns if a plugin is deployed\n   * @param implementation The address of the plugin implementation\n   * @param salt The salt\n   * @param tokenId The tokenId\n   * @param isERC6551Account Specifies the registry to use\n   * True if the tokenId was deployed via ERC6551Registry,\n   * false, it was deployed via ERC7656Registry\n   */\n  function isDeployed(\n    address implementation,\n    bytes32 salt,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) external view returns (bool);\n}\n"
    },
    "contracts/token/IManagedNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n/**\n * @title IManagedNFT\n * @author Francesco Sullo <francesco@sullo.co>\n * @notice Interface for a managed NFT\n */\ninterface IManagedNFT {\n  /**\n   * @notice Emitted when a token is transferred by a plugin\n   * @param pluginNameId The hash of the plugin name.\n   * @param tokenId The id of the token.\n   */\n  event ManagedTransfer(bytes4 indexed pluginNameId, uint256 indexed tokenId);\n\n  /**\n   * @notice Allow a plugin to transfer the token\n   * @param pluginNameId The hash of the plugin name.\n   * @param tokenId The id of the token.\n   * @param to The address of the recipient.\n   */\n  function managedTransfer(bytes4 pluginNameId, uint256 tokenId, address to) external payable;\n}\n"
    },
    "contracts/utils/CommonBase.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n\nimport {ERC7656Contract} from \"../erc/ERC7656Contract.sol\";\nimport {CrunaProtectedNFT} from \"../token/CrunaProtectedNFT.sol\";\nimport {INamed} from \"../utils/INamed.sol\";\n\nimport {ICommonBase} from \"./ICommonBase.sol\";\n\n/**\n * @title CommonBase.sol\n * @notice Base contract for managers and services\n */\nabstract contract CommonBase is ICommonBase, INamed, ERC7656Contract {\n  /**\n   * @notice Error returned when the caller is not the token owner\n   */\n  modifier onlyTokenOwner() {\n    if (owner() != msg.sender) revert NotTheTokenOwner();\n    _;\n  }\n\n  /**\n   * @notice Returns the name id of the contract\n   */\n  function nameId() external view override returns (bytes4) {\n    return _nameId();\n  }\n\n  /**\n   * @notice Internal function that must be overridden by the contract to\n   * return the name id of the contract\n   */\n  function _nameId() internal view virtual returns (bytes4);\n\n  /**\n   * @notice Returns the vault, i.e., the CrunaProtectedNFT contract\n   */\n  function vault() external view virtual returns (CrunaProtectedNFT) {\n    return _vault();\n  }\n\n  /**\n   * @notice Returns the vault, i.e., the CrunaProtectedNFT contract\n   */\n  function _vault() internal view virtual returns (CrunaProtectedNFT) {\n    return CrunaProtectedNFT(tokenAddress());\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/utils/Deployed.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n// Author: Francesco Sullo <francesco@sullo.co>\n//\nimport {ERC6551AccountLib} from \"erc6551/lib/ERC6551AccountLib.sol\";\n\nimport {Canonical} from \"../libs/Canonical.sol\";\n\n/**\n * @title Deployed\n * @notice This contract manages deploy-related functions\n */\nabstract contract Deployed {\n  /// @dev see {ICrunaProtectedNFT-isDeployed}\n  function _isDeployed(\n    address implementation,\n    bytes32 salt,\n    address tokenAddress,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) internal view virtual returns (bool) {\n    address _addr = _addressOfDeployed(implementation, salt, tokenAddress, tokenId, isERC6551Account);\n    uint32 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(_addr)\n    }\n    return (size != 0);\n  }\n\n  /**\n   * @notice Internal function to return the address of a deployed token bound contract\n   * @param implementation The address of the implementation\n   * @param salt The salt\n   * @param tokenId The tokenId\n   * @param isERC6551Account If true, the tokenId has been deployed via ERC6551Registry, if false, via ERC7656Registry\n   */\n  function _addressOfDeployed(\n    address implementation,\n    bytes32 salt,\n    address tokenAddress,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) internal view virtual returns (address) {\n    return\n      ERC6551AccountLib.computeAddress(\n        isERC6551Account ? address(Canonical.erc6551Registry()) : address(Canonical.erc7656Registry()),\n        implementation,\n        salt,\n        block.chainid,\n        tokenAddress,\n        tokenId\n      );\n  }\n\n  /**\n   * @notice This function deploys a token-linked contract (manager or plugin)\n   * @param implementation The address of the implementation\n   * @param salt The salt\n   * @param tokenId The tokenId\n   * @param isERC6551Account If true, the tokenId will be deployed via ERC6551Registry,\n   * if false, via ERC7656Registry\n   */\n  function _deploy(\n    address implementation,\n    bytes32 salt,\n    address tokenAddress,\n    uint256 tokenId,\n    bool isERC6551Account\n  ) internal virtual returns (address) {\n    if (isERC6551Account) {\n      return Canonical.erc6551Registry().createAccount(implementation, salt, block.chainid, tokenAddress, tokenId);\n    }\n    return Canonical.erc7656Registry().create(implementation, salt, block.chainid, tokenAddress, tokenId);\n  }\n}\n"
    },
    "contracts/utils/ICommonBase.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {CrunaProtectedNFT} from \"../token/CrunaProtectedNFT.sol\";\n\n/**\n * @title ICommonBase\n */\ninterface ICommonBase {\n  /**\n   * @notice Error returned when the caller is not the token owner\n   */\n  error NotTheTokenOwner();\n\n  /**\n   * @notice Returns the vault, i.e., the CrunaProtectedNFT contract\n   */\n  function vault() external view returns (CrunaProtectedNFT);\n}\n"
    },
    "contracts/utils/INamed.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n/**\n * @title INamed\n */\ninterface INamed {\n  /**\n   * @notice Returns the name id of the contract\n   */\n  function nameId() external view returns (bytes4);\n}\n"
    },
    "contracts/utils/INamedAndVersioned.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\nimport {IVersioned} from \"./IVersioned.sol\";\nimport {INamed} from \"./INamed.sol\";\n\n/**\n * @title INamedAndVersioned\n * @notice Combines INamed and IVersioned\n */\ninterface INamedAndVersioned is INamed, IVersioned {}\n"
    },
    "contracts/utils/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ISignatureValidator\n * @author Francesco Sullo <francesco@sullo.co>\n * @notice Validates signatures\n */\ninterface ISignatureValidator {\n  /**\n   * @notice Emitted when a signature is pre-approved.\n   * @param hash The hash of the signature.\n   * @param signer The signer of the signature.\n   */\n  event PreApproved(bytes32 hash, address indexed signer);\n\n  /**\n   * @dev Error returned when a timestamp is invalid or expired.\n   */\n  error TimestampInvalidOrExpired();\n\n  /**\n   * @dev Error returned when a called in unauthorized.\n   */\n  error NotAuthorized();\n\n  /**\n   * @dev Error returned when trying to call a protected operation without a valid signature\n   */\n  error NotPermittedWhenProtectorsAreActive();\n\n  /**\n   * @dev Error returned when the signature is not valid.\n   */\n  error WrongDataOrNotSignedByProtector();\n\n  /**\n   * @dev Error returned when the signature is already used.\n   */\n  error SignatureAlreadyUsed();\n\n  /**\n   * @dev Returns the address who approved a pre-approved operation.\n   * @param hash The hash of the operation.\n   */\n  function preApprovals(bytes32 hash) external view returns (address);\n\n  /**\n   * @dev Returns the hash of a signature.\n   * @param signature The signature.\n   */\n  function hashSignature(bytes calldata signature) external pure returns (bytes32);\n\n  /**\n   * @dev Returns if a signature has been used.\n   * @param hash The hash of the signature.\n   */\n  function isSignatureUsed(bytes32 hash) external view returns (bool);\n\n  /**\n   * @dev This function validates a signature trying to be as flexible as possible.\n   * As long as called inside the same contract, the cost adding some more parameters is negligible.\n   * Instead, calling it from other contracts can be expensive.\n   * @param selector The selector of the function being called.\n   * @param owner The owner of the token.\n   * @param actor The actor being authorized.\n   * It can be address(0) if the parameter is not needed.\n   * @param tokenAddress The address of the token.\n   * @param tokenId The id of the token.\n   * @param extra The extra\n   * @param extra2 The extra2\n   * @param extra3 The extra3\n   * @param timeValidation A combination of timestamp and validity of the signature.\n   * @return The signer of the signature and the hash of the signature.\n   */\n  function recoverSigner(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation,\n    bytes calldata signature\n  ) external view returns (address, bytes32);\n\n  /**\n   * @dev Pre-approve a signature.\n   * @param selector The selector of the function being called.\n   * @param owner The owner of the token.\n   * @param actor The actor being authorized.\n   * It can be address(0) if the parameter is not needed.\n   * @param tokenAddress The address of the token.\n   * @param tokenId The id of the token.\n   * @param extra The extra\n   * @param extra2 The extra2\n   * @param extra3 The extra3\n   * @param timeValidation A combination of timestamp and validity of the signature.\n   */\n  function preApprove(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation\n  ) external;\n}\n"
    },
    "contracts/utils/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: GPL3\npragma solidity ^0.8.20;\n\n/**\n * @title IVersioned\n * @author Francesco Sullo <francesco@sullo.co>\n */\ninterface IVersioned {\n  /**\n   * @notice Returns the version of the contract.\n   * The format is similar to semver, where any element takes 3 digits.\n   * For example, version 1.2.14 is 1_002_014.\n   */\n  function version() external view returns (uint256);\n}\n"
    },
    "contracts/utils/SignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {ISignatureValidator} from \"./ISignatureValidator.sol\";\nimport {ICrunaManager} from \"../manager/ICrunaManager.sol\";\n\n/**\n * @title SignatureValidator\n * @author Francesco Sullo <francesco@sullo.co>\n * @notice This contract is used to validate signatures.\n * It is based on EIP712 and supports typed messages V4.\n */\nabstract contract SignatureValidator is ISignatureValidator, EIP712, Context {\n  using ECDSA for bytes32;\n\n  /**\n   * @notice The time validation is a uint256 with the following structure:\n   * - the timestamp is multiplied by 10_000_000\n   * - the validity is added to the timestamp\n   * For example, if timestamp is 1710280592 and validFor is 3600\n   * the timeValidation will be 17102805920003600\n   */\n\n  /**\n   * @notice The maximum validFor. If more than this it will conflict with the timestamp.\n   */\n  uint256 internal constant _MAX_VALID_FOR = 9_999_999;\n\n  /**\n   * @notice The multiplier for the timestamp in the timeValidation parameter.\n   */\n  uint256 internal constant _TIMESTAMP_MULTIPLIER = 10_000_000;\n\n  /**\n   * @notice All the pre approvals\n   * - operationsHash The hash of operations\n   * - approver The protector approving it\n   */\n  mapping(bytes32 operationsHash => address approver) private _preApprovals;\n\n  /**\n   * @notice All the used signatures\n   * - signatureHash The hash of the signature\n   * - used 1 if the signature has been use, 0 (default) if not\n   */\n  mapping(bytes32 signatureHash => uint256 used) private _usedSignatures;\n\n  bytes32 private constant _AUTH =\n    keccak256(\n      \"Auth(bytes4 selector,address owner,address actor,address tokenAddress,uint256 tokenId,uint256 extra,uint256 extra2,uint256 extra3,uint256 timeValidation)\"\n    );\n\n  /**\n   * @notice EIP712 constructor\n   */\n  constructor() payable EIP712(\"Cruna\", \"1\") {}\n\n  /// @dev see {ISignatureValidator-preApprovals}\n  function preApprovals(bytes32 hash) external view override returns (address) {\n    return _preApprovals[hash];\n  }\n\n  /// @dev see {ISignatureValidator-hashSignature}\n  function hashSignature(bytes calldata signature) external pure override returns (bytes32) {\n    return _hashBytes(signature);\n  }\n\n  /// @dev see {ISignatureValidator-isSignatureUsed}\n  function isSignatureUsed(bytes32 hash) external view override returns (bool) {\n    return _usedSignatures[hash] == 1;\n  }\n\n  /// @dev see {ISignatureValidator-recoverSigner}\n  function recoverSigner(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation,\n    bytes calldata signature\n  ) public view override returns (address, bytes32) {\n    unchecked {\n      uint256 timestamp = timeValidation / _TIMESTAMP_MULTIPLIER;\n      if (timestamp != 0)\n        if (timestamp > block.timestamp || timestamp < block.timestamp - (timeValidation % _TIMESTAMP_MULTIPLIER))\n          revert TimestampInvalidOrExpired();\n      bytes32 hash = _hashData(selector, owner, actor, tokenAddress, tokenId, extra, extra2, extra3, timeValidation);\n      if (65 == signature.length) {\n        return (_hashTypedDataV4(hash).recover(signature), hash);\n      }\n      return (_preApprovals[hash], hash);\n    }\n  }\n\n  /// @dev see {ISignatureValidator-preApprove}\n  function preApprove(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation\n  ) external override {\n    if (!_canPreApprove(selector, actor, _msgSender())) revert NotAuthorized();\n    bytes32 hash = _hashData(selector, owner, actor, tokenAddress, tokenId, extra, extra2, extra3, timeValidation);\n    _preApprovals[hash] = _msgSender();\n    emit PreApproved(hash, _msgSender());\n  }\n\n  /**\n   * @notice Checks if someone can pre approve an operation.\n   * Must be implemented by the contract using this base contract\n   * @param selector The selector of the function being called.\n   * @param actor The actor being authorized.\n   * @param signer The signer of the operation (the protector)\n   */\n  function _canPreApprove(bytes4 selector, address actor, address signer) internal view virtual returns (bool);\n\n  /**\n   * @notice Checks if the NFT is protected.\n   * Must be implemented by the contract using this base contract\n   */\n  function _isProtected() internal view virtual returns (bool);\n\n  /**\n   * @notice Checks if an address is a protector.\n   * Must be implemented by the contract using this base contract\n   */\n  function _isProtector(address protector) internal view virtual returns (bool);\n\n  /**\n   * @notice Validates and checks the signature.\n   * @param selector The selector of the function being called.\n   * @param owner The owner of the token.\n   * @param actor The actor being authorized.\n   * @param tokenAddress The address of the token.\n   * @param tokenId The id of the token.\n   * @param extra The extra\n   * @param extra2 The extra2\n   * @param extra3 The extra3\n   * @param timeValidation A combination of timestamp and validity of the signature.\n   * @param signature The signature.\n   */\n  function _validateAndCheckSignature(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    // we encode here the isProtector to avoid too many variables, when setting the first protector\n    uint256 timeValidation,\n    bytes calldata signature\n  ) internal virtual {\n    if (timeValidation < _TIMESTAMP_MULTIPLIER) {\n      if (_isProtected()) revert NotPermittedWhenProtectorsAreActive();\n    } else {\n      bytes32 signatureHash = _hashBytes(signature);\n      if (_usedSignatures[signatureHash] == 1) revert SignatureAlreadyUsed();\n      _usedSignatures[signatureHash] = 1;\n      (address signer, bytes32 hash) = recoverSigner(\n        selector,\n        owner,\n        actor,\n        tokenAddress,\n        tokenId,\n        extra,\n        extra2,\n        extra3,\n        timeValidation,\n        signature\n      );\n      if (selector == ICrunaManager.setProtector.selector && !_isProtected()) {\n        if (signer != actor) revert WrongDataOrNotSignedByProtector();\n      } else if (!_isProtector(signer)) revert WrongDataOrNotSignedByProtector();\n      delete _preApprovals[hash];\n    }\n  }\n\n  /**\n   * @notice Hashes the data.\n   * @param selector The selector of the function being called.\n   * @param owner The owner of the token.\n   * @param actor The actor being authorized.\n   * @param tokenAddress The address of the token.\n   * @param tokenId The id of the token.\n   * @param extra The extra\n   * @param extra2 The extra2\n   * @param extra3 The extra3\n   * @param timeValidation A combination of timestamp and validity of the signature.\n   */\n  function _hashData(\n    bytes4 selector,\n    address owner,\n    address actor,\n    address tokenAddress,\n    uint256 tokenId,\n    uint256 extra,\n    uint256 extra2,\n    uint256 extra3,\n    uint256 timeValidation\n  ) internal pure returns (bytes32) {\n    return _hashBytes(abi.encode(_AUTH, selector, owner, actor, tokenAddress, tokenId, extra, extra2, extra3, timeValidation));\n  }\n\n  /**\n   * @notice Util to hash the bytes of the signature saving gas in comparison with using keccak256.\n   * @param signature The signature.\n   */\n  function _hashBytes(bytes memory signature) internal pure returns (bytes32 hash) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the data pointer of the `signature` bytes array\n      let data := add(signature, 32) // Skip the length field\n      // Load the length of the `signature` bytes array\n      let length := mload(signature)\n      // Perform the `keccak256` hash operation\n      hash := keccak256(data, length)\n    }\n  }\n\n  // @dev This empty reserved space is put in place to allow future versions to add new\n  // variables without shifting down storage in the inheritance chain.\n  // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\n  uint256[50] private __gap;\n}\n"
    },
    "erc6551/ERC6551Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC6551Registry {\n    /**\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\n     */\n    event ERC6551AccountCreated(\n        address account,\n        address indexed implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\n     */\n    error AccountCreationFailed();\n\n    /**\n     * @dev Creates a token bound account for a non-fungible token.\n     *\n     * If account has already been created, returns the account address without calling create2.\n     *\n     * Emits ERC6551AccountCreated event.\n     *\n     * @return account The address of the token bound account\n     */\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n\n    /**\n     * @dev Returns the computed token bound account address for a non-fungible token.\n     *\n     * @return account The address of the token bound account\n     */\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address account);\n}\n\ncontract ERC6551Registry is IERC6551Registry {\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address) {\n        assembly {\n            // Memory Layout:\n            // ----\n            // 0x00   0xff                           (1 byte)\n            // 0x01   registry (address)             (20 bytes)\n            // 0x15   salt (bytes32)                 (32 bytes)\n            // 0x35   Bytecode Hash (bytes32)        (32 bytes)\n            // ----\n            // 0x55   ERC-1167 Constructor + Header  (20 bytes)\n            // 0x69   implementation (address)       (20 bytes)\n            // 0x5D   ERC-1167 Footer                (15 bytes)\n            // 0x8C   salt (uint256)                 (32 bytes)\n            // 0xAC   chainId (uint256)              (32 bytes)\n            // 0xCC   tokenContract (address)        (32 bytes)\n            // 0xEC   tokenId (uint256)              (32 bytes)\n\n            // Silence unused variable warnings\n            pop(chainId)\n\n            // Copy bytecode + constant data to memory\n            calldatacopy(0x8c, 0x24, 0x80) // salt, chainId, tokenContract, tokenId\n            mstore(0x6c, 0x5af43d82803e903d91602b57fd5bf3) // ERC-1167 footer\n            mstore(0x5d, implementation) // implementation\n            mstore(0x49, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73) // ERC-1167 constructor + header\n\n            // Copy create2 computation data to memory\n            mstore8(0x00, 0xff) // 0xFF\n            mstore(0x35, keccak256(0x55, 0xb7)) // keccak256(bytecode)\n            mstore(0x01, shl(96, address())) // registry address\n            mstore(0x15, salt) // salt\n\n            // Compute account address\n            let computed := keccak256(0x00, 0x55)\n\n            // If the account has not yet been deployed\n            if iszero(extcodesize(computed)) {\n                // Deploy account contract\n                let deployed := create2(0, 0x55, 0xb7, salt)\n\n                // Revert if the deployment fails\n                if iszero(deployed) {\n                    mstore(0x00, 0x20188a59) // `AccountCreationFailed()`\n                    revert(0x1c, 0x04)\n                }\n\n                // Store account address in memory before salt and chainId\n                mstore(0x6c, deployed)\n\n                // Emit the ERC6551AccountCreated event\n                log4(\n                    0x6c,\n                    0x60,\n                    // `ERC6551AccountCreated(address,address,bytes32,uint256,address,uint256)`\n                    0x79f19b3655ee38b1ce526556b7731a20c8f218fbda4a3990b6cc4172fdf88722,\n                    implementation,\n                    tokenContract,\n                    tokenId\n                )\n\n                // Return the account address\n                return(0x6c, 0x20)\n            }\n\n            // Otherwise, return the computed account address\n            mstore(0x00, shr(96, shl(96, computed)))\n            return(0x00, 0x20)\n        }\n    }\n\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address) {\n        assembly {\n            // Silence unused variable warnings\n            pop(chainId)\n            pop(tokenContract)\n            pop(tokenId)\n\n            // Copy bytecode + constant data to memory\n            calldatacopy(0x8c, 0x24, 0x80) // salt, chainId, tokenContract, tokenId\n            mstore(0x6c, 0x5af43d82803e903d91602b57fd5bf3) // ERC-1167 footer\n            mstore(0x5d, implementation) // implementation\n            mstore(0x49, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73) // ERC-1167 constructor + header\n\n            // Copy create2 computation data to memory\n            mstore8(0x00, 0xff) // 0xFF\n            mstore(0x35, keccak256(0x55, 0xb7)) // keccak256(bytecode)\n            mstore(0x01, shl(96, address())) // registry address\n            mstore(0x15, salt) // salt\n\n            // Store computed account address in memory\n            mstore(0x00, shr(96, shl(96, keccak256(0x00, 0x55))))\n\n            // Return computed account address\n            return(0x00, 0x20)\n        }\n    }\n}\n"
    },
    "erc6551/interfaces/IERC6551Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC6551Registry {\n    /**\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\n     */\n    event ERC6551AccountCreated(\n        address account,\n        address indexed implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\n     */\n    error AccountCreationFailed();\n\n    /**\n     * @dev Creates a token bound account for a non-fungible token.\n     *\n     * If account has already been created, returns the account address without calling create2.\n     *\n     * Emits ERC6551AccountCreated event.\n     *\n     * @return account The address of the token bound account\n     */\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n\n    /**\n     * @dev Returns the computed token bound account address for a non-fungible token.\n     *\n     * @return account The address of the token bound account\n     */\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address account);\n}\n"
    },
    "erc6551/lib/ERC6551AccountLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"./ERC6551BytecodeLib.sol\";\n\nlibrary ERC6551AccountLib {\n    function computeAddress(\n        address registry,\n        address _implementation,\n        bytes32 _salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) internal pure returns (address) {\n        bytes32 bytecodeHash = keccak256(\n            ERC6551BytecodeLib.getCreationCode(\n                _implementation, _salt, chainId, tokenContract, tokenId\n            )\n        );\n\n        return Create2.computeAddress(_salt, bytecodeHash, registry);\n    }\n\n    function isERC6551Account(address account, address expectedImplementation, address registry)\n        internal\n        view\n        returns (bool)\n    {\n        // invalid bytecode size\n        if (account.code.length != 0xAD) return false;\n\n        address _implementation = implementation(account);\n\n        // implementation does not exist\n        if (_implementation.code.length == 0) return false;\n\n        // invalid implementation\n        if (_implementation != expectedImplementation) return false;\n\n        (bytes32 _salt, uint256 chainId, address tokenContract, uint256 tokenId) = context(account);\n\n        return account\n            == computeAddress(registry, _implementation, _salt, chainId, tokenContract, tokenId);\n    }\n\n    function implementation(address account) internal view returns (address _implementation) {\n        assembly {\n            // copy proxy implementation (0x14 bytes)\n            extcodecopy(account, 0xC, 0xA, 0x14)\n            _implementation := mload(0x00)\n        }\n    }\n\n    function implementation() internal view returns (address _implementation) {\n        return implementation(address(this));\n    }\n\n    function token(address account) internal view returns (uint256, address, uint256) {\n        bytes memory encodedData = new bytes(0x60);\n\n        assembly {\n            // copy 0x60 bytes from end of context\n            extcodecopy(account, add(encodedData, 0x20), 0x4d, 0x60)\n        }\n\n        return abi.decode(encodedData, (uint256, address, uint256));\n    }\n\n    function token() internal view returns (uint256, address, uint256) {\n        return token(address(this));\n    }\n\n    function salt(address account) internal view returns (bytes32) {\n        bytes memory encodedData = new bytes(0x20);\n\n        assembly {\n            // copy 0x20 bytes from beginning of context\n            extcodecopy(account, add(encodedData, 0x20), 0x2d, 0x20)\n        }\n\n        return abi.decode(encodedData, (bytes32));\n    }\n\n    function salt() internal view returns (bytes32) {\n        return salt(address(this));\n    }\n\n    function context(address account) internal view returns (bytes32, uint256, address, uint256) {\n        bytes memory encodedData = new bytes(0x80);\n\n        assembly {\n            // copy full context (0x80 bytes)\n            extcodecopy(account, add(encodedData, 0x20), 0x2D, 0x80)\n        }\n\n        return abi.decode(encodedData, (bytes32, uint256, address, uint256));\n    }\n\n    function context() internal view returns (bytes32, uint256, address, uint256) {\n        return context(address(this));\n    }\n}\n"
    },
    "erc6551/lib/ERC6551BytecodeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary ERC6551BytecodeLib {\n    /**\n     * @dev Returns the creation code of the token bound account for a non-fungible token.\n     *\n     * @return result The creation code of the token bound account\n     */\n    function getCreationCode(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) internal pure returns (bytes memory result) {\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer\n            // Layout the variables and bytecode backwards\n            mstore(add(result, 0xb7), tokenId)\n            mstore(add(result, 0x97), shr(96, shl(96, tokenContract)))\n            mstore(add(result, 0x77), chainId)\n            mstore(add(result, 0x57), salt)\n            mstore(add(result, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x28), implementation)\n            mstore(add(result, 0x14), 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(result, 0xb7) // Store the length\n            mstore(0x40, add(result, 0xd7)) // Allocate the memory\n        }\n    }\n\n    /**\n     * @dev Returns the create2 address computed from `salt`, `bytecodeHash`, `deployer`.\n     *\n     * @return result The create2 address computed from `salt`, `bytecodeHash`, `deployer`\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer)\n        internal\n        pure\n        returns (address result)\n    {\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer\n            mstore8(result, 0xff)\n            mstore(add(result, 0x35), bytecodeHash)\n            mstore(add(result, 0x01), shl(96, deployer))\n            mstore(add(result, 0x15), salt)\n            result := keccak256(result, 0x55)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}