{{
  "language": "Solidity",
  "sources": {
    "lib/openmesh-admin/lib/ens-reverse-claimable/src/ENSReverseClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSReverseClaimable {\n    /// @notice ENS reverse name resolution is claimable by the owner of the contract.\n    function owner() external pure virtual returns (address) {\n        return 0x2309762aAcA0a8F689463a42c0A6A84BE3A7ea51; // plopmenz.eth\n    }\n}\n"
    },
    "lib/openmesh-admin/src/Openmesh.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Openmesh {\n    address constant OPENMESH_ADMIN = 0x24496D746Fd003397790E41d0d1Ce61F4F7fd61f;\n}\n"
    },
    "lib/openmesh-admin/src/OpenmeshENSReverseClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ENSReverseClaimable} from \"../lib/ens-reverse-claimable/src/ENSReverseClaimable.sol\";\nimport {Openmesh} from \"./Openmesh.sol\";\n\ncontract OpenmeshENSReverseClaimable is Openmesh, ENSReverseClaimable {\n    /// @inheritdoc ENSReverseClaimable\n    function owner() external pure override returns (address) {\n        return OPENMESH_ADMIN;\n    }\n}\n"
    },
    "lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "lib/openrd-foundry/lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "lib/openrd-foundry/src/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Escrow {\r\n    using SafeERC20 for IERC20;\r\n\r\n    error AlreadyInitialized();\r\n    error NotOwner();\r\n    error NativeTransferFailed();\r\n\r\n    address internal owner;\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    /// @notice Initializes the Escrow with the sender of the transaction as owner.\r\n    /// @dev This should be called in the same transaction as deploying the escrow, to prevent front running.\r\n    function __Escrow_init() public payable {\r\n        if (owner != address(0)) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of ERC20 token to a given address. Can only be called by the owner.\r\n    /// @param token The ERC20 contract address.\r\n    /// @param to The address to receive the tokens.\r\n    /// @param amount The amount of ERC20 token to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transfer(IERC20 token, address to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            token.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of native currency to a given address. Can only be called by the owner.\r\n    /// @param to The address to receive the currency.\r\n    /// @param amount The amount of native currency to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transferNative(address payable to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            // Use call instead of transfer for correct gas estimation to smart contracts\r\n            (bool success,) = to.call{value: amount}(\"\");\r\n            if (!success) {\r\n                revert NativeTransferFailed();\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "lib/openrd-foundry/src/ITasks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Escrow, IERC20} from \"./Escrow.sol\";\r\n\r\ninterface ITasks {\r\n    error TaskDoesNotExist();\r\n    error TaskNotOpen();\r\n    error TaskNotTaken();\r\n    error TaskNotClosed();\r\n    error TaskClosed();\r\n\r\n    error NotManager();\r\n    error NotExecutor();\r\n    error NotDisputeManager();\r\n\r\n    error RewardAboveBudget();\r\n    error RewardDoesntEndWithNextToken();\r\n    error NotEnoughNativeCurrencyAttached();\r\n    error ApplicationDoesNotExist();\r\n    error NotYourApplication();\r\n    error ApplicationNotAccepted();\r\n    error SubmissionDoesNotExist();\r\n    error SubmissionAlreadyJudged();\r\n    error JudgementNone();\r\n\r\n    error RequestDoesNotExist();\r\n    error RequestAlreadyAccepted();\r\n    error RequestNotAccepted();\r\n    error RequestAlreadyExecuted();\r\n\r\n    error Overflow();\r\n    error ManualBudgetIncreaseNeeded();\r\n    error PartialRewardAboveFullReward();\r\n    error NativeTransferFailed();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    // The budget here represents the call of the funder to the escrow, the actual value in the escrow (actual budget) might differ in case of transfer fees / rewards.\r\n    event TaskCreated(\r\n        uint256 indexed taskId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        address manager,\r\n        address disputeManager,\r\n        address creator,\r\n        uint96 nativeBudget,\r\n        ERC20Transfer[] budget,\r\n        Escrow escrow\r\n    );\r\n    event ApplicationCreated(\r\n        uint256 indexed taskId,\r\n        uint32 indexed applicationId,\r\n        string metadata,\r\n        address applicant,\r\n        NativeReward[] nativeReward,\r\n        Reward[] reward\r\n    );\r\n    event ApplicationAccepted(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event TaskTaken(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event SubmissionCreated(uint256 indexed taskId, uint8 indexed submissionId, string metadata);\r\n    event SubmissionReviewed(\r\n        uint256 indexed taskId, uint8 indexed submissionId, SubmissionJudgement judgement, string feedback\r\n    );\r\n    event TaskCompleted(uint256 indexed taskId, TaskCompletionSource source);\r\n\r\n    event CancelTaskRequested(uint256 indexed taskId, uint8 indexed requestId, string metadata);\r\n    event TaskCancelled(uint256 indexed taskId, string metadata);\r\n    event RequestAccepted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId);\r\n    event RequestExecuted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId, address by);\r\n\r\n    event DeadlineChanged(uint256 indexed taskId, uint64 newDeadline);\r\n    event BudgetChanged(uint256 indexed taskId); // Quite expensive to transfer budget into a datastructure to emit\r\n    event RewardIncreased(\r\n        uint256 indexed taskId, uint32 indexed applicationId, uint96[] nativeIncrease, uint88[] increase\r\n    );\r\n    event MetadataChanged(uint256 indexed taskId, string newMetadata);\r\n    event ManagerChanged(uint256 indexed taskId, address newManager);\r\n    event PartialPayment(uint256 indexed taskId, uint96[] partialNativeReward, uint88[] partialReward);\r\n\r\n    /// @notice A container for ERC20 transfer information.\r\n    /// @param tokenContract ERC20 token to transfer.\r\n    /// @param amount How much of this token should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct ERC20Transfer {\r\n        IERC20 tokenContract;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a native reward payout.\r\n    /// @param to Whom the native reward should be transfered to.\r\n    /// @param amount How much native reward should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct NativeReward {\r\n        address to;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a reward payout.\r\n    /// @param nextToken If this reward is payed out in the next ERC20 token.\r\n    /// @dev IERC20 (address) is a lot of storage, rather just keep those only in budget.\r\n    /// @notice nextToken should always be true for the last entry\r\n    /// @param to Whom this token should be transfered to.\r\n    /// @param amount How much of this token should be transfered. uint88 to keep struct packed into a single uint256.\r\n    struct Reward {\r\n        bool nextToken;\r\n        address to;\r\n        uint88 amount;\r\n    }\r\n\r\n    /// @notice A container for a task application.\r\n    /// @param metadata Metadata of the application. (IPFS hash)\r\n    /// @param applicant Who has submitted this application.\r\n    /// @param accepted If the application has been accepted by the manager.\r\n    /// @param nativeReward How much native currency the applicant wants for completion.\r\n    /// @param reward How much rewards the applicant wants for completion.\r\n    struct Application {\r\n        string metadata;\r\n        // Storage block separator\r\n        address applicant;\r\n        bool accepted;\r\n        uint8 nativeRewardCount;\r\n        uint8 rewardCount;\r\n        // Storage block separator\r\n        mapping(uint8 => NativeReward) nativeReward;\r\n        mapping(uint8 => Reward) reward;\r\n    }\r\n\r\n    struct OffChainApplication {\r\n        string metadata;\r\n        address applicant;\r\n        bool accepted;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    /// @notice For approving people on task creation (they are not required to make an application).\r\n    struct PreapprovedApplication {\r\n        address applicant;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    enum SubmissionJudgement {\r\n        None,\r\n        Accepted,\r\n        Rejected\r\n    }\r\n\r\n    /// @notice A container for a task submission.\r\n    /// @param metadata Metadata of the submission. (IPFS hash)\r\n    /// @param judgement Judgement cast on the submission.\r\n    /// @param feedback A response from the manager. (IPFS hash)\r\n    struct Submission {\r\n        string metadata;\r\n        string feedback;\r\n        SubmissionJudgement judgement;\r\n    }\r\n\r\n    // This is for future expansion of the request system\r\n    enum RequestType {\r\n        CancelTask\r\n    }\r\n\r\n    /// @notice A container for shared request information.\r\n    /// @param accepted If the request was accepted.\r\n    /// @param executed If the request was executed.\r\n    struct Request {\r\n        bool accepted;\r\n        bool executed;\r\n    }\r\n\r\n    /// @notice A container for a request to cancel the task.\r\n    /// @param request Request information.\r\n    /// @param metadata Metadata of the request. (IPFS hash, Why the task should be cancelled)\r\n    struct CancelTaskRequest {\r\n        Request request;\r\n        string metadata;\r\n    }\r\n\r\n    enum TaskState {\r\n        Open,\r\n        Taken,\r\n        Closed\r\n    }\r\n\r\n    /// @notice A container for task-related information.\r\n    /// @param metadata Metadata of the task. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the task expires if not completed.\r\n    /// @param escrow The address of the escrow which holds the budget funds.\r\n    /// @param budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param nativeBudget Maximum native currency reward that can be earned by completing the task.\r\n    /// @param creator Who has created the task.\r\n    /// @param disputeManager Who has the permission to complete the task without the managers approval.\r\n    /// @param manager Who has the permission to manage the task.\r\n    /// @param state Current state the task is in.\r\n    /// @param applications Applications to take the job.\r\n    /// @param executorApplication Index of the application that will execute the task.\r\n    /// @param submissions Submission made to finish the task.\r\n    struct Task {\r\n        string metadata;\r\n        // Storage block separator\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        // Storage block separator\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        // Storage block separator\r\n        address disputeManager;\r\n        // Storage block separator\r\n        address manager;\r\n        TaskState state;\r\n        uint32 executorApplication;\r\n        uint8 budgetCount;\r\n        uint32 applicationCount;\r\n        uint8 submissionCount;\r\n        uint8 cancelTaskRequestCount;\r\n        // Storage block separator\r\n        mapping(uint8 => ERC20Transfer) budget;\r\n        mapping(uint32 => Application) applications;\r\n        mapping(uint8 => Submission) submissions;\r\n        mapping(uint8 => CancelTaskRequest) cancelTaskRequests;\r\n    }\r\n\r\n    struct OffChainTask {\r\n        string metadata;\r\n        uint64 deadline;\r\n        uint32 executorApplication;\r\n        address manager;\r\n        address disputeManager;\r\n        address creator;\r\n        TaskState state;\r\n        Escrow escrow;\r\n        uint96 nativeBudget;\r\n        ERC20Transfer[] budget;\r\n        OffChainApplication[] applications;\r\n        Submission[] submissions;\r\n        CancelTaskRequest[] cancelTaskRequests;\r\n    }\r\n\r\n    enum TaskCompletionSource {\r\n        SubmissionAccepted,\r\n        Dispute\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created tasks.\r\n    function taskCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all task information by id.\r\n    /// @param _taskId Id of the task.\r\n    function getTask(uint256 _taskId) external view returns (OffChainTask memory);\r\n\r\n    /// @notice Retrieves multiple tasks in a single call.\r\n    /// @param _taskIds Ids of the tasks.\r\n    function getTasks(uint256[] calldata _taskIds) external view returns (OffChainTask[] memory);\r\n\r\n    /// @notice Create a new task.\r\n    /// @param _metadata Metadata of the task. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the task expires if not completed.\r\n    /// @param _manager Who will manage the task (become the manager).\r\n    /// @param _disputeManager Who will manage the disputes (handle situations where the manager and executor are in disagreement).\r\n    /// @param _budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param _preapprove List of addresses (with reward) that are able to take the task without creating an application themselves.\r\n    /// @return taskId Id of the newly created task.\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        address _manager,\r\n        address _disputeManager,\r\n        ERC20Transfer[] calldata _budget,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId);\r\n\r\n    /// @notice Apply to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of your application.\r\n    /// @param _nativeReward Wanted native currency for completing the task.\r\n    /// @param _reward Wanted rewards for completing the task.\r\n    /// @return applicationId Id of the newly created application.\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        NativeReward[] calldata _nativeReward,\r\n        Reward[] calldata _reward\r\n    ) external returns (uint32 applicationId);\r\n\r\n    /// @notice Accept application to allow them to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationIds Indexes of the applications to accept.\r\n    /// @dev Will revert if applicant reward is higher than the budget. increaseBudget should be called beforehand.\r\n    function acceptApplications(uint256 _taskId, uint32[] calldata _applicationIds) external;\r\n\r\n    /// @notice Take the task after your application has been accepted.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Index of application you made that has been accepted.\r\n    function takeTask(uint256 _taskId, uint32 _applicationId) external;\r\n\r\n    /// @notice Create a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of the submission. (IPFS hash)\r\n    /// @return submissionId Id of the newly created submission.\r\n    function createSubmission(uint256 _taskId, string calldata _metadata) external returns (uint8 submissionId);\r\n\r\n    /// @notice Review a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _submissionId Index of the submission that is reviewed.\r\n    /// @param _judgement Outcome of the review.\r\n    /// @param _feedback Reasoning of the reviewer. (IPFS hash)\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external;\r\n\r\n    /// @notice Cancels a task. This can be used to close a task and receive back the budget.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Why the task was cancelled. (IPFS hash)\r\n    /// @return cancelTaskRequestId Id of the newly created request for task cancellation.\r\n    function cancelTask(uint256 _taskId, string calldata _metadata) external returns (uint8 cancelTaskRequestId);\r\n\r\n    /// @notice Accepts a request, executing the proposed action.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    /// @param _execute If the request should also be executed in this transaction.\r\n    function acceptRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId, bool _execute) external;\r\n\r\n    /// @notice Executes an accepted request, allows anyone to pay for the gas costs of the execution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    function executeRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId) external;\r\n\r\n    /// @notice Extend the deadline of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _extension How much to extend the deadline by.\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external;\r\n\r\n    /// @notice Increase the budget of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    /// @dev Any attached native reward will also be used to increase the budget.\r\n    function increaseBudget(uint256 _taskId, uint96[] calldata _increase) external payable;\r\n\r\n    /// @notice Increase the reward of an application of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Id of the application.\r\n    /// @param _nativeIncrease How much to increase each native amount by.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    function increaseReward(\r\n        uint256 _taskId,\r\n        uint32 _applicationId,\r\n        uint96[] calldata _nativeIncrease,\r\n        uint88[] calldata _increase\r\n    ) external;\r\n\r\n    /// @notice Edit the metadata of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newMetadata New metadata of the task.\r\n    /// @dev This metadata update might change the task completely. Show a warning to people who applied before the change.\r\n    function editMetadata(uint256 _taskId, string calldata _newMetadata) external;\r\n\r\n    /// @notice Transfers the manager role to a different address.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newManager What address should become the manager.\r\n    function transferManagement(uint256 _taskId, address _newManager) external;\r\n\r\n    /// @notice Completes the task through dispute resolution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint96[] calldata _partialNativeReward,\r\n        uint88[] calldata _partialReward\r\n    ) external;\r\n\r\n    /// @notice Releases a part of the reward to the executor without marking the task as complete.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    /// @dev Will fetch balanceOf to set the budget afterwards, can be used in case funds where sent manually to the escrow to sync the budget.\r\n    function partialPayment(uint256 _taskId, uint96[] calldata _partialNativeReward, uint88[] calldata _partialReward)\r\n        external;\r\n}\r\n"
    },
    "src/IRFPs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {RFPEscrow, IERC20, SafeERC20} from \"./RFPEscrow.sol\";\r\nimport {ITasks} from \"../lib/openrd-foundry/src/ITasks.sol\";\r\n\r\ninterface IRFPs {\r\n    error RFPDoesNotExist();\r\n    error RFPClosed();\r\n    error NotManager();\r\n    error ProjectDoesNotExist();\r\n    error ProjectAlreadyAccepted();\r\n    error RewardDoesntEndWithNextToken();\r\n\r\n    error Overflow();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    event RFPCreated(\r\n        uint256 indexed rfpId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        uint256 nativeBudget,\r\n        ITasks.ERC20Transfer[] budget,\r\n        address creator,\r\n        address tasksManager,\r\n        address disputeManager,\r\n        address manager,\r\n        RFPEscrow escrow\r\n    );\r\n    event ProjectSubmitted(\r\n        uint256 indexed rfpId,\r\n        uint32 projectId,\r\n        string metadata,\r\n        address representative,\r\n        uint64 deadline,\r\n        ITasks.NativeReward[] nativeReward,\r\n        ITasks.Reward[] reward\r\n    );\r\n    event ProjectAccepted(\r\n        uint256 indexed rfpId, uint32 projectId, uint96[] nativeReward, uint88[] reward, uint256 taskId\r\n    );\r\n    event RFPEmptied(uint256 indexed rfpId);\r\n\r\n    /// @notice A container for a RFP project.\r\n    /// @param metadata Metadata of the project. (IPFS hash)\r\n    /// @param representative Who has submitted this project.\r\n    /// @param deadline The deadline after which the project should be completed.\r\n    /// @param accepted If the project has been accepted. To prevent 2 OpenR&D tasks from being created.\r\n    /// @param nativeReward How much native currency the representative wants for completion.\r\n    /// @param reward How much rewards the representative wants for completion.\r\n    struct Project {\r\n        string metadata;\r\n        address representative;\r\n        uint64 deadline;\r\n        bool accepted;\r\n        uint8 nativeRewardCount;\r\n        uint8 rewardCount;\r\n        mapping(uint8 => ITasks.NativeReward) nativeReward;\r\n        mapping(uint8 => ITasks.Reward) reward;\r\n    }\r\n\r\n    struct OffchainProject {\r\n        string metadata;\r\n        address representative;\r\n        uint64 deadline;\r\n        bool accepted;\r\n        ITasks.NativeReward[] nativeReward;\r\n        ITasks.Reward[] reward;\r\n    }\r\n\r\n    /// @notice A container for RFP-related information.\r\n    /// @param metadata Metadata of the RFP. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the RFP closes.\r\n    /// @param budget The ERC20 contracts that compose the budget.\r\n    /// @param creator Who has created the RFP.\r\n    /// @param tasksManager Who has the permission to manage the OpenR&D tasks.\r\n    /// @param disputeManager Who has the permission to manage disputes on the OpenR&D tasks.\r\n    /// @param manager Who has the permission to manage the RFP.\r\n    /// @param projects Projects that want to be funded by the RFP.\r\n    struct RFP {\r\n        string metadata;\r\n        // Storage block separator\r\n        uint64 deadline;\r\n        RFPEscrow escrow;\r\n        // Storage block separator\r\n        address creator;\r\n        // Storage block separator\r\n        address tasksManager;\r\n        // Storage block separator\r\n        address disputeManager;\r\n        // Storage block separator\r\n        address manager;\r\n        uint8 budgetCount;\r\n        uint32 projectCount;\r\n        // Storage block separator\r\n        mapping(uint8 => IERC20) budget;\r\n        mapping(uint32 => Project) projects;\r\n    }\r\n\r\n    struct OffChainRFP {\r\n        string metadata;\r\n        uint64 deadline;\r\n        RFPEscrow escrow;\r\n        address creator;\r\n        address tasksManager;\r\n        address disputeManager;\r\n        address manager;\r\n        IERC20[] budget;\r\n        OffchainProject[] projects;\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created RFPs.\r\n    function rfpCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all RFP information by id.\r\n    /// @param _rfpId Id of the RFP.\r\n    function getRFP(uint256 _rfpId) external view returns (OffChainRFP memory);\r\n\r\n    /// @notice Retrieves multiple RFPs.\r\n    /// @param _rfpIds Ids of the RFPs.\r\n    function getRFPs(uint256[] calldata _rfpIds) external view returns (OffChainRFP[] memory);\r\n\r\n    /// @notice Create a new RFP.\r\n    /// @param _metadata Metadata of the RFP. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the RFP closes.\r\n    /// @param _budget Maximum ERC20 rewards available for projects of the RFP.\r\n    /// @param _tasksManager Who will manage the project Tasks (become the OpenR&D manager).\r\n    /// @param _manager Who will manage the RFP (become the manager).\r\n    /// @return rfpId Id of the newly created RFP.\r\n    function createRFP(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.ERC20Transfer[] calldata _budget,\r\n        address _tasksManager,\r\n        address _disputeManager,\r\n        address _manager\r\n    ) external payable returns (uint256 rfpId);\r\n\r\n    /// @notice Propose a project to be funded by an RFP.\r\n    /// @param _rfpId Id of the RFP.\r\n    /// @param _metadata Metadata of your project.\r\n    /// @param _deadline Before when the proposed project will be completed.\r\n    /// @param _nativeReward Wanted native currency from the RFP for the project.\r\n    /// @param _reward Wanted rewards from the RFP for the project.\r\n    function submitProject(\r\n        uint256 _rfpId,\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.NativeReward[] calldata _nativeReward,\r\n        ITasks.Reward[] calldata _reward\r\n    ) external returns (uint32 projectId);\r\n\r\n    /// @notice Accept project to be funded by the RFP.\r\n    /// @param _rfpId Id of the RFP.\r\n    /// @param _projectId Id of the project to accept.\r\n    /// @param _nativeReward Native reward granted to the project (can be lower or higher than requested).\r\n    /// @param _reward Reward granted to the project (can be lower or higher than requested).\r\n    function acceptProject(\r\n        uint256 _rfpId,\r\n        uint32 _projectId,\r\n        uint96[] calldata _nativeReward,\r\n        uint88[] calldata _reward\r\n    ) external;\r\n\r\n    /// @notice Refunds any leftover budget to the creator.\r\n    /// @param _rfpId Id of the RFP.\r\n    function emptyRFP(uint256 _rfpId) external;\r\n}\r\n"
    },
    "src/RFPEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Escrow, IERC20, SafeERC20} from \"../lib/openrd-foundry/src/Escrow.sol\";\nimport {ITasks} from \"../lib/openrd-foundry/src/ITasks.sol\";\n\ncontract RFPEscrow is Escrow {\n    using SafeERC20 for IERC20;\n\n    /// @notice Initializes the additional RFP logic and performs the base Escrow init.\n    function __RFPEscrow_init(ITasks _spender, ITasks.ERC20Transfer[] calldata _budget) public payable {\n        __Escrow_init();\n\n        for (uint256 i; i < _budget.length;) {\n            // Approve unlimited spending by the Tasks contract to save on gas fees\n            _budget[i].tokenContract.forceApprove(address(_spender), type(uint256).max);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice The Escrow created the task, so that any refunds will flow back to this, instead of the RFPs contract.\n    /// They can be withdrawn if no further tasks are desired to be funded by calling emptyRFP.\n    function createTask(\n        ITasks _tasks,\n        string calldata _metadata,\n        uint64 _deadline,\n        address _manager,\n        address _disputeManager,\n        uint96 _nativeBudget,\n        ITasks.ERC20Transfer[] calldata _budget,\n        ITasks.PreapprovedApplication[] calldata _preapprove\n    ) external returns (uint256) {\n        if (msg.sender != owner) {\n            revert NotOwner();\n        }\n\n        return _tasks.createTask{value: _nativeBudget}(\n            _metadata, _deadline, _manager, _disputeManager, _budget, _preapprove\n        );\n    }\n}\n"
    },
    "src/RFPs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {OpenmeshENSReverseClaimable} from \"../lib/openmesh-admin/src/OpenmeshENSReverseClaimable.sol\";\r\n\r\nimport {IRFPs, IERC20, RFPEscrow, ITasks, SafeERC20} from \"./IRFPs.sol\";\r\n\r\ncontract RFPs is OpenmeshENSReverseClaimable, IRFPs {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice The Tasks deployment where accepted projects will be created.\r\n    ITasks public immutable tasks;\r\n\r\n    /// @notice The incremental ID for RFPs.\r\n    uint256 private rfpCounter;\r\n\r\n    /// @notice A mapping between RFP IDs and RFP information.\r\n    mapping(uint256 => RFP) internal rfps;\r\n\r\n    /// @notice The base escrow contract that will be cloned for every RFP.\r\n    address public immutable escrowImplementation;\r\n\r\n    constructor(ITasks _tasks) {\r\n        tasks = _tasks;\r\n        escrowImplementation = address(new RFPEscrow());\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /// @inheritdoc IRFPs\r\n    function rfpCount() external view returns (uint256) {\r\n        return rfpCounter;\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function getRFP(uint256 _rfpId) public view returns (OffChainRFP memory offchainRFP) {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n        offchainRFP = _toOffchainRFP(rfp);\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function getRFPs(uint256[] memory _rfpIds) public view returns (OffChainRFP[] memory) {\r\n        OffChainRFP[] memory offchainRFPs = new OffChainRFP[](_rfpIds.length);\r\n        for (uint256 i; i < _rfpIds.length;) {\r\n            offchainRFPs[i] = getRFP(_rfpIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return offchainRFPs;\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function createRFP(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.ERC20Transfer[] calldata _budget,\r\n        address _tasksManager,\r\n        address _disputeManager,\r\n        address _manager\r\n    ) external payable returns (uint256 rfpId) {\r\n        rfpId = rfpCounter++;\r\n        RFP storage rfp = rfps[rfpId];\r\n        rfp.metadata = _metadata;\r\n        rfp.deadline = _deadline;\r\n\r\n        RFPEscrow escrow = RFPEscrow(payable(clone(escrowImplementation)));\r\n        escrow.__RFPEscrow_init{value: msg.value}(tasks, _budget);\r\n        rfp.escrow = escrow;\r\n\r\n        rfp.budgetCount = _toUint8(_budget.length);\r\n        for (uint8 i; i < uint8(_budget.length);) {\r\n            _budget[i].tokenContract.safeTransferFrom(msg.sender, address(escrow), _budget[i].amount);\r\n\r\n            // Only token addresses are saved, the escrow can be topped up freely at any time\r\n            rfp.budget[i] = _budget[i].tokenContract;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        rfp.manager = _manager;\r\n        rfp.tasksManager = _tasksManager;\r\n        rfp.disputeManager = _disputeManager;\r\n        rfp.creator = msg.sender;\r\n\r\n        emit RFPCreated(\r\n            rfpId,\r\n            _metadata,\r\n            _deadline,\r\n            msg.value,\r\n            _budget,\r\n            msg.sender,\r\n            _tasksManager,\r\n            _disputeManager,\r\n            _manager,\r\n            escrow\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function submitProject(\r\n        uint256 _rfpId,\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.NativeReward[] calldata _nativeReward,\r\n        ITasks.Reward[] calldata _reward\r\n    ) external returns (uint32 projectId) {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure not past deadline\r\n        if (rfp.deadline <= block.timestamp) {\r\n            revert RFPClosed();\r\n        }\r\n\r\n        // Ensure reward ends with next token\r\n        unchecked {\r\n            if (_reward.length != 0 && !_reward[_reward.length - 1].nextToken) {\r\n                revert RewardDoesntEndWithNextToken();\r\n            }\r\n        }\r\n\r\n        projectId = rfp.projectCount++;\r\n        Project storage project = rfp.projects[projectId];\r\n        project.metadata = _metadata;\r\n        project.deadline = _deadline;\r\n        project.representative = msg.sender;\r\n\r\n        // Gas optimization\r\n        if (_nativeReward.length != 0) {\r\n            project.nativeRewardCount = _toUint8(_nativeReward.length);\r\n            for (uint8 i; i < uint8(_nativeReward.length);) {\r\n                project.nativeReward[i] = _nativeReward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_reward.length != 0) {\r\n            project.rewardCount = _toUint8(_reward.length);\r\n            for (uint8 i; i < uint8(_reward.length);) {\r\n                project.reward[i] = _reward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit ProjectSubmitted(_rfpId, projectId, _metadata, msg.sender, _deadline, _nativeReward, _reward);\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function acceptProject(\r\n        uint256 _rfpId,\r\n        uint32 _projectId,\r\n        uint96[] calldata _nativeReward,\r\n        uint88[] calldata _reward\r\n    ) external {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure sender is manager\r\n        if (msg.sender != rfp.manager) {\r\n            revert NotManager();\r\n        }\r\n\r\n        // Ensure project exists\r\n        if (_projectId >= rfp.projectCount) {\r\n            revert ProjectDoesNotExist();\r\n        }\r\n\r\n        Project storage project = rfp.projects[_projectId];\r\n\r\n        // Ensure project not accepted\r\n        if (project.accepted) {\r\n            revert ProjectAlreadyAccepted();\r\n        }\r\n\r\n        uint96 taskNativeBudget;\r\n        ITasks.NativeReward[] memory taskNativeReward = new ITasks.NativeReward[](project.nativeRewardCount);\r\n        for (uint8 i; i < taskNativeReward.length;) {\r\n            taskNativeReward[i] = ITasks.NativeReward(project.nativeReward[i].to, _nativeReward[i]);\r\n            taskNativeBudget += _nativeReward[i];\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        ITasks.ERC20Transfer[] memory taskBudget = new ITasks.ERC20Transfer[](rfp.budgetCount);\r\n        ITasks.Reward[] memory taskReward = new ITasks.Reward[](project.rewardCount);\r\n        {\r\n            uint8 j;\r\n            for (uint8 i; i < taskBudget.length;) {\r\n                IERC20 erc20 = rfp.budget[i];\r\n                uint96 projectBudget;\r\n                while (j < taskReward.length) {\r\n                    taskReward[j] = project.reward[j];\r\n                    taskReward[j].amount = _reward[j];\r\n                    projectBudget += _reward[j];\r\n\r\n                    if (taskReward[j].nextToken) {\r\n                        unchecked {\r\n                            ++j;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    unchecked {\r\n                        ++j;\r\n                    }\r\n                }\r\n\r\n                taskBudget[i] = ITasks.ERC20Transfer(erc20, projectBudget);\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        ITasks.PreapprovedApplication[] memory preapproved = new ITasks.PreapprovedApplication[](1);\r\n        preapproved[0] = ITasks.PreapprovedApplication(project.representative, taskNativeReward, taskReward);\r\n\r\n        uint256 taskId = rfp.escrow.createTask(\r\n            tasks,\r\n            project.metadata,\r\n            project.deadline,\r\n            rfp.tasksManager,\r\n            rfp.disputeManager,\r\n            taskNativeBudget,\r\n            taskBudget,\r\n            preapproved\r\n        );\r\n        project.accepted = true;\r\n        emit ProjectAccepted(_rfpId, _projectId, _nativeReward, _reward, taskId);\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function emptyRFP(uint256 _rfpId) external {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure sender is manager\r\n        if (msg.sender != rfp.manager) {\r\n            revert NotManager();\r\n        }\r\n\r\n        rfp.escrow.transferNative(payable(rfp.creator), address(rfp.escrow).balance);\r\n\r\n        uint8 budgetCount = rfp.budgetCount;\r\n        for (uint8 i; i < budgetCount;) {\r\n            IERC20 erc20 = rfp.budget[i];\r\n\r\n            rfp.escrow.transfer(erc20, rfp.creator, erc20.balanceOf(address(rfp.escrow)));\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit RFPEmptied(_rfpId);\r\n    }\r\n\r\n    error NativeTransferFailed();\r\n\r\n    /// @notice To save any native funds stuck in this contract (done by the Openmesh community)\r\n    function rescueNative(address payable to, uint256 amount) external {\r\n        if (msg.sender != OPENMESH_ADMIN) {\r\n            revert NotManager();\r\n        }\r\n\r\n        (bool success,) = to.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert NativeTransferFailed();\r\n        }\r\n    }\r\n\r\n    /// @notice To save any erc20 funds stuck in this contract (done by the Openmesh community)\r\n    function rescue(IERC20 token, address to, uint256 amount) external {\r\n        if (msg.sender != OPENMESH_ADMIN) {\r\n            revert NotManager();\r\n        }\r\n\r\n        token.transfer(to, amount);\r\n    }\r\n\r\n    function _getRFP(uint256 _rfpId) internal view returns (RFP storage rfp) {\r\n        if (_rfpId >= rfpCounter) {\r\n            revert RFPDoesNotExist();\r\n        }\r\n\r\n        rfp = rfps[_rfpId];\r\n    }\r\n\r\n    function _toOffchainRFP(RFP storage rfp) internal view returns (OffChainRFP memory offchainRFP) {\r\n        offchainRFP.metadata = rfp.metadata;\r\n        offchainRFP.deadline = rfp.deadline;\r\n        offchainRFP.creator = rfp.creator;\r\n        offchainRFP.tasksManager = rfp.tasksManager;\r\n        offchainRFP.manager = rfp.manager;\r\n        offchainRFP.escrow = rfp.escrow;\r\n\r\n        offchainRFP.budget = new IERC20[](rfp.budgetCount);\r\n        for (uint8 i; i < offchainRFP.budget.length;) {\r\n            offchainRFP.budget[i] = rfp.budget[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainRFP.projects = new OffchainProject[](rfp.projectCount);\r\n        for (uint8 i; i < offchainRFP.projects.length;) {\r\n            Project storage project = rfp.projects[i];\r\n            offchainRFP.projects[i].metadata = project.metadata;\r\n            offchainRFP.projects[i].deadline = project.deadline;\r\n            offchainRFP.projects[i].representative = project.representative;\r\n            offchainRFP.projects[i].accepted = project.accepted;\r\n\r\n            offchainRFP.projects[i].nativeReward = new ITasks.NativeReward[](project.nativeRewardCount);\r\n            for (uint8 j; j < offchainRFP.projects[i].nativeReward.length;) {\r\n                offchainRFP.projects[i].nativeReward[j] = project.nativeReward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n\r\n            offchainRFP.projects[i].reward = new ITasks.Reward[](project.rewardCount);\r\n            for (uint8 j; j < offchainRFP.projects[i].reward.length;) {\r\n                offchainRFP.projects[i].reward[j] = project.reward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n\r\n    function _toUint8(uint256 value) internal pure returns (uint8) {\r\n        if (value > type(uint8).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint8(value);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openrd-foundry/lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openrd-foundry/lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "ens-reverse-claimable/=lib/openmesh-admin/lib/ens-reverse-claimable/src/",
      "erc4626-tests/=lib/openrd-foundry/lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openmesh-admin/=lib/openmesh-admin/src/",
      "openrd-foundry/=lib/openrd-foundry/src/",
      "openzeppelin-contracts/=lib/openrd-foundry/lib/openzeppelin-contracts/",
      "smart-account/=lib/openmesh-admin/lib/smart-account/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "shanghai",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}