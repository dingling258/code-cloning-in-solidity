{{
  "language": "Solidity",
  "sources": {
    "src/dev/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n\n  constructor(\n    address newOwner\n  )\n    ConfirmedOwnerWithProposal(\n      newOwner,\n      address(0)\n    )\n  {\n  }\n\n}"
    },
    "src/dev/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor(\n    address newOwner,\n    address pendingOwner\n  ) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(\n    address to\n  )\n    public\n    override\n    onlyOwner()\n  {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n    override\n  {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner()\n    public\n    view\n    override\n    returns (\n      address\n    )\n  {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(\n    address to\n  )\n    private\n  {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership()\n    internal\n    view\n  {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n\n}"
    },
    "src/dev/OCR2Abstract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/TypeAndVersionInterface.sol\";\n\n\nabstract contract OCR2Abstract is TypeAndVersionInterface {\n  // Maximum number of oracles the offchain reporting protocol is designed for\n  uint256 constant internal maxNumOracles = 31;\n\n  /**\n   * @notice triggers a new run of the offchain reporting protocol\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\n   * @param configDigest configDigest of this configuration\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\n   * @param signers ith element is address ith oracle uses to sign a report\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\n   * @param f maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version of the serialization format used for \"offchainConfig\" parameter\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  event ConfigSet(\n    uint32 previousConfigBlockNumber,\n    bytes32 configDigest,\n    uint64 configCount,\n    address[] signers,\n    address[] transmitters,\n    uint8 f,\n    bytes onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes offchainConfig\n  );\n\n  /**\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\n   * @param signers addresses with which oracles sign the reports\n   * @param transmitters addresses oracles use to transmit the reports\n   * @param f number of faulty oracles the system can tolerate\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version number for offchainEncoding schema\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  function setConfig(\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  )\n    external\n    virtual;\n\n  /**\n   * @notice information about current offchain reporting protocol configuration\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\n   * @return blockNumber block at which this config was set\n   * @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\n   */\n  function latestConfigDetails()\n    external\n    view\n    virtual\n    returns (\n      uint32 configCount,\n      uint32 blockNumber,\n      bytes32 configDigest\n    );\n\n  function _configDigestFromConfigData(\n    uint256 chainId,\n    address contractAddress,\n    uint64 configCount,\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    uint256 h = uint256(keccak256(abi.encode(chainId, contractAddress, configCount,\n      signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig\n    )));\n    uint256 prefixMask = type(uint256).max << (256-16); // 0xFFFF00..00\n    uint256 prefix = 0x0001 << (256-16); // 0x000100..00\n    return bytes32((prefix & prefixMask) | (h & ~prefixMask));\n  }\n\n  /**\n  * @notice optionally emitted to indicate the latest configDigest and epoch for\n     which a report was successfully transmitted. Alternatively, the contract may\n     use latestConfigDigestAndEpoch with scanLogs set to false.\n  */\n  event Transmitted(\n    bytes32 configDigest,\n    uint32 epoch\n  );\n\n  /**\n   * @notice optionally returns the latest configDigest and epoch for which a\n     report was successfully transmitted. Alternatively, the contract may return\n     scanLogs set to true and use Transmitted events to provide this information\n     to offchain watchers.\n   * @return scanLogs indicates whether to rely on the configDigest and epoch\n     returned or whether to scan logs for the Transmitted event instead.\n   * @return configDigest\n   * @return epoch\n   */\n  function latestConfigDigestAndEpoch()\n    external\n    view\n    virtual\n    returns(\n      bool scanLogs,\n      bytes32 configDigest,\n      uint32 epoch\n    );\n\n  /**\n   * @notice transmit is called to post a new report to the contract\n   * @param reportContext serialized report context containing configDigest, epoch, round, extraHash\n   * @param report serialized report, which the signatures are signing\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param rawVs ith element is the the V component of the ith signature\n   */\n  function transmit(\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n    bytes32[3] calldata reportContext,\n    bytes calldata report,\n    bytes32[] calldata rs, bytes32[] calldata ss, bytes32 rawVs // signatures\n  )\n    external\n    virtual;\n}\n"
    },
    "src/dev/OCRConfigurationStoreEVMSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./lib/ConfigDigestUtilEVMSimple.sol\";\nimport \"./OwnerIsCreator.sol\";\nimport \"./OCR2Abstract.sol\";\n\n/// @title OCRConfigurationStoreEVMSimple\n/// @notice This contract stores configurations for protocol versions OCR2 and\n/// above in contract storage. It uses the \"EVMSimple\" config digester.\ncontract OCRConfigurationStoreEVMSimple is TypeAndVersionInterface {\n\n    struct ConfigurationEVMSimple {\n        address[] signers;\n        address[] transmitters;\n        bytes onchainConfig;\n        bytes offchainConfig;\n        address contractAddress;\n        uint64 offchainConfigVersion;\n        uint32 configCount;\n        uint8 f;\n    }\n\n    /// @notice a list of configurations keyed by their digest\n    mapping(bytes32 => ConfigurationEVMSimple) internal s_configurations;\n\n    /// @notice emitted when a new configuration is added\n    event NewConfiguration(bytes32 indexed configDigest);\n\n    /// @notice adds a new configuration to the store\n    function addConfig(ConfigurationEVMSimple calldata configuration) external returns (bytes32) {\n\n        bytes32 configDigest = ConfigDigestUtilEVMSimple.configDigestFromConfigData(\n            block.chainid,\n            configuration.contractAddress,\n            configuration.configCount,\n            configuration.signers,\n            configuration.transmitters,\n            configuration.f,\n            configuration.onchainConfig,\n            configuration.offchainConfigVersion,\n            configuration.offchainConfig\n        );\n\n        s_configurations[configDigest] = configuration;\n\n        emit NewConfiguration(configDigest);\n\n        return configDigest;\n    }\n\n    /// @notice reads a configuration from the store\n    function readConfig(bytes32 configDigest) external view returns (ConfigurationEVMSimple memory) {\n        return s_configurations[configDigest];\n    }\n\n    /// @inheritdoc TypeAndVersionInterface\n    function typeAndVersion() external override pure virtual returns (string memory)\n    {\n        return \"OCRConfigurationStoreEVMSimple 1.0.0\";\n    }\n}\n"
    },
    "src/dev/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwner.sol\";\n\n/**\n * @title The OwnerIsCreator contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract OwnerIsCreator is ConfirmedOwner {\n\n  constructor(\n  )\n    ConfirmedOwner(\n      msg.sender\n    )\n  {\n  }\n\n}"
    },
    "src/dev/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner()\n    external\n    returns (\n      address\n    );\n\n  function transferOwnership(\n    address recipient\n  )\n    external;\n\n  function acceptOwnership()\n    external;\n}\n"
    },
    "src/dev/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface TypeAndVersionInterface{\n  function typeAndVersion()\n    external\n    pure\n    returns (string memory);\n}"
    },
    "src/dev/lib/ConfigDigestUtilEVMSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\n/// @title ConfigDigestUtilEVMSimple\n/// @notice ConfigDigest related utility functions for \"EVMSimple\" config\n/// digester\nlibrary ConfigDigestUtilEVMSimple {\n\n    function configDigestFromConfigData(\n        uint256 chainId,\n        address contractAddress,\n        uint64 configCount,\n        address[] memory signers,\n        address[] memory transmitters,\n        uint8 f,\n        bytes memory onchainConfig,\n        uint64 offchainConfigVersion,\n        bytes memory offchainConfig\n    ) internal pure returns (bytes32)\n    {\n        uint256 hash = uint256(\n            keccak256(\n                abi.encode(\n                    chainId,\n                    contractAddress,\n                    configCount,\n                    signers,\n                    transmitters,\n                    f,\n                    onchainConfig,\n                    offchainConfigVersion,\n                    offchainConfig\n        )));\n\n        uint256 prefixMask = type(uint256).max << (256-16); // 0xFFFF00..00\n        uint256 prefix = 0x0001 << (256-16); // 0x000100..00\n\n        return bytes32((prefix & prefixMask) | (hash & ~prefixMask));\n    }\n\n}"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}