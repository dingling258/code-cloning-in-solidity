{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/EtherFiLiquidUsdDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\nimport {UniswapV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol\";\nimport {BalancerV2DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/BalancerV2DecoderAndSanitizer.sol\";\nimport {MorphoBlueDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/MorphoBlueDecoderAndSanitizer.sol\";\nimport {ERC4626DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/ERC4626DecoderAndSanitizer.sol\";\nimport {CurveDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/CurveDecoderAndSanitizer.sol\";\nimport {AuraDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/AuraDecoderAndSanitizer.sol\";\nimport {ConvexDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/ConvexDecoderAndSanitizer.sol\";\nimport {EtherFiDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/EtherFiDecoderAndSanitizer.sol\";\nimport {NativeWrapperDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/NativeWrapperDecoderAndSanitizer.sol\";\nimport {OneInchDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol\";\nimport {GearboxDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/GearboxDecoderAndSanitizer.sol\";\nimport {PendleRouterDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol\";\nimport {AaveV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/AaveV3DecoderAndSanitizer.sol\";\nimport {LidoDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/LidoDecoderAndSanitizer.sol\";\n\ncontract EtherFiLiquidUsdDecoderAndSanitizer is\n    UniswapV3DecoderAndSanitizer,\n    BalancerV2DecoderAndSanitizer,\n    MorphoBlueDecoderAndSanitizer,\n    ERC4626DecoderAndSanitizer,\n    CurveDecoderAndSanitizer,\n    AuraDecoderAndSanitizer,\n    ConvexDecoderAndSanitizer,\n    EtherFiDecoderAndSanitizer,\n    NativeWrapperDecoderAndSanitizer,\n    OneInchDecoderAndSanitizer,\n    GearboxDecoderAndSanitizer,\n    PendleRouterDecoderAndSanitizer,\n    AaveV3DecoderAndSanitizer,\n    LidoDecoderAndSanitizer\n{\n    constructor(address _boringVault, address _uniswapV3NonFungiblePositionManager)\n        BaseDecoderAndSanitizer(_boringVault)\n        UniswapV3DecoderAndSanitizer(_uniswapV3NonFungiblePositionManager)\n    {}\n\n    //============================== HANDLE FUNCTION COLLISIONS ===============================\n    /**\n     * @notice BalancerV2, ERC4626, and Curve all specify a `deposit(uint256,address)`,\n     *         all cases are handled the same way.\n     */\n    function deposit(uint256, address receiver)\n        external\n        pure\n        override(BalancerV2DecoderAndSanitizer, ERC4626DecoderAndSanitizer, CurveDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    /**\n     * @notice EtherFi, NativeWrapper all specify a `deposit()`,\n     *         all cases are handled the same way.\n     */\n    function deposit()\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, NativeWrapperDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        return addressesFound;\n    }\n\n    /**\n     * @notice BalancerV2, NativeWrapper, Curve, and Gearbox all specify a `withdraw(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function withdraw(uint256)\n        external\n        pure\n        override(\n            BalancerV2DecoderAndSanitizer,\n            CurveDecoderAndSanitizer,\n            NativeWrapperDecoderAndSanitizer,\n            GearboxDecoderAndSanitizer\n        )\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    /**\n     * @notice Aura, and Convex all specify a `getReward(address,bool)`,\n     *         all cases are handled the same way.\n     */\n    function getReward(address _addr, bool)\n        external\n        pure\n        override(AuraDecoderAndSanitizer, ConvexDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_addr);\n    }\n\n    /**\n     * @notice EtherFi, and Lido all specify a `wrap(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function wrap(uint256)\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, LidoDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    /**\n     * @notice EtherFi, and Lido all specify a `unwrap(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function unwrap(uint256)\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, LidoDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault contract address.\n     */\n    address internal immutable boringVault;\n\n    constructor(address _boringVault) {\n        boringVault = _boringVault;\n    }\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {INonFungiblePositionManager} from \"src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol\";\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract UniswapV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error UniswapV3DecoderAndSanitizer__BadPathFormat();\n    error UniswapV3DecoderAndSanitizer__BadTokenId();\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The networks uniswapV3 nonfungible position manager.\n     */\n    INonFungiblePositionManager internal immutable uniswapV3NonFungiblePositionManager;\n\n    constructor(address _uniswapV3NonFungiblePositionManager) {\n        uniswapV3NonFungiblePositionManager = INonFungiblePositionManager(_uniswapV3NonFungiblePositionManager);\n    }\n\n    //============================== UNISWAP V3 ===============================\n\n    function exactInput(DecoderCustomTypes.ExactInputParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        // Determine how many addresses are in params.path.\n        uint256 chunkSize = 23; // 3 bytes for uint24 fee, and 20 bytes for address token\n        uint256 pathLength = params.path.length;\n        if (pathLength % chunkSize != 20) revert UniswapV3DecoderAndSanitizer__BadPathFormat();\n        uint256 pathAddressLength = 1 + (pathLength / chunkSize);\n        uint256 pathIndex;\n        for (uint256 i; i < pathAddressLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, params.path[pathIndex:pathIndex + 20]);\n            pathIndex += chunkSize;\n        }\n        addressesFound = abi.encodePacked(addressesFound, params.recipient);\n    }\n\n    function mint(DecoderCustomTypes.MintParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.token0, params.token1, params.recipient);\n    }\n\n    function increaseLiquidity(DecoderCustomTypes.IncreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n        // Extract addresses from uniswapV3NonFungiblePositionManager.positions(params.tokenId).\n        (, address operator, address token0, address token1,,,,,,,,) =\n            uniswapV3NonFungiblePositionManager.positions(params.tokenId);\n        addressesFound = abi.encodePacked(operator, token0, token1);\n    }\n\n    function decreaseLiquidity(DecoderCustomTypes.DecreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // No addresses in data\n        return addressesFound;\n    }\n\n    function collect(DecoderCustomTypes.CollectParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.recipient);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/BalancerV2DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract BalancerV2DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error BalancerV2DecoderAndSanitizer__SingleSwapUserDataLengthNonZero();\n    error BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n\n    //============================== BALANCER V2 ===============================\n\n    function flashLoan(address recipient, address[] calldata tokens, uint256[] calldata, bytes calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(recipient);\n        for (uint256 i; i < tokens.length; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, tokens[i]);\n        }\n    }\n\n    function swap(\n        DecoderCustomTypes.SingleSwap calldata singleSwap,\n        DecoderCustomTypes.FundManagement calldata funds,\n        uint256,\n        uint256\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (singleSwap.userData.length > 0) revert BalancerV2DecoderAndSanitizer__SingleSwapUserDataLengthNonZero();\n        if (funds.fromInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        if (funds.toInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(\n            _getPoolAddressFromPoolId(singleSwap.poolId),\n            singleSwap.assetIn,\n            singleSwap.assetOut,\n            funds.sender,\n            funds.recipient\n        );\n    }\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        DecoderCustomTypes.JoinPoolRequest calldata req\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (req.fromInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(_getPoolAddressFromPoolId(poolId), sender, recipient);\n        uint256 assetsLength = req.assets.length;\n        for (uint256 i; i < assetsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, req.assets[i]);\n        }\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        DecoderCustomTypes.ExitPoolRequest calldata req\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (req.toInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(_getPoolAddressFromPoolId(poolId), sender, recipient);\n        uint256 assetsLength = req.assets.length;\n        for (uint256 i; i < assetsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, req.assets[i]);\n        }\n    }\n\n    function deposit(uint256, address recipient) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(recipient);\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // No addresses in data\n        return addressesFound;\n    }\n\n    function mint(address gauge) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(gauge);\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n\n    /**\n     * @notice Internal helper function that converts poolIds to pool addresses.\n     */\n    function _getPoolAddressFromPoolId(bytes32 poolId) internal pure returns (address) {\n        return address(uint160(uint256(poolId >> 96)));\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/MorphoBlueDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract MorphoBlueDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n    //============================== MORPHO BLUE ===============================\n\n    function supply(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function withdraw(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n\n    function borrow(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n\n    function repay(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function supplyCollateral(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function withdrawCollateral(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ERC4626DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract ERC4626DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERC4626 ===============================\n\n    function deposit(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function mint(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function withdraw(uint256, address receiver, address owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver, owner);\n    }\n\n    function redeem(uint256, address receiver, address owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver, owner);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/CurveDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract CurveDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CURVE ===============================\n\n    function exchange(int128, int128, uint256, uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function add_liquidity(uint256[] calldata, uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function remove_liquidity(uint256, uint256[] calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function deposit(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claim_rewards(address _addr) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/AuraDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract AuraDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== AURA ===============================\n\n    function getReward(address _user, bool) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_user);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ConvexDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract ConvexDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CONVEX ===============================\n\n    function deposit(uint256, uint256, bool) external view virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdrawAndUnwrap(uint256, bool) external view virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function getReward(address _addr, bool) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/EtherFiDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract EtherFiDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ETHERFI ===============================\n\n    function deposit() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function wrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function unwrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function requestWithdraw(address _addr, uint256) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n\n    function claimWithdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/NativeWrapperDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract NativeWrapperDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ETHERFI ===============================\n\n    function deposit() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract OneInchDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error OneInchDecoderAndSanitizer__PermitNotSupported();\n\n    //============================== ONEINCH ===============================\n\n    function swap(\n        address executor,\n        DecoderCustomTypes.SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata\n    ) external pure returns (bytes memory addressesFound) {\n        if (permit.length > 0) revert OneInchDecoderAndSanitizer__PermitNotSupported();\n        addressesFound = abi.encodePacked(executor, desc.srcToken, desc.dstToken, desc.srcReceiver, desc.dstReceiver);\n    }\n\n    function uniswapV3Swap(uint256, uint256, uint256[] calldata pools)\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        for (uint256 i; i < pools.length; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, uint160(pools[i]));\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/GearboxDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract GearboxDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== GEARBOX ===============================\n\n    function deposit(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claim() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract PendleRouterDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n    //============================== PENDLEROUTER ===============================\n\n    function mintSyFromToken(address user, address sy, uint256, DecoderCustomTypes.TokenInput calldata input)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            input.swapData.swapType != DecoderCustomTypes.SwapType.NONE || input.swapData.extRouter != address(0)\n                || input.pendleSwap != address(0) || input.tokenIn != input.tokenMintSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound =\n            abi.encodePacked(user, sy, input.tokenIn, input.tokenMintSy, input.pendleSwap, input.swapData.extRouter);\n    }\n\n    function mintPyFromSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function swapExactPtForYt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function swapExactYtForPt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function addLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function removeLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function redeemPyToSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function redeemSyToToken(address user, address sy, uint256, DecoderCustomTypes.TokenOutput calldata output)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            output.swapData.swapType != DecoderCustomTypes.SwapType.NONE || output.swapData.extRouter != address(0)\n                || output.pendleSwap != address(0) || output.tokenOut != output.tokenRedeemSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound = abi.encodePacked(\n            user, sy, output.tokenOut, output.tokenRedeemSy, output.pendleSwap, output.swapData.extRouter\n        );\n    }\n\n    function redeemDueInterestAndRewards(\n        address user,\n        address[] calldata sys,\n        address[] calldata yts,\n        address[] calldata markets\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(user);\n        uint256 sysLength = sys.length;\n        for (uint256 i; i < sysLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, sys[i]);\n        }\n        uint256 ytsLength = yts.length;\n        for (uint256 i; i < ytsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, yts[i]);\n        }\n        uint256 marketsLength = markets.length;\n        for (uint256 i; i < marketsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, markets[i]);\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/AaveV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract AaveV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== AAVEV3 ===============================\n\n    function supply(address asset, uint256, address onBehalfOf, uint16)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function withdraw(address asset, uint256, address to) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(asset, to);\n    }\n\n    function borrow(address asset, uint256, uint256, uint16, address onBehalfOf)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function repay(address asset, uint256, uint256, address onBehalfOf)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function setUserUseReserveAsCollateral(address asset, bool)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset);\n    }\n\n    function setUserEMode(uint8) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/LidoDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract LidoDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== LIDO ===============================\n\n    function submit(address referral) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(referral);\n    }\n\n    function wrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function unwrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function requestWithdrawals(uint256[] calldata, address _owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_owner);\n    }\n\n    function claimWithdrawal(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claimWithdrawals(uint256[] calldata, uint256[] calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n}\n"
    },
    "src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n// Swell\ninterface INonFungiblePositionManager {\n    struct Position {\n        // the nonce for permits\n        uint96 nonce;\n        // the address that is approved for spending this token\n        address operator;\n        // the ID of the pool with which this token is connected\n        uint80 poolId;\n        // the tick range of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // the liquidity of the position\n        uint128 liquidity;\n        // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n    }\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "libraries": {}
  }
}}