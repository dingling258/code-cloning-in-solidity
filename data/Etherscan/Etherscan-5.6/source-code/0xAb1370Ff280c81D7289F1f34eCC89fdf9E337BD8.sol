{{
  "language": "Solidity",
  "sources": {
    "src/AccessControlledOCR2Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport \"./OCR2Aggregator.sol\";\nimport \"./SimpleReadAccessController.sol\";\n\n/**\n * @notice Wrapper of OCR2Aggregator which checks read access on Aggregator-interface methods\n */\ncontract AccessControlledOCR2Aggregator is OCR2Aggregator, SimpleReadAccessController {\n\n  constructor(\n    LinkTokenInterface _link,\n    int192 _minAnswer,\n    int192 _maxAnswer,\n    AccessControllerInterface _billingAccessController,\n    AccessControllerInterface _requesterAccessController,\n    uint8 _decimals,\n    string memory description\n  )\n    OCR2Aggregator(\n      _link,\n      _minAnswer,\n      _maxAnswer,\n      _billingAccessController,\n      _requesterAccessController,\n      _decimals,\n      description\n    ) {\n    }\n\n  /*\n   * Versioning\n   */\n\n  function typeAndVersion()\n    external\n    override\n    pure\n    virtual\n    returns (string memory)\n  {\n    return \"AccessControlledOCR2Aggregator 1.0.0\";\n  }\n\n\n  /*\n   * v2 Aggregator interface\n   */\n\n  /// @inheritdoc OCR2Aggregator\n  function latestAnswer()\n    public\n    override\n    view\n    checkAccess()\n    returns (int256)\n  {\n    return super.latestAnswer();\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function latestTimestamp()\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.latestTimestamp();\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function latestRound()\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.latestRound();\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function getAnswer(uint256 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (int256)\n  {\n    return super.getAnswer(_roundId);\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function getTimestamp(uint256 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.getTimestamp(_roundId);\n  }\n\n  /*\n   * v3 Aggregator interface\n   */\n\n  /// @inheritdoc OCR2Aggregator\n  function description()\n    public\n    override\n    view\n    checkAccess()\n    returns (string memory)\n  {\n    return super.description();\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function getRoundData(uint80 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return super.getRoundData(_roundId);\n  }\n\n  /// @inheritdoc OCR2Aggregator\n  function latestRoundData()\n    public\n    override\n    view\n    checkAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return super.latestRoundData();\n  }\n\n}\n"
    },
    "src/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n\n  constructor(\n    address newOwner\n  )\n    ConfirmedOwnerWithProposal(\n      newOwner,\n      address(0)\n    )\n  {\n  }\n\n}"
    },
    "src/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor(\n    address newOwner,\n    address pendingOwner\n  ) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(\n    address to\n  )\n    public\n    override\n    onlyOwner()\n  {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n    override\n  {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner()\n    public\n    view\n    override\n    returns (\n      address\n    )\n  {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(\n    address to\n  )\n    private\n  {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership()\n    internal\n    view\n  {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n\n}"
    },
    "src/OCR2Abstract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/TypeAndVersionInterface.sol\";\n\n\nabstract contract OCR2Abstract is TypeAndVersionInterface {\n  // Maximum number of oracles the offchain reporting protocol is designed for\n  uint256 constant internal maxNumOracles = 31;\n\n  /**\n   * @notice triggers a new run of the offchain reporting protocol\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\n   * @param configDigest configDigest of this configuration\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\n   * @param signers ith element is address ith oracle uses to sign a report\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\n   * @param f maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version of the serialization format used for \"offchainConfig\" parameter\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  event ConfigSet(\n    uint32 previousConfigBlockNumber,\n    bytes32 configDigest,\n    uint64 configCount,\n    address[] signers,\n    address[] transmitters,\n    uint8 f,\n    bytes onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes offchainConfig\n  );\n\n  /**\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\n   * @param signers addresses with which oracles sign the reports\n   * @param transmitters addresses oracles use to transmit the reports\n   * @param f number of faulty oracles the system can tolerate\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\n   * @param offchainConfigVersion version number for offchainEncoding schema\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\n   */\n  function setConfig(\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  )\n    external\n    virtual;\n\n  /**\n   * @notice information about current offchain reporting protocol configuration\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\n   * @return blockNumber block at which this config was set\n   * @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\n   */\n  function latestConfigDetails()\n    external\n    view\n    virtual\n    returns (\n      uint32 configCount,\n      uint32 blockNumber,\n      bytes32 configDigest\n    );\n\n  function _configDigestFromConfigData(\n    uint256 chainId,\n    address contractAddress,\n    uint64 configCount,\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    uint256 h = uint256(keccak256(abi.encode(chainId, contractAddress, configCount,\n      signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig\n    )));\n    uint256 prefixMask = type(uint256).max << (256-16); // 0xFFFF00..00\n    uint256 prefix = 0x0001 << (256-16); // 0x000100..00\n    return bytes32((prefix & prefixMask) | (h & ~prefixMask));\n  }\n\n  /**\n  * @notice optionally emitted to indicate the latest configDigest and epoch for\n     which a report was successfully transmitted. Alternatively, the contract may\n     use latestConfigDigestAndEpoch with scanLogs set to false.\n  */\n  event Transmitted(\n    bytes32 configDigest,\n    uint32 epoch\n  );\n\n  /**\n   * @notice optionally returns the latest configDigest and epoch for which a\n     report was successfully transmitted. Alternatively, the contract may return\n     scanLogs set to true and use Transmitted events to provide this information\n     to offchain watchers.\n   * @return scanLogs indicates whether to rely on the configDigest and epoch\n     returned or whether to scan logs for the Transmitted event instead.\n   * @return configDigest\n   * @return epoch\n   */\n  function latestConfigDigestAndEpoch()\n    external\n    view\n    virtual\n    returns(\n      bool scanLogs,\n      bytes32 configDigest,\n      uint32 epoch\n    );\n\n  /**\n   * @notice transmit is called to post a new report to the contract\n   * @param reportContext serialized report context containing configDigest, epoch, round, extraHash\n   * @param report serialized report, which the signatures are signing\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param rawVs ith element is the the V component of the ith signature\n   */\n  function transmit(\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n    bytes32[3] calldata reportContext,\n    bytes calldata report,\n    bytes32[] calldata rs, bytes32[] calldata ss, bytes32 rawVs // signatures\n  )\n    external\n    virtual;\n}\n"
    },
    "src/OCR2Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport \"./interfaces/AccessControllerInterface.sol\";\nimport \"./interfaces/AggregatorV2V3Interface.sol\";\nimport \"./interfaces/AggregatorValidatorInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./OCR2Abstract.sol\";\nimport \"./OwnerIsCreator.sol\";\n\n\n/**\n * @notice OCR2Aggregator for numerical data with billing support.\n\n * @dev\n * If you read or change this, be sure to read or adjust the comments. They\n * track the units of the values under consideration, and are crucial to\n * the readability of the operations it specifies.\n\n * @notice\n * Billing Trust Model:\n\n * Nothing in this contract prevents a billing admin from setting insane\n * values for the billing parameters in setBilling. Oracles\n * participating in this contract should regularly check that the\n * parameters make sense. Similarly, the outstanding obligations of this\n * contract to the oracles can exceed the funds held by the contract.\n * Oracles participating in this contract should regularly check that it\n * holds sufficient funds and stop interacting with it if funding runs\n * out.\n\n * This still leaves oracles with some risk due to TOCTOU issues.\n * However, since the sums involved are pretty small (Ethereum\n * transactions aren't that expensive in the end) and an oracle would\n * likely stop participating in a contract it repeatedly lost money on,\n * this risk is deemed acceptable. Oracles should also regularly\n * withdraw any funds in the contract to prevent issues where the\n * contract becomes underfunded at a later time, and different oracles\n * are competing for the left-over funds.\n\n * Finally, note that any change to the set of oracles or to the billing\n * parameters will trigger payout of all oracles first (using the old\n * parameters), a billing admin cannot take away funds that are already\n * marked for payment.\n */\ncontract OCR2Aggregator is OCR2Abstract, OwnerIsCreator, AggregatorV2V3Interface {\n  // This contract is divided into sections. Each section defines a set of\n  // variables, events, and functions that belong together.\n\n  /***************************************************************************\n   * Section: Variables used in multiple other sections\n   **************************************************************************/\n\n  struct Transmitter {\n    bool active;\n\n    // Index of oracle in s_signersList/s_transmittersList\n    uint8 index;\n\n    // juels-denominated payment for transmitters, covering gas costs incurred\n    // by the transmitter plus additional rewards. The entire LINK supply (1e9\n    // LINK = 1e27 Juels) will always fit into a uint96.\n    uint96 paymentJuels;\n  }\n  mapping (address /* transmitter address */ => Transmitter) internal s_transmitters;\n\n  struct Signer {\n    bool active;\n\n    // Index of oracle in s_signersList/s_transmittersList\n    uint8 index;\n  }\n  mapping (address /* signer address */ => Signer) internal s_signers;\n\n  // s_signersList contains the signing address of each oracle\n  address[] internal s_signersList;\n\n  // s_transmittersList contains the transmission address of each oracle,\n  // i.e. the address the oracle actually sends transactions to the contract from\n  address[] internal s_transmittersList;\n\n  // We assume that all oracles contribute observations to all rounds. this\n  // variable tracks (per-oracle) from what round an oracle should be rewarded,\n  // i.e. the oracle gets (latestAggregatorRoundId -\n  // rewardFromAggregatorRoundId) * reward\n  uint32[maxNumOracles] internal s_rewardFromAggregatorRoundId;\n\n  bytes32 s_latestConfigDigest;\n\n  // Storing these fields used on the hot path in a HotVars variable reduces the\n  // retrieval of all of them to a single SLOAD.\n  struct HotVars {\n    // maximum number of faulty oracles\n    uint8 f;\n\n    // epoch and round from OCR protocol.\n    // 32 most sig bits for epoch, 8 least sig bits for round\n    uint40 latestEpochAndRound;\n\n    // Chainlink Aggregators expose a roundId to consumers. The offchain reporting\n    // protocol does not use this id anywhere. We increment it whenever a new\n    // transmission is made to provide callers with contiguous ids for successive\n    // reports.\n    uint32 latestAggregatorRoundId;\n\n    // Highest compensated gas price, in gwei uints\n    uint32 maximumGasPriceGwei;\n\n    // If gas price is less (in gwei units), transmitter gets half the savings\n    uint32 reasonableGasPriceGwei;\n\n    // Fixed LINK reward for each observer\n    uint32 observationPaymentGjuels;\n\n    // Fixed reward for transmitter\n    uint32 transmissionPaymentGjuels;\n\n    // Overhead incurred by accounting logic\n    uint24 accountingGas;\n  }\n  HotVars internal s_hotVars;\n\n  // Transmission records the median answer from the transmit transaction at\n  // time timestamp\n  struct Transmission {\n    int192 answer; // 192 bits ought to be enough for anyone\n    uint32 observationsTimestamp; // when were observations made offchain\n    uint32 transmissionTimestamp; // when was report received onchain\n  }\n  mapping(uint32 /* aggregator round ID */ => Transmission) internal s_transmissions;\n\n  // Lowest answer the system is allowed to report in response to transmissions\n  int192 immutable public minAnswer;\n  // Highest answer the system is allowed to report in response to transmissions\n  int192 immutable public maxAnswer;\n\n  /***************************************************************************\n   * Section: Constructor\n   **************************************************************************/\n\n  /**\n   * @param link address of the LINK contract\n   * @param minAnswer_ lowest answer the median of a report is allowed to be\n   * @param maxAnswer_ highest answer the median of a report is allowed to be\n   * @param requesterAccessController access controller for requesting new rounds\n   * @param decimals_ answers are stored in fixed-point format, with this many digits of precision\n   * @param description_ short human-readable description of observable this contract's answers pertain to\n   */\n  constructor(\n    LinkTokenInterface link,\n    int192 minAnswer_,\n    int192 maxAnswer_,\n    AccessControllerInterface billingAccessController,\n    AccessControllerInterface requesterAccessController,\n    uint8 decimals_,\n    string memory description_\n  ) {\n    s_linkToken = link;\n    emit LinkTokenSet(LinkTokenInterface(address(0)), link);\n    _setBillingAccessController(billingAccessController);\n\n    decimals = decimals_;\n    s_description = description_;\n    setRequesterAccessController(requesterAccessController);\n    setValidatorConfig(AggregatorValidatorInterface(address(0x0)), 0);\n    minAnswer = minAnswer_;\n    maxAnswer = maxAnswer_;\n  }\n\n\n  /***************************************************************************\n   * Section: OCR2Abstract Configuration\n   **************************************************************************/\n\n  // incremented each time a new config is posted. This count is incorporated\n  // into the config digest to prevent replay attacks.\n  uint32 internal s_configCount;\n\n  // makes it easier for offchain systems to extract config from logs\n  uint32 internal s_latestConfigBlockNumber;\n\n  // left as a function so this check can be disabled in derived contracts\n  function _requirePositiveF (\n    uint256 f\n  )\n    internal\n    pure\n    virtual\n  {\n    require(0 < f, \"f must be positive\");\n  }\n\n  struct SetConfigArgs {\n    address[] signers;\n    address[] transmitters;\n    uint8 f;\n    bytes onchainConfig;\n    uint64 offchainConfigVersion;\n    bytes offchainConfig;\n  }\n\n  /// @inheritdoc OCR2Abstract\n  function setConfig(\n    address[] memory signers,\n    address[] memory transmitters,\n    uint8 f,\n    bytes memory onchainConfig,\n    uint64 offchainConfigVersion,\n    bytes memory offchainConfig\n  )\n    external\n    override\n    onlyOwner()\n  {\n    require(signers.length <= maxNumOracles, \"too many oracles\");\n    require(signers.length == transmitters.length, \"oracle length mismatch\");\n    require(3*f < signers.length, \"faulty-oracle f too high\");\n    _requirePositiveF(f);\n    require(keccak256(onchainConfig) == keccak256(abi.encodePacked(uint8(1) /*version*/, minAnswer, maxAnswer)), \"invalid onchainConfig\");\n\n    SetConfigArgs memory args = SetConfigArgs({\n      signers: signers,\n      transmitters: transmitters,\n      f: f,\n      onchainConfig: onchainConfig,\n      offchainConfigVersion: offchainConfigVersion,\n      offchainConfig: offchainConfig\n    });\n\n    s_hotVars.latestEpochAndRound = 0;\n    _payOracles();\n\n    // remove any old signer/transmitter addresses\n    uint256 oldLength = s_signersList.length;\n    for (uint256 i = 0; i < oldLength; i++) {\n      address signer = s_signersList[i];\n      address transmitter = s_transmittersList[i];\n      delete s_signers[signer];\n      delete s_transmitters[transmitter];\n    }\n    delete s_signersList;\n    delete s_transmittersList;\n\n    // add new signer/transmitter addresses\n    for (uint i = 0; i < args.signers.length; i++) {\n      require(\n        !s_signers[args.signers[i]].active,\n        \"repeated signer address\"\n      );\n      s_signers[args.signers[i]] = Signer({\n        active: true,\n        index: uint8(i)\n      });\n      require(\n        !s_transmitters[args.transmitters[i]].active,\n        \"repeated transmitter address\"\n      );\n      s_transmitters[args.transmitters[i]] = Transmitter({\n        active: true,\n        index: uint8(i),\n        paymentJuels: 0\n      });\n    }\n    s_signersList = args.signers;\n    s_transmittersList = args.transmitters;\n\n    s_hotVars.f = args.f;\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\n    s_latestConfigBlockNumber = uint32(block.number);\n    s_configCount += 1;\n    s_latestConfigDigest = _configDigestFromConfigData(\n      block.chainid,\n      address(this),\n      s_configCount,\n      args.signers,\n      args.transmitters,\n      args.f,\n      args.onchainConfig,\n      args.offchainConfigVersion,\n      args.offchainConfig\n    );\n\n    emit ConfigSet(\n      previousConfigBlockNumber,\n      s_latestConfigDigest,\n      s_configCount,\n      args.signers,\n      args.transmitters,\n      args.f,\n      args.onchainConfig,\n      args.offchainConfigVersion,\n      args.offchainConfig\n    );\n\n    uint32 latestAggregatorRoundId = s_hotVars.latestAggregatorRoundId;\n    for (uint256 i = 0; i < args.signers.length; i++) {\n      s_rewardFromAggregatorRoundId[i] = latestAggregatorRoundId;\n    }\n  }\n\n  /// @inheritdoc OCR2Abstract\n  function latestConfigDetails()\n    external\n    override\n    view\n    returns (\n      uint32 configCount,\n      uint32 blockNumber,\n      bytes32 configDigest\n    )\n  {\n    return (s_configCount, s_latestConfigBlockNumber, s_latestConfigDigest);\n  }\n\n  /**\n   * @return list of addresses permitted to transmit reports to this contract\n\n   * @dev The list will match the order used to specify the transmitter during setConfig\n   */\n  function getTransmitters()\n    external\n    view\n    returns(address[] memory)\n  {\n    return s_transmittersList;\n  }\n\n  /***************************************************************************\n   * Section: Onchain Validation\n   **************************************************************************/\n\n  // Configuration for validator\n  struct ValidatorConfig {\n    AggregatorValidatorInterface validator;\n    uint32 gasLimit;\n  }\n  ValidatorConfig private s_validatorConfig;\n\n  /**\n   * @notice indicates that the validator configuration has been set\n   * @param previousValidator previous validator contract\n   * @param previousGasLimit previous gas limit for validate calls\n   * @param currentValidator current validator contract\n   * @param currentGasLimit current gas limit for validate calls\n   */\n  event ValidatorConfigSet(\n    AggregatorValidatorInterface indexed previousValidator,\n    uint32 previousGasLimit,\n    AggregatorValidatorInterface indexed currentValidator,\n    uint32 currentGasLimit\n  );\n\n  /**\n   * @notice validator configuration\n   * @return validator validator contract\n   * @return gasLimit gas limit for validate calls\n   */\n  function getValidatorConfig()\n    external\n    view\n    returns (AggregatorValidatorInterface validator, uint32 gasLimit)\n  {\n    ValidatorConfig memory vc = s_validatorConfig;\n    return (vc.validator, vc.gasLimit);\n  }\n\n  /**\n   * @notice sets validator configuration\n   * @dev set newValidator to 0x0 to disable validate calls\n   * @param newValidator address of the new validator contract\n   * @param newGasLimit new gas limit for validate calls\n   */\n  function setValidatorConfig(\n    AggregatorValidatorInterface newValidator,\n    uint32 newGasLimit\n  )\n    public\n    onlyOwner()\n  {\n    ValidatorConfig memory previous = s_validatorConfig;\n\n    if (previous.validator != newValidator || previous.gasLimit != newGasLimit) {\n      s_validatorConfig = ValidatorConfig({\n        validator: newValidator,\n        gasLimit: newGasLimit\n      });\n\n      emit ValidatorConfigSet(previous.validator, previous.gasLimit, newValidator, newGasLimit);\n    }\n  }\n\n  function _validateAnswer(\n    uint32 aggregatorRoundId,\n    int256 answer\n  )\n    private\n  {\n    ValidatorConfig memory vc = s_validatorConfig;\n\n    if (address(vc.validator) == address(0)) {\n      return;\n    }\n\n    uint32 prevAggregatorRoundId = aggregatorRoundId - 1;\n    int256 prevAggregatorRoundAnswer = s_transmissions[prevAggregatorRoundId].answer;\n    require(\n      _callWithExactGasEvenIfTargetIsNoContract(\n        vc.gasLimit,\n        address(vc.validator),\n        abi.encodeWithSignature(\n          \"validate(uint256,int256,uint256,int256)\",\n          uint256(prevAggregatorRoundId),\n          prevAggregatorRoundAnswer,\n          uint256(aggregatorRoundId),\n          answer\n        )\n      ),\n      \"insufficient gas\"\n    );\n  }\n\n  uint256 private constant CALL_WITH_EXACT_GAS_CUSHION = 5_000;\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available.\n   */\n  function _callWithExactGasEvenIfTargetIsNoContract(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  )\n    private\n    returns (bool sufficientGas)\n  {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let g := gas()\n      // Compute g -= CALL_WITH_EXACT_GAS_CUSHION and check for underflow. We\n      // need the cushion since the logic following the above call to gas also\n      // costs gas which we cannot account for exactly. So cushion is a\n      // conservative upper bound for the cost of this logic.\n      if iszero(lt(g, CALL_WITH_EXACT_GAS_CUSHION)) {\n        g := sub(g, CALL_WITH_EXACT_GAS_CUSHION)\n        // If g - g//64 <= gasAmount, we don't have enough gas. (We subtract g//64\n        // because of EIP-150.)\n        if gt(sub(g, div(g, 64)), gasAmount) {\n          // Call and ignore success/return data. Note that we did not check\n          // whether a contract actually exists at the target address.\n          pop(call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0))\n          sufficientGas := true\n        }\n      }\n    }\n  }\n\n  /***************************************************************************\n   * Section: RequestNewRound\n   **************************************************************************/\n\n  AccessControllerInterface internal s_requesterAccessController;\n\n  /**\n   * @notice emitted when a new requester access controller contract is set\n   * @param old the address prior to the current setting\n   * @param current the address of the new access controller contract\n   */\n  event RequesterAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\n\n  /**\n   * @notice emitted to immediately request a new round\n   * @param requester the address of the requester\n   * @param configDigest the latest transmission's configDigest\n   * @param epoch the latest transmission's epoch\n   * @param round the latest transmission's round\n   */\n  event RoundRequested(address indexed requester, bytes32 configDigest, uint32 epoch, uint8 round);\n\n  /**\n   * @notice address of the requester access controller contract\n   * @return requester access controller address\n   */\n  function getRequesterAccessController()\n    external\n    view\n    returns (AccessControllerInterface)\n  {\n    return s_requesterAccessController;\n  }\n\n  /**\n   * @notice sets the requester access controller\n   * @param requesterAccessController designates the address of the new requester access controller\n   */\n  function setRequesterAccessController(AccessControllerInterface requesterAccessController)\n    public\n    onlyOwner()\n  {\n    AccessControllerInterface oldController = s_requesterAccessController;\n    if (requesterAccessController != oldController) {\n      s_requesterAccessController = AccessControllerInterface(requesterAccessController);\n      emit RequesterAccessControllerSet(oldController, requesterAccessController);\n    }\n  }\n\n  /**\n   * @notice immediately requests a new round\n   * @return the aggregatorRoundId of the next round. Note: The report for this round may have been\n   * transmitted (but not yet mined) *before* requestNewRound() was even called. There is *no*\n   * guarantee of causality between the request and the report at aggregatorRoundId.\n   */\n  function requestNewRound() external returns (uint80) {\n    require(msg.sender == owner() || s_requesterAccessController.hasAccess(msg.sender, msg.data),\n      \"Only owner&requester can call\");\n\n    uint40 latestEpochAndRound = s_hotVars.latestEpochAndRound;\n    uint32 latestAggregatorRoundId = s_hotVars.latestAggregatorRoundId;\n\n    emit RoundRequested(\n      msg.sender,\n      s_latestConfigDigest,\n      uint32(latestEpochAndRound >> 8),\n      uint8(latestEpochAndRound)\n    );\n    return latestAggregatorRoundId + 1;\n  }\n\n  /***************************************************************************\n   * Section: Transmission\n   **************************************************************************/\n\n  /**\n   * @notice indicates that a new report was transmitted\n   * @param aggregatorRoundId the round to which this report was assigned\n   * @param answer median of the observations attached to this report\n   * @param transmitter address from which the report was transmitted\n   * @param observationsTimestamp when were observations made offchain\n   * @param observations observations transmitted with this report\n   * @param observers i-th element is the oracle id of the oracle that made the i-th observation\n   * @param juelsPerFeeCoin exchange rate between feeCoin (e.g. ETH on Ethereum) and LINK, denominated in juels\n   * @param configDigest configDigest of transmission\n   * @param epochAndRound least-significant byte is the OCR protocol round number, the other bytes give the big-endian OCR protocol epoch number\n   */\n  event NewTransmission(\n    uint32 indexed aggregatorRoundId,\n    int192 answer,\n    address transmitter,\n    uint32 observationsTimestamp,\n    int192[] observations,\n    bytes observers,\n    int192 juelsPerFeeCoin,\n    bytes32 configDigest,\n    uint40 epochAndRound\n  );\n\n  // Used to relieve stack pressure in transmit\n  struct Report {\n    uint32 observationsTimestamp;\n    bytes observers; // ith element is the index of the ith observer\n    int192[] observations; // ith element is the ith observation\n    int192 juelsPerFeeCoin;\n  }\n\n  // _decodeReport decodes a serialized report into a Report struct\n  function _decodeReport(bytes memory rawReport)\n    internal\n    pure\n    returns (\n      Report memory\n    )\n  {\n    uint32 observationsTimestamp;\n    bytes32 rawObservers;\n    int192[] memory observations;\n    int192 juelsPerFeeCoin;\n    (observationsTimestamp, rawObservers, observations, juelsPerFeeCoin) = abi.decode(rawReport, (uint32, bytes32, int192[], int192));\n\n    _requireExpectedReportLength(rawReport, observations);\n\n    uint256 numObservations = observations.length;\n    bytes memory observers = abi.encodePacked(rawObservers);\n    assembly {\n      // we truncate observers from length 32 to the number of observations\n      mstore(observers, numObservations)\n    }\n\n    return Report({\n      observationsTimestamp: observationsTimestamp,\n      observers: observers,\n      observations: observations,\n      juelsPerFeeCoin: juelsPerFeeCoin\n    });\n  }\n\n  // The constant-length components of the msg.data sent to transmit.\n  // See the \"If we wanted to call sam\" example on for example reasoning\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\n  uint256 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\n    4 + // function selector\n    32 * 3 + // 3 words containing reportContext\n    32 + // word containing start location of abiencoded report value\n    32 + // word containing start location of abiencoded rs value\n    32 + // word containing start location of abiencoded ss value\n    32 + // rawVs value\n    32 + // word containing length of report\n    32 + // word containing length rs\n    32 + // word containing length of ss\n    0; // placeholder\n\n  // Make sure the calldata length matches the inputs. Otherwise, the\n  // transmitter could append an arbitrarily long (up to gas-block limit)\n  // string of 0 bytes, which we would reimburse at a rate of 16 gas/byte, but\n  // which would only cost the transmitter 4 gas/byte.\n  function _requireExpectedMsgDataLength(\n    bytes calldata report,\n    bytes32[] calldata rs,\n    bytes32[] calldata ss\n  )\n    private\n    pure\n  {\n    // calldata will never be big enough to make this overflow\n    uint256 expected = TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT +\n      report.length + // one byte per entry in report\n      rs.length * 32 + // 32 bytes per entry in rs\n      ss.length * 32 + // 32 bytes per entry in ss\n      0; // placeholder\n    require(msg.data.length == expected, \"calldata length mismatch\");\n  }\n\n  /// @inheritdoc OCR2Abstract\n  function transmit(\n    // reportContext consists of:\n    // reportContext[0]: ConfigDigest\n    // reportContext[1]: 27 byte padding, 4-byte epoch and 1-byte round\n    // reportContext[2]: ExtraHash\n    bytes32[3] calldata reportContext,\n    bytes calldata report,\n    // ECDSA signatures\n    bytes32[] calldata rs,\n    bytes32[] calldata ss,\n    bytes32 rawVs\n  )\n    external\n    override\n  {\n    // NOTE: If the arguments to this function are changed, _requireExpectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n\n    uint256 initialGas = gasleft(); // This line must come first\n\n    HotVars memory hotVars = s_hotVars;\n\n    uint40 epochAndRound = uint40(uint256(reportContext[1]));\n\n    require(hotVars.latestEpochAndRound < epochAndRound, \"stale report\");\n\n    require(s_transmitters[msg.sender].active, \"unauthorized transmitter\");\n\n    require(s_latestConfigDigest == reportContext[0], \"configDigest mismatch\");\n\n    _requireExpectedMsgDataLength(report, rs, ss);\n\n    require(rs.length == hotVars.f + 1, \"wrong number of signatures\");\n    require(rs.length == ss.length, \"signatures out of registration\");\n\n    // Verify signatures attached to report\n    {\n      bytes32 h = keccak256(abi.encode(keccak256(report), reportContext));\n\n      // i-th byte counts number of sigs made by i-th signer\n      uint256 signedCount = 0;\n\n      Signer memory signer;\n      for (uint i = 0; i < rs.length; i++) {\n        address signerAddress = ecrecover(h, uint8(rawVs[i])+27, rs[i], ss[i]);\n        signer = s_signers[signerAddress];\n        require(signer.active, \"signature error\");\n        unchecked{\n          signedCount += 1 << (8 * signer.index);\n        }\n      }\n\n      // The first byte of the mask can be 0, because we only ever have 31 oracles\n      require(signedCount & 0x0001010101010101010101010101010101010101010101010101010101010101 == signedCount, \"duplicate signer\");\n    }\n\n    int192 juelsPerFeeCoin = _report(hotVars, reportContext[0], epochAndRound, report);\n\n    _payTransmitter(hotVars, juelsPerFeeCoin, uint32(initialGas), msg.sender);\n  }\n\n  /**\n   * @notice details about the most recent report\n   * @return configDigest domain separation tag for the latest report\n   * @return epoch epoch in which the latest report was generated\n   * @return round OCR round in which the latest report was generated\n   * @return latestAnswer_ median value from latest report\n   * @return latestTimestamp_ when the latest report was transmitted\n   */\n  function latestTransmissionDetails()\n    external\n    view\n    returns (\n      bytes32 configDigest,\n      uint32 epoch,\n      uint8 round,\n      int192 latestAnswer_,\n      uint64 latestTimestamp_\n    )\n  {\n    require(msg.sender == tx.origin, \"Only callable by EOA\");\n    return (\n      s_latestConfigDigest,\n      uint32(s_hotVars.latestEpochAndRound >> 8),\n      uint8(s_hotVars.latestEpochAndRound),\n      s_transmissions[s_hotVars.latestAggregatorRoundId].answer,\n      s_transmissions[s_hotVars.latestAggregatorRoundId].transmissionTimestamp\n    );\n  }\n\n  /// @inheritdoc OCR2Abstract\n  function latestConfigDigestAndEpoch()\n    external\n    override\n    view\n    virtual\n    returns(\n      bool scanLogs,\n      bytes32 configDigest,\n      uint32 epoch\n    )\n  {\n    return (false, s_latestConfigDigest, uint32(s_hotVars.latestEpochAndRound >> 8));\n  }\n\n  function _requireExpectedReportLength(\n    bytes memory report,\n    int192[] memory observations\n  )\n    private\n    pure\n  {\n    uint256 expected =\n      32 + // observationsTimestamp\n      32 + // rawObservers\n      32 + // observations offset\n      32 + // juelsPerFeeCoin\n      32 + // observations length\n      32 * observations.length + // observations payload\n      0;\n    require(report.length == expected, \"report length mismatch\");\n  }\n\n  function _report(\n    HotVars memory hotVars,\n    bytes32 configDigest,\n    uint40 epochAndRound,\n    bytes memory rawReport\n  )\n    internal\n    returns (int192 juelsPerFeeCoin)\n  {\n    Report memory report = _decodeReport(rawReport);\n\n\n    require(report.observations.length <= maxNumOracles, \"num observations out of bounds\");\n    // Offchain logic ensures that a quorum of oracles is operating on a matching set of at least\n    // 2f+1 observations. By assumption, up to f of those can be faulty, which includes being\n    // malformed. Conversely, more than f observations have to be well-formed and sent on chain.\n    require(hotVars.f < report.observations.length, \"too few values to trust median\");\n\n    hotVars.latestEpochAndRound = epochAndRound;\n\n    // get median, validate its range, store it in new aggregator round\n    int192 median = report.observations[report.observations.length/2];\n    require(minAnswer <= median && median <= maxAnswer, \"median is out of min-max range\");\n    hotVars.latestAggregatorRoundId++;\n    s_transmissions[hotVars.latestAggregatorRoundId] =\n      Transmission({\n        answer: median,\n        observationsTimestamp: report.observationsTimestamp,\n        transmissionTimestamp: uint32(block.timestamp)\n      });\n\n    // persist updates to hotVars\n    s_hotVars = hotVars;\n\n    emit NewTransmission(\n      hotVars.latestAggregatorRoundId,\n      median,\n      msg.sender,\n      report.observationsTimestamp,\n      report.observations,\n      report.observers,\n      report.juelsPerFeeCoin,\n      configDigest,\n      epochAndRound\n    );\n    // Emit these for backwards compatibility with offchain consumers\n    // that only support legacy events\n    emit NewRound(\n      hotVars.latestAggregatorRoundId,\n      address(0x0), // use zero address since we don't have anybody \"starting\" the round here\n      report.observationsTimestamp\n    );\n    emit AnswerUpdated(\n      median,\n      hotVars.latestAggregatorRoundId,\n      block.timestamp\n    );\n\n    _validateAnswer(hotVars.latestAggregatorRoundId, median);\n\n    return report.juelsPerFeeCoin;\n  }\n\n  /***************************************************************************\n   * Section: v2 AggregatorInterface\n   **************************************************************************/\n\n  /**\n   * @notice median from the most recent report\n   */\n  function latestAnswer()\n    public\n    override\n    view\n    virtual\n    returns (int256)\n  {\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].answer;\n  }\n\n  /**\n   * @notice timestamp of block in which last report was transmitted\n   */\n  function latestTimestamp()\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].transmissionTimestamp;\n  }\n\n  /**\n   * @notice Aggregator round (NOT OCR round) in which last report was transmitted\n   */\n  function latestRound()\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    return s_hotVars.latestAggregatorRoundId;\n  }\n\n  /**\n   * @notice median of report from given aggregator round (NOT OCR round)\n   * @param roundId the aggregator round of the target report\n   */\n  function getAnswer(uint256 roundId)\n    public\n    override\n    view\n    virtual\n    returns (int256)\n  {\n    if (roundId > 0xFFFFFFFF) { return 0; }\n    return s_transmissions[uint32(roundId)].answer;\n  }\n\n  /**\n   * @notice timestamp of block in which report from given aggregator round was transmitted\n   * @param roundId aggregator round (NOT OCR round) of target report\n   */\n  function getTimestamp(uint256 roundId)\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    if (roundId > 0xFFFFFFFF) { return 0; }\n    return s_transmissions[uint32(roundId)].transmissionTimestamp;\n  }\n\n  /***************************************************************************\n   * Section: v3 AggregatorInterface\n   **************************************************************************/\n\n  /**\n   * @return answers are stored in fixed-point format, with this many digits of precision\n   */\n  uint8 immutable public override decimals;\n\n  /**\n   * @notice aggregator contract version\n   */\n  uint256 constant public override version = 6;\n\n  string internal s_description;\n\n  /**\n   * @notice human-readable description of observable this contract is reporting on\n   */\n  function description()\n    public\n    override\n    view\n    virtual\n    returns (string memory)\n  {\n    return s_description;\n  }\n\n  /**\n   * @notice details for the given aggregator round\n   * @param roundId target aggregator round (NOT OCR round). Must fit in uint32\n   * @return roundId_ roundId\n   * @return answer median of report from given roundId\n   * @return startedAt timestamp of when observations were made offchain\n   * @return updatedAt timestamp of block in which report from given roundId was transmitted\n   * @return answeredInRound roundId\n   */\n  function getRoundData(uint80 roundId)\n    public\n    override\n    view\n    virtual\n    returns (\n      uint80 roundId_,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    if(roundId > type(uint32).max) { return (0, 0, 0, 0, 0); }\n    Transmission memory transmission = s_transmissions[uint32(roundId)];\n    return (\n      roundId,\n      transmission.answer,\n      transmission.observationsTimestamp,\n      transmission.transmissionTimestamp,\n      roundId\n    );\n  }\n\n  /**\n   * @notice aggregator details for the most recently transmitted report\n   * @return roundId aggregator round of latest report (NOT OCR round)\n   * @return answer median of latest report\n   * @return startedAt timestamp of when observations were made offchain\n   * @return updatedAt timestamp of block containing latest report\n   * @return answeredInRound aggregator round of latest report\n   */\n  function latestRoundData()\n    public\n    override\n    view\n    virtual\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    uint32 latestAggregatorRoundId = s_hotVars.latestAggregatorRoundId;\n\n    Transmission memory transmission = s_transmissions[latestAggregatorRoundId];\n    return (\n      latestAggregatorRoundId,\n      transmission.answer,\n      transmission.observationsTimestamp,\n      transmission.transmissionTimestamp,\n      latestAggregatorRoundId\n    );\n  }\n\n  /***************************************************************************\n   * Section: Configurable LINK Token\n   **************************************************************************/\n\n  // We assume that the token contract is correct. This contract is not written\n  // to handle misbehaving ERC20 tokens!\n  LinkTokenInterface internal s_linkToken;\n\n  /*\n   * @notice emitted when the LINK token contract is set\n   * @param oldLinkToken the address of the old LINK token contract\n   * @param newLinkToken the address of the new LINK token contract\n   */\n  event LinkTokenSet(\n    LinkTokenInterface indexed oldLinkToken,\n    LinkTokenInterface indexed newLinkToken\n  );\n\n  /**\n   * @notice sets the LINK token contract used for paying oracles\n   * @param linkToken the address of the LINK token contract\n   * @param recipient remaining funds from the previous token contract are transferred\n   * here\n   * @dev this function will return early (without an error) without changing any state\n   * if linkToken equals getLinkToken().\n   * @dev this will trigger a payout so that a malicious owner cannot take from oracles\n   * what is already owed to them.\n   * @dev we assume that the token contract is correct. This contract is not written\n   * to handle misbehaving ERC20 tokens!\n   */\n  function setLinkToken(\n    LinkTokenInterface linkToken,\n    address recipient\n  ) external\n    onlyOwner()\n  {\n    LinkTokenInterface oldLinkToken = s_linkToken;\n    if (linkToken == oldLinkToken) {\n      // No change, nothing to be done\n      return;\n    }\n    // call balanceOf as a sanity check on whether we're talking to a token\n    // contract\n    linkToken.balanceOf(address(this));\n    // we break CEI here, but that's okay because we're dealing with a correct\n    // token contract (by assumption).\n    _payOracles();\n    uint256 remainingBalance = oldLinkToken.balanceOf(address(this));\n    require(oldLinkToken.transfer(recipient, remainingBalance), \"transfer remaining funds failed\");\n    s_linkToken = linkToken;\n    emit LinkTokenSet(oldLinkToken, linkToken);\n  }\n\n  /*\n   * @notice gets the LINK token contract used for paying oracles\n   * @return linkToken the address of the LINK token contract\n   */\n  function getLinkToken()\n    external\n    view\n    returns(LinkTokenInterface linkToken)\n  {\n    return s_linkToken;\n  }\n\n  /***************************************************************************\n   * Section: BillingAccessController Management\n   **************************************************************************/\n\n  // Controls who can change billing parameters. A billingAdmin is not able to\n  // affect any OCR protocol settings and therefore cannot tamper with the\n  // liveness or integrity of a data feed. However, a billingAdmin can set\n  // faulty billing parameters causing oracles to be underpaid, or causing them\n  // to be paid so much that further calls to setConfig, setBilling,\n  // setLinkToken will always fail due to the contract being underfunded.\n  AccessControllerInterface internal s_billingAccessController;\n\n  /**\n   * @notice emitted when a new access-control contract is set\n   * @param old the address prior to the current setting\n   * @param current the address of the new access-control contract\n   */\n  event BillingAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\n\n  function _setBillingAccessController(AccessControllerInterface billingAccessController)\n    internal\n  {\n    AccessControllerInterface oldController = s_billingAccessController;\n    if (billingAccessController != oldController) {\n      s_billingAccessController = billingAccessController;\n      emit BillingAccessControllerSet(\n        oldController,\n        billingAccessController\n      );\n    }\n  }\n\n  /**\n   * @notice sets billingAccessController\n   * @param _billingAccessController new billingAccessController contract address\n   * @dev only owner can call this\n   */\n  function setBillingAccessController(AccessControllerInterface _billingAccessController)\n    external\n    onlyOwner\n  {\n    _setBillingAccessController(_billingAccessController);\n  }\n\n  /**\n   * @notice gets billingAccessController\n   * @return address of billingAccessController contract\n   */\n  function getBillingAccessController()\n    external\n    view\n    returns (AccessControllerInterface)\n  {\n    return s_billingAccessController;\n  }\n\n  /***************************************************************************\n   * Section: Billing Configuration\n   **************************************************************************/\n\n  /**\n   * @notice emitted when billing parameters are set\n   * @param maximumGasPriceGwei highest gas price for which transmitter will be compensated\n   * @param reasonableGasPriceGwei transmitter will receive reward for gas prices under this value\n   * @param observationPaymentGjuels reward to oracle for contributing an observation to a successfully transmitted report\n   * @param transmissionPaymentGjuels reward to transmitter of a successful report\n   * @param accountingGas gas overhead incurred by accounting logic\n   */\n  event BillingSet(\n    uint32 maximumGasPriceGwei,\n    uint32 reasonableGasPriceGwei,\n    uint32 observationPaymentGjuels,\n    uint32 transmissionPaymentGjuels,\n    uint24 accountingGas\n  );\n\n  /**\n   * @notice sets billing parameters\n   * @param maximumGasPriceGwei highest gas price for which transmitter will be compensated\n   * @param reasonableGasPriceGwei transmitter will receive reward for gas prices under this value\n   * @param observationPaymentGjuels reward to oracle for contributing an observation to a successfully transmitted report\n   * @param transmissionPaymentGjuels reward to transmitter of a successful report\n   * @param accountingGas gas overhead incurred by accounting logic\n   * @dev access control provided by billingAccessController\n   */\n  function setBilling(\n    uint32 maximumGasPriceGwei,\n    uint32 reasonableGasPriceGwei,\n    uint32 observationPaymentGjuels,\n    uint32 transmissionPaymentGjuels,\n    uint24 accountingGas\n  )\n    external\n  {\n    AccessControllerInterface access = s_billingAccessController;\n    require(msg.sender == owner() || access.hasAccess(msg.sender, msg.data),\n      \"Only owner&billingAdmin can call\");\n    _payOracles();\n\n    s_hotVars.maximumGasPriceGwei = maximumGasPriceGwei;\n    s_hotVars.reasonableGasPriceGwei = reasonableGasPriceGwei;\n    s_hotVars.observationPaymentGjuels = observationPaymentGjuels;\n    s_hotVars.transmissionPaymentGjuels = transmissionPaymentGjuels;\n    s_hotVars.accountingGas = accountingGas;\n\n    emit BillingSet(maximumGasPriceGwei, reasonableGasPriceGwei,\n      observationPaymentGjuels, transmissionPaymentGjuels, accountingGas);\n  }\n\n  /**\n   * @notice gets billing parameters\n   * @param maximumGasPriceGwei highest gas price for which transmitter will be compensated\n   * @param reasonableGasPriceGwei transmitter will receive reward for gas prices under this value\n   * @param observationPaymentGjuels reward to oracle for contributing an observation to a successfully transmitted report\n   * @param transmissionPaymentGjuels reward to transmitter of a successful report\n   * @param accountingGas gas overhead of the accounting logic\n   */\n  function getBilling()\n    external\n    view\n    returns (\n      uint32 maximumGasPriceGwei,\n      uint32 reasonableGasPriceGwei,\n      uint32 observationPaymentGjuels,\n      uint32 transmissionPaymentGjuels,\n      uint24 accountingGas\n    )\n  {\n    return (\n      s_hotVars.maximumGasPriceGwei,\n      s_hotVars.reasonableGasPriceGwei,\n      s_hotVars.observationPaymentGjuels,\n      s_hotVars.transmissionPaymentGjuels,\n      s_hotVars.accountingGas\n    );\n  }\n\n  /***************************************************************************\n   * Section: Payments and Withdrawals\n   **************************************************************************/\n\n  /**\n   * @notice withdraws an oracle's payment from the contract\n   * @param transmitter the transmitter address of the oracle\n   * @dev must be called by oracle's payee address\n   */\n  function withdrawPayment(address transmitter)\n    external\n  {\n    require(msg.sender == s_payees[transmitter], \"Only payee can withdraw\");\n    _payOracle(transmitter);\n  }\n\n  /**\n   * @notice query an oracle's payment amount, denominated in juels\n   * @param transmitterAddress the transmitter address of the oracle\n   */\n  function owedPayment(address transmitterAddress)\n    public\n    view\n    returns (uint256)\n  {\n    Transmitter memory transmitter = s_transmitters[transmitterAddress];\n    if (!transmitter.active) { return 0; }\n    // safe from overflow:\n    // s_hotVars.latestAggregatorRoundId - s_rewardFromAggregatorRoundId[transmitter.index] <= 2**32\n    // s_hotVars.observationPaymentGjuels <= 2**32\n    // 1 gwei <= 2**32\n    // hence juelsAmount <= 2**96\n    uint256 juelsAmount =\n      uint256(s_hotVars.latestAggregatorRoundId - s_rewardFromAggregatorRoundId[transmitter.index]) *\n      uint256(s_hotVars.observationPaymentGjuels) *\n      (1 gwei);\n    juelsAmount += transmitter.paymentJuels;\n    return juelsAmount;\n  }\n\n  /**\n   * @notice emitted when an oracle has been paid LINK\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param payee address to which the payment is sent\n   * @param amount amount of LINK sent\n   * @param linkToken address of the LINK token contract\n   */\n  event OraclePaid(\n    address indexed transmitter,\n    address indexed payee,\n    uint256 amount,\n    LinkTokenInterface indexed linkToken\n  );\n\n  // _payOracle pays out transmitter's balance to the corresponding payee, and zeros it out\n  function _payOracle(address transmitterAddress)\n    internal\n  {\n    Transmitter memory transmitter = s_transmitters[transmitterAddress];\n    if (!transmitter.active) { return; }\n    uint256 juelsAmount = owedPayment(transmitterAddress);\n    if (juelsAmount > 0) {\n      address payee = s_payees[transmitterAddress];\n      // Poses no re-entrancy issues, because LINK.transfer does not yield\n      // control flow.\n      require(s_linkToken.transfer(payee, juelsAmount), \"insufficient funds\");\n      s_rewardFromAggregatorRoundId[transmitter.index] = s_hotVars.latestAggregatorRoundId;\n      s_transmitters[transmitterAddress].paymentJuels = 0;\n      emit OraclePaid(transmitterAddress, payee, juelsAmount, s_linkToken);\n    }\n  }\n\n  // _payOracles pays out all transmitters, and zeros out their balances.\n  //\n  // It's much more gas-efficient to do this as a single operation, to avoid\n  // hitting storage too much.\n  function _payOracles()\n    internal\n  {\n    unchecked {\n      LinkTokenInterface linkToken = s_linkToken;\n      uint32 latestAggregatorRoundId = s_hotVars.latestAggregatorRoundId;\n      uint32[maxNumOracles] memory rewardFromAggregatorRoundId = s_rewardFromAggregatorRoundId;\n      address[] memory transmitters = s_transmittersList;\n      for (uint transmitteridx = 0; transmitteridx < transmitters.length; transmitteridx++) {\n        uint256 reimbursementAmountJuels = s_transmitters[transmitters[transmitteridx]].paymentJuels;\n        s_transmitters[transmitters[transmitteridx]].paymentJuels = 0;\n        uint256 obsCount = latestAggregatorRoundId - rewardFromAggregatorRoundId[transmitteridx];\n        uint256 juelsAmount =\n          obsCount * uint256(s_hotVars.observationPaymentGjuels) * (1 gwei) + reimbursementAmountJuels;\n        if (juelsAmount > 0) {\n            address payee = s_payees[transmitters[transmitteridx]];\n            // Poses no re-entrancy issues, because LINK.transfer does not yield\n            // control flow.\n            require(linkToken.transfer(payee, juelsAmount), \"insufficient funds\");\n            rewardFromAggregatorRoundId[transmitteridx] = latestAggregatorRoundId;\n            emit OraclePaid(transmitters[transmitteridx], payee, juelsAmount, linkToken);\n          }\n      }\n      // \"Zero\" the accounting storage variables\n      s_rewardFromAggregatorRoundId = rewardFromAggregatorRoundId;\n    }\n  }\n\n  /**\n   * @notice withdraw any available funds left in the contract, up to amount, after accounting for the funds due to participants in past reports\n   * @param recipient address to send funds to\n   * @param amount maximum amount to withdraw, denominated in LINK-wei.\n   * @dev access control provided by billingAccessController\n   */\n  function withdrawFunds(\n    address recipient,\n    uint256 amount\n  )\n    external\n  {\n    require(msg.sender == owner() || s_billingAccessController.hasAccess(msg.sender, msg.data),\n      \"Only owner&billingAdmin can call\");\n    uint256 linkDue = _totalLinkDue();\n    uint256 linkBalance = s_linkToken.balanceOf(address(this));\n    require(linkBalance >= linkDue, \"insufficient balance\");\n    require(s_linkToken.transfer(recipient, _min(linkBalance - linkDue, amount)), \"insufficient funds\");\n  }\n\n  // Total LINK due to participants in past reports (denominated in Juels).\n  function _totalLinkDue()\n    internal\n    view\n    returns (uint256 linkDue)\n  {\n    // Argument for overflow safety: We do all computations in\n    // uint256s. The inputs to linkDue are:\n    // - the <= 31 observation rewards each of which has less than\n    //   64 bits (32 bits for observationPaymentGjuels, 32 bits\n    //   for wei/gwei conversion). Hence 69 bits are sufficient for this part.\n    // - the <= 31 gas reimbursements, each of which consists of at most 96\n    //   bits. Hence 101 bits are sufficient for this part.\n    // So we never need more than 102 bits.\n\n    address[] memory transmitters = s_transmittersList;\n    uint256 n = transmitters.length;\n\n    uint32 latestAggregatorRoundId = s_hotVars.latestAggregatorRoundId;\n    uint32[maxNumOracles] memory rewardFromAggregatorRoundId = s_rewardFromAggregatorRoundId;\n    for (uint i = 0; i < n; i++) {\n      linkDue += latestAggregatorRoundId - rewardFromAggregatorRoundId[i];\n    }\n    // Convert observationPaymentGjuels to uint256, or this overflows!\n    linkDue *= uint256(s_hotVars.observationPaymentGjuels) * (1 gwei);\n    for (uint i = 0; i < n; i++) {\n      linkDue += uint256(s_transmitters[transmitters[i]].paymentJuels);\n    }\n  }\n\n  /**\n   * @notice allows oracles to check that sufficient LINK balance is available\n   * @return availableBalance LINK available on this contract, after accounting for outstanding obligations. can become negative\n   */\n  function linkAvailableForPayment()\n    external\n    view\n    returns (int256 availableBalance)\n  {\n    // there are at most one billion LINK, so this cast is safe\n    int256 balance = int256(s_linkToken.balanceOf(address(this)));\n    // according to the argument in the definition of _totalLinkDue,\n    // _totalLinkDue is never greater than 2**102, so this cast is safe\n    int256 due = int256(_totalLinkDue());\n    // safe from overflow according to above sizes\n    return int256(balance) - int256(due);\n  }\n\n  /**\n   * @notice number of observations oracle is due to be reimbursed for\n   * @param transmitterAddress address used by oracle for signing or transmitting reports\n   */\n  function oracleObservationCount(address transmitterAddress)\n    external\n    view\n    returns (uint32)\n  {\n    Transmitter memory transmitter = s_transmitters[transmitterAddress];\n    if (!transmitter.active) { return 0; }\n    return s_hotVars.latestAggregatorRoundId - s_rewardFromAggregatorRoundId[transmitter.index];\n  }\n\n  /***************************************************************************\n   * Section: Transmitter Payment\n   **************************************************************************/\n\n  // Gas price at which the transmitter should be reimbursed, in gwei/gas\n  function _reimbursementGasPriceGwei(\n    uint256 txGasPriceGwei,\n    uint256 reasonableGasPriceGwei,\n    uint256 maximumGasPriceGwei\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    // this happens on the path for transmissions. we'd rather pay out\n    // a wrong reward than risk a liveness failure due to a revert.\n    unchecked {\n      // Reward the transmitter for choosing an efficient gas price: if they manage\n      // to come in lower than considered reasonable, give them half the savings.\n      uint256 gasPriceGwei = txGasPriceGwei;\n      if (txGasPriceGwei < reasonableGasPriceGwei) {\n        // Give transmitter half the savings for coming in under the reasonable gas price\n        gasPriceGwei += (reasonableGasPriceGwei - txGasPriceGwei) / 2;\n      }\n      // Don't reimburse a gas price higher than maximumGasPriceGwei\n      return _min(gasPriceGwei, maximumGasPriceGwei);\n    }\n  }\n\n  // gas reimbursement due the transmitter, in wei\n  function _transmitterGasCostWei(\n    uint256 initialGas,\n    uint256 gasPriceGwei,\n    uint256 callDataGas,\n    uint256 accountingGas,\n    uint256 leftGas\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    // this happens on the path for transmissions. we'd rather pay out\n    // a wrong reward than risk a liveness failure due to a revert.\n    unchecked {\n      require(initialGas >= leftGas, \"leftGas cannot exceed initialGas\");\n      uint256 usedGas =\n        initialGas - leftGas + // observed gas usage\n        callDataGas + accountingGas; // estimated gas usage\n      uint256 fullGasCostWei = usedGas * gasPriceGwei * (1 gwei);\n      return fullGasCostWei;\n    }\n  }\n\n  function _payTransmitter(\n    HotVars memory hotVars,\n    int192 juelsPerFeeCoin,\n    uint32 initialGas,\n    address transmitter\n  )\n    internal\n    virtual\n  {\n    // this happens on the path for transmissions. we'd rather pay out\n    // a wrong reward than risk a liveness failure due to a revert.\n    unchecked {\n      // we can't deal with negative juelsPerFeeCoin, better to just not pay\n      if (juelsPerFeeCoin < 0) {\n        return;\n      }\n\n      // Reimburse transmitter of the report for gas usage\n      uint256 gasPriceGwei = _reimbursementGasPriceGwei(\n        tx.gasprice / (1 gwei), // convert to ETH-gwei units\n        hotVars.reasonableGasPriceGwei,\n        hotVars.maximumGasPriceGwei\n      );\n      // The following is only an upper bound, as it ignores the cheaper cost for\n      // 0 bytes. Safe from overflow, because calldata just isn't that long.\n      uint256 callDataGasCost = 16 * msg.data.length;\n      uint256 gasLeft = gasleft();\n      uint256 gasCostEthWei = _transmitterGasCostWei(\n        uint256(initialGas),\n        gasPriceGwei,\n        callDataGasCost,\n        hotVars.accountingGas,\n        gasLeft\n      );\n\n      // Even if we assume absurdly large values, this still does not overflow. With\n      // - usedGas <= 1'000'000 gas <= 2**20 gas\n      // - weiPerGas <= 1'000'000 gwei <= 2**50 wei\n      // - hence gasCostEthWei <= 2**70\n      // - juelsPerFeeCoin <= 2**96 (more than the entire supply)\n      // we still fit into 166 bits\n      uint256 gasCostJuels = (gasCostEthWei * uint192(juelsPerFeeCoin))/1e18;\n\n      uint96 oldTransmitterPaymentJuels = s_transmitters[transmitter].paymentJuels;\n      uint96 newTransmitterPaymentJuels = uint96(uint256(oldTransmitterPaymentJuels) +\n        gasCostJuels + uint256(hotVars.transmissionPaymentGjuels) * (1 gwei));\n\n      // overflow *should* never happen, but if it does, let's not persist it.\n      if (newTransmitterPaymentJuels < oldTransmitterPaymentJuels) {\n        return;\n      }\n      s_transmitters[transmitter].paymentJuels = newTransmitterPaymentJuels;\n    }\n  }\n\n  /***************************************************************************\n   * Section: Payee Management\n   **************************************************************************/\n\n  // Addresses at which oracles want to receive payments, by transmitter address\n  mapping (address /* transmitter */ => address /* payment address */)\n    internal\n    s_payees;\n\n  // Payee addresses which must be approved by the owner\n  mapping (address /* transmitter */ => address /* payment address */)\n    internal\n    s_proposedPayees;\n\n  /**\n   * @notice emitted when a transfer of an oracle's payee address has been initiated\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param current the payee address for the oracle, prior to this setting\n   * @param proposed the proposed new payee address for the oracle\n   */\n  event PayeeshipTransferRequested(\n    address indexed transmitter,\n    address indexed current,\n    address indexed proposed\n  );\n\n  /**\n   * @notice emitted when a transfer of an oracle's payee address has been completed\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param current the payee address for the oracle, prior to this setting\n   */\n  event PayeeshipTransferred(\n    address indexed transmitter,\n    address indexed previous,\n    address indexed current\n  );\n\n  /**\n   * @notice sets the payees for transmitting addresses\n   * @param transmitters addresses oracles use to transmit the reports\n   * @param payees addresses of payees corresponding to list of transmitters\n   * @dev must be called by owner\n   * @dev cannot be used to change payee addresses, only to initially populate them\n   */\n  function setPayees(\n    address[] calldata transmitters,\n    address[] calldata payees\n  )\n    external\n    onlyOwner()\n  {\n    require(transmitters.length == payees.length, \"transmitters.size != payees.size\");\n\n    for (uint i = 0; i < transmitters.length; i++) {\n      address transmitter = transmitters[i];\n      address payee = payees[i];\n      address currentPayee = s_payees[transmitter];\n      bool zeroedOut = currentPayee == address(0);\n      require(zeroedOut || currentPayee == payee, \"payee already set\");\n      s_payees[transmitter] = payee;\n\n      if (currentPayee != payee) {\n        emit PayeeshipTransferred(transmitter, currentPayee, payee);\n      }\n    }\n  }\n\n  /**\n   * @notice first step of payeeship transfer (safe transfer pattern)\n   * @param transmitter transmitter address of oracle whose payee is changing\n   * @param proposed new payee address\n   * @dev can only be called by payee address\n   */\n  function transferPayeeship(\n    address transmitter,\n    address proposed\n  )\n    external\n  {\n    require(msg.sender == s_payees[transmitter], \"only current payee can update\");\n    require(msg.sender != proposed, \"cannot transfer to self\");\n\n    address previousProposed = s_proposedPayees[transmitter];\n    s_proposedPayees[transmitter] = proposed;\n\n    if (previousProposed != proposed) {\n      emit PayeeshipTransferRequested(transmitter, msg.sender, proposed);\n    }\n  }\n\n  /**\n   * @notice second step of payeeship transfer (safe transfer pattern)\n   * @param transmitter transmitter address of oracle whose payee is changing\n   * @dev can only be called by proposed new payee address\n   */\n  function acceptPayeeship(\n    address transmitter\n  )\n    external\n  {\n    require(msg.sender == s_proposedPayees[transmitter], \"only proposed payees can accept\");\n\n    address currentPayee = s_payees[transmitter];\n    s_payees[transmitter] = msg.sender;\n    s_proposedPayees[transmitter] = address(0);\n\n    emit PayeeshipTransferred(transmitter, currentPayee, msg.sender);\n  }\n\n  /***************************************************************************\n   * Section: TypeAndVersionInterface\n   **************************************************************************/\n\n  function typeAndVersion()\n    external\n    override\n    pure\n    virtual\n    returns (string memory)\n  {\n    return \"OCR2Aggregator 1.0.0\";\n  }\n\n  /***************************************************************************\n   * Section: Helper Functions\n   **************************************************************************/\n\n  function _min(\n    uint256 a,\n    uint256 b\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    unchecked {\n      if (a < b) { return a; }\n      return b;\n    }\n  }\n}\n"
    },
    "src/OCRConfigurationStoreEVMSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./lib/ConfigDigestUtilEVMSimple.sol\";\nimport \"./OwnerIsCreator.sol\";\nimport \"./OCR2Abstract.sol\";\n\n/// @title OCRConfigurationStoreEVMSimple\n/// @notice This contract stores configurations for protocol versions OCR2 and\n/// above in contract storage. It uses the \"EVMSimple\" config digester.\ncontract OCRConfigurationStoreEVMSimple is TypeAndVersionInterface {\n\n    struct ConfigurationEVMSimple {\n        address[] signers;\n        address[] transmitters;\n        bytes onchainConfig;\n        bytes offchainConfig;\n        address contractAddress;\n        uint64 offchainConfigVersion;\n        uint32 configCount;\n        uint8 f;\n    }\n\n    /// @notice a list of configurations keyed by their digest\n    mapping(bytes32 => ConfigurationEVMSimple) internal s_configurations;\n\n    /// @notice emitted when a new configuration is added\n    event NewConfiguration(bytes32 indexed configDigest);\n\n    /// @notice adds a new configuration to the store\n    function addConfig(ConfigurationEVMSimple calldata configuration) external returns (bytes32) {\n\n        bytes32 configDigest = ConfigDigestUtilEVMSimple.configDigestFromConfigData(\n            block.chainid,\n            configuration.contractAddress,\n            configuration.configCount,\n            configuration.signers,\n            configuration.transmitters,\n            configuration.f,\n            configuration.onchainConfig,\n            configuration.offchainConfigVersion,\n            configuration.offchainConfig\n        );\n\n        s_configurations[configDigest] = configuration;\n\n        emit NewConfiguration(configDigest);\n\n        return configDigest;\n    }\n\n    /// @notice reads a configuration from the store\n    function readConfig(bytes32 configDigest) external view returns (ConfigurationEVMSimple memory) {\n        return s_configurations[configDigest];\n    }\n\n    /// @inheritdoc TypeAndVersionInterface\n    function typeAndVersion() external override pure virtual returns (string memory)\n    {\n        return \"OCRConfigurationStoreEVMSimple 1.0.0\";\n    }\n}\n"
    },
    "src/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwner.sol\";\n\n/**\n * @title The OwnerIsCreator contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract OwnerIsCreator is ConfirmedOwner {\n\n  constructor(\n  )\n    ConfirmedOwner(\n      msg.sender\n    )\n  {\n  }\n\n}"
    },
    "src/SimpleReadAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SimpleWriteAccessController.sol\";\n\n/**\n * @title SimpleReadAccessController\n * @notice Gives access to:\n * - any externally owned account (note that offchain actors can always read\n * any contract storage regardless of onchain access control measures, so this\n * does not weaken the access control while improving usability)\n * - accounts explicitly added to an access list\n * @dev SimpleReadAccessController is not suitable for access controlling writes\n * since it grants any externally owned account access! See\n * SimpleWriteAccessController for that.\n */\ncontract SimpleReadAccessController is SimpleWriteAccessController {\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory _calldata\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\n  }\n\n}\n"
    },
    "src/SimpleWriteAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OwnerIsCreator.sol\";\nimport \"./interfaces/AccessControllerInterface.sol\";\n\n/**\n * @title SimpleWriteAccessController\n * @notice Gives access to accounts explicitly added to an access list by the\n * controller's owner.\n * @dev does not make any special permissions for externally, see\n * SimpleReadAccessController for that.\n */\ncontract SimpleWriteAccessController is AccessControllerInterface, OwnerIsCreator {\n\n  bool public checkEnabled;\n  mapping(address => bool) internal accessList;\n\n  event AddedAccess(address user);\n  event RemovedAccess(address user);\n  event CheckAccessEnabled();\n  event CheckAccessDisabled();\n\n  constructor()\n  // TODO\n  // this is modified from the version in the Chainlink monorepo\n  //  OwnerIsCreator()\n  {\n    checkEnabled = true;\n  }\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return accessList[_user] || !checkEnabled;\n  }\n\n  /**\n   * @notice Adds an address to the access list\n   * @param _user The address to add\n   */\n  function addAccess(address _user)\n    external\n    onlyOwner()\n  {\n    if (!accessList[_user]) {\n      accessList[_user] = true;\n\n      emit AddedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice Removes an address from the access list\n   * @param _user The address to remove\n   */\n  function removeAccess(address _user)\n    external\n    onlyOwner()\n  {\n    if (accessList[_user]) {\n      accessList[_user] = false;\n\n      emit RemovedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice makes the access check enforced\n   */\n  function enableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (!checkEnabled) {\n      checkEnabled = true;\n\n      emit CheckAccessEnabled();\n    }\n  }\n\n  /**\n   * @notice makes the access check unenforced\n   */\n  function disableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (checkEnabled) {\n      checkEnabled = false;\n\n      emit CheckAccessDisabled();\n    }\n  }\n\n  /**\n   * @dev reverts if the caller does not have access\n   */\n  modifier checkAccess() {\n    require(hasAccess(msg.sender, msg.data), \"No access\");\n    _;\n  }\n}\n"
    },
    "src/interfaces/AccessControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AccessControllerInterface {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n"
    },
    "src/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}"
    },
    "src/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "src/interfaces/AggregatorValidatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorValidatorInterface {\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external returns (bool);\n}"
    },
    "src/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "src/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner()\n    external\n    returns (\n      address\n    );\n\n  function transferOwnership(\n    address recipient\n  )\n    external;\n\n  function acceptOwnership()\n    external;\n}\n"
    },
    "src/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface TypeAndVersionInterface{\n  function typeAndVersion()\n    external\n    pure\n    returns (string memory);\n}"
    },
    "src/lib/ConfigDigestUtilEVMSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\n/// @title ConfigDigestUtilEVMSimple\n/// @notice ConfigDigest related utility functions for \"EVMSimple\" config\n/// digester\nlibrary ConfigDigestUtilEVMSimple {\n\n    function configDigestFromConfigData(\n        uint256 chainId,\n        address contractAddress,\n        uint64 configCount,\n        address[] memory signers,\n        address[] memory transmitters,\n        uint8 f,\n        bytes memory onchainConfig,\n        uint64 offchainConfigVersion,\n        bytes memory offchainConfig\n    ) internal pure returns (bytes32)\n    {\n        uint256 hash = uint256(\n            keccak256(\n                abi.encode(\n                    chainId,\n                    contractAddress,\n                    configCount,\n                    signers,\n                    transmitters,\n                    f,\n                    onchainConfig,\n                    offchainConfigVersion,\n                    offchainConfig\n        )));\n\n        uint256 prefixMask = type(uint256).max << (256-16); // 0xFFFF00..00\n        uint256 prefix = 0x0001 << (256-16); // 0x000100..00\n\n        return bytes32((prefix & prefixMask) | (hash & ~prefixMask));\n    }\n\n}"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}}