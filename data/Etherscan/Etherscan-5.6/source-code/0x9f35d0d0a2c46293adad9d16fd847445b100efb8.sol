{{
  "language": "Solidity",
  "sources": {
    "contracts/Dependencies/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Base {\n    // --- Registered contracts ---\n\n    enum Contract {\n        ETHKey,\n        ETHMI,\n        Treasury\n    }\n}\n"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Dependencies/Base.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Interfaces/IRegistry.sol\";\n\ncontract Registry is IRegistry, Ownable {\n    // --- Data ---\n\n    mapping(Base.Contract => address) private contracts;\n    int256 counter = 0;\n\n    // --- Constructor ---\n\n    constructor() Ownable(msg.sender) {}\n\n    // --- External Functions ---\n\n    //This initializes the contract and locks in the system forever\n    function setupContractAddress(Base.Contract name, address _addr)\n        external\n        override\n        onlyOwner\n    {\n        //This locks contract after setting initial values\n        require(counter < 3, \"Contracts already registered\");\n        contracts[name] = _addr;\n        counter += 1;\n    }\n\n    function getContractAddress(Base.Contract name)\n        external\n        view\n        override\n        returns (address)\n    {\n        return contracts[name];\n    }\n}\n"
    },
    "contracts/Dependencies/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * Based on OpenZeppelin's Ownable contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n *\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor(address _address) {\n    _owner = _address;\n    emit OwnershipTransferred(address(0), _address);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   *\n   * NOTE: This function is not safe, as it doesnâ€™t check owner is calling it.\n   * Make sure you check it before calling it.\n   */\n  function _renounceOwnership() internal {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n}\n"
    },
    "contracts/Interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Dependencies/Base.sol\";\n\n/**\n * @notice Manages contracts registry\n */\ninterface IRegistry {\n  // --- Functions --\n\n  function setupContractAddress(Base.Contract name, address _addr) external;\n\n  function getContractAddress(Base.Contract name)\n    external\n    view\n    returns (address);\n}"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./Dependencies/Context.sol\";\nimport \"./Dependencies/DSMath.sol\";\nimport \"./Interfaces/IETHKey.sol\";\nimport \"./Interfaces/IETHMicro.sol\";\nimport \"./Interfaces/IRegistry.sol\";\n\npragma solidity ^0.8.0;\n\ncontract Treasury is Context, DSMath {\n    uint256 private initializationCount;\n    uint256 private excessETHKeySupply;\n\n    IETHMicro public ethmi;\n    IETHKey public ethKey;\n    IRegistry public registry;\n\n    constructor(uint256 excess) {\n        initializationCount = 0;\n        excessETHKeySupply = excess;\n    }\n\n    event Deposit(address indexed _from, uint256 _ethmi, uint256 _ethKey);\n\n    event Withdrawl(address indexed _to, uint256 _ether);\n\n    //Initialize initial addresses and then lock it forever\n    function initializeContract(address ethmiAddress, address ethKeyAddress) external {\n        require(\n            initializationCount == 0,\n            \"Contract can only be initialized once\"\n        );\n\n        //initialize ethmi contract\n        ethmi = IETHMicro(ethmiAddress);\n\n        //initialize ethKey contract\n        ethKey = IETHKey(ethKeyAddress);\n\n        initializationCount += 1;\n    }\n\n    function getExcessETHKey() external view returns (uint256){\n        return excessETHKeySupply;\n    }\n\n    function deposit() external payable {\n        uint256 tokenCount = (msg.value * 1000);\n\n        uint256 depositTxFee = (tokenCount * 2) / 100;\n\n        ethmi.mint(msg.sender, tokenCount, depositTxFee);\n\n        if (excessETHKeySupply > 0) {\n            uint256 tier1 = 85000000 ether;\n            uint256 tier3 = 4;\n            uint256 tier4 = 3;\n            uint256 tier5 = 2;\n            if (\n                excessETHKeySupply <= 100000000 ether &&\n                excessETHKeySupply > 15000000 ether\n            ) {\n                ethKey.mint(msg.sender, tokenCount + tier1, depositTxFee);\n                excessETHKeySupply -= tier1;\n            } else if (\n                excessETHKeySupply <= 15000000 ether &&\n                excessETHKeySupply > 10000000 ether\n            ) {\n                ethKey.mint(msg.sender, tokenCount * tier3, depositTxFee);\n                excessETHKeySupply -= ((tokenCount * tier3) - tokenCount);\n            } else if (\n                excessETHKeySupply <= 10000000 ether &&\n                excessETHKeySupply > 5000000 ether\n            ) {\n                ethKey.mint(msg.sender, tokenCount * tier4, depositTxFee);\n                excessETHKeySupply -= ((tokenCount * tier4) - tokenCount);\n            }\n            else if (\n                excessETHKeySupply <= 5000000 ether &&\n                excessETHKeySupply > 0 ether\n            ) {\n                if (excessETHKeySupply >= ((tokenCount * tier5) - tokenCount)) {\n                    ethKey.mint(msg.sender, tokenCount * tier5, depositTxFee);\n                    excessETHKeySupply -= ((tokenCount * tier5) - tokenCount);\n                } else {\n                    ethKey.mint(msg.sender, tokenCount + excessETHKeySupply, depositTxFee);\n                    excessETHKeySupply = 0;\n                }\n            }\n        } else {\n            ethKey.mint(msg.sender, tokenCount, depositTxFee);\n        }\n\n        emit Deposit(msg.sender, (tokenCount - depositTxFee), tokenCount);\n    }\n\n    function withdraw(uint256 amount) external {\n        address payable sender = payable(msg.sender);\n\n        require(\n            ethmi.balanceOf(sender) >= amount,\n            \"Insufficient ETH Micro balance\"\n        );\n        require(\n            ethKey.balanceOf(sender) >= amount,\n            \"Insufficient ETH Key Balance\"\n        );\n\n        ethmi.burn(sender, amount);\n        ethKey.burn(sender, amount);\n\n        sender.transfer(amount / 1000);\n\n        emit Withdrawl(sender, (amount / 1000));\n    }\n}\n"
    },
    "contracts/Dependencies/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/Dependencies/DSMath.sol": {
      "content": "// SPDX-License-Identifier: GNU\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >0.4.13;\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    uint256 constant WAD = 10**18;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n}\n"
    },
    "contracts/Interfaces/IETHKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./IERC20.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IETHKey is IERC20 {\n    // --- Events ---\n\n    // --- Functions ---\n\n    function mint(\n        address _account,\n        uint256 _amount,\n        uint256 _mintFee\n    ) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function setRate(uint256 amount) external;\n}\n"
    },
    "contracts/Interfaces/IETHMicro.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./IERC20.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IETHMicro is IERC20 {\n    // --- Events ---\n\n    // --- Functions ---\n\n    function mint(\n        address _account,\n        uint256 _amount,\n        uint256 _mintFee\n    ) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function transferRewards(address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n"
    },
    "contracts/Interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/ETHMicro.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/IETHMicro.sol\";\nimport \"./Interfaces/IRegistry.sol\";\nimport \"./Interfaces/IETHKey.sol\";\nimport \"./Dependencies/DSMath.sol\";\nimport \"./Interfaces/ITreasury.sol\";\nimport \"./Dependencies/Context.sol\";\nimport \"./Dependencies/Base.sol\";\n\npragma solidity ^0.8.0;\n\ncontract ETHMicro is IETHMicro, Context, DSMath {\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) private _reflectedBalances;\n    mapping(address => uint256) private _rates;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint256 private globalRate;\n\n    uint256 private initializationCount;\n\n    IETHKey public ethKey;\n    ITreasury public treasury;\n    IRegistry public registry;\n\n    string private _name = \"ETH Micro\";\n    string private _symbol = \"ETHMI\";\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() {\n        initializationCount = 0;\n        globalRate = 1 ether;\n    }\n\n    function initializeContract(address ethKeyAddress, address treasuryAddress) external {\n        require(\n            initializationCount == 0,\n            \"Contract can only be initialized once\"\n        );\n        ethKey = IETHKey(ethKeyAddress);\n        treasury = ITreasury(treasuryAddress);\n        initializationCount += 1;\n    }\n\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 mintFee\n    ) external override onlyTreasury {\n        assert(account != address(0));\n        _mint(account, amount, mintFee);\n    }\n\n    function burn(address account, uint256 amount)\n        external\n        override\n        onlyTreasury\n    {\n        assert(account != address(0));\n        _burn(account, amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function getRate(address account) public view returns (uint256) {\n        if (account != address(ethKey) && account != address(this)) {\n            return (globalRate - _rates[account]);\n        } else {\n            return 1 ether;\n        }\n\n    }\n\n\n    function getGlobalRate() public view returns (uint256) {\n        return globalRate;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        if (account == address(this) || account == address(ethKey)) {\n            return _reflectedBalances[account];\n        }\n        return wmul(_balances[account], globalRate - _rates[account]);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferRewards(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        onlyETHKey\n        returns (bool)\n    {\n        _transferRewards(address(ethKey), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != sender, \"ERC20: recipient cannot be the same as sender\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(\n            _reflectedBalances[sender] >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        uint256 senderRate = _rates[sender];\n        uint256 recipientRate = _rates[recipient];\n        if (recipientRate == 0 && _reflectedBalances[recipient] == 0) {\n            recipientRate = globalRate - 1 ether;\n        }\n\n        uint256 contractBalance = _reflectedBalances[address(this)];\n        uint256 ethKeyContractBalance = _reflectedBalances[address(ethKey)];\n\n        uint256 txFee = amount / 160;\n        uint256 microShare = (txFee / 100) * 60;\n        uint256 keyShare = (txFee / 100) * 40;\n\n        contractBalance += microShare;\n        ethKeyContractBalance += keyShare;\n\n\n        uint256 recipientBalance = _balances[recipient];\n        uint256 senderBalance = _balances[sender];\n        recipientBalance += (wdiv(( amount - txFee),(globalRate - recipientRate)));\n        senderBalance -= wdiv(amount, (globalRate - senderRate));\n\n        uint256 effectiveSupply = _totalSupply -\n        contractBalance -\n        ethKeyContractBalance - recipientBalance;\n\n        if (senderBalance < effectiveSupply) {\n            effectiveSupply -= senderBalance;\n            globalRate +=  wdiv(microShare, effectiveSupply);\n            recipientRate +=  wdiv(microShare, effectiveSupply);\n            senderRate +=  wdiv(microShare, effectiveSupply);\n        }\n\n\n        ethKey.setRate(keyShare);\n        _rates[sender] = senderRate;\n        _rates[recipient] = recipientRate;\n\n\n        _reflectedBalances[sender] -= amount;\n        _balances[sender] = senderBalance;\n        _balances[recipient] = recipientBalance;\n        _reflectedBalances[recipient] += ((amount - txFee));\n        _reflectedBalances[address(this)] = contractBalance;\n        _reflectedBalances[address(ethKey)] = ethKeyContractBalance;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transferRewards(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 effectiveRate = globalRate - _rates[recipient];\n        _balances[recipient] += wdiv(amount,effectiveRate);\n        _reflectedBalances[recipient] += (amount);\n        _reflectedBalances[sender] -= amount;\n        \n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        uint256 mintFee\n    ) internal virtual {\n        require(account != address(0), \"ERC20: cannot mint to the zero address\");\n        require(amount != 0, \"Cannot mint 0 tokens\");\n\n        uint256 userAmount = amount - mintFee;\n        \n        if (_rates[account] == 0 && _reflectedBalances[account] == 0) {\n            _rates[account] = globalRate - 1 ether;\n        }\n\n        uint256 effectiveRate = globalRate - _rates[account];\n        _balances[account] += wdiv(userAmount,effectiveRate);\n            \n        _reflectedBalances[account] += userAmount;\n\n        _reflectedBalances[address(ethKey)] += mintFee;\n\n        _totalSupply += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        require(\n            _reflectedBalances[account] >= amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n\n        uint256 baseAmount;\n        uint256 tempRate = _rates[account];\n        uint256 tempGlobalRate = globalRate;\n\n        if (tempRate <= (tempGlobalRate - 1 ether)) {\n            baseAmount = wdiv(amount, (tempGlobalRate - tempRate));\n        } else {\n            baseAmount = amount;\n            tempRate = tempGlobalRate - 1 ether;\n        }\n\n        _reflectedBalances[account] -= amount;\n        _balances[account] -= baseAmount;\n\n        _reflectedBalances[address(this)] -= (amount - baseAmount);\n        _totalSupply -= amount;\n\n        if (_balances[account] == 0) {\n            _rates[account] = globalRate - 1 ether;\n        } else {\n            _rates[account] = tempRate;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Ensure that msg.sender === Treasury contract address.\n     */\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"Access Denied\");\n        _;\n    }\n\n    /**\n     * @dev Ensure that msg.sender === ETHKey contract address.\n     */\n    modifier onlyETHKey() {\n        require(msg.sender == address(ethKey), \"Access Denied\");\n        _;\n    }\n}\n"
    },
    "contracts/Interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the Treasury Contract\n */\ninterface ITreasury {\n    function deposit() payable external;\n\n    function withdraw(uint amount) payable external;\n}"
    },
    "contracts/ETHKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/IETHKey.sol\";\nimport \"./Interfaces/ITreasury.sol\";\nimport \"./Interfaces/IRegistry.sol\";\nimport \"./Interfaces/IETHMicro.sol\";\nimport \"./Dependencies/Context.sol\";\nimport \"./Dependencies/DSMath.sol\";\nimport \"./Dependencies/Base.sol\";\n\npragma solidity ^0.8.0;\n\ncontract ETHKey is IETHKey, Context, DSMath {\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) private _rates;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string private _name = \"ETH Key\";\n    string private _symbol = \"ETHKEY\";\n\n    uint256 private globalRate;\n    int256 private initializationCount;\n\n    IETHMicro public ethmi;\n    IRegistry public registry;\n    ITreasury public treasury;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() {\n        globalRate = 0;\n        initializationCount = 0;\n    }\n\n    function initializeContract(address ethmiAddress, address treasuryAddress) external {\n        require(\n            initializationCount == 0,\n            \"Contract can only be initialized once\"\n        );\n        ethmi = IETHMicro(ethmiAddress);\n        treasury = ITreasury(treasuryAddress);\n        initializationCount += 1;\n    }\n\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 mintFee\n    ) external override onlyTreasury {\n        assert(account != address(0));\n\n        _mint(account, amount, mintFee);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(address account, uint256 amount)\n        external\n        override\n        onlyTreasury\n    {\n        assert(account != address(0));\n        _burn(account, amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function getRate(address account) public view returns (uint256) {\n        return (globalRate - _rates[account]);\n    }\n\n    function setRate(uint256 amount) public override onlyETHMI {\n        _setRate(amount);\n    }\n\n    function getRewardsBalance(address account) public view returns (uint256) {\n        return wmul(_balances[account], (globalRate - _rates[account]));\n    }\n\n    function getGlobalRate() public view returns (uint256) {\n        return globalRate;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev sets new globalRate with `amount`.\n     *\n     * This internal function is used to set the global rate\n     *\n     *\n     * Requirements:\n     *\n     * - `amount` must be positive.\n     */\n    function _setRate(uint256 amount) internal virtual {\n        (globalRate += wdiv(amount, _totalSupply));\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != sender, \"ERC20: recipient cannot be the same as sender\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n\n        if (_rates[recipient] == 0 && _balances[recipient] == 0) {\n            _rates[recipient] = globalRate;\n        }\n\n        uint256 senderEffectiveRate = (globalRate - _rates[sender]);\n        uint256 recipientBalance = _balances[recipient];\n        uint256 senderRewards = wmul(senderEffectiveRate, amount);\n\n        uint256 effectiveSupply;\n        uint256 senderReceiverBalances = senderBalance + recipientBalance;\n        uint256 capitalAdjustment;\n\n        //If the receiver and sender are the only holders of ETHKey\n        //Then we dont move any rates and just burn the rewards\n        if (senderReceiverBalances >= _totalSupply) {\n            effectiveSupply = 0;\n            capitalAdjustment = 0;\n        } else {\n            effectiveSupply = _totalSupply - senderReceiverBalances;\n            capitalAdjustment = wdiv(senderRewards, effectiveSupply);\n        }\n\n        _balances[recipient] += amount;\n        _balances[sender] -= amount;\n\n        globalRate += capitalAdjustment;\n        _rates[recipient] += capitalAdjustment;\n\n        if (_balances[sender] != 0) {\n            _rates[sender] += capitalAdjustment;\n        } else {\n            _rates[sender] = globalRate;\n        }\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        uint256 mintFee\n    ) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        require(amount != 0, \"You cannot mint 0 tokens\");\n\n        uint256 accountBalance = _balances[account];\n        if (_rates[account] == 0 && accountBalance == 0) {\n            _rates[account] = globalRate;\n        }\n\n        uint256 capitalAdjustment;\n        uint256 tempGlobalRate = globalRate;\n\n\n\n        uint256 effectiveRate = tempGlobalRate - _rates[account];\n        uint256 effectiveSupply = _totalSupply - accountBalance;\n        uint256 rewards = wmul(accountBalance, effectiveRate);\n\n        if (effectiveSupply != 0) {\n            capitalAdjustment = wdiv((mintFee), effectiveSupply);\n        } else {\n            if (_totalSupply == 0) {\n                capitalAdjustment = wdiv((mintFee), amount);\n            } else {\n                capitalAdjustment= wdiv((mintFee), _totalSupply);\n            }\n        }\n        \n        tempGlobalRate += capitalAdjustment;\n        accountBalance += amount;\n\n        if (rewards != 0) {\n            _rates[account] = tempGlobalRate - wdiv(rewards, accountBalance);\n        } else {\n            _rates[account] = tempGlobalRate;\n        }\n\n        _totalSupply += (amount);\n        _balances[account] = (accountBalance);\n        globalRate = tempGlobalRate;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        require(\n            _balances[account] >= amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n\n        //Temporary variables for rates and rewards amounts\n        uint256 tempGlobalRate = globalRate;\n        uint256 tempRate = _rates[account];\n        uint256 effectiveRate = tempGlobalRate - tempRate;\n        uint256 effectiveRewardsAmount = wmul(amount, effectiveRate);\n\n        //Update balances\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n\n        //figure redemption fee, get effective supply and figure capital adjustment\n        uint256 redemptionFee = (effectiveRewardsAmount / 10);\n        uint256 effectiveSupply = (_totalSupply - _balances[account]);\n        uint256 capitalAdjustment;\n        if (effectiveSupply != 0) {\n            capitalAdjustment = wdiv(redemptionFee, effectiveSupply);\n        } else {\n            capitalAdjustment = 0;\n        }\n\n        //Update global rate by capital adjustment to distribute rewards\n        tempGlobalRate += capitalAdjustment;\n\n\n        //If the account balance is over 0 then update their rate accordingly to keep their same effective rate\n        //If it is 0 then reset their effective rate to 0\n        if (_balances[account] != 0) {\n            _rates[account] += capitalAdjustment;\n        } else {\n            _rates[account] = tempGlobalRate;\n        }\n\n        globalRate = tempGlobalRate;\n        //Finally transfer out the rewards\n        ethmi.transferRewards(account, (effectiveRewardsAmount - redemptionFee));\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Ensure that msg.sender === Treasury contract address.\n     */\n    modifier onlyTreasury() {\n        require(msg.sender == address(treasury), \"Access Denied\");\n        _;\n    }\n\n    /**\n     * @dev Ensure that msg.sender === ETHMI contract address.\n     */\n    modifier onlyETHMI() {\n        require(msg.sender == address(ethmi), \"Access Denied\");\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none"
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}