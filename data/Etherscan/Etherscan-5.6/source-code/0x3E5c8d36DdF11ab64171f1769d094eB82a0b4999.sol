{{
  "language": "Solidity",
  "sources": {
    "ERC4626Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"IERC4626.sol\";\n\nimport \"ScaledMath.sol\";\n\nimport \"IOracle.sol\";\nimport \"IController.sol\";\n\ncontract ERC4626Oracle is IOracle {\n    using ScaledMath for uint256;\n\n    IController public controller;\n\n    constructor(IController controller_) {\n        controller = controller_;\n    }\n\n    function getUSDPrice(address token) external view returns (uint256) {\n        IERC4626 vault = IERC4626(token);\n        uint256 assetPrice = controller.priceOracle().getUSDPrice(vault.asset());\n        uint256 rate = vault.convertToAssets(ScaledMath.ONE);\n        return assetPrice.mulDown(rate);\n    }\n\n    function isTokenSupported(address token) external view returns (bool) {\n        if (token == address(0)) return false;\n        try IERC4626(token).asset() returns (address underlying) {\n            return controller.priceOracle().isTokenSupported(underlying);\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "ScaledMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary ScaledMath {\n    uint256 internal constant DECIMALS = 18;\n    uint256 internal constant ONE = 10 ** DECIMALS;\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / ONE;\n    }\n\n    function mulDown(uint256 a, uint256 b, uint256 decimals) internal pure returns (uint256) {\n        return (a * b) / (10 ** decimals);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * ONE) / b;\n    }\n\n    function divDown(uint256 a, uint256 b, uint256 decimals) internal pure returns (uint256) {\n        return (a * 10 ** decimals) / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        return ((a * ONE) - 1) / b + 1;\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        return (a * b) / int256(ONE);\n    }\n\n    function mulDownUint128(uint128 a, uint128 b) internal pure returns (uint128) {\n        return (a * b) / uint128(ONE);\n    }\n\n    function mulDown(int256 a, int256 b, uint256 decimals) internal pure returns (int256) {\n        return (a * b) / int256(10 ** decimals);\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        return (a * int256(ONE)) / b;\n    }\n\n    function divDownUint128(uint128 a, uint128 b) internal pure returns (uint128) {\n        return (a * uint128(ONE)) / b;\n    }\n\n    function divDown(int256 a, int256 b, uint256 decimals) internal pure returns (int256) {\n        return (a * int256(10 ** decimals)) / b;\n    }\n\n    function convertScale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) return a;\n        if (fromDecimals > toDecimals) return downscale(a, fromDecimals, toDecimals);\n        return upscale(a, fromDecimals, toDecimals);\n    }\n\n    function convertScale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        if (fromDecimals == toDecimals) return a;\n        if (fromDecimals > toDecimals) return downscale(a, fromDecimals, toDecimals);\n        return upscale(a, fromDecimals, toDecimals);\n    }\n\n    function upscale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        return a * (10 ** (toDecimals - fromDecimals));\n    }\n\n    function downscale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        return a / (10 ** (fromDecimals - toDecimals));\n    }\n\n    function upscale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        return a * int256(10 ** (toDecimals - fromDecimals));\n    }\n\n    function downscale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        return a / int256(10 ** (fromDecimals - toDecimals));\n    }\n\n    function intPow(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 result = ONE;\n        for (uint256 i; i < n; ) {\n            result = mulDown(result, a);\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a >= b ? a - b : b - a;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n"
    },
    "IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IOracle {\n    event TokenUpdated(address indexed token, address feed, uint256 maxDelay, bool isEthPrice);\n\n    /// @notice returns the price in USD of symbol.\n    function getUSDPrice(address token) external view returns (uint256);\n\n    /// @notice returns if the given token is supported for pricing.\n    function isTokenSupported(address token) external view returns (bool);\n}\n"
    },
    "IController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"IConicPoolWeightManagement.sol\";\nimport \"IConicPool.sol\";\nimport \"IGenericOracle.sol\";\nimport \"IInflationManager.sol\";\nimport \"ILpTokenStaker.sol\";\nimport \"IBonding.sol\";\nimport \"IPoolAdapter.sol\";\nimport \"IFeeRecipient.sol\";\nimport \"ICurveRegistryCache.sol\";\n\ninterface IController {\n    event PoolAdded(address indexed pool);\n    event PoolRemoved(address indexed pool);\n    event PoolShutdown(address indexed pool);\n    event ConvexBoosterSet(address convexBooster);\n    event CurveHandlerSet(address curveHandler);\n    event ConvexHandlerSet(address convexHandler);\n    event CurveRegistryCacheSet(address curveRegistryCache);\n    event InflationManagerSet(address inflationManager);\n    event BondingSet(address bonding);\n    event FeeRecipientSet(address feeRecipient);\n    event PriceOracleSet(address priceOracle);\n    event WeightUpdateMinDelaySet(uint256 weightUpdateMinDelay);\n    event PauseManagerSet(address indexed manager, bool isManager);\n    event MultiDepositsWithdrawsWhitelistSet(address pool, bool allowed);\n    event MinimumTaintedTransferAmountSet(address indexed token, uint256 amount);\n    event DefaultPoolAdapterSet(address poolAdapter);\n    event CustomPoolAdapterSet(address indexed pool, address poolAdapter);\n\n    struct WeightUpdate {\n        address conicPoolAddress;\n        IConicPoolWeightManagement.PoolWeight[] weights;\n    }\n\n    function initialize(address _lpTokenStaker) external;\n\n    // inflation manager\n\n    function inflationManager() external view returns (IInflationManager);\n\n    function setInflationManager(address manager) external;\n\n    // views\n    function curveRegistryCache() external view returns (ICurveRegistryCache);\n\n    // pool adapter\n    function poolAdapterFor(address pool) external view returns (IPoolAdapter);\n\n    function defaultPoolAdapter() external view returns (IPoolAdapter);\n\n    function setDefaultPoolAdapter(address poolAdapter) external;\n\n    function setCustomPoolAdapter(address pool, address poolAdapter) external;\n\n    /// lp token staker\n    function switchLpTokenStaker(address _lpTokenStaker) external;\n\n    function lpTokenStaker() external view returns (ILpTokenStaker);\n\n    // bonding\n    function bonding() external view returns (IBonding);\n\n    function setBonding(address _bonding) external;\n\n    // fees\n    function feeRecipient() external view returns (IFeeRecipient);\n\n    function setFeeRecipient(address _feeRecipient) external;\n\n    // oracle\n    function priceOracle() external view returns (IGenericOracle);\n\n    function setPriceOracle(address oracle) external;\n\n    // pool functions\n\n    function listPools() external view returns (address[] memory);\n\n    function listActivePools() external view returns (address[] memory);\n\n    function isPool(address poolAddress) external view returns (bool);\n\n    function isActivePool(address poolAddress) external view returns (bool);\n\n    function addPool(address poolAddress) external;\n\n    function shutdownPool(address poolAddress) external;\n\n    function removePool(address poolAddress) external;\n\n    function cncToken() external view returns (address);\n\n    function lastWeightUpdate(address poolAddress) external view returns (uint256);\n\n    function updateWeights(WeightUpdate memory update) external;\n\n    function updateAllWeights(WeightUpdate[] memory weights) external;\n\n    // handler functions\n\n    function convexBooster() external view returns (address);\n\n    function curveHandler() external view returns (address);\n\n    function convexHandler() external view returns (address);\n\n    function setConvexBooster(address _convexBooster) external;\n\n    function setCurveHandler(address _curveHandler) external;\n\n    function setConvexHandler(address _convexHandler) external;\n\n    function setCurveRegistryCache(address curveRegistryCache_) external;\n\n    function setWeightUpdateMinDelay(uint256 delay) external;\n\n    function isPauseManager(address account) external view returns (bool);\n\n    function listPauseManagers() external view returns (address[] memory);\n\n    function setPauseManager(address account, bool isManager) external;\n\n    // deposit/withdrawal whitelist\n    function isAllowedMultipleDepositsWithdraws(address poolAddress) external view returns (bool);\n\n    function setAllowedMultipleDepositsWithdraws(address account, bool allowed) external;\n\n    function getMultipleDepositsWithdrawsWhitelist() external view returns (address[] memory);\n\n    // tainted transfer amount\n    function setMinimumTaintedTransferAmount(address token, uint256 amount) external;\n\n    function getMinimumTaintedTransferAmount(address token) external view returns (uint256);\n\n    // constants\n\n    function MAX_WEIGHT_UPDATE_MIN_DELAY() external view returns (uint256);\n\n    function MIN_WEIGHT_UPDATE_MIN_DELAY() external view returns (uint256);\n}\n"
    },
    "IConicPoolWeightManagement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IConicPoolWeightManagement {\n    struct PoolWeight {\n        address poolAddress;\n        uint256 weight;\n    }\n\n    function addPool(address pool) external;\n\n    function removePool(address pool) external;\n\n    function updateWeights(PoolWeight[] memory poolWeights) external;\n\n    function handleDepeggedCurvePool(address curvePool_) external;\n\n    function handleInvalidConvexPid(address pool) external returns (uint256);\n\n    function allPools() external view returns (address[] memory);\n\n    function poolsCount() external view returns (uint256);\n\n    function getPoolAtIndex(uint256 _index) external view returns (address);\n\n    function getWeight(address curvePool) external view returns (uint256);\n\n    function getWeights() external view returns (PoolWeight[] memory);\n\n    function isRegisteredPool(address _pool) external view returns (bool);\n}\n"
    },
    "IConicPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"ILpToken.sol\";\nimport \"IRewardManager.sol\";\nimport \"IOracle.sol\";\nimport \"IController.sol\";\nimport \"IPausable.sol\";\nimport \"IConicPoolWeightManagement.sol\";\n\ninterface IConicPool is IConicPoolWeightManagement, IPausable {\n    event Deposit(\n        address indexed sender,\n        address indexed receiver,\n        uint256 depositedAmount,\n        uint256 lpReceived\n    );\n    event Withdraw(address indexed account, uint256 amount);\n    event NewWeight(address indexed curvePool, uint256 newWeight);\n    event NewMaxIdleCurveLpRatio(uint256 newRatio);\n    event ClaimedRewards(uint256 claimedCrv, uint256 claimedCvx);\n    event HandledDepeggedCurvePool(address curvePool_);\n    event HandledInvalidConvexPid(address curvePool_, uint256 pid_);\n    event CurvePoolAdded(address curvePool_);\n    event CurvePoolRemoved(address curvePool_);\n    event Shutdown();\n    event DepegThresholdUpdated(uint256 newThreshold);\n    event MaxDeviationUpdated(uint256 newMaxDeviation);\n    event RebalancingRewardsEnabledSet(bool enabled);\n    event EmergencyRebalancingRewardFactorUpdated(uint256 factor);\n\n    struct PoolWithAmount {\n        address poolAddress;\n        uint256 amount;\n    }\n\n    function underlying() external view returns (IERC20Metadata);\n\n    function lpToken() external view returns (ILpToken);\n\n    function rewardManager() external view returns (IRewardManager);\n\n    function depegThreshold() external view returns (uint256);\n\n    function maxDeviation() external view returns (uint256);\n\n    function maxIdleCurveLpRatio() external view returns (uint256);\n\n    function setMaxIdleCurveLpRatio(uint256 value) external;\n\n    function setMaxDeviation(uint256 maxDeviation_) external;\n\n    function updateDepegThreshold(uint256 value) external;\n\n    function depositFor(\n        address _account,\n        uint256 _amount,\n        uint256 _minLpReceived,\n        bool stake\n    ) external returns (uint256);\n\n    function deposit(uint256 _amount, uint256 _minLpReceived) external returns (uint256);\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minLpReceived,\n        bool stake\n    ) external returns (uint256);\n\n    function exchangeRate() external view returns (uint256);\n\n    function usdExchangeRate() external view returns (uint256);\n\n    function unstakeAndWithdraw(uint256 _amount, uint256 _minAmount) external returns (uint256);\n\n    function unstakeAndWithdraw(\n        uint256 _amount,\n        uint256 _minAmount,\n        address _to\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, uint256 _minAmount) external returns (uint256);\n\n    function withdraw(uint256 _amount, uint256 _minAmount, address _to) external returns (uint256);\n\n    function getAllocatedUnderlying() external view returns (PoolWithAmount[] memory);\n\n    function rebalancingRewardActive() external view returns (bool);\n\n    function totalDeviationAfterWeightUpdate() external view returns (uint256);\n\n    function computeTotalDeviation() external view returns (uint256);\n\n    /// @notice returns the total amount of funds held by this pool in terms of underlying\n    function totalUnderlying() external view returns (uint256);\n\n    function getTotalAndPerPoolUnderlying()\n        external\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        );\n\n    /// @notice same as `totalUnderlying` but returns a cached version\n    /// that might be slightly outdated if oracle prices have changed\n    /// @dev this is useful in cases where we want to reduce gas usage and do\n    /// not need a precise value\n    function cachedTotalUnderlying() external view returns (uint256);\n\n    function updateRewardSpendingApproval(address token, bool approved) external;\n\n    function shutdownPool() external;\n\n    function isShutdown() external view returns (bool);\n\n    function isBalanced() external view returns (bool);\n\n    function rebalancingRewardsEnabled() external view returns (bool);\n\n    function setRebalancingRewardsEnabled(bool enabled) external;\n\n    function getAllUnderlyingCoins() external view returns (address[] memory result);\n\n    function rebalancingRewardsFactor() external view returns (uint256);\n\n    function rebalancingRewardsActivatedAt() external view returns (uint64);\n\n    function getWeights() external view returns (PoolWeight[] memory);\n\n    function runSanityChecks() external;\n}\n"
    },
    "ILpToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"IERC20Metadata.sol\";\n\ninterface ILpToken is IERC20Metadata {\n    function minter() external view returns (address);\n\n    function mint(address account, uint256 amount, address ubo) external returns (uint256);\n\n    function burn(address _owner, uint256 _amount, address ubo) external returns (uint256);\n\n    function taint(address from, address to, uint256 amount) external;\n}\n"
    },
    "IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IRewardManager {\n    event ClaimedRewards(uint256 claimedCrv, uint256 claimedCvx);\n    event SoldRewardTokens(uint256 targetTokenReceived);\n    event ExtraRewardAdded(address reward);\n    event ExtraRewardRemoved(address reward);\n    event ExtraRewardsCurvePoolSet(address extraReward, address curvePool);\n    event FeesSet(uint256 feePercentage);\n    event FeesEnabled(uint256 feePercentage);\n    event EarningsClaimed(\n        address indexed claimedBy,\n        uint256 cncEarned,\n        uint256 crvEarned,\n        uint256 cvxEarned\n    );\n\n    function accountCheckpoint(address account) external;\n\n    function poolCheckpoint() external returns (bool);\n\n    function addExtraReward(address reward) external returns (bool);\n\n    function addBatchExtraRewards(address[] memory rewards) external;\n\n    function conicPool() external view returns (address);\n\n    function setFeePercentage(uint256 _feePercentage) external;\n\n    function claimableRewards(\n        address account\n    ) external view returns (uint256 cncRewards, uint256 crvRewards, uint256 cvxRewards);\n\n    function claimEarnings() external returns (uint256, uint256, uint256);\n\n    function claimPoolEarningsAndSellRewardTokens() external;\n\n    function feePercentage() external view returns (uint256);\n\n    function feesEnabled() external view returns (bool);\n}\n"
    },
    "IPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"Ownable.sol\";\n\nimport \"IController.sol\";\n\ninterface IPausable {\n    event Paused(uint256 pausedUntil);\n    event PauseDurationSet(uint256 pauseDuration);\n\n    function controller() external view returns (IController);\n\n    function pausedUntil() external view returns (uint256);\n\n    function pauseDuration() external view returns (uint256);\n\n    function isPaused() external view returns (bool);\n\n    function setPauseDuration(uint256 _pauseDuration) external;\n\n    function pause() external;\n}\n"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "IGenericOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"IOracle.sol\";\n\ninterface IGenericOracle is IOracle {\n    /// @notice returns the oracle to be used to price `token`\n    function getOracle(address token) external view returns (IOracle);\n\n    /// @notice converts the price of an LP token to the given underlying\n    function curveLpToUnderlying(\n        address curveLpToken,\n        address underlying,\n        uint256 curveLpAmount\n    ) external view returns (uint256);\n\n    /// @notice same as above but avoids fetching the underlying price again\n    function curveLpToUnderlying(\n        address curveLpToken,\n        address underlying,\n        uint256 curveLpAmount,\n        uint256 underlyingPrice\n    ) external view returns (uint256);\n\n    /// @notice converts the price an underlying asset to a given Curve LP token\n    function underlyingToCurveLp(\n        address underlying,\n        address curveLpToken,\n        uint256 underlyingAmount\n    ) external view returns (uint256);\n}\n"
    },
    "IInflationManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IInflationManager {\n    event TokensClaimed(address indexed pool, uint256 cncAmount);\n    event RebalancingRewardHandlerAdded(address indexed pool, address indexed handler);\n    event RebalancingRewardHandlerRemoved(address indexed pool, address indexed handler);\n    event PoolWeightsUpdated();\n\n    function executeInflationRateUpdate() external;\n\n    function updatePoolWeights() external;\n\n    /// @notice returns the weights of the Conic pools to know how much inflation\n    /// each of them will receive, as well as the total amount of USD value in all the pools\n    function computePoolWeights()\n        external\n        view\n        returns (address[] memory _pools, uint256[] memory poolWeights, uint256 totalUSDValue);\n\n    function computePoolWeight(\n        address pool\n    ) external view returns (uint256 poolWeight, uint256 totalUSDValue);\n\n    function currentInflationRate() external view returns (uint256);\n\n    function getCurrentPoolInflationRate(address pool) external view returns (uint256);\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external;\n\n    function addPoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external;\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external;\n\n    function rebalancingRewardHandlers(\n        address poolAddress\n    ) external view returns (address[] memory);\n\n    function hasPoolRebalancingRewardHandler(\n        address poolAddress,\n        address handler\n    ) external view returns (bool);\n}\n"
    },
    "ILpTokenStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface ILpTokenStaker {\n    event LpTokenStaked(address indexed account, uint256 amount);\n    event LpTokenUnstaked(address indexed account, uint256 amount);\n    event TokensClaimed(address indexed pool, uint256 cncAmount);\n    event Shutdown();\n\n    function stake(uint256 amount, address conicPool) external;\n\n    function unstake(uint256 amount, address conicPool) external;\n\n    function stakeFor(uint256 amount, address conicPool, address account) external;\n\n    function unstakeFor(uint256 amount, address conicPool, address account) external;\n\n    function unstakeFrom(uint256 amount, address account) external;\n\n    function getUserBalanceForPool(\n        address conicPool,\n        address account\n    ) external view returns (uint256);\n\n    function getBalanceForPool(address conicPool) external view returns (uint256);\n\n    function updateBoost(address user) external;\n\n    function claimCNCRewardsForPool(address pool) external;\n\n    function claimableCnc(address pool) external view returns (uint256);\n\n    function checkpoint(address pool) external returns (uint256);\n\n    function shutdown() external;\n\n    function getBoost(address user) external view returns (uint256);\n\n    function isShutdown() external view returns (bool);\n}\n"
    },
    "IBonding.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IBonding {\n    event CncStartPriceSet(uint256 startPrice);\n    event PriceIncreaseFactorSet(uint256 factor);\n    event MinBondingAmountSet(uint256 amount);\n    event Bonded(\n        address indexed account,\n        address indexed recipient,\n        uint256 lpTokenAmount,\n        uint256 cncReceived,\n        uint256 lockTime\n    );\n    event DebtPoolSet(address indexed pool);\n    event DebtPoolFeesClaimed(uint256 crvAmount, uint256 cvxAmount, uint256 cncAmount);\n    event StreamClaimed(address indexed account, uint256 amount);\n    event BondingStarted(uint256 amount, uint256 epochs);\n    event RemainingCNCRecovered(uint256 amount);\n\n    function startBonding() external;\n\n    function setCncStartPrice(uint256 _cncStartPrice) external;\n\n    function setCncPriceIncreaseFactor(uint256 _priceIncreaseFactor) external;\n\n    function setMinBondingAmount(uint256 _minBondingAmount) external;\n\n    function setDebtPool(address _debtPool) external;\n\n    function bondCncCrvUsd(\n        uint256 lpTokenAmount,\n        uint256 minCncReceived,\n        uint64 cncLockTime\n    ) external returns (uint256);\n\n    function recoverRemainingCNC() external;\n\n    function claimStream() external;\n\n    function claimFeesForDebtPool() external;\n\n    function streamCheckpoint() external;\n\n    function accountCheckpoint(address account) external;\n\n    function computeCurrentCncBondPrice() external view returns (uint256);\n\n    function cncAvailable() external view returns (uint256);\n\n    function cncBondPrice() external view returns (uint256);\n\n    function bondCncCrvUsdFor(\n        uint256 lpTokenAmount,\n        uint256 minCncReceived,\n        uint64 cncLockTime,\n        address recipient\n    ) external returns (uint256);\n}\n"
    },
    "IPoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IPoolAdapter {\n    /// @notice This is to set which LP token price the value computation should use\n    /// `Latest` uses a freshly computed price\n    /// `Cached` uses the price in cache\n    /// `Minimum` uses the minimum of these two\n    enum PriceMode {\n        Latest,\n        Cached,\n        Minimum\n    }\n\n    /// @notice Deposit `underlyingAmount` of `underlying` into `pool`\n    /// @dev This function should be written with the assumption that it will be delegate-called into\n    function deposit(address pool, address underlying, uint256 underlyingAmount) external;\n\n    /// @notice Withdraw `underlyingAmount` of `underlying` from `pool`\n    /// @dev This function should be written with the assumption that it will be delegate-called into\n    function withdraw(address pool, address underlying, uint256 underlyingAmount) external;\n\n    /// @notice Returns the amount of of assets that `conicPool` holds in `pool`, in terms of USD\n    function computePoolValueInUSD(\n        address conicPool,\n        address pool\n    ) external view returns (uint256 usdAmount);\n\n    /// @notice Updates the price caches of the given pools\n    function updatePriceCache(address pool) external;\n\n    /// @notice Returns the amount of of assets that `conicPool` holds in `pool`, in terms of USD\n    /// using the given price mode\n    function computePoolValueInUSD(\n        address conicPool,\n        address pool,\n        PriceMode priceMode\n    ) external view returns (uint256 usdAmount);\n\n    /// @notice Returns the amount of of assets that `conicPool` holds in `pool`, in terms of underlying\n    function computePoolValueInUnderlying(\n        address conicPool,\n        address pool,\n        address underlying,\n        uint256 underlyingPrice\n    ) external view returns (uint256 underlyingAmount);\n\n    /// @notice Returns the amount of of assets that `conicPool` holds in `pool`, in terms of underlying\n    /// using the given price mode\n    function computePoolValueInUnderlying(\n        address conicPool,\n        address pool,\n        address underlying,\n        uint256 underlyingPrice,\n        PriceMode priceMode\n    ) external view returns (uint256 underlyingAmount);\n\n    /// @notice Claim earnings of `conicPool` from `pool`\n    function claimEarnings(address conicPool, address pool) external;\n\n    /// @notice Returns the LP token of a given `pool`\n    function lpToken(address pool) external view returns (address);\n\n    /// @notice Returns true if `pool` supports `asset`\n    function supportsAsset(address pool, address asset) external view returns (bool);\n\n    /// @notice Returns the amount of CRV earned by `pool` on Convex\n    function getCRVEarnedOnConvex(\n        address account,\n        address curvePool\n    ) external view returns (uint256);\n\n    /// @notice Executes a sanity check, e.g. checking for reentrancy\n    function executeSanityCheck(address pool) external;\n\n    /// @notice returns all the underlying coins of the pool\n    function getAllUnderlyingCoins(address pool) external view returns (address[] memory);\n}\n"
    },
    "IFeeRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IFeeRecipient {\n    event FeesReceived(address indexed sender, uint256 crvAmount, uint256 cvxAmount);\n\n    function receiveFees(uint256 amountCrv, uint256 amountCvx) external;\n}\n"
    },
    "ICurveRegistryCache.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"IBooster.sol\";\nimport \"CurvePoolUtils.sol\";\nimport \"Types.sol\";\n\ninterface ICurveRegistryCache {\n    event PoolInitialized(address indexed pool, uint256 indexed pid);\n\n    function BOOSTER() external view returns (IBooster);\n\n    function initPool(address pool_) external;\n\n    function initPool(address pool_, uint256 pid_) external;\n\n    function initPool(address pool_, Types.PoolInfo memory poolInfo_) external;\n\n    function initPool(address pool_, uint256 pid_, Types.PoolInfo memory poolInfo_) external;\n\n    function lpToken(address pool_) external view returns (address);\n\n    function assetType(address pool_) external view returns (CurvePoolUtils.AssetType);\n\n    function isRegistered(address pool_) external view returns (bool);\n\n    function hasCoinDirectly(address pool_, address coin_) external view returns (bool);\n\n    function hasCoinAnywhere(address pool_, address coin_) external view returns (bool);\n\n    function basePool(address pool_) external view returns (address);\n\n    function coinIndex(address pool_, address coin_) external view returns (int128);\n\n    function nCoins(address pool_) external view returns (uint256);\n\n    function coinIndices(\n        address pool_,\n        address from_,\n        address to_\n    ) external view returns (int128, int128, bool);\n\n    function decimals(address pool_) external view returns (uint256[] memory);\n\n    function interfaceVersion(address pool_) external view returns (uint256);\n\n    function poolFromLpToken(address lpToken_) external view returns (address);\n\n    function coins(address pool_) external view returns (address[] memory);\n\n    function getPid(address _pool) external view returns (uint256);\n\n    function getRewardPool(address _pool) external view returns (address);\n\n    function isShutdownPid(uint256 pid_) external view returns (bool);\n\n    /// @notice this returns the underlying coins of a pool, including the underlying of the base pool\n    /// if the given pool is a meta pool\n    /// This does not return the LP token of the base pool as an underlying\n    /// e.g. if the pool is 3CrvFrax, this will return FRAX, DAI, USDC, USDT\n    function getAllUnderlyingCoins(address pool) external view returns (address[] memory);\n}\n"
    },
    "IBooster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IBooster {\n    function poolInfo(\n        uint256 pid\n    )\n        external\n        view\n        returns (\n            address lpToken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function poolLength() external view returns (uint256);\n\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function earmarkRewards(uint256 _pid) external returns (bool);\n\n    function isShutdown() external view returns (bool);\n}\n"
    },
    "CurvePoolUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"ICurvePoolV2.sol\";\nimport \"ICurvePoolV1.sol\";\nimport \"ScaledMath.sol\";\n\nlibrary CurvePoolUtils {\n    using ScaledMath for uint256;\n\n    error NotWithinThreshold(address pool, uint256 assetA, uint256 assetB);\n\n    /// @dev by default, allow for 30 bps deviation regardless of pool fees\n    uint256 internal constant _DEFAULT_IMBALANCE_BUFFER = 30e14;\n\n    /// @dev Curve scales the `fee` by 1e10\n    uint8 internal constant _CURVE_POOL_FEE_DECIMALS = 10;\n\n    /// @dev allow imbalance to be buffer + 3x the fee, e.g. if fee is 3.6 bps and buffer is 30 bps, allow 40.8 bps\n    uint256 internal constant _FEE_IMBALANCE_MULTIPLIER = 3;\n\n    enum AssetType {\n        USD,\n        ETH,\n        BTC,\n        OTHER,\n        CRYPTO\n    }\n\n    struct PoolMeta {\n        address pool;\n        uint256 numberOfCoins;\n        AssetType assetType;\n        uint256[] decimals;\n        uint256[] prices;\n        uint256[] imbalanceBuffers;\n    }\n\n    function ensurePoolBalanced(PoolMeta memory poolMeta) internal view {\n        uint256 poolFee = ICurvePoolV1(poolMeta.pool).fee().convertScale(\n            _CURVE_POOL_FEE_DECIMALS,\n            18\n        );\n\n        for (uint256 i = 0; i < poolMeta.numberOfCoins - 1; i++) {\n            uint256 fromDecimals = poolMeta.decimals[i];\n            uint256 fromBalance = 10 ** fromDecimals;\n            uint256 fromPrice = poolMeta.prices[i];\n\n            for (uint256 j = i + 1; j < poolMeta.numberOfCoins; j++) {\n                uint256 toDecimals = poolMeta.decimals[j];\n                uint256 toPrice = poolMeta.prices[j];\n                uint256 toExpectedUnscaled = (fromBalance * fromPrice) / toPrice;\n                uint256 toExpected = toExpectedUnscaled.convertScale(\n                    uint8(fromDecimals),\n                    uint8(toDecimals)\n                );\n\n                uint256 toActual;\n\n                if (poolMeta.assetType == AssetType.CRYPTO) {\n                    // Handling crypto pools\n                    toActual = ICurvePoolV2(poolMeta.pool).get_dy(i, j, fromBalance);\n                } else {\n                    // Handling other pools\n                    toActual = ICurvePoolV1(poolMeta.pool).get_dy(\n                        int128(uint128(i)),\n                        int128(uint128(j)),\n                        fromBalance\n                    );\n                }\n                uint256 _maxImbalanceBuffer = poolMeta.imbalanceBuffers[i].max(\n                    poolMeta.imbalanceBuffers[j]\n                );\n\n                if (!_isWithinThreshold(toExpected, toActual, poolFee, _maxImbalanceBuffer))\n                    revert NotWithinThreshold(poolMeta.pool, i, j);\n            }\n        }\n    }\n\n    function _isWithinThreshold(\n        uint256 a,\n        uint256 b,\n        uint256 poolFee,\n        uint256 imbalanceBuffer\n    ) internal pure returns (bool) {\n        if (imbalanceBuffer == 0) imbalanceBuffer = _DEFAULT_IMBALANCE_BUFFER;\n        uint256 imbalanceTreshold = imbalanceBuffer + poolFee * _FEE_IMBALANCE_MULTIPLIER;\n        if (a > b) return (a - b).divDown(a) <= imbalanceTreshold;\n        return (b - a).divDown(b) <= imbalanceTreshold;\n    }\n}\n"
    },
    "ICurvePoolV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface ICurvePoolV2 {\n    function token() external view returns (address);\n\n    function coins(uint256 i) external view returns (address);\n\n    function factory() external view returns (address);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[3] memory amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[3] memory amounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[2] memory min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] memory min_amounts) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[3] memory min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory amounts) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n"
    },
    "ICurvePoolV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface ICurvePoolV1 {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[8] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[7] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[6] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[5] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity_imbalance(\n        uint256[4] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function lp_token() external view returns (address);\n\n    function A_PRECISION() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;\n\n    function exchange(\n        int128 from,\n        int128 to,\n        uint256 _from_amount,\n        uint256 _min_to_amount\n    ) external;\n\n    function coins(uint256 i) external view returns (address);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function get_dy(int128 i, int128 j, uint256 _dx) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[4] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[3] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[2] calldata amounts,\n        bool deposit\n    ) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        int128 i\n    ) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function fee() external view returns (uint256);\n}\n"
    },
    "Types.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary Types {\n    struct Coin {\n        address coinAddress;\n        uint8 decimals;\n    }\n\n    struct CliffInfo {\n        uint256 currentCliff;\n        bool withinThreshold;\n    }\n\n    struct PoolInfo {\n        address lpToken;\n        address basePool;\n        uint256 assetType;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "london",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "ERC4626Oracle.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}