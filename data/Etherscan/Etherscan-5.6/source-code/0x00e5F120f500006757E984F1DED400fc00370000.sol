{{
  "language": "Solidity",
  "sources": {
    "contracts/helpers/ArrayHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"seaport-types/src/helpers/PointerLibraries.sol\";\n\n/**\n * @author d1ll0n\n * @custom:coauthor Most of the natspec is cribbed from the TypeScript\n *                  documentation\n */\nlibrary ArrayHelpers {\n    // Has to be out of place to silence a linter warning\n    function reduceWithArg(\n        MemoryPointer array,\n        /* function (uint256 currentResult, uint256 element, uint256 arg) */\n        /* returns (uint256 newResult) */\n        function(uint256, uint256, MemoryPointer) internal returns (uint256) fn,\n        uint256 initialValue,\n        MemoryPointer arg\n    ) internal returns (uint256 result) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n\n            result = initialValue;\n            while (srcPosition.lt(srcEnd)) {\n                result = fn(result, srcPosition.readUint256(), arg);\n                srcPosition = srcPosition.next();\n            }\n        }\n    }\n\n    function flatten(\n        MemoryPointer array1,\n        MemoryPointer array2\n    ) internal view returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 arrayLength1 = array1.readUint256();\n            uint256 arrayLength2 = array2.readUint256();\n            uint256 array1HeadSize = arrayLength1 * 32;\n            uint256 array2HeadSize = arrayLength2 * 32;\n\n            newArray = malloc(array1HeadSize + array2HeadSize + 32);\n            newArray.write(arrayLength1 + arrayLength2);\n\n            MemoryPointer dst = newArray.next();\n            if (arrayLength1 > 0) {\n                array1.next().copy(dst, array1HeadSize);\n            }\n            if (arrayLength2 > 0) {\n                array2.next().copy(dst.offset(array1HeadSize), array2HeadSize);\n            }\n        }\n    }\n\n    function flattenThree(\n        MemoryPointer array1,\n        MemoryPointer array2,\n        MemoryPointer array3\n    ) internal view returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 arrayLength1 = array1.readUint256();\n            uint256 arrayLength2 = array2.readUint256();\n            uint256 arrayLength3 = array3.readUint256();\n            uint256 array1HeadSize = arrayLength1 * 32;\n            uint256 array2HeadSize = arrayLength2 * 32;\n            uint256 array3HeadSize = arrayLength3 * 32;\n\n            newArray = malloc(\n                array1HeadSize + array2HeadSize + array3HeadSize + 32\n            );\n            newArray.write(arrayLength1 + arrayLength2 + arrayLength3);\n\n            MemoryPointer dst = newArray.next();\n            if (arrayLength1 > 0) {\n                array1.next().copy(dst, array1HeadSize);\n            }\n            if (arrayLength2 > 0) {\n                array2.next().copy(dst.offset(array1HeadSize), array2HeadSize);\n            }\n            if (arrayLength3 > 0) {\n                array3.next().copy(\n                    dst.offset(array1HeadSize + array2HeadSize),\n                    array3HeadSize\n                );\n            }\n        }\n    }\n\n    // =====================================================================//\n    //            map with (element) => (newElement) callback               //\n    // =====================================================================//\n\n    /**\n     * @dev map calls a defined callback function on each element of an array\n     *      and returns an array that contains the results\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                returns a new value to put in its place in the new array\n     *\n     * @return newArray the new array created with the results from calling\n     *         fn with each element\n     */\n    function map(\n        MemoryPointer array,\n        /* function (uint256 value) returns (uint256 newValue) */\n        function(uint256) internal pure returns (uint256) fn\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n            newArray.write(length);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            while (srcPosition.lt(srcEnd)) {\n                dstPosition.write(fn(srcPosition.readUint256()));\n                srcPosition = srcPosition.next();\n                dstPosition = dstPosition.next();\n            }\n        }\n    }\n\n    // =====================================================================//\n    //         filterMap with (element) => (newElement) callback            //\n    // =====================================================================//\n\n    /**\n     * @dev filterMap calls a defined callback function on each element of an\n     *      array and returns an array that contains only the non-zero results\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                returns a new value to put in its place in the new array\n     *                or a zero value to indicate that the element should not\n     *                be included in the new array\n     *\n     * @return newArray the new array created with the results from calling\n     *                  fn with each element\n     */\n    function filterMap(\n        MemoryPointer array,\n        /* function (uint256 value) returns (uint256 newValue) */\n        function(MemoryPointer) internal pure returns (MemoryPointer) fn\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            length = 0;\n\n            while (srcPosition.lt(srcEnd)) {\n                MemoryPointer result = fn(srcPosition.readMemoryPointer());\n                if (!result.isNull()) {\n                    dstPosition.write(result);\n                    dstPosition = dstPosition.next();\n                    length += 1;\n                }\n                srcPosition = srcPosition.next();\n            }\n            newArray.write(length);\n        }\n    }\n\n    // =====================================================================//\n    //      filterMap with (element, arg) => (newElement) callback          //\n    // =====================================================================//\n\n    /**\n     * @dev filterMap calls a defined callback function on each element of an\n     *      array and returns an array that contains only the non-zero results\n     *\n     *        filterMapWithArg = (arr, callback, arg) => arr.map(\n     *          (element) => callback(element, arg)\n     *        ).filter(result => result != 0)\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                returns a new value to put in its place in the new array\n     *                or a zero value to indicate that the element should not\n     *                be included in the new array\n     * @param arg     an arbitrary value provided in each call to fn\n     *\n     * @return newArray the new array created with the results from calling\n     *                  fn with each element\n     */\n    function filterMapWithArg(\n        MemoryPointer array,\n        /* function (MemoryPointer element, MemoryPointer arg) */\n        /* returns (uint256 newValue) */\n        function(MemoryPointer, MemoryPointer)\n            internal\n            pure\n            returns (MemoryPointer) fn,\n        MemoryPointer arg\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            length = 0;\n\n            while (srcPosition.lt(srcEnd)) {\n                MemoryPointer result = fn(srcPosition.readMemoryPointer(), arg);\n                if (!result.isNull()) {\n                    dstPosition.write(result);\n                    dstPosition = dstPosition.next();\n                    length += 1;\n                }\n                srcPosition = srcPosition.next();\n            }\n            newArray.write(length);\n        }\n    }\n\n    // ====================================================================//\n    //         filter  with (element, arg) => (bool) predicate             //\n    // ====================================================================//\n\n    /**\n     * @dev filter calls a defined callback function on each element of an array\n     *      and returns an array that contains only the elements which the\n     *      callback returned true for\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                returns a boolean that indicates whether the element\n     *                should be included in the new array\n     * @param arg     an arbitrary value provided in each call to fn\n     *\n     * @return newArray the new array created with the elements which the\n     *                  callback returned true for\n     */\n    function filterWithArg(\n        MemoryPointer array,\n        /* function (uint256 value, uint256 arg) returns (bool) */\n        function(MemoryPointer, MemoryPointer) internal pure returns (bool) fn,\n        MemoryPointer arg\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            length = 0;\n\n            while (srcPosition.lt(srcEnd)) {\n                MemoryPointer element = srcPosition.readMemoryPointer();\n                if (fn(element, arg)) {\n                    dstPosition.write(element);\n                    dstPosition = dstPosition.next();\n                    length += 1;\n                }\n                srcPosition = srcPosition.next();\n            }\n            newArray.write(length);\n        }\n    }\n\n    // ====================================================================//\n    //            filter  with (element) => (bool) predicate               //\n    // ====================================================================//\n\n    /**\n     * @dev filter calls a defined callback function on each element of an array\n     *      and returns an array that contains only the elements which the\n     *      callback returned true for\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                returns a boolean that indicates whether the element\n     *                should be included in the new array\n     *\n     * @return newArray the new array created with the elements which the\n     *                  callback returned true for\n     */\n    function filter(\n        MemoryPointer array,\n        /* function (uint256 value) returns (bool) */\n        function(MemoryPointer) internal pure returns (bool) fn\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            length = 0;\n\n            while (srcPosition.lt(srcEnd)) {\n                MemoryPointer element = srcPosition.readMemoryPointer();\n                if (fn(element)) {\n                    dstPosition.write(element);\n                    dstPosition = dstPosition.next();\n                    length += 1;\n                }\n                srcPosition = srcPosition.next();\n            }\n            newArray.write(length);\n        }\n    }\n\n    /**\n     * @dev mapWithIndex calls a defined callback function with each element of\n     *      an array and its index and returns an array that contains the\n     *      results\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                its index and returns a new value to put in its place\n     *                in the new array\n     *\n     * @return newArray the new array created with the results from calling\n     *         fn with each element\n     */\n    function mapWithIndex(\n        MemoryPointer array,\n        /* function (uint256 value, uint256 index) returns (uint256 newValue) */\n        function(uint256, uint256) internal pure returns (uint256) fn\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n            newArray.write(length);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            uint256 index;\n            while (srcPosition.lt(srcEnd)) {\n                dstPosition.write(fn(srcPosition.readUint256(), index++));\n                srcPosition = srcPosition.next();\n                dstPosition = dstPosition.next();\n            }\n        }\n    }\n\n    /**\n     * @dev map calls a defined callback function on each element of an array\n     *      and returns an array that contains the results\n     *\n     * @param array   the array to map\n     * @param fn      a function that accepts each element in the array and\n     *                the `arg` value provided in the call to map and returns\n     *                a new value to put in its place in the new array\n     * @param arg     an arbitrary value provided in each call to fn\n     *\n     * @return newArray the new array created with the results from calling\n     *         fn with each element\n     */\n    function mapWithArg(\n        MemoryPointer array,\n        /* function (uint256 value, uint256 arg) returns (uint256 newValue) */\n        function(MemoryPointer, MemoryPointer)\n            internal\n            pure\n            returns (MemoryPointer) fn,\n        MemoryPointer arg\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n            newArray.write(length);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            while (srcPosition.lt(srcEnd)) {\n                dstPosition.write(fn(srcPosition.readMemoryPointer(), arg));\n                srcPosition = srcPosition.next();\n                dstPosition = dstPosition.next();\n            }\n        }\n    }\n\n    function mapWithIndex(\n        MemoryPointer array,\n        /* function (uint256 value, uint256 index, uint256 arg) */\n        /* returns (uint256 newValue) */\n        function(uint256, uint256, uint256) internal pure returns (uint256) fn,\n        uint256 arg\n    ) internal pure returns (MemoryPointer newArray) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            newArray = malloc((length + 1) * 32);\n            newArray.write(length);\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            MemoryPointer dstPosition = newArray.next();\n\n            uint256 index;\n            while (srcPosition.lt(srcEnd)) {\n                dstPosition.write(fn(srcPosition.readUint256(), index++, arg));\n                srcPosition = srcPosition.next();\n                dstPosition = dstPosition.next();\n            }\n        }\n    }\n\n    function reduce(\n        MemoryPointer array,\n        /* function (uint256 currentResult, uint256 element) */\n        /* returns (uint256 newResult) */\n        function(uint256, uint256) internal pure returns (uint256) fn,\n        uint256 initialValue\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n\n            result = initialValue;\n            while (srcPosition.lt(srcEnd)) {\n                result = fn(result, srcPosition.readUint256());\n                srcPosition = srcPosition.next();\n            }\n        }\n    }\n\n    // This was the previous home of `reduceWithArg`. It can now be found near\n    // the top of this file.\n\n    function forEach(\n        MemoryPointer array,\n        /* function (MemoryPointer element, MemoryPointer arg) */\n        function(MemoryPointer, MemoryPointer) internal pure fn,\n        MemoryPointer arg\n    ) internal pure {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n\n            while (srcPosition.lt(srcEnd)) {\n                fn(srcPosition.readMemoryPointer(), arg);\n                srcPosition = srcPosition.next();\n            }\n        }\n    }\n\n    function forEach(\n        MemoryPointer array,\n        /* function (MemoryPointer element) */\n        function(MemoryPointer) internal pure fn\n    ) internal pure {\n        unchecked {\n            uint256 length = array.readUint256();\n\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n\n            while (srcPosition.lt(srcEnd)) {\n                fn(srcPosition.readMemoryPointer());\n                srcPosition = srcPosition.next();\n            }\n        }\n    }\n\n    // =====================================================================//\n    //     find with function(uint256 element, uint256 arg) predicate       //\n    // =====================================================================//\n\n    /**\n     * @dev calls `predicate` once for each element of the array, in ascending\n     *      order, until it finds one where predicate returns true. If such an\n     *      element is found, find immediately returns that element value.\n     *      Otherwise, find returns 0.\n     *\n     * @param array     array to search\n     * @param predicate function that checks whether each element meets the\n     *                  search filter.\n     * @param arg       second input to `predicate`\n     *\n     * @return          the value of the first element in the array where\n     *                  predicate is true and 0 otherwise.\n     */\n    function find(\n        MemoryPointer array,\n        function(uint256, uint256) internal pure returns (bool) predicate,\n        uint256 arg\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = array.readUint256();\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            while (srcPosition.lt(srcEnd)) {\n                uint256 value = srcPosition.readUint256();\n                if (predicate(value, arg)) return value;\n                srcPosition = srcPosition.next();\n            }\n            return 0;\n        }\n    }\n\n    // =====================================================================//\n    //            find with function(uint256 element) predicate             //\n    // =====================================================================//\n\n    /**\n     * @dev calls `predicate` once for each element of the array, in ascending\n     *      order, until it finds one where predicate returns true. If such an\n     *      element is found, find immediately returns that element value.\n     *      Otherwise, find returns 0.\n     *\n     * @param array     array to search\n     * @param predicate function that checks whether each element meets the\n     *                  search filter.\n     * @param fromIndex index to start search at\n     *\n     * @custom:return   the value of the first element in the array where\n     *                  predicate is trueand 0 otherwise.\n     */\n    function find(\n        MemoryPointer array,\n        function(uint256) internal pure returns (bool) predicate,\n        uint256 fromIndex\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = array.readUint256();\n            MemoryPointer srcPosition = array.next().offset(fromIndex * 0x20);\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            while (srcPosition.lt(srcEnd)) {\n                uint256 value = srcPosition.readUint256();\n                if (predicate(value)) return value;\n                srcPosition = srcPosition.next();\n            }\n            return 0;\n        }\n    }\n\n    // =====================================================================//\n    //            find with function(uint256 element) predicate             //\n    // =====================================================================//\n\n    /**\n     * @dev calls `predicate` once for each element of the array, in ascending\n     *      order, until it finds one where predicate returns true. If such an\n     *      element is found, find immediately returns that element value.\n     *      Otherwise, find returns 0.\n     *\n     * @param array     array to search\n     * @param predicate function that checks whether each element meets the\n     *                  search filter.\n     *\n     * @return          the value of the first element in the array where\n     *                  predicate is true and 0 otherwise.\n     */\n    function find(\n        MemoryPointer array,\n        function(uint256) internal pure returns (bool) predicate\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = array.readUint256();\n            MemoryPointer srcPosition = array.next();\n            MemoryPointer srcEnd = srcPosition.offset(length * 0x20);\n            while (srcPosition.lt(srcEnd)) {\n                uint256 value = srcPosition.readUint256();\n                if (predicate(value)) return value;\n                srcPosition = srcPosition.next();\n            }\n            return 0;\n        }\n    }\n\n    // =====================================================================//\n    //                               indexOf                                //\n    // =====================================================================//\n\n    /**\n     * @dev Returns the index of the first occurrence of a value in an array,\n     *      or -1 if it is not present.\n     *\n     * @param array         array to search\n     * @param searchElement the value to locate in the array.\n     */\n    function indexOf(\n        MemoryPointer array,\n        uint256 searchElement\n    ) internal pure returns (int256 index) {\n        unchecked {\n            int256 length = array.readInt256();\n            MemoryPointer src = array;\n            int256 reachedEnd;\n            while (\n                ((reachedEnd = toInt(index == length)) |\n                    toInt((src = src.next()).readUint256() == searchElement)) ==\n                0\n            ) {\n                index += 1;\n            }\n            return (reachedEnd * -1) | index;\n        }\n    }\n\n    function toInt(bool a) internal pure returns (int256 b) {\n        assembly {\n            b := a\n        }\n    }\n\n    // =====================================================================//\n    //                     findIndex with one argument                      //\n    // =====================================================================//\n\n    function findIndexWithArg(\n        MemoryPointer array,\n        function(uint256, uint256) internal pure returns (bool) predicate,\n        uint256 arg\n    ) internal pure returns (int256 index) {\n        unchecked {\n            int256 length = array.readInt256();\n            MemoryPointer src = array;\n            while (index < length) {\n                if (predicate((src = src.next()).readUint256(), arg)) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        }\n    }\n\n    // =====================================================================//\n    //                     findIndex from start index                       //\n    // =====================================================================//\n\n    function findIndexFrom(\n        MemoryPointer array,\n        function(MemoryPointer) internal pure returns (bool) predicate,\n        uint256 fromIndex\n    ) internal pure returns (int256 index) {\n        unchecked {\n            index = int256(fromIndex);\n            int256 length = array.readInt256();\n            MemoryPointer src = array.offset(fromIndex * 0x20);\n            while (index < length) {\n                if (predicate((src = src.next()).readMemoryPointer())) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        }\n    }\n\n    function countFrom(\n        MemoryPointer array,\n        function(MemoryPointer) internal pure returns (bool) predicate,\n        uint256 fromIndex\n    ) internal pure returns (int256 count) {\n        unchecked {\n            uint256 index = fromIndex;\n            uint256 length = array.readUint256();\n            MemoryPointer src = array.offset(fromIndex * 0x20);\n            while (index < length) {\n                if (predicate((src = src.next()).readMemoryPointer())) {\n                    count += 1;\n                }\n                index += 1;\n            }\n        }\n    }\n\n    // =====================================================================//\n    //                      includes with one argument                      //\n    // =====================================================================//\n\n    function includes(\n        MemoryPointer array,\n        uint256 value\n    ) internal pure returns (bool) {\n        return indexOf(array, value) != -1;\n    }\n}\n"
    },
    "seaport-types/src/helpers/PointerLibraries.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype CalldataPointer is uint256;\n\ntype ReturndataPointer is uint256;\n\ntype MemoryPointer is uint256;\n\nusing CalldataPointerLib for CalldataPointer global;\nusing MemoryPointerLib for MemoryPointer global;\nusing ReturndataPointerLib for ReturndataPointer global;\n\nusing CalldataReaders for CalldataPointer global;\nusing ReturndataReaders for ReturndataPointer global;\nusing MemoryReaders for MemoryPointer global;\nusing MemoryWriters for MemoryPointer global;\n\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\nuint256 constant IdentityPrecompileAddress = 0x4;\nuint256 constant OffsetOrLengthMask = 0xffffffff;\nuint256 constant _OneWord = 0x20;\nuint256 constant _FreeMemoryPointerSlot = 0x40;\n\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\n///    and returns the memory pointer to the first byte of the allocated region.\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\n    assembly {\n        mPtr := mload(_FreeMemoryPointerSlot)\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\n    }\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\n    FreeMemoryPPtr.write(mPtr);\n}\n\nlibrary CalldataPointerLib {\n    function lt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `cdPtr + headOffset`.\n    function pptr(\n        CalldataPointer cdPtr,\n        uint256 headOffset\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\n    ///      first member, e.g. `struct { bytes data; }`\n    function pptr(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\n    function next(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        CalldataPointer cdPtr,\n        uint256 _offset\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\n    ///      `dst`.\n    function copy(\n        CalldataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            calldatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary ReturndataPointerLib {\n    function lt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `rdPtr + headOffset`.\n    function pptr(\n        ReturndataPointer rdPtr,\n        uint256 headOffset\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\n    function next(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        ReturndataPointer rdPtr,\n        uint256 _offset\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\n    /// `dst`.\n    function copy(\n        ReturndataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            returndatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary MemoryPointerLib {\n    function copy(\n        MemoryPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal view {\n        assembly {\n            let success := staticcall(\n                gas(),\n                IdentityPrecompileAddress,\n                src,\n                size,\n                dst,\n                size\n            )\n            if or(iszero(returndatasize()), iszero(success)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function lt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    function hash(\n        MemoryPointer ptr,\n        uint256 length\n    ) internal pure returns (bytes32 _hash) {\n        assembly {\n            _hash := keccak256(ptr, length)\n        }\n    }\n\n    /// @dev Returns the memory pointer one word after `mPtr`.\n    function next(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\n    function offset(\n        MemoryPointer mPtr,\n        uint256 _offset\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _offset)\n        }\n    }\n\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\n    ///    type's pointer stored at `mPtr + headOffset`.\n    function pptr(\n        MemoryPointer mPtr,\n        uint256 headOffset\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\n    }\n\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\n    ///    `mPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.readMemoryPointer();\n    }\n}\n\nlibrary CalldataReaders {\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\n    ///    last 4 bytes.\n    function readMaskedUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `cdPtr` in calldata.\n    function readBool(\n        CalldataPointer cdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the address at `cdPtr` in calldata.\n    function readAddress(\n        CalldataPointer cdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\n    function readBytes1(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\n    function readBytes2(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\n    function readBytes3(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\n    function readBytes4(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\n    function readBytes5(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\n    function readBytes6(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\n    function readBytes7(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\n    function readBytes8(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\n    function readBytes9(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\n    function readBytes10(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\n    function readBytes11(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\n    function readBytes12(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\n    function readBytes13(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\n    function readBytes14(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\n    function readBytes15(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\n    function readBytes16(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\n    function readBytes17(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\n    function readBytes18(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\n    function readBytes19(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\n    function readBytes20(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\n    function readBytes21(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\n    function readBytes22(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\n    function readBytes23(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\n    function readBytes24(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\n    function readBytes25(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\n    function readBytes26(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\n    function readBytes27(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\n    function readBytes28(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\n    function readBytes29(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\n    function readBytes30(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\n    function readBytes31(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\n    function readBytes32(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\n    function readUint8(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\n    function readUint16(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\n    function readUint24(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\n    function readUint32(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\n    function readUint40(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\n    function readUint48(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\n    function readUint56(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\n    function readUint64(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\n    function readUint72(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\n    function readUint80(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\n    function readUint88(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\n    function readUint96(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\n    function readUint104(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\n    function readUint112(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\n    function readUint120(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\n    function readUint128(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\n    function readUint136(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\n    function readUint144(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\n    function readUint152(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\n    function readUint160(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\n    function readUint168(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\n    function readUint176(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\n    function readUint184(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\n    function readUint192(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\n    function readUint200(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\n    function readUint208(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\n    function readUint216(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\n    function readUint224(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\n    function readUint232(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\n    function readUint240(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\n    function readUint248(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\n    function readUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `cdPtr` in calldata.\n    function readInt8(\n        CalldataPointer cdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `cdPtr` in calldata.\n    function readInt16(\n        CalldataPointer cdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `cdPtr` in calldata.\n    function readInt24(\n        CalldataPointer cdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `cdPtr` in calldata.\n    function readInt32(\n        CalldataPointer cdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `cdPtr` in calldata.\n    function readInt40(\n        CalldataPointer cdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `cdPtr` in calldata.\n    function readInt48(\n        CalldataPointer cdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `cdPtr` in calldata.\n    function readInt56(\n        CalldataPointer cdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `cdPtr` in calldata.\n    function readInt64(\n        CalldataPointer cdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `cdPtr` in calldata.\n    function readInt72(\n        CalldataPointer cdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `cdPtr` in calldata.\n    function readInt80(\n        CalldataPointer cdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `cdPtr` in calldata.\n    function readInt88(\n        CalldataPointer cdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `cdPtr` in calldata.\n    function readInt96(\n        CalldataPointer cdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `cdPtr` in calldata.\n    function readInt104(\n        CalldataPointer cdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `cdPtr` in calldata.\n    function readInt112(\n        CalldataPointer cdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `cdPtr` in calldata.\n    function readInt120(\n        CalldataPointer cdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `cdPtr` in calldata.\n    function readInt128(\n        CalldataPointer cdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `cdPtr` in calldata.\n    function readInt136(\n        CalldataPointer cdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `cdPtr` in calldata.\n    function readInt144(\n        CalldataPointer cdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `cdPtr` in calldata.\n    function readInt152(\n        CalldataPointer cdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `cdPtr` in calldata.\n    function readInt160(\n        CalldataPointer cdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `cdPtr` in calldata.\n    function readInt168(\n        CalldataPointer cdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `cdPtr` in calldata.\n    function readInt176(\n        CalldataPointer cdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `cdPtr` in calldata.\n    function readInt184(\n        CalldataPointer cdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `cdPtr` in calldata.\n    function readInt192(\n        CalldataPointer cdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `cdPtr` in calldata.\n    function readInt200(\n        CalldataPointer cdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `cdPtr` in calldata.\n    function readInt208(\n        CalldataPointer cdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `cdPtr` in calldata.\n    function readInt216(\n        CalldataPointer cdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `cdPtr` in calldata.\n    function readInt224(\n        CalldataPointer cdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `cdPtr` in calldata.\n    function readInt232(\n        CalldataPointer cdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `cdPtr` in calldata.\n    function readInt240(\n        CalldataPointer cdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `cdPtr` in calldata.\n    function readInt248(\n        CalldataPointer cdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `cdPtr` in calldata.\n    function readInt256(\n        CalldataPointer cdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n}\n\nlibrary ReturndataReaders {\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `rdPtr` in returndata.\n    function readBool(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the address at `rdPtr` in returndata.\n    function readAddress(\n        ReturndataPointer rdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\n    function readBytes1(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\n    function readBytes2(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\n    function readBytes3(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\n    function readBytes4(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\n    function readBytes5(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\n    function readBytes6(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\n    function readBytes7(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\n    function readBytes8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\n    function readBytes9(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\n    function readBytes10(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\n    function readBytes11(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\n    function readBytes12(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\n    function readBytes13(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\n    function readBytes14(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\n    function readBytes15(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\n    function readBytes16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\n    function readBytes17(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\n    function readBytes18(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\n    function readBytes19(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\n    function readBytes20(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\n    function readBytes21(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\n    function readBytes22(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\n    function readBytes23(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\n    function readBytes24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\n    function readBytes25(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\n    function readBytes26(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\n    function readBytes27(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\n    function readBytes28(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\n    function readBytes29(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\n    function readBytes30(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\n    function readBytes31(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\n    function readBytes32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\n    function readUint8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\n    function readUint16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\n    function readUint24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\n    function readUint32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\n    function readUint40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\n    function readUint48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\n    function readUint56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\n    function readUint64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\n    function readUint72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\n    function readUint80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\n    function readUint88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\n    function readUint96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\n    function readUint104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\n    function readUint112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\n    function readUint120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\n    function readUint128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\n    function readUint136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\n    function readUint144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\n    function readUint152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\n    function readUint160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\n    function readUint168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\n    function readUint176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\n    function readUint184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\n    function readUint192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\n    function readUint200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\n    function readUint208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\n    function readUint216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\n    function readUint224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\n    function readUint232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\n    function readUint240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\n    function readUint248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\n    function readUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int8 at `rdPtr` in returndata.\n    function readInt8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int16 at `rdPtr` in returndata.\n    function readInt16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int24 at `rdPtr` in returndata.\n    function readInt24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int32 at `rdPtr` in returndata.\n    function readInt32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int40 at `rdPtr` in returndata.\n    function readInt40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int48 at `rdPtr` in returndata.\n    function readInt48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int56 at `rdPtr` in returndata.\n    function readInt56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int64 at `rdPtr` in returndata.\n    function readInt64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int72 at `rdPtr` in returndata.\n    function readInt72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int80 at `rdPtr` in returndata.\n    function readInt80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int88 at `rdPtr` in returndata.\n    function readInt88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int96 at `rdPtr` in returndata.\n    function readInt96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int104 at `rdPtr` in returndata.\n    function readInt104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int112 at `rdPtr` in returndata.\n    function readInt112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int120 at `rdPtr` in returndata.\n    function readInt120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int128 at `rdPtr` in returndata.\n    function readInt128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int136 at `rdPtr` in returndata.\n    function readInt136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int144 at `rdPtr` in returndata.\n    function readInt144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int152 at `rdPtr` in returndata.\n    function readInt152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int160 at `rdPtr` in returndata.\n    function readInt160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int168 at `rdPtr` in returndata.\n    function readInt168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int176 at `rdPtr` in returndata.\n    function readInt176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int184 at `rdPtr` in returndata.\n    function readInt184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int192 at `rdPtr` in returndata.\n    function readInt192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int200 at `rdPtr` in returndata.\n    function readInt200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int208 at `rdPtr` in returndata.\n    function readInt208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int216 at `rdPtr` in returndata.\n    function readInt216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int224 at `rdPtr` in returndata.\n    function readInt224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int232 at `rdPtr` in returndata.\n    function readInt232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int240 at `rdPtr` in returndata.\n    function readInt240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int248 at `rdPtr` in returndata.\n    function readInt248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int256 at `rdPtr` in returndata.\n    function readInt256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n}\n\nlibrary MemoryReaders {\n    /// @dev Reads the memory pointer at `mPtr` in memory.\n    function readMemoryPointer(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        value = mPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `mPtr` in memory.\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the address at `mPtr` in memory.\n    function readAddress(\n        MemoryPointer mPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `mPtr` in memory.\n    function readBytes1(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `mPtr` in memory.\n    function readBytes2(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `mPtr` in memory.\n    function readBytes3(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `mPtr` in memory.\n    function readBytes4(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `mPtr` in memory.\n    function readBytes5(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `mPtr` in memory.\n    function readBytes6(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `mPtr` in memory.\n    function readBytes7(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `mPtr` in memory.\n    function readBytes8(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `mPtr` in memory.\n    function readBytes9(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `mPtr` in memory.\n    function readBytes10(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `mPtr` in memory.\n    function readBytes11(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `mPtr` in memory.\n    function readBytes12(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `mPtr` in memory.\n    function readBytes13(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `mPtr` in memory.\n    function readBytes14(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `mPtr` in memory.\n    function readBytes15(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `mPtr` in memory.\n    function readBytes16(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `mPtr` in memory.\n    function readBytes17(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `mPtr` in memory.\n    function readBytes18(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `mPtr` in memory.\n    function readBytes19(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `mPtr` in memory.\n    function readBytes20(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `mPtr` in memory.\n    function readBytes21(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `mPtr` in memory.\n    function readBytes22(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `mPtr` in memory.\n    function readBytes23(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `mPtr` in memory.\n    function readBytes24(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `mPtr` in memory.\n    function readBytes25(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `mPtr` in memory.\n    function readBytes26(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `mPtr` in memory.\n    function readBytes27(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `mPtr` in memory.\n    function readBytes28(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `mPtr` in memory.\n    function readBytes29(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `mPtr` in memory.\n    function readBytes30(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `mPtr` in memory.\n    function readBytes31(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `mPtr` in memory.\n    function readBytes32(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `mPtr` in memory.\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `mPtr` in memory.\n    function readUint16(\n        MemoryPointer mPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `mPtr` in memory.\n    function readUint24(\n        MemoryPointer mPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `mPtr` in memory.\n    function readUint32(\n        MemoryPointer mPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `mPtr` in memory.\n    function readUint40(\n        MemoryPointer mPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `mPtr` in memory.\n    function readUint48(\n        MemoryPointer mPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `mPtr` in memory.\n    function readUint56(\n        MemoryPointer mPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `mPtr` in memory.\n    function readUint64(\n        MemoryPointer mPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `mPtr` in memory.\n    function readUint72(\n        MemoryPointer mPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `mPtr` in memory.\n    function readUint80(\n        MemoryPointer mPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `mPtr` in memory.\n    function readUint88(\n        MemoryPointer mPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `mPtr` in memory.\n    function readUint96(\n        MemoryPointer mPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `mPtr` in memory.\n    function readUint104(\n        MemoryPointer mPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `mPtr` in memory.\n    function readUint112(\n        MemoryPointer mPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `mPtr` in memory.\n    function readUint120(\n        MemoryPointer mPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `mPtr` in memory.\n    function readUint128(\n        MemoryPointer mPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `mPtr` in memory.\n    function readUint136(\n        MemoryPointer mPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `mPtr` in memory.\n    function readUint144(\n        MemoryPointer mPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `mPtr` in memory.\n    function readUint152(\n        MemoryPointer mPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `mPtr` in memory.\n    function readUint160(\n        MemoryPointer mPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `mPtr` in memory.\n    function readUint168(\n        MemoryPointer mPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `mPtr` in memory.\n    function readUint176(\n        MemoryPointer mPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `mPtr` in memory.\n    function readUint184(\n        MemoryPointer mPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `mPtr` in memory.\n    function readUint192(\n        MemoryPointer mPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `mPtr` in memory.\n    function readUint200(\n        MemoryPointer mPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `mPtr` in memory.\n    function readUint208(\n        MemoryPointer mPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `mPtr` in memory.\n    function readUint216(\n        MemoryPointer mPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `mPtr` in memory.\n    function readUint224(\n        MemoryPointer mPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `mPtr` in memory.\n    function readUint232(\n        MemoryPointer mPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `mPtr` in memory.\n    function readUint240(\n        MemoryPointer mPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `mPtr` in memory.\n    function readUint248(\n        MemoryPointer mPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `mPtr` in memory.\n    function readUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `mPtr` in memory.\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `mPtr` in memory.\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `mPtr` in memory.\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `mPtr` in memory.\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `mPtr` in memory.\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `mPtr` in memory.\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `mPtr` in memory.\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `mPtr` in memory.\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `mPtr` in memory.\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `mPtr` in memory.\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `mPtr` in memory.\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `mPtr` in memory.\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `mPtr` in memory.\n    function readInt104(\n        MemoryPointer mPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `mPtr` in memory.\n    function readInt112(\n        MemoryPointer mPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `mPtr` in memory.\n    function readInt120(\n        MemoryPointer mPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `mPtr` in memory.\n    function readInt128(\n        MemoryPointer mPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `mPtr` in memory.\n    function readInt136(\n        MemoryPointer mPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `mPtr` in memory.\n    function readInt144(\n        MemoryPointer mPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `mPtr` in memory.\n    function readInt152(\n        MemoryPointer mPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `mPtr` in memory.\n    function readInt160(\n        MemoryPointer mPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `mPtr` in memory.\n    function readInt168(\n        MemoryPointer mPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `mPtr` in memory.\n    function readInt176(\n        MemoryPointer mPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `mPtr` in memory.\n    function readInt184(\n        MemoryPointer mPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `mPtr` in memory.\n    function readInt192(\n        MemoryPointer mPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `mPtr` in memory.\n    function readInt200(\n        MemoryPointer mPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `mPtr` in memory.\n    function readInt208(\n        MemoryPointer mPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `mPtr` in memory.\n    function readInt216(\n        MemoryPointer mPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `mPtr` in memory.\n    function readInt224(\n        MemoryPointer mPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `mPtr` in memory.\n    function readInt232(\n        MemoryPointer mPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `mPtr` in memory.\n    function readInt240(\n        MemoryPointer mPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `mPtr` in memory.\n    function readInt248(\n        MemoryPointer mPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `mPtr` in memory.\n    function readInt256(\n        MemoryPointer mPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n}\n\nlibrary MemoryWriters {\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\n        assembly {\n            mstore(mPtr, valuePtr)\n        }\n    }\n\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, bool value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an address `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, address value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n}\n"
    },
    "seaport-core/src/lib/ConsiderationEncoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    BasicOrder_additionalRecipients_length_cdPtr,\n    BasicOrder_common_params_size,\n    BasicOrder_startTime_cdPtr,\n    BasicOrder_startTimeThroughZoneHash_size,\n    Common_amount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    generateOrder_base_tail_offset,\n    generateOrder_context_head_offset,\n    generateOrder_head_offset,\n    generateOrder_maximumSpent_head_offset,\n    generateOrder_minimumReceived_head_offset,\n    generateOrder_selector_offset,\n    generateOrder_selector,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    OrderFulfilled_baseDataSize,\n    OrderFulfilled_offer_length_baseOffset,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_endTime_offset,\n    OrderParameters_offer_head_offset,\n    OrderParameters_startTime_offset,\n    OrderParameters_zoneHash_offset,\n    ratifyOrder_base_tail_offset,\n    ratifyOrder_consideration_head_offset,\n    ratifyOrder_context_head_offset,\n    ratifyOrder_contractNonce_offset,\n    ratifyOrder_head_offset,\n    ratifyOrder_orderHashes_head_offset,\n    ratifyOrder_selector_offset,\n    ratifyOrder_selector,\n    ReceivedItem_size,\n    Selector_length,\n    SixtyThreeBytes,\n    SpentItem_size_shift,\n    SpentItem_size,\n    validateOrder_head_offset,\n    validateOrder_selector_offset,\n    validateOrder_selector,\n    validateOrder_zoneParameters_offset,\n    ZoneParameters_base_tail_offset,\n    ZoneParameters_basicOrderFixedElements_length,\n    ZoneParameters_consideration_head_offset,\n    ZoneParameters_endTime_offset,\n    ZoneParameters_extraData_head_offset,\n    ZoneParameters_fulfiller_offset,\n    ZoneParameters_offer_head_offset,\n    ZoneParameters_offerer_offset,\n    ZoneParameters_orderHashes_head_offset,\n    ZoneParameters_selectorAndPointer_length,\n    ZoneParameters_startTime_offset,\n    ZoneParameters_zoneHash_offset\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {BasicOrderParameters, OrderParameters} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {CalldataPointer, getFreeMemoryPointer, MemoryPointer} from \"seaport-types/src/helpers/PointerLibraries.sol\";\n\ncontract ConsiderationEncoder {\n    /**\n     * @dev Takes a bytes array and casts it to a memory pointer.\n     *\n     * @param obj A bytes array in memory.\n     *\n     * @return ptr A memory pointer to the start of the bytes array in memory.\n     */\n    function toMemoryPointer(bytes memory obj) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\n     *\n     * @param obj An array of bytes32 types in memory.\n     *\n     * @return ptr A memory pointer to the start of the array of bytes32 types\n     *             in memory.\n     */\n    function toMemoryPointer(bytes32[] memory obj) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes a bytes array in memory and copies it to a new location in\n     *      memory.\n     *\n     * @param src A memory pointer referencing the bytes array to be copied (and\n     *            pointing to the length of the bytes array).\n     * @param src A memory pointer referencing the location in memory to copy\n     *            the bytes array to (and pointing to the length of the copied\n     *            bytes array).\n     *\n     * @return size The size of the bytes array.\n     */\n    function _encodeBytes(MemoryPointer src, MemoryPointer dst) internal view returns (uint256 size) {\n        unchecked {\n            // Mask the length of the bytes array to protect against overflow\n            // and round up to the nearest word.\n            // Note: `size` also includes the 1 word that stores the length.\n            size = (src.readUint256() + SixtyThreeBytes) & OnlyFullWordMask;\n\n            // Copy the bytes array to the new memory location.\n            src.copy(dst, size);\n        }\n    }\n\n    /**\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\n     *      and encodes it as `generateOrder` calldata.\n     *\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `generateOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `generateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeGenerateOrder(OrderParameters memory orderParameters, bytes memory context)\n        internal\n        view\n        returns (MemoryPointer dst, uint256 size)\n    {\n        // Get the memory pointer for the OrderParameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Get free memory pointer to write calldata to.\n        dst = getFreeMemoryPointer();\n\n        // Write generateOrder selector and get pointer to start of calldata.\n        dst.write(generateOrder_selector);\n        dst = dst.offset(generateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\n\n        // Write `fulfiller` to calldata.\n        dstHead.write(msg.sender);\n\n        // Initialize tail offset, used to populate the minimumReceived array.\n        uint256 tailOffset = generateOrder_base_tail_offset;\n\n        // Write offset to minimumReceived.\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(tailOffset);\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src.offset(OrderParameters_offer_head_offset).readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 minimumReceivedSize = _encodeSpentItems(srcOfferPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate maximumSpent array.\n            tailOffset += minimumReceivedSize;\n        }\n\n        // Write offset to maximumSpent.\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(tailOffset);\n\n        // Get memory pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer =\n            src.offset(OrderParameters_consideration_head_offset).readMemoryPointer();\n\n        // Encode the consideration array as a `SpentItem[]`.\n        uint256 maximumSpentSize = _encodeSpentItems(srcConsiderationPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += maximumSpentSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\n\n        // Get memory pointer to context.\n        MemoryPointer srcContext = toMemoryPointer(context);\n\n        // Encode context as a bytes array.\n        uint256 contextSize = _encodeBytes(srcContext, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += contextSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash (e.g. offerer shifted 96 bits to the left XOR'd\n     *      with the contract nonce in the case of contract orders), an\n     *      OrderParameters struct, context bytes array, and an array of order\n     *      hashes for each order included as part of the current fulfillment\n     *      and encodes it as `ratifyOrder` calldata.\n     *\n     * @param orderHash       The order hash (e.g. shl(0x60, offerer) ^ nonce).\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     * @param shiftedOfferer  The offerer for the order, shifted 96 bits to the\n     *                        left.\n     *\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeRatifyOrder(\n        bytes32 orderHash, // e.g. shl(0x60, offerer) ^ contract nonce\n        OrderParameters memory orderParameters,\n        bytes memory context, // encoded based on the schemaID\n        bytes32[] memory orderHashes,\n        uint256 shiftedOfferer\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write ratifyOrder selector and get pointer to start of calldata.\n        dst.write(ratifyOrder_selector);\n        dst = dst.offset(ratifyOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\n\n        // Write contractNonce to calldata via xor(orderHash, shiftedOfferer).\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(uint256(orderHash) ^ shiftedOfferer);\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Write offset to `offer`.\n        dstHead.write(tailOffset);\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src.offset(OrderParameters_offer_head_offset).readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(srcOfferPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer =\n            src.offset(OrderParameters_consideration_head_offset).readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize =\n            _encodeConsiderationAsReceivedItems(srcConsiderationPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\n\n        // Encode context.\n        uint256 contextSize = _encodeBytes(toMemoryPointer(context), dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += contextSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\n\n        // Encode orderHashes.\n        uint256 orderHashesSize = _encodeOrderHashes(toMemoryPointer(orderHashes), dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\n     *      and array of order hashes for each order included as part of the\n     *      current fulfillment and encodes it as `validateOrder` calldata.\n     *      Note that future, new versions of this contract may end up writing\n     *      to a memory region that might have been potentially dirtied by the\n     *      accumulator. Since the book-keeping for the accumulator does not\n     *      update the free memory pointer, it will be necessary to ensure that\n     *      all bytes in the memory in the range [dst, dst+size) are fully\n     *      updated/written to in this function.\n     *\n     * @param orderHash       The order hash.\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param extraData       The extraData bytes array used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateOrder(\n        bytes32 orderHash,\n        OrderParameters memory orderParameters,\n        bytes memory extraData,\n        bytes32[] memory orderHashes\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n\n        // Get the memory pointer to the order parameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\n        dstHead.offset(ZoneParameters_startTime_offset).write(\n            src.offset(OrderParameters_startTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_endTime_offset).write(src.offset(OrderParameters_endTime_offset).readUint256());\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(src.offset(OrderParameters_zoneHash_offset).readUint256());\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to `offer`.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src.offset(OrderParameters_offer_head_offset).readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(srcOfferPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer =\n            src.offset(OrderParameters_consideration_head_offset).readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize =\n            _encodeConsiderationAsReceivedItems(srcConsiderationPointer, dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        // Copy extraData.\n        uint256 extraDataSize = _encodeBytes(toMemoryPointer(extraData), dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += extraDataSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(tailOffset);\n\n        // Encode the order hashes array.\n        uint256 orderHashesSize = _encodeOrderHashes(toMemoryPointer(orderHashes), dstHead.offset(tailOffset));\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive final size including selector and ZoneParameters pointer.\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\n     *      and encodes it as `validateOrder` calldata.\n     *\n     * @param orderHash  The order hash.\n     * @param parameters The BasicOrderParameters struct used to construct the\n     *                   encoded `validateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateBasicOrder(bytes32 orderHash, BasicOrderParameters calldata parameters)\n        internal\n        view\n        returns (MemoryPointer dst, uint256 size)\n    {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write offerer, orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n        dstHead.offset(ZoneParameters_offerer_offset).write(parameters.offerer);\n\n        // Copy startTime, endTime and zoneHash to zoneParameters.\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\n            dstHead.offset(ZoneParameters_startTime_offset), BasicOrder_startTimeThroughZoneHash_size\n        );\n\n        // Initialize tail offset, used for the offer + consideration arrays.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to offer from event data into target calldata.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        unchecked {\n            // Write consideration offset next (located 5 words after offer).\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(tailOffset + BasicOrder_common_params_size);\n\n            // Retrieve the offset to the length of additional recipients.\n            uint256 additionalRecipientsLength =\n                CalldataPointer.wrap(BasicOrder_additionalRecipients_length_cdPtr).readUint256();\n\n            // Derive offset to event data using base offset & total recipients.\n            uint256 offerDataOffset = OrderFulfilled_offer_length_baseOffset + additionalRecipientsLength * OneWord;\n\n            // Derive size of offer and consideration data.\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\n            uint256 offerAndConsiderationSize =\n                OrderFulfilled_baseDataSize + (additionalRecipientsLength * ReceivedItem_size);\n\n            // Copy offer and consideration data from event data to calldata.\n            MemoryPointer.wrap(offerDataOffset).copy(dstHead.offset(tailOffset), offerAndConsiderationSize);\n\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += offerAndConsiderationSize;\n        }\n\n        // Write empty bytes for extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        dstHead.offset(tailOffset).write(0);\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += OneWord;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(tailOffset);\n\n        // Write length = 1 to the orderHashes array.\n        dstHead.offset(tailOffset).write(1);\n\n        unchecked {\n            // Write the single order hash to the orderHashes array.\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\n\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an array of bytes32 values representing\n     *      the order hashes included as part of the fulfillment and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory.\n     *\n     * @param srcLength A memory pointer referencing the order hashes array to\n     *                  be copied (and pointing to the length of the array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the orderHashes array to (and pointing to the\n     *                  length of the copied array).\n     *\n     * @return size The size of the order hashes array (including the length).\n     */\n    function _encodeOrderHashes(MemoryPointer srcLength, MemoryPointer dstLength)\n        internal\n        view\n        returns (uint256 size)\n    {\n        // Read length of the array from source and write to destination.\n        uint256 length = srcLength.readUint256();\n        dstLength.write(length);\n\n        unchecked {\n            // Determine head & tail size as one word per element in the array.\n            uint256 headAndTailSize = length << OneWordShift;\n\n            // Copy the tail starting from the next element of the source to the\n            // next element of the destination.\n            srcLength.next().copy(dstLength.next(), headAndTailSize);\n\n            // Set size to the length of the tail plus one word for length.\n            size = headAndTailSize + OneWord;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an offer or consideration array and a\n     *      memory pointer to a location to copy it to, and copies the source\n     *      data to the destination in memory as a SpentItem array.\n     *\n     * @param srcLength A memory pointer referencing the offer or consideration\n     *                  array to be copied as a SpentItem array (and pointing to\n     *                  the length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the offer array to (and pointing to the length of\n     *                  the copied array).\n     *\n     * @return size The size of the SpentItem array (including the length).\n     */\n    function _encodeSpentItems(MemoryPointer srcLength, MemoryPointer dstLength) internal pure returns (uint256 size) {\n        assembly {\n            // Read length of the array from source and write to destination.\n            let length := mload(srcLength)\n            mstore(dstLength, length)\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            let mPtrHead := add(srcLength, OneWord)\n\n            // Position in memory to write next item for calldata. Since\n            // SpentItem has a fixed length, the array elements do not contain\n            // head elements in calldata, they are concatenated together after\n            // the array length.\n            let cdPtrData := add(dstLength, OneWord)\n\n            // Pointer to end of array head in memory.\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\n\n            for {} lt(mPtrHead, mPtrHeadEnd) {} {\n                // Read pointer to data for array element from head position.\n                let mPtrTail := mload(mPtrHead)\n\n                // Copy itemType, token, identifier, amount to calldata.\n                mstore(cdPtrData, mload(mPtrTail))\n                mstore(add(cdPtrData, Common_token_offset), mload(add(mPtrTail, Common_token_offset)))\n                mstore(add(cdPtrData, Common_identifier_offset), mload(add(mPtrTail, Common_identifier_offset)))\n                mstore(add(cdPtrData, Common_amount_offset), mload(add(mPtrTail, Common_amount_offset)))\n\n                mPtrHead := add(mPtrHead, OneWord)\n                cdPtrData := add(cdPtrData, SpentItem_size)\n            }\n\n            size := add(OneWord, shl(SpentItem_size_shift, length))\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an consideration array and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory as a ReceivedItem array.\n     *\n     * @param srcLength A memory pointer referencing the consideration array to\n     *                  be copied as a ReceivedItem array (and pointing to the\n     *                  length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the consideration array to as a ReceivedItem array\n     *                  (and pointing to the length of the new array).\n     *\n     * @return size The size of the ReceivedItem array (including the length).\n     */\n    function _encodeConsiderationAsReceivedItems(MemoryPointer srcLength, MemoryPointer dstLength)\n        internal\n        view\n        returns (uint256 size)\n    {\n        unchecked {\n            // Read length of the array from source and write to destination.\n            uint256 length = srcLength.readUint256();\n            dstLength.write(length);\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            MemoryPointer srcHead = srcLength.next();\n            MemoryPointer srcHeadEnd = srcHead.offset(length << OneWordShift);\n\n            // Position in memory to write next item for calldata. Since\n            // ReceivedItem has a fixed length, the array elements do not\n            // contain offsets in calldata, they are concatenated together after\n            // the array length.\n            MemoryPointer dstHead = dstLength.next();\n            while (srcHead.lt(srcHeadEnd)) {\n                MemoryPointer srcTail = srcHead.pptr();\n                srcTail.copy(dstHead, ReceivedItem_size);\n                srcHead = srcHead.next();\n                dstHead = dstHead.offset(ReceivedItem_size);\n            }\n\n            size = OneWord + (length * ReceivedItem_size);\n        }\n    }\n}\n"
    },
    "seaport-types/src/lib/ConsiderationConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term \"pointer\" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix \"_ptr\" refers to a memory pointer.\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\n *\n *    - The term \"offset\" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\n// Declare constants for name, version, and reentrancy sentinel values.\n\n// Name is right padded, so it touches the length which is left padded. This\n// enables writing both values at once. Length goes at byte 95 in memory, and\n// name fills bytes 96-109, so both values can be written left-padded to 77.\nuint256 constant NameLengthPtr = 0x4D;\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\n\nuint256 constant information_version_offset = 0;\nuint256 constant information_version_cd_offset = 0x60;\nuint256 constant information_domainSeparator_offset = 0x20;\nuint256 constant information_conduitController_offset = 0x40;\nuint256 constant information_versionLengthPtr = 0x63;\nuint256 constant information_versionWithLength = 0x03312e35; // 1.5\nuint256 constant information_length = 0xa0;\n\nuint256 constant _NOT_ENTERED = 1;\nuint256 constant _ENTERED = 2;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS = 3;\n\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts = (\n    0x60\n);\n\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\n\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\n\n// Common Offsets\n// Offsets for identically positioned fields shared by:\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\n\nuint256 constant Selector_length = 0x4;\n\nuint256 constant Common_token_offset = 0x20;\nuint256 constant Common_identifier_offset = 0x40;\nuint256 constant Common_amount_offset = 0x60;\nuint256 constant Common_endAmount_offset = 0x80;\n\nuint256 constant SpentItem_size = 0x80;\nuint256 constant SpentItem_size_shift = 0x7;\n\nuint256 constant OfferItem_size = 0xa0;\nuint256 constant OfferItem_size_with_length = 0xc0;\n\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\nuint256 constant ReceivedItem_size = 0xa0;\nuint256 constant ReceivedItem_amount_offset = 0x60;\nuint256 constant ReceivedItem_recipient_offset = 0x80;\n\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\n\nuint256 constant ConsiderationItem_size = 0xc0;\nuint256 constant ConsiderationItem_size_with_length = 0xe0;\n\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\n// Store the same constant in an abbreviated format for a line length fix.\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\n\nuint256 constant Execution_offerer_offset = 0x20;\nuint256 constant Execution_conduit_offset = 0x40;\n\n// uint256 constant OrderParameters_offerer_offset = 0x00;\nuint256 constant OrderParameters_zone_offset = 0x20;\nuint256 constant OrderParameters_offer_head_offset = 0x40;\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\n// uint256 constant OrderParameters_orderType_offset = 0x80;\nuint256 constant OrderParameters_startTime_offset = 0xa0;\nuint256 constant OrderParameters_endTime_offset = 0xc0;\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\n// uint256 constant OrderParameters_salt_offset = 0x100;\nuint256 constant OrderParameters_conduit_offset = 0x120;\nuint256 constant OrderParameters_counter_offset = 0x140;\n\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\n\nuint256 constant AdvancedOrder_head_size = 0xa0;\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\nuint256 constant AdvancedOrder_signature_offset = 0x60;\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\n\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant SixtyThreeBytes = 0x3f;\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\n\n// uint256 constant BasicOrder_endAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_common_params_size = 0xa0;\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\nuint256 constant BasicOrder_receivedItemByteMap = (\n    0x0000010102030000000000000000000000000000000000000000000000000000\n);\nuint256 constant BasicOrder_offeredItemByteMap = (\n    0x0203020301010000000000000000000000000000000000000000000000000000\n);\n\nbytes32 constant OrdersMatchedTopic0 = (\n    0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7\n);\n\nuint256 constant EIP712_Order_size = 0x180;\nuint256 constant EIP712_OfferItem_size = 0xc0;\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\nuint256 constant AdditionalRecipient_size = 0x40;\nuint256 constant AdditionalRecipient_size_shift = 0x6;\n\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_OrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\n\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\nuint256 constant EIP712_domainData_size = 0xa0;\n\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\n// 768 for 24 siblings.\n\nuint256 constant BulkOrderProof_minSize = 0x63;\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\nuint256 constant BulkOrderProof_keyShift = 0xe8;\nuint256 constant BulkOrderProof_keySize = 0x3;\n\nuint256 constant BulkOrder_Typehash_Height_One = (\n    0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32\n);\nuint256 constant BulkOrder_Typehash_Height_Two = (\n    0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30\n);\nuint256 constant BulkOrder_Typehash_Height_Three = (\n    0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d\n);\nuint256 constant BulkOrder_Typehash_Height_Four = (\n    0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1\n);\nuint256 constant BulkOrder_Typehash_Height_Five = (\n    0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6\n);\nuint256 constant BulkOrder_Typehash_Height_Six = (\n    0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55\n);\nuint256 constant BulkOrder_Typehash_Height_Seven = (\n    0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c\n);\nuint256 constant BulkOrder_Typehash_Height_Eight = (\n    0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14\n);\nuint256 constant BulkOrder_Typehash_Height_Nine = (\n    0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a\n);\nuint256 constant BulkOrder_Typehash_Height_Ten = (\n    0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05\n);\nuint256 constant BulkOrder_Typehash_Height_Eleven = (\n    0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53\n);\nuint256 constant BulkOrder_Typehash_Height_Twelve = (\n    0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f\n);\nuint256 constant BulkOrder_Typehash_Height_Thirteen = (\n    0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e\n);\nuint256 constant BulkOrder_Typehash_Height_Fourteen = (\n    0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590\n);\nuint256 constant BulkOrder_Typehash_Height_Fifteen = (\n    0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9\n);\nuint256 constant BulkOrder_Typehash_Height_Sixteen = (\n    0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8\n);\nuint256 constant BulkOrder_Typehash_Height_Seventeen = (\n    0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222\n);\nuint256 constant BulkOrder_Typehash_Height_Eighteen = (\n    0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877\n);\nuint256 constant BulkOrder_Typehash_Height_Nineteen = (\n    0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d\n);\nuint256 constant BulkOrder_Typehash_Height_Twenty = (\n    0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyOne = (\n    0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo = (\n    0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyThree = (\n    0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyFour = (\n    0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c\n);\n\nuint256 constant receivedItemsHash_ptr = 0x60;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  data for OrderFulfilled\n *\n *   event OrderFulfilled(\n *     bytes32 orderHash,\n *     address indexed offerer,\n *     address indexed zone,\n *     address fulfiller,\n *     SpentItem[] offer,\n *       > (itemType, token, id, amount)\n *     ReceivedItem[] consideration\n *       > (itemType, token, id, amount, recipient)\n *   )\n *\n *  - 0x00: orderHash\n *  - 0x20: fulfiller\n *  - 0x40: offer offset (0x80)\n *  - 0x60: consideration offset (0x120)\n *  - 0x80: offer.length (1)\n *  - 0xa0: offerItemType\n *  - 0xc0: offerToken\n *  - 0xe0: offerIdentifier\n *  - 0x100: offerAmount\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\n *  - 0x140: considerationItemType\n *  - 0x160: considerationToken\n *  - 0x180: considerationIdentifier\n *  - 0x1a0: considerationAmount\n *  - 0x1c0: considerationRecipient\n *  - ...\n */\n\n// Minimum length of the OrderFulfilled event data.\n// Must be added to the size of the ReceivedItem array for additionalRecipients\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\nuint256 constant OrderFulfilled_selector = (\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\n);\n\n// Minimum offset in memory to OrderFulfilled event data.\n// Must be added to the size of the EIP712 hash array for additionalRecipients\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\nuint256 constant OrderFulfilled_baseOffset = 0x180;\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\n\n// Related constants used for restricted order checks on basic orders.\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\n\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\n\n// BasicOrderParameters\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\nuint256 constant BasicOrder_parameters_ptr = 0x20;\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for ConsiderationItem\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n *   - 0xa0: itemType\n *   - 0xc0: token\n *   - 0xe0: identifier\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n *   - 0x140: recipient\n */\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for OfferItem\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\n *   - 0xa0:  itemType\n *   - 0xc0:  token\n *   - 0xe0:  identifier (reused for offeredItemsHash)\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n */\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for Order\n *   - 0x80:   Order EIP-712 typehash (constant)\n *   - 0xa0:   orderParameters.offerer\n *   - 0xc0:   orderParameters.zone\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n *   - 0x120:  orderType\n *   - 0x140:  startTime\n *   - 0x160:  endTime\n *   - 0x180:  zoneHash\n *   - 0x1a0:  salt\n *   - 0x1c0:  conduit\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n */\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\nuint256 constant BasicOrder_signature_ptr = 0x260;\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\n\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\n\nuint256 constant Counter_blockhash_shift = 0x80;\n\n// Signature-related\nbytes32 constant EIP2098_allButHighestBitMask = (\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n);\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\n    0x0000000000000000000000000000000000000000000000000000000101000000\n);\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\nbytes32 constant EIP1271_isValidSignature_selector = (\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\n\nuint256 constant EIP_712_PREFIX = (\n    0x1901000000000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\nuint256 constant Create2AddressDerivation_length = 0x55;\n\nuint256 constant MaskOverByteTwelve = (\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\n);\nuint256 constant MaskOverLastTwentyBytes = (\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\n);\nuint256 constant AddressDirtyUpperBitThreshold = (\n    0x0000000000000000000000010000000000000000000000000000000000000000\n);\nuint256 constant MaskOverFirstFourBytes = (\n    0xffffffff00000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant Conduit_execute_signature = (\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant MaxUint8 = 0xff;\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\n\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\n\nuint256 constant OneConduitExecute_size = 0x104;\n\n// Sentinel value to indicate that the conduit accumulator is not armed.\nuint256 constant AccumulatorDisarmed = 0x20;\nuint256 constant AccumulatorArmed = 0x40;\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\nuint256 constant Accumulator_selector_ptr = 0x40;\nuint256 constant Accumulator_array_offset_ptr = 0x44;\nuint256 constant Accumulator_array_length_ptr = 0x64;\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\nuint256 constant Accumulator_array_offset = 0x20;\n\nuint256 constant Conduit_transferItem_size = 0xc0;\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\n\nuint256 constant Ecrecover_precompile = 0x1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant Signature_lower_v = 27;\n\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\nuint256 constant NonMatchSelector_MagicMask = (\n    0x4000000000000000000000000000000000000000000000000000000000\n);\n\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\n// indicates that a non match selector has been called.\nuint256 constant NonMatchSelector_InvalidErrorValue = (\n    0x4000000000000000000000000000000000000000000000000000000001\n);\n\n/**\n * @dev Selector and offsets for generateOrder\n *\n * function generateOrder(\n *   address fulfiller,\n *   SpentItem[] calldata minimumReceived,\n *   SpentItem[] calldata maximumSpent,\n *   bytes calldata context\n * )\n */\nuint256 constant generateOrder_selector = 0x98919765;\nuint256 constant generateOrder_selector_offset = 0x1c;\nuint256 constant generateOrder_head_offset = 0x04;\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\nuint256 constant generateOrder_context_head_offset = 0x60;\nuint256 constant generateOrder_base_tail_offset = 0x80;\nuint256 constant generateOrder_maximum_returndatasize = 0xffff;\n\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\nuint256 constant ratifyOrder_selector_offset = 0x1c;\nuint256 constant ratifyOrder_head_offset = 0x04;\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\nuint256 constant ratifyOrder_context_head_offset = 0x40;\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\n\nuint256 constant validateOrder_selector = 0x17b1f942;\nuint256 constant validateOrder_selector_offset = 0x1c;\nuint256 constant validateOrder_head_offset = 0x04;\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\n\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\nuint256 constant ZoneParameters_offerer_offset = 0x40;\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\nuint256 constant ZoneParameters_endTime_offset = 0x100;\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x64;\n\n// ConsiderationDecoder Constants\nuint256 constant OrderParameters_head_size = 0x0160;\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\n    0x0140\n);\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\n\nuint256 constant Order_signature_offset = 0x20;\nuint256 constant Order_head_size = 0x40;\n\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\n\nuint256 constant CriteriaResolver_head_size = 0xa0;\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\n\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\nuint256 constant Fulfillment_head_size = 0x40;\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\n\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\n"
    },
    "seaport-types/src/lib/ConsiderationStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BasicOrderType,\n    ItemType,\n    OrderType,\n    Side\n} from \"./ConsiderationEnums.sol\";\n\nimport {\n    CalldataPointer,\n    MemoryPointer\n} from \"../helpers/PointerLibraries.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n\nusing StructPointers for OrderComponents global;\nusing StructPointers for OfferItem global;\nusing StructPointers for ConsiderationItem global;\nusing StructPointers for SpentItem global;\nusing StructPointers for ReceivedItem global;\nusing StructPointers for BasicOrderParameters global;\nusing StructPointers for AdditionalRecipient global;\nusing StructPointers for OrderParameters global;\nusing StructPointers for Order global;\nusing StructPointers for AdvancedOrder global;\nusing StructPointers for OrderStatus global;\nusing StructPointers for CriteriaResolver global;\nusing StructPointers for Fulfillment global;\nusing StructPointers for FulfillmentComponent global;\nusing StructPointers for Execution global;\nusing StructPointers for ZoneParameters global;\n\n/**\n * @dev This library provides a set of functions for converting structs to\n *      pointers.\n */\nlibrary StructPointers {\n    /**\n     * @dev Get a MemoryPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderComponents memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderComponents calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OfferItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OfferItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ConsiderationItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ConsiderationItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        SpentItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        SpentItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ReceivedItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ReceivedItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        BasicOrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        BasicOrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdditionalRecipient memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdditionalRecipient calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Order memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Order calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdvancedOrder memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdvancedOrder calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderStatus memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderStatus calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        CriteriaResolver memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        CriteriaResolver calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Fulfillment memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Fulfillment calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        FulfillmentComponent memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        FulfillmentComponent calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Execution memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Execution calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ZoneParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ZoneParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n}\n"
    },
    "seaport-types/src/lib/ConsiderationEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}\n"
    },
    "seaport-core/src/lib/ConsiderationDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    Fulfillment,\n    FulfillmentComponent,\n    OfferItem,\n    Order,\n    OrderParameters,\n    ReceivedItem\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {\n    AdvancedOrder_denominator_offset,\n    AdvancedOrder_extraData_offset,\n    AdvancedOrder_fixed_segment_0,\n    AdvancedOrder_head_size,\n    AdvancedOrder_numerator_offset,\n    AdvancedOrder_signature_offset,\n    AdvancedOrderPlusOrderParameters_head_size,\n    Common_amount_offset,\n    Common_endAmount_offset,\n    ConsiderationItem_size_with_length,\n    ConsiderationItem_size,\n    CriteriaResolver_criteriaProof_offset,\n    CriteriaResolver_fixed_segment_0,\n    CriteriaResolver_head_size,\n    FourWords,\n    FreeMemoryPointerSlot,\n    Fulfillment_considerationComponents_offset,\n    Fulfillment_head_size,\n    FulfillmentComponent_mem_tail_size_shift,\n    FulfillmentComponent_mem_tail_size,\n    generateOrder_maximum_returndatasize,\n    OfferItem_size_with_length,\n    OfferItem_size,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    Order_head_size,\n    Order_signature_offset,\n    OrderComponents_OrderParameters_common_head_size,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_head_size,\n    OrderParameters_offer_head_offset,\n    OrderParameters_totalOriginalConsiderationItems_offset,\n    ReceivedItem_recipient_offset,\n    ReceivedItem_size,\n    ReceivedItem_size_excluding_recipient,\n    SpentItem_size_shift,\n    SpentItem_size,\n    ThirtyOneBytes,\n    TwoWords\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {CalldataPointer, malloc, MemoryPointer, OffsetOrLengthMask} from \"seaport-types/src/helpers/PointerLibraries.sol\";\n\ncontract ConsiderationDecoder {\n    /**\n     * @dev Takes a bytes array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the bytes array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeBytes(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Derive the size of the bytes array, rounding up to nearest word\n            // and adding a word for the length field. Note: masking\n            // `calldataload(cdPtrLength)` is redundant here.\n            let size := add(and(add(calldataload(cdPtrLength), ThirtyOneBytes), OnlyFullWordMask), OneWord)\n\n            // Copy bytes from calldata into memory based on pointers and size.\n            calldatacopy(mPtrLength, cdPtrLength, size)\n\n            // Store the masked value in memory. Note: the value of `size` is at\n            // least 32, meaning the calldatacopy above will at least write to\n            // `[mPtrLength, mPtrLength + 32)`.\n            mstore(mPtrLength, and(calldataload(cdPtrLength), OffsetOrLengthMask))\n\n            // Update free memory pointer based on the size of the bytes array.\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\n        }\n    }\n\n    /**\n     * @dev Takes an offer array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the offer array\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the offer array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeOffer(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all offer array data into memory at the tail pointer.\n            calldatacopy(mPtrTail, add(cdPtrLength, OneWord), mul(arrLength, OfferItem_size))\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {} lt(mPtrHeadNext, mPtrTail) {} {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment the next tail pointer by the size of an offer item.\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a consideration array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the consideration\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the consideration\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeConsideration(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all consideration array data into memory at tail pointer.\n            calldatacopy(mPtrTail, add(cdPtrLength, OneWord), mul(arrLength, ConsiderationItem_size))\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {} lt(mPtrHeadNext, mPtrTail) {} {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment next tail pointer by size of a consideration item.\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\n     *      OrderParameters struct and associated offer and consideration data\n     *      to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     * @param mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParametersTo(CalldataPointer cdPtr, MemoryPointer mPtr) internal pure {\n        // Copy the full OrderParameters head from calldata to memory.\n        cdPtr.copy(mPtr, OrderParameters_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            _decodeConsideration(cdPtr.pptr(OrderParameters_consideration_head_offset))\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParameters(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the OrderParameters head (offer and\n        // consideration are allocated independently).\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Decode and copy the order parameters to the newly allocated memory.\n        _decodeOrderParametersTo(cdPtr, mPtr);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the Order struct head.\n     */\n    function _decodeOrder(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Order head (OrderParameters and\n        // signature are allocated independently).\n        mPtr = malloc(Order_head_size);\n\n        // Resolve OrderParameters calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(Order_signature_offset).write(_decodeBytes(cdPtr.pptr(Order_signature_offset)));\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeAdvancedOrder(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Use numerator + denominator calldata offset to decode and copy\n        // from calldata and write resultant memory offset to head in memory.\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\n            mPtr.offset(AdvancedOrder_numerator_offset), AdvancedOrder_fixed_segment_0\n        );\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters to memory.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(_decodeBytes(cdPtr.pptr(AdvancedOrder_signature_offset)));\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(_decodeBytes(cdPtr.pptr(AdvancedOrder_extraData_offset)));\n    }\n\n    /**\n     * @dev Allocates a single word of empty bytes in memory and returns the\n     *      pointer to that memory region.\n     *\n     * @return mPtr The memory pointer to the new empty word in memory.\n     */\n    function _getEmptyBytesOrArray() internal pure returns (MemoryPointer mPtr) {\n        mPtr = malloc(OneWord);\n        mPtr.write(0);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory as an AdvancedOrder.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeOrderAsAdvancedOrder(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Write default Order numerator and denominator values (i.e. 1/1).\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(_decodeBytes(cdPtr.pptr(Order_signature_offset)));\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(_getEmptyBytesOrArray());\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\n     *      decoded array to memory as an array of AdvancedOrder structs.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the array of advanced\n     *                    orders in memory which contains length of the array.\n     */\n    function _decodeOrdersAsAdvancedOrders(CalldataPointer cdPtrLength)\n        internal\n        pure\n        returns (MemoryPointer mPtrLength)\n    {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy from\n                // calldata, and write resultant AdvancedOrder offset to memory.\n                mPtrHead.offset(offset).write(_decodeOrderAsAdvancedOrder(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\n     *      types, and copies the decoded proof to memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria proof\n     *                    in memory which contains length of the array.\n     */\n    function _decodeCriteriaProof(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive array size based on one word per array element and length.\n            uint256 arrSize = (arrLength + 1) << OneWordShift;\n\n            // Allocate memory equal to the array size.\n            mPtrLength = malloc(arrSize);\n\n            // Copy the array from calldata into memory.\n            cdPtrLength.copy(mPtrLength, arrSize);\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\n     *\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\n     */\n    function _decodeCriteriaResolver(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the CriteriaResolver head (the criteria\n        // proof bytes32 array is allocated independently).\n        mPtr = malloc(CriteriaResolver_head_size);\n\n        // Decode and copy order index, side, index, and identifier from\n        // calldata and write resultant memory offset to head in memory.\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\n\n        // Resolve criteria proof calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\n            _decodeCriteriaProof(cdPtr.pptr(CriteriaResolver_criteriaProof_offset))\n        );\n    }\n\n    /**\n     * @dev Takes an array of criteria resolvers from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria\n     *                    resolver array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeCriteriaResolvers(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve CriteriaResolver calldata offset, use it to decode\n                // and copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(_decodeCriteriaResolver(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of orders from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the orders array\n     *                    in memory which contains the length of the array.\n     */\n    function _decodeOrders(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy\n                // from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(_decodeOrder(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of fulfillment components from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\n     *                    components array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillment\n     *                    components array in memory which contains the length\n     *                    of the array.\n     */\n    function _decodeFulfillmentComponents(CalldataPointer cdPtrLength)\n        internal\n        pure\n        returns (MemoryPointer mPtrLength)\n    {\n        assembly {\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            mstore(mPtrLength, arrLength)\n            let mPtrHead := add(mPtrLength, OneWord)\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n            let mPtrTailNext := mPtrTail\n            calldatacopy(mPtrTail, add(cdPtrLength, OneWord), shl(FulfillmentComponent_mem_tail_size_shift, arrLength))\n            let mPtrHeadNext := mPtrHead\n            for {} lt(mPtrHeadNext, mPtrTail) {} {\n                mstore(mPtrHeadNext, mPtrTailNext)\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n                mPtrTailNext := add(mPtrTailNext, FulfillmentComponent_mem_tail_size)\n            }\n\n            // Update the free memory pointer.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a nested array of fulfillment components from calldata and\n     *      copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the nested\n     *                    fulfillment components array in calldata which\n     *                    contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the nested\n     *                    fulfillment components array in memory which\n     *                    contains the length of the array.\n     */\n    function _decodeNestedFulfillmentComponents(CalldataPointer cdPtrLength)\n        internal\n        pure\n        returns (MemoryPointer mPtrLength)\n    {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve FulfillmentComponents array calldata offset, use it\n                // to decode and copy from calldata, and write memory offset.\n                mPtrHead.offset(offset).write(_decodeFulfillmentComponents(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of advanced orders from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the advanced orders\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeAdvancedOrders(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve AdvancedOrder calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(_decodeAdvancedOrder(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\n     *\n     * @return mPtr A memory pointer to the Fulfillment struct head.\n     */\n    function _decodeFulfillment(CalldataPointer cdPtr) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Fulfillment head (the fulfillment\n        // components arrays are allocated independently).\n        mPtr = malloc(Fulfillment_head_size);\n\n        // Resolve offerComponents calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\n\n        // Resolve considerationComponents calldata offset, use it to decode and\n        // copy from calldata, and write resultant memory offset to memory head.\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\n            _decodeFulfillmentComponents(cdPtr.pptr(Fulfillment_considerationComponents_offset))\n        );\n    }\n\n    /**\n     * @dev Takes an array of fulfillments from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillments\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeFulfillments(CalldataPointer cdPtrLength) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Fulfillment calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(_decodeFulfillment(cdPtrHead.pptr(offset)));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\n     *      decoded struct to memory as an OrderParameters struct (with the\n     *      totalOriginalConsiderationItems value set equal to the length of the\n     *      supplied consideration array).\n     *\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderComponentsAsOrderParameters(CalldataPointer cdPtr)\n        internal\n        pure\n        returns (MemoryPointer mPtr)\n    {\n        // Allocate memory for the OrderParameters head.\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Copy the full OrderComponents head from calldata to memory.\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        MemoryPointer consideration = _decodeConsideration(cdPtr.pptr(OrderParameters_consideration_head_offset));\n        mPtr.offset(OrderParameters_consideration_head_offset).write(consideration);\n\n        // Write masked consideration length to totalOriginalConsiderationItems.\n        mPtr.offset(OrderParameters_totalOriginalConsiderationItems_offset).write(consideration.readUint256());\n    }\n\n    /**\n     * @dev Decodes the returndata from a call to generateOrder, or returns\n     *      empty arrays and a boolean signifying that the returndata does not\n     *      adhere to a valid encoding scheme if it cannot be decoded.\n     *\n     * @return invalidEncoding A boolean signifying whether the returndata has\n     *                         an invalid encoding.\n     * @return offer           The decoded offer array.\n     * @return consideration   The decoded consideration array.\n     */\n    function _decodeGenerateOrderReturndata()\n        internal\n        pure\n        returns (uint256 invalidEncoding, MemoryPointer offer, MemoryPointer consideration)\n    {\n        assembly {\n            // Check that returndatasize is at least four words: offerOffset,\n            // considerationOffset, offerLength, & considerationLength\n            invalidEncoding := lt(returndatasize(), FourWords)\n\n            let offsetOffer\n            let offsetConsideration\n            let offerLength\n            let considerationLength\n\n            // Proceed if enough returndata is present to continue evaluation.\n            if iszero(invalidEncoding) {\n                // Copy first two words of returndata (the offsets to offer and\n                // consideration array lengths) to scratch space.\n                returndatacopy(0, 0, TwoWords)\n                offsetOffer := mload(0)\n                offsetConsideration := mload(OneWord)\n\n                // If valid length, check that offsets are within returndata.\n                let invalidOfferOffset := gt(offsetOffer, returndatasize())\n                let invalidConsiderationOffset := gt(offsetConsideration, returndatasize())\n\n                // Only proceed if length (and thus encoding) is valid so far.\n                invalidEncoding := or(invalidOfferOffset, invalidConsiderationOffset)\n                if iszero(invalidEncoding) {\n                    // Copy length of offer array to scratch space.\n                    returndatacopy(0, offsetOffer, OneWord)\n                    offerLength := mload(0)\n\n                    // Copy length of consideration array to scratch space.\n                    returndatacopy(OneWord, offsetConsideration, OneWord)\n                    considerationLength := mload(OneWord)\n\n                    {\n                        // Calculate total size of offer & consideration arrays.\n                        let totalOfferSize := shl(SpentItem_size_shift, offerLength)\n                        let totalConsiderationSize := mul(ReceivedItem_size, considerationLength)\n\n                        // Add 4 words to total size to cover the offset and\n                        // length fields of the two arrays.\n                        let totalSize := add(FourWords, add(totalOfferSize, totalConsiderationSize))\n                        // Don't continue if returndatasize exceeds 65535 bytes\n                        // or is greater than the calculated size.\n                        invalidEncoding :=\n                            or(\n                                gt(or(offerLength, considerationLength), generateOrder_maximum_returndatasize),\n                                gt(totalSize, returndatasize())\n                            )\n\n                        // Set first word of scratch space to 0 so length of\n                        // offer/consideration are set to 0 on invalid encoding.\n                        mstore(0, 0)\n                    }\n                }\n            }\n\n            if iszero(invalidEncoding) {\n                offer := copySpentItemsAsOfferItems(add(offsetOffer, OneWord), offerLength)\n\n                consideration :=\n                    copyReceivedItemsAsConsiderationItems(add(offsetConsideration, OneWord), considerationLength)\n            }\n\n            function copySpentItemsAsOfferItems(rdPtrHead, length) -> mPtrLength {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n\n                // Allocate memory for the array.\n                mstore(FreeMemoryPointerSlot, add(mPtrLength, add(OneWord, mul(length, OfferItem_size_with_length))))\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, length)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\n\n                // Iterate over each element.\n                for {} lt(headOffsetFromLength, headSizeWithLength) {} {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(mPtrTailNext, rdPtrHead, SpentItem_size)\n\n                    // Copy amount to endAmount.\n                    mstore(add(mPtrTailNext, Common_endAmount_offset), mload(add(mPtrTailNext, Common_amount_offset)))\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHead := add(rdPtrHead, SpentItem_size)\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n            }\n\n            function copyReceivedItemsAsConsiderationItems(rdPtrHead, length) -> mPtrLength {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n\n                // Allocate memory for the array.\n                mstore(\n                    FreeMemoryPointerSlot,\n                    add(mPtrLength, add(OneWord, mul(length, ConsiderationItem_size_with_length)))\n                )\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, length)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\n\n                // Iterate over each element.\n                for {} lt(headOffsetFromLength, headSizeWithLength) {} {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(mPtrTailNext, rdPtrHead, ReceivedItem_size_excluding_recipient)\n\n                    // Copy amount and recipient.\n                    returndatacopy(\n                        add(mPtrTailNext, Common_endAmount_offset), add(rdPtrHead, Common_amount_offset), TwoWords\n                    )\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHead := add(rdPtrHead, ReceivedItem_size)\n                    mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a function returning _decodeGenerateOrderReturndata types\n     *      into a function returning offer and consideration types.\n     *\n     * @param inFn The input function, taking no arguments and returning an\n     *             error buffer, spent item array, and received item array.\n     *\n     * @return outFn The output function, taking no arguments and returning an\n     *               error buffer, offer array, and consideration array.\n     */\n    function _convertGetGeneratedOrderResult(\n        function()\n            internal\n            pure\n            returns (uint256, MemoryPointer, MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function()\n                                                internal\n                                                pure\n                                                returns (\n                                                    uint256,\n                                                    OfferItem[] memory,\n                                                    ConsiderationItem[] memory\n                                                ) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      OfferItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking OfferItem, address, bytes32,\n     *               and bytes types.\n     */\n    function _toOfferItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(OfferItem memory, address, bytes32, bytes memory)\n                                                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      ConsiderationItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking ConsiderationItem, address,\n     *               bytes32, and bytes types.\n     */\n    function _toConsiderationItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\n                                                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an OrderParameters type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an OrderParameters type.\n     */\n    function _toOrderParametersReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (OrderParameters memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an AdvancedOrder type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an AdvancedOrder type.\n     */\n    function _toAdvancedOrderReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (AdvancedOrder memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of CriteriaResolver types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of CriteriaResolver types.\n     */\n    function _toCriteriaResolversReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (CriteriaResolver[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Order types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Order types.\n     */\n    function _toOrdersReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (Order[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a nested dynamic array of dynamic arrays of FulfillmentComponent\n     *      types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a nested dynamic array of dynamic arrays of\n     *               FulfillmentComponent types.\n     */\n    function _toNestedFulfillmentComponentsReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (FulfillmentComponent[][] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of AdvancedOrder types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of AdvancedOrder types.\n     */\n    function _toAdvancedOrdersReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (AdvancedOrder[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Fulfillment types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Fulfillment types.\n     */\n    function _toFulfillmentsReturnType(function(CalldataPointer) internal pure returns (MemoryPointer) inFn)\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                                                internal\n                                                pure\n                                                returns (Fulfillment[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Caches the endAmount in an offer item and replaces it with\n     * a given recipient so that its memory may be reused as a temporary\n     * ReceivedItem.\n     *\n     * @param offerItem The offer item.\n     * @param recipient The recipient.\n     *\n     * @return originalEndAmount The original end amount.\n     */\n    function _replaceEndAmountWithRecipient(OfferItem memory offerItem, address recipient)\n        internal\n        pure\n        returns (uint256 originalEndAmount)\n    {\n        assembly {\n            // Derive the pointer to the end amount on the offer item.\n            let endAmountPtr := add(offerItem, ReceivedItem_recipient_offset)\n\n            // Retrieve the value of the end amount on the offer item.\n            originalEndAmount := mload(endAmountPtr)\n\n            // Write recipient to received item at the offer end amount pointer.\n            mstore(endAmountPtr, recipient)\n        }\n    }\n}\n"
    },
    "seaport-core/src/lib/CounterManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ConsiderationEventsAndErrors} from \"seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol\";\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\n\nimport {Counter_blockhash_shift, OneWord, TwoWords} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\n/**\n * @title CounterManager\n * @author 0age\n * @notice CounterManager contains a storage mapping and related functionality\n *         for retrieving and incrementing a per-offerer counter.\n */\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\n    // Only orders signed using an offerer's current counter are fulfillable.\n    mapping(address => uint256) private _counters;\n\n    /**\n     * @dev Internal function to cancel all orders from a given offerer in bulk\n     *      by incrementing a counter by a large, quasi-random interval. Note\n     *      that only the offerer may increment the counter. Note that the\n     *      counter is incremented by a large, quasi-random interval, which\n     *      makes it infeasible to \"activate\" signed orders by incrementing the\n     *      counter.  This activation functionality can be achieved instead with\n     *      restricted orders or contract orders.\n     *\n     * @return newCounter The new counter.\n     */\n    function _incrementCounter() internal returns (uint256 newCounter) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Utilize assembly to access counters storage mapping directly. Skip\n        // overflow check as counter cannot be incremented that far.\n        assembly {\n            // Use second half of previous block hash as a quasi-random number.\n            let quasiRandomNumber := shr(Counter_blockhash_shift, blockhash(sub(number(), 1)))\n\n            // Write the caller to scratch space.\n            mstore(0, caller())\n\n            // Write the storage slot for _counters to scratch space.\n            mstore(OneWord, _counters.slot)\n\n            // Derive the storage pointer for the counter value.\n            let storagePointer := keccak256(0, TwoWords)\n\n            // Derive new counter value using random number and original value.\n            newCounter := add(quasiRandomNumber, sload(storagePointer))\n\n            // Store the updated counter value.\n            sstore(storagePointer, newCounter)\n        }\n\n        // Emit an event containing the new counter.\n        emit CounterIncremented(newCounter, msg.sender);\n    }\n\n    /**\n     * @dev Internal view function to retrieve the current counter for a given\n     *      offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return currentCounter The current counter.\n     */\n    function _getCounter(address offerer) internal view returns (uint256 currentCounter) {\n        // Return the counter for the supplied offerer.\n        currentCounter = _counters[offerer];\n    }\n}\n"
    },
    "seaport-core/src/lib/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyErrors} from \"seaport-types/src/interfaces/ReentrancyErrors.sol\";\n\nimport {LowLevelHelpers} from \"./LowLevelHelpers.sol\";\n\nimport {_revertInvalidMsgValue, _revertNoReentrantCalls} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\nimport {\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS, _ENTERED, _NOT_ENTERED\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\n/**\n * @title ReentrancyGuard\n * @author 0age\n * @notice ReentrancyGuard contains a storage variable and related functionality\n *         for protecting against reentrancy.\n */\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\n    // Prevent reentrant calls on protected functions.\n    uint256 private _reentrancyGuard;\n\n    /**\n     * @dev Initialize the reentrancy guard during deployment.\n     */\n    constructor() {\n        // Initialize the reentrancy guard in a cleared state.\n        _reentrancyGuard = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\n     *      guard is not currently set and, if not, to set a sentinel value for\n     *      the reentrancy guard based on whether or not native tokens may be\n     *      received during execution or not.\n     *\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\n     *                           be received during execution or not.\n     */\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\n        // Ensure that the reentrancy guard is not already set.\n        _assertNonReentrant();\n\n        // Set the reentrancy guard. A value of 2 indicates that native tokens\n        // may not be accepted during execution, whereas a value of 3 indicates\n        // that they will be accepted (with any remaining native tokens returned\n        // to the caller).\n        unchecked {\n            _reentrancyGuard = _ENTERED + _cast(acceptNativeTokens);\n        }\n    }\n\n    /**\n     * @dev Internal function to unset the reentrancy guard sentinel value.\n     */\n    function _clearReentrancyGuard() internal {\n        // Clear the reentrancy guard.\n        _reentrancyGuard = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Internal view function to ensure that a sentinel value for the\n     *         reentrancy guard is not currently set.\n     */\n    function _assertNonReentrant() internal view {\n        // Ensure that the reentrancy guard is not currently set.\n        if (_reentrancyGuard != _NOT_ENTERED) {\n            _revertNoReentrantCalls();\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that the sentinel value indicating\n     *      native tokens may be received during execution is currently set.\n     */\n    function _assertAcceptingNativeTokens() internal view {\n        // Ensure that the reentrancy guard is not currently set.\n        if (_reentrancyGuard != _ENTERED_AND_ACCEPTING_NATIVE_TOKENS) {\n            _revertInvalidMsgValue(msg.value);\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    OrderParameters,\n    ReceivedItem,\n    SpentItem\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationEventsAndErrors\n * @author 0age\n * @notice ConsiderationEventsAndErrors contains all events and errors.\n */\ninterface ConsiderationEventsAndErrors {\n    /**\n     * @dev Emit an event whenever an order is successfully fulfilled.\n     *\n     * @param orderHash     The hash of the fulfilled order.\n     * @param offerer       The offerer of the fulfilled order.\n     * @param zone          The zone of the fulfilled order.\n     * @param recipient     The recipient of each spent item on the fulfilled\n     *                      order, or the null address if there is no specific\n     *                      fulfiller (i.e. the order is part of a group of\n     *                      orders). Defaults to the caller unless explicitly\n     *                      specified otherwise by the fulfiller.\n     * @param offer         The offer items spent as part of the order.\n     * @param consideration The consideration items received as part of the\n     *                      order along with the recipients of each item.\n     */\n    event OrderFulfilled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone,\n        address recipient,\n        SpentItem[] offer,\n        ReceivedItem[] consideration\n    );\n\n    /**\n     * @dev Emit an event whenever an order is successfully cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     * @param offerer   The offerer of the cancelled order.\n     * @param zone      The zone of the cancelled order.\n     */\n    event OrderCancelled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone\n    );\n\n    /**\n     * @dev Emit an event whenever an order is explicitly validated. Note that\n     *      this event will not be emitted on partial fills even though they do\n     *      validate the order as part of partial fulfillment.\n     *\n     * @param orderHash        The hash of the validated order.\n     * @param orderParameters  The parameters of the validated order.\n     */\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\n\n    /**\n     * @dev Emit an event whenever one or more orders are matched using either\n     *      matchOrders or matchAdvancedOrders.\n     *\n     * @param orderHashes The order hashes of the matched orders.\n     */\n    event OrdersMatched(bytes32[] orderHashes);\n\n    /**\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\n     *\n     * @param newCounter The new counter for the offerer.\n     * @param offerer    The offerer in question.\n     */\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has\n     *      already been fully filled.\n     *\n     * @param orderHash The order hash on which a fill was attempted.\n     */\n    error OrderAlreadyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order outside the\n     *      specified start time and end time.\n     *\n     * @param startTime The time at which the order becomes active.\n     * @param endTime   The time at which the order becomes inactive.\n     */\n    error InvalidTime(uint256 startTime, uint256 endTime);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order referencing an\n     *      invalid conduit (i.e. one that has not been deployed).\n     */\n    error InvalidConduit(bytes32 conduitKey, address conduit);\n\n    /**\n     * @dev Revert with an error when an order is supplied for fulfillment with\n     *      a consideration array that is shorter than the original array.\n     */\n    error MissingOriginalConsiderationItems();\n\n    /**\n     * @dev Revert with an error when an order is validated and the length of\n     *      the consideration array is not equal to the supplied total original\n     *      consideration items value. This error is also thrown when contract\n     *      orders supply a total original consideration items value that does\n     *      not match the supplied consideration array length.\n     */\n    error ConsiderationLengthNotEqualToTotalOriginal();\n\n    /**\n     * @dev Revert with an error when a call to a conduit fails with revert data\n     *      that is too expensive to return.\n     */\n    error InvalidCallToConduit(address conduit);\n\n    /**\n     * @dev Revert with an error if a consideration amount has not been fully\n     *      zeroed out after applying all fulfillments.\n     *\n     * @param orderIndex         The index of the order with the consideration\n     *                           item with a shortfall.\n     * @param considerationIndex The index of the consideration item on the\n     *                           order.\n     * @param shortfallAmount    The unfulfilled consideration amount.\n     */\n    error ConsiderationNotMet(\n        uint256 orderIndex,\n        uint256 considerationIndex,\n        uint256 shortfallAmount\n    );\n\n    /**\n     * @dev Revert with an error when insufficient native tokens are supplied as\n     *      part of msg.value when fulfilling orders.\n     */\n    error InsufficientNativeTokensSupplied();\n\n    /**\n     * @dev Revert with an error when a native token transfer reverts.\n     */\n    error NativeTokenTransferGenericFailure(address account, uint256 amount);\n\n    /**\n     * @dev Revert with an error when a partial fill is attempted on an order\n     *      that does not specify partial fill support in its order type.\n     */\n    error PartialFillsNotEnabledForOrder();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has been\n     *      cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     */\n    error OrderIsCancelled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order that has\n     *      been partially filled.\n     *\n     * @param orderHash The hash of the partially used order.\n     */\n    error OrderPartiallyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to cancel an order as a caller\n     *      other than the indicated offerer or zone or when attempting to\n     *      cancel a contract order.\n     */\n    error CannotCancelOrder();\n\n    /**\n     * @dev Revert with an error when supplying a fraction with a value of zero\n     *      for the numerator or denominator, or one where the numerator exceeds\n     *      the denominator.\n     */\n    error BadFraction();\n\n    /**\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\n     *      non-payable basic order route or does not supply any callvalue to a\n     *      payable basic order route.\n     */\n    error InvalidMsgValue(uint256 value);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order using\n     *      calldata not produced by default ABI encoding.\n     */\n    error InvalidBasicOrderParameterEncoding();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order with an\n     *      offer for a native token outside of matching orders.\n     */\n    error InvalidNativeOfferItem();\n}\n"
    },
    "seaport-types/src/lib/ConsiderationErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Side } from \"./ConsiderationEnums.sol\";\n\nimport {\n    BadFraction_error_length,\n    BadFraction_error_selector,\n    CannotCancelOrder_error_length,\n    CannotCancelOrder_error_selector,\n    ConsiderationLengthNotEqualToTotalOriginal_error_length,\n    ConsiderationLengthNotEqualToTotalOriginal_error_selector,\n    ConsiderationNotMet_error_considerationIndex_ptr,\n    ConsiderationNotMet_error_length,\n    ConsiderationNotMet_error_orderIndex_ptr,\n    ConsiderationNotMet_error_selector,\n    ConsiderationNotMet_error_shortfallAmount_ptr,\n    CriteriaNotEnabledForItem_error_length,\n    CriteriaNotEnabledForItem_error_selector,\n    Error_selector_offset,\n    InsufficientNativeTokensSupplied_error_length,\n    InsufficientNativeTokensSupplied_error_selector,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidCallToConduit_error_conduit_ptr,\n    InvalidCallToConduit_error_length,\n    InvalidCallToConduit_error_selector,\n    InvalidConduit_error_conduit_ptr,\n    InvalidConduit_error_conduitKey_ptr,\n    InvalidConduit_error_length,\n    InvalidConduit_error_selector,\n    InvalidContractOrder_error_length,\n    InvalidContractOrder_error_orderHash_ptr,\n    InvalidContractOrder_error_selector,\n    InvalidERC721TransferAmount_error_amount_ptr,\n    InvalidERC721TransferAmount_error_length,\n    InvalidERC721TransferAmount_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_value_ptr,\n    InvalidNativeOfferItem_error_length,\n    InvalidNativeOfferItem_error_selector,\n    InvalidProof_error_length,\n    InvalidProof_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n    MismatchedOfferAndConsiderationComponents_error_length,\n    MismatchedOfferAndConsiderationComponents_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_length,\n    MissingFulfillmentComponentOnAggregation_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_side_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    NoReentrantCalls_error_length,\n    NoReentrantCalls_error_selector,\n    NoSpecifiedOrdersAvailable_error_length,\n    NoSpecifiedOrdersAvailable_error_selector,\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\n    OrderAlreadyFilled_error_length,\n    OrderAlreadyFilled_error_orderHash_ptr,\n    OrderAlreadyFilled_error_selector,\n    OrderCriteriaResolverOutOfRange_error_length,\n    OrderCriteriaResolverOutOfRange_error_selector,\n    OrderCriteriaResolverOutOfRange_error_side_ptr,\n    OrderIsCancelled_error_length,\n    OrderIsCancelled_error_orderHash_ptr,\n    OrderIsCancelled_error_selector,\n    OrderPartiallyFilled_error_length,\n    OrderPartiallyFilled_error_orderHash_ptr,\n    OrderPartiallyFilled_error_selector,\n    PartialFillsNotEnabledForOrder_error_length,\n    PartialFillsNotEnabledForOrder_error_selector,\n    UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\n    UnresolvedConsiderationCriteria_error_length,\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n    UnresolvedConsiderationCriteria_error_selector,\n    UnresolvedOfferCriteria_error_length,\n    UnresolvedOfferCriteria_error_offerIndex_ptr,\n    UnresolvedOfferCriteria_error_orderIndex_ptr,\n    UnresolvedOfferCriteria_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @dev Reverts the current transaction with a \"BadFraction\" error message.\n */\nfunction _revertBadFraction() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, BadFraction_error_selector)\n\n        // revert(abi.encodeWithSignature(\"BadFraction()\"))\n        revert(Error_selector_offset, BadFraction_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"ConsiderationNotMet\" error\n *      message, including the provided order index, consideration index, and\n *      shortfall amount.\n *\n * @param orderIndex         The index of the order that did not meet the\n *                           consideration criteria.\n * @param considerationIndex The index of the consideration item that did not\n *                           meet its criteria.\n * @param shortfallAmount    The amount by which the consideration criteria were\n *                           not met.\n */\nfunction _revertConsiderationNotMet(\n    uint256 orderIndex,\n    uint256 considerationIndex,\n    uint256 shortfallAmount\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationNotMet_error_selector)\n\n        // Store arguments.\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\n        mstore(\n            ConsiderationNotMet_error_considerationIndex_ptr,\n            considerationIndex\n        )\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationNotMet(uint256,uint256,uint256)\",\n        //     orderIndex,\n        //     considerationIndex,\n        //     shortfallAmount\n        // ))\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"CriteriaNotEnabledForItem\" error\n *      message.\n */\nfunction _revertCriteriaNotEnabledForItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CriteriaNotEnabledForItem()\"))\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InsufficientNativeTokensSupplied\" error message.\n */\nfunction _revertInsufficientNativeTokensSupplied() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InsufficientNativeTokensSupplied()\"))\n        revert(\n            Error_selector_offset,\n            InsufficientNativeTokensSupplied_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InvalidBasicOrderParameterEncoding\" error message.\n */\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidBasicOrderParameterEncoding()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            InvalidBasicOrderParameterEncoding_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidCallToConduit\" error\n *      message, including the provided address of the conduit that was called\n *      improperly.\n *\n * @param conduit The address of the conduit that was called improperly.\n */\nfunction _revertInvalidCallToConduit(address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidCallToConduit_error_selector)\n\n        // Store argument.\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidCallToConduit(address)\",\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"CannotCancelOrder\" error\n *      message.\n */\nfunction _revertCannotCancelOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CannotCancelOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CannotCancelOrder()\"))\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidConduit\" error message,\n *      including the provided key and address of the invalid conduit.\n *\n * @param conduitKey    The key of the invalid conduit.\n * @param conduit       The address of the invalid conduit.\n */\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidConduit_error_selector)\n\n        // Store arguments.\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidConduit(bytes32,address)\",\n        //     conduitKey,\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidERC721TransferAmount\"\n *      error message.\n *\n * @param amount The invalid amount.\n */\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidERC721TransferAmount_error_selector)\n\n        // Store argument.\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidERC721TransferAmount(uint256)\",\n        //     amount\n        // ))\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidMsgValue\" error message,\n *      including the invalid value that was sent in the transaction's\n *      `msg.value` field.\n *\n * @param value The invalid value that was sent in the transaction's `msg.value`\n *              field.\n */\nfunction _revertInvalidMsgValue(uint256 value) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidMsgValue_error_selector)\n\n        // Store argument.\n        mstore(InvalidMsgValue_error_value_ptr, value)\n\n        // revert(abi.encodeWithSignature(\"InvalidMsgValue(uint256)\", value))\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidNativeOfferItem\" error\n *      message.\n */\nfunction _revertInvalidNativeOfferItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidNativeOfferItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidNativeOfferItem()\"))\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidProof\" error message.\n */\nfunction _revertInvalidProof() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidProof_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidProof()\"))\n        revert(Error_selector_offset, InvalidProof_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidContractOrder\" error\n *      message.\n *\n * @param orderHash The hash of the contract order that caused the error.\n */\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidContractOrder_error_selector)\n\n        // Store arguments.\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidContractOrder(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidTime\" error message.\n *\n * @param startTime       The time at which the order becomes active.\n * @param endTime         The time at which the order becomes inactive.\n */\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidTime_error_selector)\n\n        // Store arguments.\n        mstore(InvalidTime_error_startTime_ptr, startTime)\n        mstore(InvalidTime_error_endTime_ptr, endTime)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidTime(uint256,uint256)\",\n        //     startTime,\n        //     endTime\n        // ))\n        revert(Error_selector_offset, InvalidTime_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a\n *      \"MismatchedFulfillmentOfferAndConsiderationComponents\" error message.\n *\n * @param fulfillmentIndex         The index of the fulfillment that caused the\n *                                 error.\n */\nfunction _revertMismatchedFulfillmentOfferAndConsiderationComponents(\n    uint256 fulfillmentIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MismatchedOfferAndConsiderationComponents_error_selector)\n\n        // Store fulfillment index argument.\n        mstore(\n            MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n            fulfillmentIndex\n        )\n\n        // revert(abi.encodeWithSignature(\n        //     \"MismatchedFulfillmentOfferAndConsiderationComponents(uint256)\",\n        //     fulfillmentIndex\n        // ))\n        revert(\n            Error_selector_offset,\n            MismatchedOfferAndConsiderationComponents_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingFulfillmentComponentOnAggregation\"\n *       error message.\n *\n * @param side The side of the fulfillment component that is missing (0 for\n *             offer, 1 for consideration).\n *\n */\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\n\n        // Store argument.\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingFulfillmentComponentOnAggregation(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingFulfillmentComponentOnAggregation_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingOriginalConsiderationItems\" error\n *      message.\n */\nfunction _revertMissingOriginalConsiderationItems() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingOriginalConsiderationItems()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingOriginalConsiderationItems_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoReentrantCalls\" error message.\n */\nfunction _revertNoReentrantCalls() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoReentrantCalls_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoSpecifiedOrdersAvailable\" error message.\n */\nfunction _revertNoSpecifiedOrdersAvailable() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoSpecifiedOrdersAvailable()\"))\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"OfferAndConsiderationRequiredOnFulfillment\"\n *      error message.\n */\nfunction _revertOfferAndConsiderationRequiredOnFulfillment() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OfferAndConsiderationRequiredOnFulfillment_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OfferAndConsiderationRequiredOnFulfillment()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            OfferAndConsiderationRequiredOnFulfillment_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderAlreadyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been filled.\n */\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderAlreadyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderAlreadyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderCriteriaResolverOutOfRange\" error\n *      message.\n *\n * @param side The side of the criteria that is missing (0 for offer, 1 for\n *             consideration).\n *\n */\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\n\n        // Store argument.\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderCriteriaResolverOutOfRange(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            OrderCriteriaResolverOutOfRange_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderIsCancelled\" error message.\n *\n * @param orderHash The hash of the order that has already been cancelled.\n */\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderIsCancelled_error_selector)\n\n        // Store argument.\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderIsCancelled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderPartiallyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been partially\n *                  filled.\n */\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderPartiallyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderPartiallyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"PartialFillsNotEnabledForOrder\" error message.\n */\nfunction _revertPartialFillsNotEnabledForOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"PartialFillsNotEnabledForOrder()\"))\n        revert(\n            Error_selector_offset,\n            PartialFillsNotEnabledForOrder_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnresolvedConsiderationCriteria\" error\n *      message.\n */\nfunction _revertUnresolvedConsiderationCriteria(\n    uint256 orderIndex,\n    uint256 considerationIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnresolvedConsiderationCriteria_error_selector)\n\n        // Store orderIndex and considerationIndex arguments.\n        mstore(UnresolvedConsiderationCriteria_error_orderIndex_ptr, orderIndex)\n        mstore(\n            UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\n            considerationIndex\n        )\n\n        // revert(abi.encodeWithSignature(\n        //     \"UnresolvedConsiderationCriteria(uint256, uint256)\",\n        //     orderIndex,\n        //     considerationIndex\n        // ))\n        revert(\n            Error_selector_offset,\n            UnresolvedConsiderationCriteria_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnresolvedOfferCriteria\" error message.\n */\nfunction _revertUnresolvedOfferCriteria(\n    uint256 orderIndex,\n    uint256 offerIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnresolvedOfferCriteria_error_selector)\n\n        // Store arguments.\n        mstore(UnresolvedOfferCriteria_error_orderIndex_ptr, orderIndex)\n        mstore(UnresolvedOfferCriteria_error_offerIndex_ptr, offerIndex)\n\n        // revert(abi.encodeWithSignature(\n        //     \"UnresolvedOfferCriteria(uint256, uint256)\",\n        //     orderIndex,\n        //     offerIndex\n        // ))\n        revert(Error_selector_offset, UnresolvedOfferCriteria_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnusedItemParameters\" error message.\n */\nfunction _revertUnusedItemParameters() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnusedItemParameters_error_selector)\n\n        // revert(abi.encodeWithSignature(\"UnusedItemParameters()\"))\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"ConsiderationLengthNotEqualToTotalOriginal\"\n *      error message.\n */\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationLengthNotEqualToTotalOriginal()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\n        )\n    }\n}\n"
    },
    "seaport-types/src/interfaces/ReentrancyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ReentrancyErrors\n * @author 0age\n * @notice ReentrancyErrors contains errors related to reentrancy.\n */\ninterface ReentrancyErrors {\n    /**\n     * @dev Revert with an error when a caller attempts to reenter a protected\n     *      function.\n     */\n    error NoReentrantCalls();\n}\n"
    },
    "seaport-core/src/lib/LowLevelHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    CostPerWord,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    MemoryExpansionCoefficientShift,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := shr(OneWordShift, add(returndatasize(), ThirtyOneBytes))\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := shr(OneWordShift, mload(FreeMemoryPointerSlot))\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost :=\n                        add(\n                            cost,\n                            add(\n                                mul(sub(returnDataWords, msizeWords), CostPerWord),\n                                shr(\n                                    MemoryExpansionCoefficientShift,\n                                    sub(mul(returnDataWords, returnDataWords), mul(msizeWords, msizeWords))\n                                )\n                            )\n                        )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to branchlessly select either the caller (if\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\n     *      that recipient is a nonzero value).\n     *\n     * @param recipient The supplied recipient.\n     *\n     * @return updatedRecipient The updated recipient.\n     */\n    function _substituteCallerForEmptyRecipient(address recipient) internal view returns (address updatedRecipient) {\n        // Utilize assembly to perform a branchless operation on the recipient.\n        assembly {\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\n     *\n     * @param b The `bool` value to cast.\n     *\n     * @return u The `uint256` value.\n     */\n    function _cast(bool b) internal pure returns (uint256 u) {\n        assembly {\n            u := b\n        }\n    }\n}\n"
    },
    "seaport-types/src/lib/ConsiderationErrorConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nuint256 constant Error_selector_offset = 0x1c;\n\n/*\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\n    0x375c24c1\n);\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\n\n/*\n *  error OfferAndConsiderationRequiredOnFulfillment()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\n    0x98e9db6e\n);\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\n\n/*\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\n *      uint256 fulfillmentIndex\n *  )\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: fulfillmentIndex\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\n    0xbced929d\n);\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\n\n/*\n *  error InvalidFulfillmentComponentData()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\n\n/*\n *  error InexactFraction()\n *    - Defined in AmountDerivationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\nuint256 constant InexactFraction_error_length = 0x04;\n\n/*\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\n\n/*\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: offerIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\n\n/*\n *  error UnresolvedConsiderationCriteria(\n *      uint256 orderIndex,\n *      uint256 considerationIndex\n *  )\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedConsiderationCriteria_error_considerationIdx_ptr = (\n    0x40\n);\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\n\n/*\n *  error OfferCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\n// uint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error ConsiderationCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\n    0x6088d7de\n);\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\n    0x6088d7de\n);\n// uint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error CriteriaNotEnabledForItem()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\n\n/*\n *  error InvalidProof()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidProof_error_selector = 0x09bde339;\nuint256 constant InvalidProof_error_length = 0x04;\n\n/*\n *  error InvalidRestrictedOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\n\n/*\n *  error InvalidContractOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidContractOrder_error_length = 0x24;\n\n/*\n *  error BadSignatureV(uint8 v)\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: v\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\nuint256 constant BadSignatureV_error_length = 0x24;\n\n/*\n *  error InvalidSigner()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\nuint256 constant InvalidSigner_error_length = 0x04;\n\n/*\n *  error InvalidSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\nuint256 constant InvalidSignature_error_length = 0x04;\n\n/*\n *  error BadContractSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\nuint256 constant BadContractSignature_error_length = 0x04;\n\n/*\n *  error InvalidERC721TransferAmount(uint256 amount)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: amount\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\n\n/*\n *  error MissingItemAmount()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\nuint256 constant MissingItemAmount_error_length = 0x04;\n\n/*\n *  error UnusedItemParameters()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\nuint256 constant UnusedItemParameters_error_length = 0x04;\n\n/*\n *  error NoReentrantCalls()\n *    - Defined in ReentrancyErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\nuint256 constant NoReentrantCalls_error_length = 0x04;\n\n/*\n *  error OrderAlreadyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\n\n/*\n *  error InvalidTime(uint256 startTime, uint256 endTime)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: startTime\n *    - 0x40: endTime\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\nuint256 constant InvalidTime_error_length = 0x44;\n\n/*\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduitKey\n *    - 0x40: conduit\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\nuint256 constant InvalidConduit_error_length = 0x44;\n\n/*\n *  error MissingOriginalConsiderationItems()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\n\n/*\n *  error InvalidCallToConduit(address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduit\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\nuint256 constant InvalidCallToConduit_error_length = 0x24;\n\n/*\n *  error ConsiderationNotMet(\n *      uint256 orderIndex,\n *      uint256 considerationIndex,\n *      uint256 shortfallAmount\n *  )\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n *    - 0x60: shortfallAmount\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\nuint256 constant ConsiderationNotMet_error_length = 0x64;\n\n/*\n *  error InsufficientNativeTokensSupplied()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\n\n/*\n *  error NativeTokenTransferGenericFailure(address account, uint256 amount)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: account\n *    - 0x40: amount\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\n\n/*\n *  error PartialFillsNotEnabledForOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\n\n/*\n *  error OrderIsCancelled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\nuint256 constant OrderIsCancelled_error_length = 0x24;\n\n/*\n *  error OrderPartiallyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\n\n/*\n *  error CannotCancelOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\nuint256 constant CannotCancelOrder_error_length = 0x04;\n\n/*\n *  error BadFraction()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadFraction_error_selector = 0x5a052b32;\nuint256 constant BadFraction_error_length = 0x04;\n\n/*\n *  error InvalidMsgValue(uint256 value)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: value\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\nuint256 constant InvalidMsgValue_error_length = 0x24;\n\n/*\n *  error InvalidBasicOrderParameterEncoding()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\n\n/*\n *  error NoSpecifiedOrdersAvailable()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\n\n/*\n *  error InvalidNativeOfferItem()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\n\n/*\n *  error ConsiderationLengthNotEqualToTotalOriginal()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\n    0x2165628a\n);\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\n\n/*\n *  error Panic(uint256 code)\n *    - Built-in Solidity error\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: code\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant Panic_error_selector = 0x4e487b71;\nuint256 constant Panic_error_code_ptr = 0x20;\nuint256 constant Panic_error_length = 0x24;\n\nuint256 constant Panic_arithmetic = 0x11;\n// uint256 constant Panic_resource = 0x41;\n"
    },
    "seaport-core/src/lib/ConsiderationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ConduitControllerInterface} from \"seaport-types/src/interfaces/ConduitControllerInterface.sol\";\n\nimport {ConsiderationEventsAndErrors} from \"seaport-types/src/interfaces/ConsiderationEventsAndErrors.sol\";\n\nimport {\n    BulkOrder_Typehash_Height_One,\n    BulkOrder_Typehash_Height_Two,\n    BulkOrder_Typehash_Height_Three,\n    BulkOrder_Typehash_Height_Four,\n    BulkOrder_Typehash_Height_Five,\n    BulkOrder_Typehash_Height_Six,\n    BulkOrder_Typehash_Height_Seven,\n    BulkOrder_Typehash_Height_Eight,\n    BulkOrder_Typehash_Height_Nine,\n    BulkOrder_Typehash_Height_Ten,\n    BulkOrder_Typehash_Height_Eleven,\n    BulkOrder_Typehash_Height_Twelve,\n    BulkOrder_Typehash_Height_Thirteen,\n    BulkOrder_Typehash_Height_Fourteen,\n    BulkOrder_Typehash_Height_Fifteen,\n    BulkOrder_Typehash_Height_Sixteen,\n    BulkOrder_Typehash_Height_Seventeen,\n    BulkOrder_Typehash_Height_Eighteen,\n    BulkOrder_Typehash_Height_Nineteen,\n    BulkOrder_Typehash_Height_Twenty,\n    BulkOrder_Typehash_Height_TwentyOne,\n    BulkOrder_Typehash_Height_TwentyTwo,\n    BulkOrder_Typehash_Height_TwentyThree,\n    BulkOrder_Typehash_Height_TwentyFour,\n    EIP712_domainData_chainId_offset,\n    EIP712_domainData_nameHash_offset,\n    EIP712_domainData_size,\n    EIP712_domainData_verifyingContract_offset,\n    EIP712_domainData_versionHash_offset,\n    FreeMemoryPointerSlot,\n    NameLengthPtr,\n    NameWithLength,\n    OneWord,\n    Slot0x80,\n    ThreeWords,\n    ZeroSlot\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {ConsiderationDecoder} from \"./ConsiderationDecoder.sol\";\n\nimport {ConsiderationEncoder} from \"./ConsiderationEncoder.sol\";\n\n/**\n * @title ConsiderationBase\n * @author 0age\n * @notice ConsiderationBase contains immutable constants and constructor logic.\n */\ncontract ConsiderationBase is ConsiderationDecoder, ConsiderationEncoder, ConsiderationEventsAndErrors {\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\n    bytes32 internal immutable _ORDER_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    // Allow for interaction with the conduit controller.\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\n\n    // Cache the conduit creation code hash used by the conduit controller.\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) {\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _OFFER_ITEM_TYPEHASH,\n            _CONSIDERATION_ITEM_TYPEHASH,\n            _ORDER_TYPEHASH\n        ) = _deriveTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n\n        // Set the supplied conduit controller.\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n        // Retrieve the conduit creation code hash from the supplied controller.\n        (_CONDUIT_CREATION_CODE_HASH,) = (_CONDUIT_CONTROLLER.getConduitCodeHashes());\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator() internal view returns (bytes32 domainSeparator) {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(EIP712_domainData_nameHash_offset, nameHash)\n            mstore(EIP712_domainData_versionHash_offset, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(EIP712_domainData_chainId_offset, chainid())\n\n            // Place the address of this contract in the next memory location.\n            mstore(EIP712_domainData_verifyingContract_offset, address())\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, EIP712_domainData_size)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this\n     *      contract and return.\n     *\n     * @return The name of this contract.\n     */\n    function _name() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        assembly {\n            // First element is the offset for the returned string. Offset the\n            // value in memory by one word so that the free memory pointer will\n            // be overwritten by the next write.\n            mstore(OneWord, OneWord)\n\n            // Name is right padded, so it touches the length which is left\n            // padded. This enables writing both values at once. The free memory\n            // pointer will be overwritten in the process.\n            mstore(NameLengthPtr, NameWithLength)\n\n            // Standard ABI encoding pads returned data to the nearest word. Use\n            // the already empty zero slot memory region for this purpose and\n            // return the final name string, offset by the original single word.\n            return(OneWord, ThreeWords)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this contract\n     *      as a string that can be used internally.\n     *\n     * @return The name of this contract.\n     */\n    function _nameString() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        return \"Consideration\";\n    }\n\n    /**\n     * @dev Internal pure function to derive required EIP-712 typehashes and\n     *      other hashes during contract creation.\n     *\n     * @return nameHash                  The hash of the name of the contract.\n     * @return versionHash               The hash of the version string of the\n     *                                   contract.\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\n     *                                   types.\n     * @return considerationItemTypehash The EIP-712 typehash for\n     *                                   ConsiderationItem types.\n     * @return orderTypehash             The EIP-712 typehash for Order types.\n     */\n    function _deriveTypehashes()\n        internal\n        pure\n        returns (\n            bytes32 nameHash,\n            bytes32 versionHash,\n            bytes32 eip712DomainTypehash,\n            bytes32 offerItemTypehash,\n            bytes32 considerationItemTypehash,\n            bytes32 orderTypehash\n        )\n    {\n        // Derive hash of the name of the contract.\n        nameHash = keccak256(bytes(_nameString()));\n\n        // Derive hash of the version string of the contract.\n        versionHash = keccak256(bytes(\"1.5\"));\n\n        // Construct the OfferItem type string.\n        bytes memory offerItemTypeString = bytes(\n            \"OfferItem(\" \"uint8 itemType,\" \"address token,\" \"uint256 identifierOrCriteria,\" \"uint256 startAmount,\"\n            \"uint256 endAmount\" \")\"\n        );\n\n        // Construct the ConsiderationItem type string.\n        bytes memory considerationItemTypeString = bytes(\n            \"ConsiderationItem(\" \"uint8 itemType,\" \"address token,\" \"uint256 identifierOrCriteria,\"\n            \"uint256 startAmount,\" \"uint256 endAmount,\" \"address recipient\" \")\"\n        );\n\n        // Construct the OrderComponents type string, not including the above.\n        bytes memory orderComponentsPartialTypeString = bytes(\n            \"OrderComponents(\" \"address offerer,\" \"address zone,\" \"OfferItem[] offer,\"\n            \"ConsiderationItem[] consideration,\" \"uint8 orderType,\" \"uint256 startTime,\" \"uint256 endTime,\"\n            \"bytes32 zoneHash,\" \"uint256 salt,\" \"bytes32 conduitKey,\" \"uint256 counter\" \")\"\n        );\n\n        // Construct the primary EIP-712 domain type string.\n        eip712DomainTypehash = keccak256(\n            bytes(\"EIP712Domain(\" \"string name,\" \"string version,\" \"uint256 chainId,\" \"address verifyingContract\" \")\")\n        );\n\n        // Derive the OfferItem type hash using the corresponding type string.\n        offerItemTypehash = keccak256(offerItemTypeString);\n\n        // Derive ConsiderationItem type hash using corresponding type string.\n        considerationItemTypehash = keccak256(considerationItemTypeString);\n\n        bytes memory orderTypeString =\n            bytes.concat(orderComponentsPartialTypeString, considerationItemTypeString, offerItemTypeString);\n\n        // Derive OrderItem type hash via combination of relevant type strings.\n        orderTypehash = keccak256(orderTypeString);\n    }\n\n    /**\n     * @dev Internal pure function to look up one of twenty-four potential bulk\n     *      order typehash constants based on the height of the bulk order tree.\n     *      Note that values between one and twenty-four are supported, which is\n     *      enforced by _isValidBulkOrderSize.\n     *\n     * @param _treeHeight The height of the bulk order tree. The value must be\n     *                    between one and twenty-four.\n     *\n     * @return _typeHash The EIP-712 typehash for the bulk order type with the\n     *                   given height.\n     */\n    function _lookupBulkOrderTypehash(uint256 _treeHeight) internal pure returns (bytes32 _typeHash) {\n        // Utilize assembly to efficiently retrieve correct bulk order typehash.\n        assembly {\n            // Use a Yul function to enable use of the `leave` keyword\n            // to stop searching once the appropriate type hash is found.\n            function lookupTypeHash(treeHeight) -> typeHash {\n                // Handle tree heights one through eight.\n                if lt(treeHeight, 9) {\n                    // Handle tree heights one through four.\n                    if lt(treeHeight, 5) {\n                        // Handle tree heights one and two.\n                        if lt(treeHeight, 3) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash :=\n                                ternary(eq(treeHeight, 1), BulkOrder_Typehash_Height_One, BulkOrder_Typehash_Height_Two)\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height three and four via branchless logic.\n                        typeHash :=\n                            ternary(eq(treeHeight, 3), BulkOrder_Typehash_Height_Three, BulkOrder_Typehash_Height_Four)\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height five and six.\n                    if lt(treeHeight, 7) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash :=\n                            ternary(eq(treeHeight, 5), BulkOrder_Typehash_Height_Five, BulkOrder_Typehash_Height_Six)\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height seven and eight via branchless logic.\n                    typeHash :=\n                        ternary(eq(treeHeight, 7), BulkOrder_Typehash_Height_Seven, BulkOrder_Typehash_Height_Eight)\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height nine through sixteen.\n                if lt(treeHeight, 17) {\n                    // Handle tree height nine through twelve.\n                    if lt(treeHeight, 13) {\n                        // Handle tree height nine and ten.\n                        if lt(treeHeight, 11) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash :=\n                                ternary(eq(treeHeight, 9), BulkOrder_Typehash_Height_Nine, BulkOrder_Typehash_Height_Ten)\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height eleven and twelve via branchless logic.\n                        typeHash :=\n                            ternary(eq(treeHeight, 11), BulkOrder_Typehash_Height_Eleven, BulkOrder_Typehash_Height_Twelve)\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height thirteen and fourteen.\n                    if lt(treeHeight, 15) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash :=\n                            ternary(\n                                eq(treeHeight, 13), BulkOrder_Typehash_Height_Thirteen, BulkOrder_Typehash_Height_Fourteen\n                            )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n                    // Handle height fifteen and sixteen via branchless logic.\n                    typeHash :=\n                        ternary(eq(treeHeight, 15), BulkOrder_Typehash_Height_Fifteen, BulkOrder_Typehash_Height_Sixteen)\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height seventeen through twenty.\n                if lt(treeHeight, 21) {\n                    // Handle tree height seventeen and eighteen.\n                    if lt(treeHeight, 19) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash :=\n                            ternary(\n                                eq(treeHeight, 17), BulkOrder_Typehash_Height_Seventeen, BulkOrder_Typehash_Height_Eighteen\n                            )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height nineteen and twenty via branchless logic.\n                    typeHash :=\n                        ternary(eq(treeHeight, 19), BulkOrder_Typehash_Height_Nineteen, BulkOrder_Typehash_Height_Twenty)\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height twenty-one and twenty-two.\n                if lt(treeHeight, 23) {\n                    // Utilize branchless logic to determine typehash.\n                    typeHash :=\n                        ternary(\n                            eq(treeHeight, 21), BulkOrder_Typehash_Height_TwentyOne, BulkOrder_Typehash_Height_TwentyTwo\n                        )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle height twenty-three & twenty-four w/ branchless logic.\n                typeHash :=\n                    ternary(eq(treeHeight, 23), BulkOrder_Typehash_Height_TwentyThree, BulkOrder_Typehash_Height_TwentyFour)\n\n                // Exit the function once typehash has been located.\n                leave\n            }\n\n            // Implement ternary conditional using branchless logic.\n            function ternary(cond, ifTrue, ifFalse) -> c {\n                c := xor(ifFalse, mul(cond, xor(ifFalse, ifTrue)))\n            }\n\n            // Look up the typehash using the supplied tree height.\n            _typeHash := lookupTypeHash(_treeHeight)\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/ConduitControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ConduitControllerInterface\n * @author 0age\n * @notice ConduitControllerInterface contains all external function interfaces,\n *         structs, events, and errors for the conduit controller.\n */\ninterface ConduitControllerInterface {\n    /**\n     * @dev Track the conduit key, current owner, new potential owner, and open\n     *      channels for each deployed conduit.\n     */\n    struct ConduitProperties {\n        bytes32 key;\n        address owner;\n        address potentialOwner;\n        address[] channels;\n        mapping(address => uint256) channelIndexesPlusOne;\n    }\n\n    /**\n     * @dev Emit an event whenever a new conduit is created.\n     *\n     * @param conduit    The newly created conduit.\n     * @param conduitKey The conduit key used to create the new conduit.\n     */\n    event NewConduit(address conduit, bytes32 conduitKey);\n\n    /**\n     * @dev Emit an event whenever conduit ownership is transferred.\n     *\n     * @param conduit       The conduit for which ownership has been\n     *                      transferred.\n     * @param previousOwner The previous owner of the conduit.\n     * @param newOwner      The new owner of the conduit.\n     */\n    event OwnershipTransferred(\n        address indexed conduit,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Emit an event whenever a conduit owner registers a new potential\n     *      owner for that conduit.\n     *\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit using a\n     *      conduit key where the first twenty bytes of the key do not match the\n     *      address of the caller.\n     */\n    error InvalidCreator();\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit when no\n     *      initial owner address is supplied.\n     */\n    error InvalidInitialOwner();\n\n    /**\n     * @dev Revert with an error when attempting to set a new potential owner\n     *      that is already set.\n     */\n    error NewPotentialOwnerAlreadySet(\n        address conduit,\n        address newPotentialOwner\n    );\n\n    /**\n     * @dev Revert with an error when attempting to cancel ownership transfer\n     *      when no new potential owner is currently set.\n     */\n    error NoPotentialOwnerCurrentlySet(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to interact with a conduit that\n     *      does not yet exist.\n     */\n    error NoConduit();\n\n    /**\n     * @dev Revert with an error when attempting to create a conduit that\n     *      already exists.\n     */\n    error ConduitAlreadyExists(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to update channels or transfer\n     *      ownership of a conduit when the caller is not the owner of the\n     *      conduit in question.\n     */\n    error CallerIsNotOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to register a new potential\n     *      owner and supplying the null address.\n     */\n    error NewPotentialOwnerIsZeroAddress(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to claim ownership of a conduit\n     *      with a caller that is not the current potential owner for the\n     *      conduit in question.\n     */\n    error CallerIsNotNewPotentialOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to retrieve a channel using an\n     *      index that is out of range.\n     */\n    error ChannelOutOfRange(address conduit);\n\n    /**\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\n     *         an initial owner for the deployed conduit. Note that the first\n     *         twenty bytes of the supplied conduit key must match the caller\n     *         and that a new conduit cannot be created if one has already been\n     *         deployed using the same conduit key.\n     *\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\n     *                     the first twenty bytes of the conduit key must match\n     *                     the caller of this contract.\n     * @param initialOwner The initial owner to set for the new conduit.\n     *\n     * @return conduit The address of the newly deployed conduit.\n     */\n    function createConduit(\n        bytes32 conduitKey,\n        address initialOwner\n    ) external returns (address conduit);\n\n    /**\n     * @notice Open or close a channel on a given conduit, thereby allowing the\n     *         specified account to execute transfers against that conduit.\n     *         Extreme care must be taken when updating channels, as malicious\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\n     *         tokens where the token holder has granted the conduit approval.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to open or close the channel.\n     * @param channel The channel to open or close on the conduit.\n     * @param isOpen  A boolean indicating whether to open or close the channel.\n     */\n    function updateChannel(\n        address conduit,\n        address channel,\n        bool isOpen\n    ) external;\n\n    /**\n     * @notice Initiate conduit ownership transfer by assigning a new potential\n     *         owner for the given conduit. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to initiate ownership transfer.\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    function transferOwnership(\n        address conduit,\n        address newPotentialOwner\n    ) external;\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address conduit) external;\n\n    /**\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param conduit The conduit for which to accept ownership.\n     */\n    function acceptOwnership(address conduit) external;\n\n    /**\n     * @notice Retrieve the current owner of a deployed conduit.\n     *\n     * @param conduit The conduit for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied conduit.\n     */\n    function ownerOf(address conduit) external view returns (address owner);\n\n    /**\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\n     *         lookup.\n     *\n     * @param conduit The conduit for which to retrieve the associated conduit\n     *                key.\n     *\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\n     */\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\n\n    /**\n     * @notice Derive the conduit associated with a given conduit key and\n     *         determine whether that conduit exists (i.e. whether it has been\n     *         deployed).\n     *\n     * @param conduitKey The conduit key used to derive the conduit.\n     *\n     * @return conduit The derived address of the conduit.\n     * @return exists  A boolean indicating whether the derived conduit has been\n     *                 deployed or not.\n     */\n    function getConduit(\n        bytes32 conduitKey\n    ) external view returns (address conduit, bool exists);\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the conduit in question via `acceptOwnership`.\n     *\n     * @param conduit The conduit for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the conduit.\n     */\n    function getPotentialOwner(\n        address conduit\n    ) external view returns (address potentialOwner);\n\n    /**\n     * @notice Retrieve the status (either open or closed) of a given channel on\n     *         a conduit.\n     *\n     * @param conduit The conduit for which to retrieve the channel status.\n     * @param channel The channel for which to retrieve the status.\n     *\n     * @return isOpen The status of the channel on the given conduit.\n     */\n    function getChannelStatus(\n        address conduit,\n        address channel\n    ) external view returns (bool isOpen);\n\n    /**\n     * @notice Retrieve the total number of open channels for a given conduit.\n     *\n     * @param conduit The conduit for which to retrieve the total channel count.\n     *\n     * @return totalChannels The total number of open channels for the conduit.\n     */\n    function getTotalChannels(\n        address conduit\n    ) external view returns (uint256 totalChannels);\n\n    /**\n     * @notice Retrieve an open channel at a specific index for a given conduit.\n     *         Note that the index of a channel can change as a result of other\n     *         channels being closed on the conduit.\n     *\n     * @param conduit      The conduit for which to retrieve the open channel.\n     * @param channelIndex The index of the channel in question.\n     *\n     * @return channel The open channel, if any, at the specified channel index.\n     */\n    function getChannel(\n        address conduit,\n        uint256 channelIndex\n    ) external view returns (address channel);\n\n    /**\n     * @notice Retrieve all open channels for a given conduit. Note that calling\n     *         this function for a conduit with many channels will revert with\n     *         an out-of-gas error.\n     *\n     * @param conduit The conduit for which to retrieve open channels.\n     *\n     * @return channels An array of open channels on the given conduit.\n     */\n    function getChannels(\n        address conduit\n    ) external view returns (address[] memory channels);\n\n    /**\n     * @dev Retrieve the conduit creation code and runtime code hashes.\n     */\n    function getConduitCodeHashes()\n        external\n        view\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\n}\n"
    },
    "contracts/helpers/order-validator/lib/SeaportValidatorHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ItemType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\nimport {\n    Order,\n    OrderParameters,\n    BasicOrderParameters,\n    OfferItem,\n    ConsiderationItem,\n    Schema,\n    ZoneParameters\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport { ConsiderationTypeHashes } from \"./ConsiderationTypeHashes.sol\";\nimport {\n    ConsiderationInterface\n} from \"seaport-types/src/interfaces/ConsiderationInterface.sol\";\nimport {\n    ConduitControllerInterface\n} from \"seaport-types/src/interfaces/ConduitControllerInterface.sol\";\nimport {\n    ContractOffererInterface\n} from \"seaport-types/src/interfaces/ContractOffererInterface.sol\";\nimport { ZoneInterface } from \"seaport-types/src/interfaces/ZoneInterface.sol\";\nimport {\n    GettersAndDerivers\n} from \"seaport-core/src/lib/GettersAndDerivers.sol\";\nimport {\n    SeaportValidatorInterface\n} from \"../lib/SeaportValidatorInterface.sol\";\nimport { ZoneInterface } from \"seaport-types/src/interfaces/ZoneInterface.sol\";\nimport {\n    ERC20Interface,\n    ERC721Interface,\n    ERC1155Interface\n} from \"seaport-types/src/interfaces/AbridgedTokenInterfaces.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport { IERC2981 } from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {\n    ErrorsAndWarnings,\n    ErrorsAndWarningsLib\n} from \"../lib/ErrorsAndWarnings.sol\";\nimport { SafeStaticCall } from \"../lib/SafeStaticCall.sol\";\nimport { Murky } from \"../lib/Murky.sol\";\nimport {\n    IssueParser,\n    ValidationConfiguration,\n    TimeIssue,\n    StatusIssue,\n    OfferIssue,\n    ContractOffererIssue,\n    ConsiderationIssue,\n    PrimaryFeeIssue,\n    ERC721Issue,\n    ERC1155Issue,\n    ERC20Issue,\n    NativeIssue,\n    ZoneIssue,\n    ConduitIssue,\n    CreatorFeeIssue,\n    SignatureIssue,\n    GenericIssue,\n    ConsiderationItemConfiguration\n} from \"./SeaportValidatorTypes.sol\";\nimport { Verifiers } from \"seaport-core/src/lib/Verifiers.sol\";\n\n/**\n * @title SeaportValidator\n * @author OpenSea Protocol Team\n * @notice SeaportValidatorHelper assists in advanced validation to seaport orders.\n */\ncontract SeaportValidatorHelper is Murky {\n    using ErrorsAndWarningsLib for ErrorsAndWarnings;\n    using SafeStaticCall for address;\n    using IssueParser for *;\n\n    /// @notice Ethereum creator fee engine address\n    CreatorFeeEngineInterface public immutable creatorFeeEngine;\n\n    bytes4 public constant ERC20_INTERFACE_ID = 0x36372b07;\n\n    bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;\n\n    constructor() {\n        address creatorFeeEngineAddress;\n        if (block.chainid == 1 || block.chainid == 31337) {\n            creatorFeeEngineAddress = 0x0385603ab55642cb4Dd5De3aE9e306809991804f;\n        } else if (block.chainid == 3) {\n            // Ropsten\n            creatorFeeEngineAddress = 0xFf5A6F7f36764aAD301B7C9E85A5277614Df5E26;\n        } else if (block.chainid == 4) {\n            // Rinkeby\n            creatorFeeEngineAddress = 0x8d17687ea9a6bb6efA24ec11DcFab01661b2ddcd;\n        } else if (block.chainid == 5) {\n            // Goerli\n            creatorFeeEngineAddress = 0xe7c9Cb6D966f76f3B5142167088927Bf34966a1f;\n        } else if (block.chainid == 42) {\n            // Kovan\n            creatorFeeEngineAddress = 0x54D88324cBedfFe1e62c9A59eBb310A11C295198;\n        } else if (block.chainid == 137) {\n            // Polygon\n            creatorFeeEngineAddress = 0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2;\n        } else if (block.chainid == 80001) {\n            // Mumbai\n            creatorFeeEngineAddress = 0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07;\n        } else {\n            // No creator fee engine for this chain\n            creatorFeeEngineAddress = address(0);\n        }\n\n        creatorFeeEngine = CreatorFeeEngineInterface(creatorFeeEngineAddress);\n    }\n\n    /**\n     * @notice Strict validation operates under tight assumptions. It validates primary\n     *    fee, creator fee, private sale consideration, and overall order format.\n     * @dev Only checks first fee recipient provided by CreatorFeeEngine.\n     *    Order of consideration items must be as follows:\n     *    1. Primary consideration\n     *    2. Primary fee\n     *    3. Creator fee\n     *    4. Private sale consideration\n     * @param orderParameters The parameters for the order to validate.\n     * @param primaryFeeRecipient The primary fee recipient. Set to null address for no primary fee.\n     * @param primaryFeeBips The primary fee in BIPs.\n     * @param checkCreatorFee Should check for creator fee. If true, creator fee must be present as\n     *    according to creator fee engine. If false, must not have creator fee.\n     * @return errorsAndWarnings The errors and warnings.\n     */\n    function validateStrictLogic(\n        OrderParameters memory orderParameters,\n        address primaryFeeRecipient,\n        uint256 primaryFeeBips,\n        bool checkCreatorFee\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Check that order matches the required format (listing or offer)\n        {\n            bool canCheckFee = true;\n            // Single offer item and at least one consideration\n            if (\n                orderParameters.offer.length != 1 ||\n                orderParameters.consideration.length == 0\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be fungible\n                isPaymentToken(orderParameters.offer[0].itemType) &&\n                isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be non-fungible\n                !isPaymentToken(orderParameters.offer[0].itemType) &&\n                !isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            }\n            if (!canCheckFee) {\n                // Does not match required format\n                errorsAndWarnings.addError(\n                    GenericIssue.InvalidOrderFormat.parseInt()\n                );\n                return errorsAndWarnings;\n            }\n        }\n\n        // Validate secondary consideration items (fees)\n        (\n            uint256 tertiaryConsiderationIndex,\n            ErrorsAndWarnings memory errorsAndWarningsLocal\n        ) = _validateSecondaryConsiderationItems(\n                orderParameters,\n                ConsiderationItemConfiguration({\n                    primaryFeeRecipient: primaryFeeRecipient,\n                    primaryFeeBips: primaryFeeBips,\n                    checkCreatorFee: checkCreatorFee\n                })\n            );\n\n        errorsAndWarnings.concat(errorsAndWarningsLocal);\n\n        // Validate tertiary consideration items if not 0 (0 indicates error).\n        // Only if no prior errors\n        if (tertiaryConsiderationIndex != 0) {\n            errorsAndWarnings.concat(\n                _validateTertiaryConsiderationItems(\n                    orderParameters,\n                    tertiaryConsiderationIndex\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice Validate all consideration items for an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItems(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // You must have a consideration item\n        if (orderParameters.consideration.length == 0) {\n            errorsAndWarnings.addWarning(\n                ConsiderationIssue.ZeroItems.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        // Declare a boolean to check if offerer is receiving at least\n        // one consideration item\n        bool offererReceivingAtLeastOneItem = false;\n\n        // Iterate over each consideration item\n        for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n            // Validate consideration item\n            errorsAndWarnings.concat(\n                validateConsiderationItem(orderParameters, i, seaportAddress)\n            );\n\n            ConsiderationItem memory considerationItem1 = orderParameters\n                .consideration[i];\n\n            // Check if the offerer is the recipient\n            if (!offererReceivingAtLeastOneItem) {\n                if (considerationItem1.recipient == orderParameters.offerer) {\n                    offererReceivingAtLeastOneItem = true;\n                }\n            }\n\n            // Check for duplicate consideration items\n            for (\n                uint256 j = i + 1;\n                j < orderParameters.consideration.length;\n                j++\n            ) {\n                // Iterate over each remaining consideration item\n                // (previous items already check with this item)\n                ConsiderationItem memory considerationItem2 = orderParameters\n                    .consideration[j];\n\n                // Check if itemType, token, id, and recipient are the same\n                if (\n                    considerationItem2.itemType ==\n                    considerationItem1.itemType &&\n                    considerationItem2.token == considerationItem1.token &&\n                    considerationItem2.identifierOrCriteria ==\n                    considerationItem1.identifierOrCriteria &&\n                    considerationItem2.recipient == considerationItem1.recipient\n                ) {\n                    errorsAndWarnings.addWarning(\n                        // Duplicate consideration item, warning\n                        ConsiderationIssue.DuplicateItem.parseInt()\n                    );\n                }\n            }\n        }\n\n        if (!offererReceivingAtLeastOneItem) {\n            // Offerer is not receiving at least one consideration item\n            errorsAndWarnings.addWarning(\n                ConsiderationIssue.OffererNotReceivingAtLeastOneItem.parseInt()\n            );\n        }\n    }\n\n    /**\n     * @notice Validate a consideration item\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItem(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Validate the consideration item at considerationItemIndex\n        errorsAndWarnings.concat(\n            validateConsiderationItemParameters(\n                orderParameters,\n                considerationItemIndex,\n                seaportAddress\n            )\n        );\n    }\n\n    /**\n     * @notice Validates the parameters of a consideration item including contract validation\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        ConsiderationItem memory considerationItem = orderParameters\n            .consideration[considerationItemIndex];\n\n        // Check if startAmount and endAmount are zero\n        if (\n            considerationItem.startAmount == 0 &&\n            considerationItem.endAmount == 0\n        ) {\n            errorsAndWarnings.addError(\n                ConsiderationIssue.AmountZero.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        // Check if the recipient is the null address\n        if (considerationItem.recipient == address(0)) {\n            errorsAndWarnings.addError(\n                ConsiderationIssue.NullRecipient.parseInt()\n            );\n        }\n\n        if (\n            considerationItem.startAmount != considerationItem.endAmount &&\n            orderParameters.endTime > orderParameters.startTime\n        ) {\n            // Check that amount velocity is not too high.\n            // Assign larger and smaller amount values\n            (uint256 maxAmount, uint256 minAmount) = considerationItem\n                .startAmount > considerationItem.endAmount\n                ? (considerationItem.startAmount, considerationItem.endAmount)\n                : (considerationItem.endAmount, considerationItem.startAmount);\n\n            uint256 amountDelta = maxAmount - minAmount;\n            // delta of time that order exists for\n            uint256 timeDelta = orderParameters.endTime -\n                orderParameters.startTime;\n\n            // Velocity scaled by 1e10 for precision\n            uint256 velocity = (amountDelta * 1e10) / timeDelta;\n            // gives velocity percentage in hundredth of a basis points per second in terms of larger value\n            uint256 velocityPercentage = velocity / (maxAmount * 1e4);\n\n            // 278 * 60 * 30 ~= 500,000\n            if (velocityPercentage > 278) {\n                // Over 50% change per 30 min\n                errorsAndWarnings.addError(\n                    ConsiderationIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n            // 28 * 60 * 30 ~= 50,000\n            else if (velocityPercentage > 28) {\n                // Over 5% change per 30 min\n                errorsAndWarnings.addWarning(\n                    ConsiderationIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n\n            // Check for large amount steps\n            if (minAmount <= 1e15) {\n                errorsAndWarnings.addWarning(\n                    ConsiderationIssue.AmountStepLarge.parseInt()\n                );\n            }\n        }\n\n        if (considerationItem.itemType == ItemType.ERC721) {\n            // ERC721 type requires amounts to be 1\n            if (\n                considerationItem.startAmount != 1 ||\n                considerationItem.endAmount != 1\n            ) {\n                errorsAndWarnings.addError(ERC721Issue.AmountNotOne.parseInt());\n            }\n\n            // Check EIP165 interface\n            if (!checkInterface(considerationItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n                return errorsAndWarnings;\n            }\n\n            // Check that token exists\n            if (\n                !considerationItem.token.safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC721Interface.ownerOf.selector,\n                        considerationItem.identifierOrCriteria\n                    ),\n                    1\n                )\n            ) {\n                // Token does not exist\n                errorsAndWarnings.addError(\n                    ERC721Issue.IdentifierDNE.parseInt()\n                );\n            }\n        } else if (\n            considerationItem.itemType == ItemType.ERC721_WITH_CRITERIA\n        ) {\n            // Check EIP165 interface\n            if (!checkInterface(considerationItem.token, ERC721_INTERFACE_ID)) {\n                // Does not implement required interface\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n        } else if (\n            considerationItem.itemType == ItemType.ERC1155 ||\n            considerationItem.itemType == ItemType.ERC1155_WITH_CRITERIA\n        ) {\n            // Check EIP165 interface\n            if (\n                !checkInterface(considerationItem.token, ERC1155_INTERFACE_ID)\n            ) {\n                // Does not implement required interface\n                errorsAndWarnings.addError(\n                    ERC1155Issue.InvalidToken.parseInt()\n                );\n            }\n        } else if (considerationItem.itemType == ItemType.ERC20) {\n            // ERC20 must have `identifierOrCriteria` be zero\n            if (considerationItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.IdentifierNonZero.parseInt()\n                );\n            }\n\n            // Check that it is an ERC20 token. ERC20 will return a uint256\n            if (\n                !considerationItem.token.safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.allowance.selector,\n                        seaportAddress,\n                        seaportAddress\n                    ),\n                    0\n                )\n            ) {\n                // Not an ERC20 token\n                errorsAndWarnings.addError(ERC20Issue.InvalidToken.parseInt());\n            }\n        } else {\n            // Must be native\n            // NATIVE must have `token` be zero address\n            if (considerationItem.token != address(0)) {\n                errorsAndWarnings.addError(NativeIssue.TokenAddress.parseInt());\n            }\n            // NATIVE must have `identifierOrCriteria` be zero\n            if (considerationItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    NativeIssue.IdentifierNonZero.parseInt()\n                );\n            }\n        }\n    }\n\n    function _validateSecondaryConsiderationItems(\n        OrderParameters memory orderParameters,\n        ConsiderationItemConfiguration memory config\n    )\n        internal\n        view\n        returns (\n            uint256 /* tertiaryConsiderationIndex */,\n            ErrorsAndWarnings memory /* errorsAndWarnings */\n        )\n    {\n        ErrorsAndWarnings memory errorsAndWarnings = ErrorsAndWarnings(\n            new uint16[](0),\n            new uint16[](0)\n        );\n\n        // Consideration item to hold expected creator fee info\n        ConsiderationItem memory creatorFeeConsideration;\n\n        bool primaryFeePresent;\n\n        {\n            // non-fungible item address\n            address itemAddress;\n            // non-fungible item identifier\n            uint256 itemIdentifier;\n            // fungible item start amount\n            uint256 transactionAmountStart;\n            // fungible item end amount\n            uint256 transactionAmountEnd;\n\n            if (isPaymentToken(orderParameters.offer[0].itemType)) {\n                // Offer is an offer. Offer item is fungible and used for fees\n                creatorFeeConsideration.itemType = orderParameters\n                    .offer[0]\n                    .itemType;\n                creatorFeeConsideration.token = orderParameters.offer[0].token;\n                transactionAmountStart = orderParameters.offer[0].startAmount;\n                transactionAmountEnd = orderParameters.offer[0].endAmount;\n\n                // Set non-fungible information for calculating creator fee\n                itemAddress = orderParameters.consideration[0].token;\n                itemIdentifier = orderParameters\n                    .consideration[0]\n                    .identifierOrCriteria;\n            } else {\n                // Offer is an offer. Consideration item is fungible and used for fees\n                creatorFeeConsideration.itemType = orderParameters\n                    .consideration[0]\n                    .itemType;\n                creatorFeeConsideration.token = orderParameters\n                    .consideration[0]\n                    .token;\n                transactionAmountStart = orderParameters\n                    .consideration[0]\n                    .startAmount;\n                transactionAmountEnd = orderParameters\n                    .consideration[0]\n                    .endAmount;\n\n                // Set non-fungible information for calculating creator fees\n                itemAddress = orderParameters.offer[0].token;\n                itemIdentifier = orderParameters.offer[0].identifierOrCriteria;\n            }\n\n            // Store flag if primary fee is present\n            primaryFeePresent = false;\n            {\n                // Calculate primary fee start and end amounts\n                uint256 primaryFeeStartAmount = (transactionAmountStart *\n                    config.primaryFeeBips) / 10000;\n                uint256 primaryFeeEndAmount = (transactionAmountEnd *\n                    config.primaryFeeBips) / 10000;\n\n                // Check if primary fee check is desired. Skip if calculated amount is zero.\n                if (\n                    config.primaryFeeRecipient != address(0) &&\n                    (primaryFeeStartAmount > 0 || primaryFeeEndAmount > 0)\n                ) {\n                    // Ensure primary fee is present\n                    if (orderParameters.consideration.length < 2) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.Missing.parseInt()\n                        );\n                        return (0, errorsAndWarnings);\n                    }\n                    primaryFeePresent = true;\n\n                    ConsiderationItem memory primaryFeeItem = orderParameters\n                        .consideration[1];\n\n                    // Check item type\n                    if (\n                        primaryFeeItem.itemType !=\n                        creatorFeeConsideration.itemType\n                    ) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.ItemType.parseInt()\n                        );\n                        return (0, errorsAndWarnings);\n                    }\n                    // Check token\n                    if (primaryFeeItem.token != creatorFeeConsideration.token) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.Token.parseInt()\n                        );\n                    }\n                    // Check start amount\n                    if (primaryFeeItem.startAmount < primaryFeeStartAmount) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.StartAmount.parseInt()\n                        );\n                    }\n                    // Check end amount\n                    if (primaryFeeItem.endAmount < primaryFeeEndAmount) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.EndAmount.parseInt()\n                        );\n                    }\n                    // Check recipient\n                    if (\n                        primaryFeeItem.recipient != config.primaryFeeRecipient\n                    ) {\n                        errorsAndWarnings.addError(\n                            PrimaryFeeIssue.Recipient.parseInt()\n                        );\n                    }\n                }\n            }\n\n            // Check creator fee\n            (\n                creatorFeeConsideration.recipient,\n                creatorFeeConsideration.startAmount,\n                creatorFeeConsideration.endAmount\n            ) = getCreatorFeeInfo(\n                itemAddress,\n                itemIdentifier,\n                transactionAmountStart,\n                transactionAmountEnd\n            );\n        }\n\n        // Flag indicating if creator fee is present in considerations\n        bool creatorFeePresent = false;\n\n        // Determine if should check for creator fee\n        if (\n            creatorFeeConsideration.recipient != address(0) &&\n            config.checkCreatorFee &&\n            (creatorFeeConsideration.startAmount > 0 ||\n                creatorFeeConsideration.endAmount > 0)\n        ) {\n            // Calculate index of creator fee consideration item\n            uint16 creatorFeeConsiderationIndex = primaryFeePresent ? 2 : 1; // 2 if primary fee, ow 1\n\n            // Check that creator fee consideration item exists\n            if (\n                orderParameters.consideration.length - 1 <\n                creatorFeeConsiderationIndex\n            ) {\n                errorsAndWarnings.addError(CreatorFeeIssue.Missing.parseInt());\n                return (0, errorsAndWarnings);\n            }\n\n            ConsiderationItem memory creatorFeeItem = orderParameters\n                .consideration[creatorFeeConsiderationIndex];\n\n            creatorFeePresent = true;\n\n            // Check type\n            if (creatorFeeItem.itemType != creatorFeeConsideration.itemType) {\n                errorsAndWarnings.addError(CreatorFeeIssue.ItemType.parseInt());\n                return (0, errorsAndWarnings);\n            }\n            // Check token\n            if (creatorFeeItem.token != creatorFeeConsideration.token) {\n                errorsAndWarnings.addError(CreatorFeeIssue.Token.parseInt());\n            }\n            // Check start amount\n            if (\n                creatorFeeItem.startAmount < creatorFeeConsideration.startAmount\n            ) {\n                errorsAndWarnings.addError(\n                    CreatorFeeIssue.StartAmount.parseInt()\n                );\n            }\n            // Check end amount\n            if (creatorFeeItem.endAmount < creatorFeeConsideration.endAmount) {\n                errorsAndWarnings.addError(\n                    CreatorFeeIssue.EndAmount.parseInt()\n                );\n            }\n            // Check recipient\n            if (creatorFeeItem.recipient != creatorFeeConsideration.recipient) {\n                errorsAndWarnings.addError(\n                    CreatorFeeIssue.Recipient.parseInt()\n                );\n            }\n        }\n\n        // Calculate index of first tertiary consideration item\n        uint256 tertiaryConsiderationIndex = 1 +\n            (primaryFeePresent ? 1 : 0) +\n            (creatorFeePresent ? 1 : 0);\n\n        return (tertiaryConsiderationIndex, errorsAndWarnings);\n    }\n\n    /**\n     * @notice Internal function for validating all consideration items after the fee items.\n     *    Only additional acceptable consideration is private sale.\n     */\n    function _validateTertiaryConsiderationItems(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex\n    ) internal pure returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        if (orderParameters.consideration.length <= considerationItemIndex) {\n            // No more consideration items\n            return errorsAndWarnings;\n        }\n\n        ConsiderationItem memory privateSaleConsideration = orderParameters\n            .consideration[considerationItemIndex];\n\n        // Check if offer is payment token. Private sale not possible if so.\n        if (isPaymentToken(orderParameters.offer[0].itemType)) {\n            errorsAndWarnings.addError(\n                ConsiderationIssue.ExtraItems.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        // Check if private sale to self\n        if (privateSaleConsideration.recipient == orderParameters.offerer) {\n            errorsAndWarnings.addError(\n                ConsiderationIssue.PrivateSaleToSelf.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        // Ensure that private sale parameters match offer item.\n        if (\n            privateSaleConsideration.itemType !=\n            orderParameters.offer[0].itemType ||\n            privateSaleConsideration.token != orderParameters.offer[0].token ||\n            orderParameters.offer[0].startAmount !=\n            privateSaleConsideration.startAmount ||\n            orderParameters.offer[0].endAmount !=\n            privateSaleConsideration.endAmount ||\n            orderParameters.offer[0].identifierOrCriteria !=\n            privateSaleConsideration.identifierOrCriteria\n        ) {\n            // Invalid private sale, say extra consideration item\n            errorsAndWarnings.addError(\n                ConsiderationIssue.ExtraItems.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        errorsAndWarnings.addWarning(ConsiderationIssue.PrivateSale.parseInt());\n\n        // Should not be any additional consideration items\n        if (orderParameters.consideration.length - 1 > considerationItemIndex) {\n            // Extra consideration items\n            errorsAndWarnings.addError(\n                ConsiderationIssue.ExtraItems.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n    }\n\n    /**\n     * @notice Fetches the on chain creator fees.\n     * @dev Uses the creatorFeeEngine when available, otherwise fallback to `IERC2981`.\n     * @param token The token address\n     * @param tokenId The token identifier\n     * @param transactionAmountStart The transaction start amount\n     * @param transactionAmountEnd The transaction end amount\n     * @return recipient creator fee recipient\n     * @return creatorFeeAmountStart creator fee start amount\n     * @return creatorFeeAmountEnd creator fee end amount\n     */\n    function getCreatorFeeInfo(\n        address token,\n        uint256 tokenId,\n        uint256 transactionAmountStart,\n        uint256 transactionAmountEnd\n    )\n        public\n        view\n        returns (\n            address payable recipient,\n            uint256 creatorFeeAmountStart,\n            uint256 creatorFeeAmountEnd\n        )\n    {\n        // Check if creator fee engine is on this chain\n        if (address(creatorFeeEngine) != address(0)) {\n            // Creator fee engine may revert if no creator fees are present.\n            try\n                creatorFeeEngine.getRoyaltyView(\n                    token,\n                    tokenId,\n                    transactionAmountStart\n                )\n            returns (\n                address payable[] memory creatorFeeRecipients,\n                uint256[] memory creatorFeeAmountsStart\n            ) {\n                if (creatorFeeRecipients.length != 0) {\n                    // Use first recipient and amount\n                    recipient = creatorFeeRecipients[0];\n                    creatorFeeAmountStart = creatorFeeAmountsStart[0];\n                }\n            } catch {\n                // Creator fee not found\n            }\n\n            // If fees found for start amount, check end amount\n            if (recipient != address(0)) {\n                // Creator fee engine may revert if no creator fees are present.\n                try\n                    creatorFeeEngine.getRoyaltyView(\n                        token,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                returns (\n                    address payable[] memory,\n                    uint256[] memory creatorFeeAmountsEnd\n                ) {\n                    creatorFeeAmountEnd = creatorFeeAmountsEnd[0];\n                } catch {}\n            }\n        } else {\n            // Fallback to ERC2981\n            {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountStart\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign recipient and start amount\n                        (recipient, creatorFeeAmountStart) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n\n            // Only check end amount if start amount found\n            if (recipient != address(0)) {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign end amount\n                        (, creatorFeeAmountEnd) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely check that a contract implements an interface\n     * @param token The token address to check\n     * @param interfaceHash The interface hash to check\n     */\n    function checkInterface(\n        address token,\n        bytes4 interfaceHash\n    ) public view returns (bool) {\n        return\n            token.safeStaticCallBool(\n                abi.encodeWithSelector(\n                    IERC165.supportsInterface.selector,\n                    interfaceHash\n                ),\n                true\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Merkle Helpers\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sorts an array of token ids by the keccak256 hash of the id. Required ordering of ids\n     *    for other merkle operations.\n     * @param includedTokens An array of included token ids.\n     * @return sortedTokens The sorted `includedTokens` array.\n     */\n    function sortMerkleTokens(\n        uint256[] memory includedTokens\n    ) public pure returns (uint256[] memory sortedTokens) {\n        // Sort token ids by the keccak256 hash of the id\n        return _sortUint256ByHash(includedTokens);\n    }\n\n    /**\n     * @notice Creates a merkle root for includedTokens.\n     * @dev `includedTokens` must be sorting in strictly ascending order according to the keccak256 hash of the value.\n     * @return merkleRoot The merkle root\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleRoot(\n        uint256[] memory includedTokens\n    )\n        public\n        pure\n        returns (bytes32 merkleRoot, ErrorsAndWarnings memory errorsAndWarnings)\n    {\n        (merkleRoot, errorsAndWarnings) = _getRoot(includedTokens);\n    }\n\n    /**\n     * @notice Creates a merkle proof for the the targetIndex contained in includedTokens.\n     * @dev `targetIndex` is referring to the index of an element in `includedTokens`.\n     *    `includedTokens` must be sorting in ascending order according to the keccak256 hash of the value.\n     * @return merkleProof The merkle proof\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleProof(\n        uint256[] memory includedTokens,\n        uint256 targetIndex\n    )\n        public\n        pure\n        returns (\n            bytes32[] memory merkleProof,\n            ErrorsAndWarnings memory errorsAndWarnings\n        )\n    {\n        (merkleProof, errorsAndWarnings) = _getProof(\n            includedTokens,\n            targetIndex\n        );\n    }\n\n    /**\n     * @notice Verifies a merkle proof for the value to prove and given root and proof.\n     * @dev The `valueToProve` is hashed prior to executing the proof verification.\n     * @param merkleRoot The root of the merkle tree\n     * @param merkleProof The merkle proof\n     * @param valueToProve The value to prove\n     * @return whether proof is valid\n     */\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        bytes32[] memory merkleProof,\n        uint256 valueToProve\n    ) public pure returns (bool) {\n        bytes32 hashedValue = keccak256(abi.encode(valueToProve));\n\n        return _verifyProof(merkleRoot, merkleProof, hashedValue);\n    }\n\n    function isPaymentToken(ItemType itemType) public pure returns (bool) {\n        return itemType == ItemType.NATIVE || itemType == ItemType.ERC20;\n    }\n}\n\ninterface CreatorFeeEngineInterface {\n    function getRoyaltyView(\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 value\n    )\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory amounts);\n}\n"
    },
    "contracts/helpers/order-validator/lib/ConsiderationTypeHashes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nuint256 constant EIP712_Order_size = 0x180;\nuint256 constant EIP712_OfferItem_size = 0xc0;\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_OrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\nuint256 constant EIP_712_PREFIX = (\n    0x1901000000000000000000000000000000000000000000000000000000000000\n);\n\ncontract ConsiderationTypeHashes {\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\n    bytes32 internal immutable _ORDER_TYPEHASH;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    address internal constant seaportAddress =\n        address(0x00000000000006c7676171937C444f6BDe3D6282);\n\n    constructor() {\n        // Derive hash of the name of the contract.\n        _NAME_HASH = keccak256(bytes(\"Seaport\"));\n\n        // Derive hash of the version string of the contract.\n        _VERSION_HASH = keccak256(bytes(\"1.2\"));\n\n        bytes memory offerItemTypeString = abi.encodePacked(\n            \"OfferItem(\",\n            \"uint8 itemType,\",\n            \"address token,\",\n            \"uint256 identifierOrCriteria,\",\n            \"uint256 startAmount,\",\n            \"uint256 endAmount\",\n            \")\"\n        );\n\n        // Construct the ConsiderationItem type string.\n        // prettier-ignore\n        bytes memory considerationItemTypeString = abi.encodePacked(\n            \"ConsiderationItem(\",\n                \"uint8 itemType,\",\n                \"address token,\",\n                \"uint256 identifierOrCriteria,\",\n                \"uint256 startAmount,\",\n                \"uint256 endAmount,\",\n                \"address recipient\",\n            \")\"\n        );\n\n        // Construct the OrderComponents type string, not including the above.\n        // prettier-ignore\n        bytes memory orderComponentsPartialTypeString = abi.encodePacked(\n            \"OrderComponents(\",\n                \"address offerer,\",\n                \"address zone,\",\n                \"OfferItem[] offer,\",\n                \"ConsiderationItem[] consideration,\",\n                \"uint8 orderType,\",\n                \"uint256 startTime,\",\n                \"uint256 endTime,\",\n                \"bytes32 zoneHash,\",\n                \"uint256 salt,\",\n                \"bytes32 conduitKey,\",\n                \"uint256 counter\",\n            \")\"\n        );\n        // Derive the OfferItem type hash using the corresponding type string.\n        bytes32 offerItemTypehash = keccak256(offerItemTypeString);\n\n        // Derive ConsiderationItem type hash using corresponding type string.\n        bytes32 considerationItemTypehash = keccak256(\n            considerationItemTypeString\n        );\n\n        // Construct the primary EIP-712 domain type string.\n        // prettier-ignore\n        _EIP_712_DOMAIN_TYPEHASH = keccak256(\n            abi.encodePacked(\n                \"EIP712Domain(\",\n                    \"string name,\",\n                    \"string version,\",\n                    \"uint256 chainId,\",\n                    \"address verifyingContract\",\n                \")\"\n            )\n        );\n\n        _OFFER_ITEM_TYPEHASH = offerItemTypehash;\n        _CONSIDERATION_ITEM_TYPEHASH = considerationItemTypehash;\n\n        // Derive OrderItem type hash via combination of relevant type strings.\n        _ORDER_TYPEHASH = keccak256(\n            abi.encodePacked(\n                orderComponentsPartialTypeString,\n                considerationItemTypeString,\n                offerItemTypeString\n            )\n        );\n\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return The derived domain separator.\n     */\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        // prettier-ignore\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                seaportAddress\n            )\n        );\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param orderHash       The order hash.\n     *\n     * @return value The hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 orderHash\n    ) internal view returns (bytes32 value) {\n        bytes32 domainSeparator = _DOMAIN_SEPARATOR;\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the order hash in scratch space, spilling into the first\n            // two bytes of the free memory pointer  this should never be set\n            // as memory cannot be expanded to that size, and will be zeroed out\n            // after the hash is performed.\n            mstore(EIP712_OrderHash_offset, orderHash)\n\n            // Hash the relevant region (65 bytes).\n            value := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_OrderHash_offset, 0)\n        }\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 hash for an offer item.\n     *\n     * @param offerItem The offered item to hash.\n     *\n     * @return The hash.\n     */\n    function _hashOfferItem(\n        OfferItem memory offerItem\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _OFFER_ITEM_TYPEHASH,\n                    offerItem.itemType,\n                    offerItem.token,\n                    offerItem.identifierOrCriteria,\n                    offerItem.startAmount,\n                    offerItem.endAmount\n                )\n            );\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 hash for a consideration item.\n     *\n     * @param considerationItem The consideration item to hash.\n     *\n     * @return The hash.\n     */\n    function _hashConsiderationItem(\n        ConsiderationItem memory considerationItem\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _CONSIDERATION_ITEM_TYPEHASH,\n                    considerationItem.itemType,\n                    considerationItem.token,\n                    considerationItem.identifierOrCriteria,\n                    considerationItem.startAmount,\n                    considerationItem.endAmount,\n                    considerationItem.recipient\n                )\n            );\n    }\n\n    /**\n     * @dev Internal view function to derive the order hash for a given order.\n     *      Note that only the original consideration items are included in the\n     *      order hash, as additional consideration items may be supplied by the\n     *      caller.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     * @param counter           The counter of the order to hash.\n     *\n     * @return orderHash The hash.\n     */\n    function _deriveOrderHash(\n        OrderParameters memory orderParameters,\n        uint256 counter\n    ) internal view returns (bytes32 orderHash) {\n        // Designate new memory regions for offer and consideration item hashes.\n        bytes32[] memory offerHashes = new bytes32[](\n            orderParameters.offer.length\n        );\n        bytes32[] memory considerationHashes = new bytes32[](\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Iterate over each offer on the order.\n        for (uint256 i = 0; i < orderParameters.offer.length; ++i) {\n            // Hash the offer and place the result into memory.\n            offerHashes[i] = _hashOfferItem(orderParameters.offer[i]);\n        }\n\n        // Iterate over each consideration on the order.\n        for (\n            uint256 i = 0;\n            i < orderParameters.totalOriginalConsiderationItems;\n            ++i\n        ) {\n            // Hash the consideration and place the result into memory.\n            considerationHashes[i] = _hashConsiderationItem(\n                orderParameters.consideration[i]\n            );\n        }\n\n        // Derive and return the order hash as specified by EIP-712.\n\n        return\n            keccak256(\n                abi.encode(\n                    _ORDER_TYPEHASH,\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    keccak256(abi.encodePacked(offerHashes)),\n                    keccak256(abi.encodePacked(considerationHashes)),\n                    orderParameters.orderType,\n                    orderParameters.startTime,\n                    orderParameters.endTime,\n                    orderParameters.zoneHash,\n                    orderParameters.salt,\n                    orderParameters.conduitKey,\n                    counter\n                )\n            );\n    }\n}\n"
    },
    "contracts/helpers/order-validator/lib/SeaportValidatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { ItemType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\nimport {\n    Order,\n    OrderParameters,\n    ZoneParameters\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport { ErrorsAndWarnings } from \"./ErrorsAndWarnings.sol\";\nimport { ValidationConfiguration } from \"./SeaportValidatorTypes.sol\";\n\n/**\n * @title SeaportValidator\n * @notice SeaportValidator validates simple orders that adhere to a set of rules defined below:\n *    - The order is either a listing or an offer order (one NFT to buy or one NFT to sell).\n *    - The first consideration is the primary consideration.\n *    - The order pays up to two fees in the fungible token currency. First fee is primary fee, second is creator fee.\n *    - In private orders, the last consideration specifies a recipient for the offer item.\n *    - Offer items must be owned and properly approved by the offerer.\n *    - Consideration items must exist.\n */\ninterface SeaportValidatorInterface {\n    /**\n     * @notice Conduct a comprehensive validation of the given order.\n     * @param order The order to validate.\n     * @return errorsAndWarnings The errors and warnings found in the order.\n     */\n    function isValidOrder(\n        Order calldata order,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Same as `isValidOrder` but allows for more configuration related to fee validation.\n     */\n    function isValidOrderWithConfiguration(\n        ValidationConfiguration memory validationConfiguration,\n        Order memory order\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Checks if a conduit key is valid.\n     * @param conduitKey The conduit key to check.\n     * @return errorsAndWarnings The errors and warnings\n     */\n    function isValidConduit(\n        bytes32 conduitKey,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    // TODO: Need to add support for order with extra data\n    /**\n     * @notice Checks that the zone of an order implements the required interface\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function isValidZone(\n        OrderParameters memory orderParameters\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    function validateSignature(\n        Order memory order,\n        address seaportAddress\n    ) external returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    function validateSignatureWithCounter(\n        Order memory order,\n        uint256 counter,\n        address seaportAddress\n    ) external returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Check the time validity of an order\n     * @param orderParameters The parameters for the order to validate\n     * @param shortOrderDuration The duration of which an order is considered short\n     * @param distantOrderExpiration Distant order expiration delta in seconds.\n     * @return errorsAndWarnings The Issues and warnings\n     */\n    function validateTime(\n        OrderParameters memory orderParameters,\n        uint256 shortOrderDuration,\n        uint256 distantOrderExpiration\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validate the status of an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateOrderStatus(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validate all offer items for an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateOfferItems(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validate all consideration items for an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItems(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Strict validation operates under tight assumptions. It validates primary\n     *    fee, creator fee, private sale consideration, and overall order format.\n     * @dev Only checks first fee recipient provided by CreatorFeeRegistry.\n     *    Order of consideration items must be as follows:\n     *    1. Primary consideration\n     *    2. Primary fee\n     *    3. Creator Fee\n     *    4. Private sale consideration\n     * @param orderParameters The parameters for the order to validate.\n     * @param primaryFeeRecipient The primary fee recipient. Set to null address for no primary fee.\n     * @param primaryFeeBips The primary fee in BIPs.\n     * @param checkCreatorFee Should check for creator fee. If true, creator fee must be present as\n     *    according to creator fee engine. If false, must not have creator fee.\n     * @return errorsAndWarnings The errors and warnings.\n     */\n    function validateStrictLogic(\n        OrderParameters memory orderParameters,\n        address primaryFeeRecipient,\n        uint256 primaryFeeBips,\n        bool checkCreatorFee\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validate a consideration item\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItem(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validates the parameters of a consideration item including contract validation\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validates an offer item\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItem(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validates the OfferItem parameters. This includes token contract validation\n     * @dev OfferItems with criteria are currently not allowed\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Validates the OfferItem approvals and balances\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItemApprovalAndBalance(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Calls validateOrder on the order's zone with the given zoneParameters\n     * @param orderParameters The parameters for the order to validate\n     * @param zoneParameters The parameters for the zone to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOrderWithZone(\n        OrderParameters memory orderParameters,\n        ZoneParameters memory zoneParameters\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Gets the approval address for the given conduit key\n     * @param conduitKey Conduit key to get approval address for\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function getApprovalAddress(\n        bytes32 conduitKey,\n        address seaportAddress\n    )\n        external\n        view\n        returns (address, ErrorsAndWarnings memory errorsAndWarnings);\n\n    /**\n     * @notice Safely check that a contract implements an interface\n     * @param token The token address to check\n     * @param interfaceHash The interface hash to check\n     */\n    function checkInterface(\n        address token,\n        bytes4 interfaceHash\n    ) external view returns (bool);\n\n    function isPaymentToken(ItemType itemType) external pure returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                        Merkle Helpers\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sorts an array of token ids by the keccak256 hash of the id. Required ordering of ids\n     *    for other merkle operations.\n     * @param includedTokens An array of included token ids.\n     * @return sortedTokens The sorted `includedTokens` array.\n     */\n    function sortMerkleTokens(\n        uint256[] memory includedTokens\n    ) external view returns (uint256[] memory sortedTokens);\n\n    /**\n     * @notice Creates a merkle root for includedTokens.\n     * @dev `includedTokens` must be sorting in strictly ascending order according to the keccak256 hash of the value.\n     * @return merkleRoot The merkle root\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleRoot(\n        uint256[] memory includedTokens\n    )\n        external\n        view\n        returns (\n            bytes32 merkleRoot,\n            ErrorsAndWarnings memory errorsAndWarnings\n        );\n\n    /**\n     * @notice Creates a merkle proof for the the targetIndex contained in includedTokens.\n     * @dev `targetIndex` is referring to the index of an element in `includedTokens`.\n     *    `includedTokens` must be sorting in ascending order according to the keccak256 hash of the value.\n     * @return merkleProof The merkle proof\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleProof(\n        uint256[] memory includedTokens,\n        uint256 targetIndex\n    )\n        external\n        view\n        returns (\n            bytes32[] memory merkleProof,\n            ErrorsAndWarnings memory errorsAndWarnings\n        );\n\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        bytes32[] memory merkleProof,\n        uint256 valueToProve\n    ) external view returns (bool);\n}\n"
    },
    "contracts/helpers/order-validator/lib/ErrorsAndWarnings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {\n    ConduitIssue,\n    ConsiderationIssue,\n    ERC20Issue,\n    ERC721Issue,\n    ERC1155Issue,\n    GenericIssue,\n    OfferIssue,\n    SignatureIssue,\n    StatusIssue,\n    TimeIssue,\n    NativeIssue,\n    IssueParser\n} from \"./SeaportValidatorTypes.sol\";\n\nstruct ErrorsAndWarnings {\n    uint16[] errors;\n    uint16[] warnings;\n}\n\nlibrary ErrorsAndWarningsLib {\n    using IssueParser for ConduitIssue;\n    using IssueParser for ConsiderationIssue;\n    using IssueParser for ERC20Issue;\n    using IssueParser for ERC721Issue;\n    using IssueParser for ERC1155Issue;\n    using IssueParser for GenericIssue;\n    using IssueParser for OfferIssue;\n    using IssueParser for SignatureIssue;\n    using IssueParser for StatusIssue;\n    using IssueParser for TimeIssue;\n    using IssueParser for NativeIssue;\n\n    function concat(\n        ErrorsAndWarnings memory ew1,\n        ErrorsAndWarnings memory ew2\n    ) internal pure {\n        ew1.errors = concatMemory(ew1.errors, ew2.errors);\n        ew1.warnings = concatMemory(ew1.warnings, ew2.warnings);\n    }\n\n    function empty() internal pure returns (ErrorsAndWarnings memory) {\n        return ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n    }\n\n    function addError(\n        uint16 err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        ErrorsAndWarnings memory ew = ErrorsAndWarnings(\n            new uint16[](0),\n            new uint16[](0)\n        );\n        ew.errors = pushMemory(ew.errors, err);\n        return ew;\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        uint16 err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        ew.errors = pushMemory(ew.errors, err);\n        return ew;\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        GenericIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        ERC20Issue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        ERC721Issue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        ERC1155Issue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        ConsiderationIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        OfferIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        SignatureIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        TimeIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        ConduitIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addError(\n        ErrorsAndWarnings memory ew,\n        StatusIssue err\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addError(ew, err.parseInt());\n    }\n\n    function addWarning(\n        uint16 warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        ErrorsAndWarnings memory ew = ErrorsAndWarnings(\n            new uint16[](0),\n            new uint16[](0)\n        );\n        ew.warnings = pushMemory(ew.warnings, warn);\n        return ew;\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        uint16 warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        ew.warnings = pushMemory(ew.warnings, warn);\n        return ew;\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        GenericIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        ERC20Issue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        ERC721Issue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        ERC1155Issue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        OfferIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        ConsiderationIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        SignatureIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        TimeIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        ConduitIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        StatusIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function addWarning(\n        ErrorsAndWarnings memory ew,\n        NativeIssue warn\n    ) internal pure returns (ErrorsAndWarnings memory) {\n        return addWarning(ew, warn.parseInt());\n    }\n\n    function hasErrors(\n        ErrorsAndWarnings memory ew\n    ) internal pure returns (bool) {\n        return ew.errors.length != 0;\n    }\n\n    function hasWarnings(\n        ErrorsAndWarnings memory ew\n    ) internal pure returns (bool) {\n        return ew.warnings.length != 0;\n    }\n\n    // Helper Functions\n    function concatMemory(\n        uint16[] memory array1,\n        uint16[] memory array2\n    ) private pure returns (uint16[] memory) {\n        if (array1.length == 0) {\n            return array2;\n        } else if (array2.length == 0) {\n            return array1;\n        }\n\n        uint16[] memory returnValue = new uint16[](\n            array1.length + array2.length\n        );\n\n        for (uint256 i = 0; i < array1.length; i++) {\n            returnValue[i] = array1[i];\n        }\n        for (uint256 i = 0; i < array2.length; i++) {\n            returnValue[i + array1.length] = array2[i];\n        }\n\n        return returnValue;\n    }\n\n    function pushMemory(\n        uint16[] memory uint16Array,\n        uint16 newValue\n    ) internal pure returns (uint16[] memory) {\n        uint16[] memory returnValue = new uint16[](uint16Array.length + 1);\n\n        for (uint256 i = 0; i < uint16Array.length; i++) {\n            returnValue[i] = uint16Array[i];\n        }\n        returnValue[uint16Array.length] = newValue;\n\n        return returnValue;\n    }\n}\n"
    },
    "contracts/helpers/order-validator/lib/SafeStaticCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary SafeStaticCall {\n    function safeStaticCallBool(\n        address target,\n        bytes memory callData,\n        bool expectedReturn\n    ) internal view returns (bool) {\n        (bool success, bytes memory res) = target.staticcall(callData);\n        if (!success) return false;\n        if (res.length != 32) return false;\n\n        if (\n            bytes32(res) &\n                0x0000000000000000000000000000000000000000000000000000000000000001 !=\n            bytes32(res)\n        ) {\n            return false;\n        }\n\n        return expectedReturn ? res[31] == 0x01 : res[31] == 0;\n    }\n\n    function safeStaticCallAddress(\n        address target,\n        bytes memory callData,\n        address expectedReturn\n    ) internal view returns (bool) {\n        (bool success, bytes memory res) = target.staticcall(callData);\n        if (!success) return false;\n        if (res.length != 32) return false;\n\n        if (\n            bytes32(res) &\n                0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF !=\n            bytes32(res)\n        ) {\n            // Ensure only 20 bytes used\n            return false;\n        }\n\n        return abi.decode(res, (address)) == expectedReturn;\n    }\n\n    function safeStaticCallUint256(\n        address target,\n        bytes memory callData,\n        uint256 minExpectedReturn\n    ) internal view returns (bool) {\n        (bool success, bytes memory res) = target.staticcall(callData);\n        if (!success) return false;\n        if (res.length != 32) return false;\n\n        return abi.decode(res, (uint256)) >= minExpectedReturn;\n    }\n\n    function safeStaticCallBytes4(\n        address target,\n        bytes memory callData,\n        bytes4 expectedReturn\n    ) internal view returns (bool) {\n        (bool success, bytes memory res) = target.staticcall(callData);\n        if (!success) return false;\n        if (res.length != 32) return false;\n        if (\n            bytes32(res) &\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 !=\n            bytes32(res)\n        ) {\n            // Ensure only 4 bytes used\n            return false;\n        }\n\n        return abi.decode(res, (bytes4)) == expectedReturn;\n    }\n}\n"
    },
    "contracts/helpers/order-validator/lib/Murky.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {\n    ErrorsAndWarnings,\n    ErrorsAndWarningsLib\n} from \"./ErrorsAndWarnings.sol\";\n\nimport { IssueParser, MerkleIssue } from \"./SeaportValidatorTypes.sol\";\n\ncontract Murky {\n    using ErrorsAndWarningsLib for ErrorsAndWarnings;\n    using IssueParser for MerkleIssue;\n\n    bool internal constant HASH_ODD_WITH_ZERO = false;\n\n    function _verifyProof(\n        bytes32 root,\n        bytes32[] memory proof,\n        bytes32 valueToProve\n    ) internal pure returns (bool) {\n        // proof length must be less than max array size\n        bytes32 rollingHash = valueToProve;\n        uint256 length = proof.length;\n        unchecked {\n            for (uint256 i = 0; i < length; ++i) {\n                rollingHash = _hashLeafPairs(rollingHash, proof[i]);\n            }\n        }\n        return root == rollingHash;\n    }\n\n    /********************\n     * HASHING FUNCTION *\n     ********************/\n\n    /// ascending sort and concat prior to hashing\n    function _hashLeafPairs(\n        bytes32 left,\n        bytes32 right\n    ) internal pure returns (bytes32 _hash) {\n        assembly {\n            switch lt(left, right)\n            case 0 {\n                mstore(0x0, right)\n                mstore(0x20, left)\n            }\n            default {\n                mstore(0x0, left)\n                mstore(0x20, right)\n            }\n            _hash := keccak256(0x0, 0x40)\n        }\n    }\n\n    /********************\n     * PROOF GENERATION *\n     ********************/\n\n    function _getRoot(\n        uint256[] memory data\n    )\n        internal\n        pure\n        returns (bytes32 result, ErrorsAndWarnings memory errorsAndWarnings)\n    {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        if (data.length < 2) {\n            errorsAndWarnings.addError(MerkleIssue.SingleLeaf.parseInt());\n            return (0, errorsAndWarnings);\n        }\n\n        bool hashOddWithZero = HASH_ODD_WITH_ZERO;\n\n        if (!_processInput(data)) {\n            errorsAndWarnings.addError(MerkleIssue.Unsorted.parseInt());\n            return (0, errorsAndWarnings);\n        }\n\n        assembly {\n            function hashLeafPairs(left, right) -> _hash {\n                switch lt(left, right)\n                case 0 {\n                    mstore(0x0, right)\n                    mstore(0x20, left)\n                }\n                default {\n                    mstore(0x0, left)\n                    mstore(0x20, right)\n                }\n                _hash := keccak256(0x0, 0x40)\n            }\n            function hashLevel(_data, length, _hashOddWithZero) -> newLength {\n                // we will be modifying data in-place, so set result pointer to data pointer\n                let _result := _data\n                // get length of original data array\n                // let length := mload(_data)\n                // bool to track if we need to hash the last element of an odd-length array with zero\n                let oddLength\n\n                // if length is odd, we need to hash the last element with zero\n                switch and(length, 1)\n                case 1 {\n                    // if length is odd, add 1 so division by 2 will round up\n                    newLength := add(1, div(length, 2))\n                    oddLength := 1\n                }\n                default {\n                    newLength := div(length, 2)\n                }\n                // todo: necessary?\n                // mstore(_data, newLength)\n                let resultIndexPointer := add(0x20, _data)\n                let dataIndexPointer := resultIndexPointer\n\n                // stop iterating over for loop at length-1\n                let stopIteration := add(_data, mul(length, 0x20))\n                // write result array in-place over data array\n                for {\n\n                } lt(dataIndexPointer, stopIteration) {\n\n                } {\n                    // get next two elements from data, hash them together\n                    let data1 := mload(dataIndexPointer)\n                    let data2 := mload(add(dataIndexPointer, 0x20))\n                    let hashedPair := hashLeafPairs(data1, data2)\n                    // overwrite an element of data array with\n                    mstore(resultIndexPointer, hashedPair)\n                    // increment result pointer by 1 slot\n                    resultIndexPointer := add(0x20, resultIndexPointer)\n                    // increment data pointer by 2 slot\n                    dataIndexPointer := add(0x40, dataIndexPointer)\n                }\n                // we did not yet hash last index if odd-length\n                if oddLength {\n                    let data1 := mload(dataIndexPointer)\n                    let nextValue\n                    switch _hashOddWithZero\n                    case 0 {\n                        nextValue := data1\n                    }\n                    default {\n                        nextValue := hashLeafPairs(data1, 0)\n                    }\n                    mstore(resultIndexPointer, nextValue)\n                }\n            }\n\n            let dataLength := mload(data)\n            for {\n\n            } gt(dataLength, 1) {\n\n            } {\n                dataLength := hashLevel(data, dataLength, hashOddWithZero)\n            }\n            result := mload(add(0x20, data))\n        }\n    }\n\n    function _getProof(\n        uint256[] memory data,\n        uint256 node\n    )\n        internal\n        pure\n        returns (\n            bytes32[] memory result,\n            ErrorsAndWarnings memory errorsAndWarnings\n        )\n    {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        if (data.length < 2) {\n            errorsAndWarnings.addError(MerkleIssue.SingleLeaf.parseInt());\n            return (new bytes32[](0), errorsAndWarnings);\n        }\n\n        bool hashOddWithZero = HASH_ODD_WITH_ZERO;\n\n        if (!_processInput(data)) {\n            errorsAndWarnings.addError(MerkleIssue.Unsorted.parseInt());\n            return (new bytes32[](0), errorsAndWarnings);\n        }\n\n        // The size of the proof is equal to the ceiling of log2(numLeaves)\n        // Two overflow risks: node, pos\n        // node: max array size is 2**256-1. Largest index in the array will be 1 less than that. Also,\n        // for dynamic arrays, size is limited to 2**64-1\n        // pos: pos is bounded by log2(data.length), which should be less than type(uint256).max\n        assembly {\n            function hashLeafPairs(left, right) -> _hash {\n                switch lt(left, right)\n                case 0 {\n                    mstore(0x0, right)\n                    mstore(0x20, left)\n                }\n                default {\n                    mstore(0x0, left)\n                    mstore(0x20, right)\n                }\n                _hash := keccak256(0x0, 0x40)\n            }\n            function hashLevel(_data, length, _hashOddWithZero) -> newLength {\n                // we will be modifying data in-place, so set result pointer to data pointer\n                let _result := _data\n                // get length of original data array\n                // let length := mload(_data)\n                // bool to track if we need to hash the last element of an odd-length array with zero\n                let oddLength\n\n                // if length is odd, we'll need to hash the last element with zero\n                switch and(length, 1)\n                case 1 {\n                    // if length is odd, add 1 so division by 2 will round up\n                    newLength := add(1, div(length, 2))\n                    oddLength := 1\n                }\n                default {\n                    newLength := div(length, 2)\n                }\n                // todo: necessary?\n                // mstore(_data, newLength)\n                let resultIndexPointer := add(0x20, _data)\n                let dataIndexPointer := resultIndexPointer\n\n                // stop iterating over for loop at length-1\n                let stopIteration := add(_data, mul(length, 0x20))\n                // write result array in-place over data array\n                for {\n\n                } lt(dataIndexPointer, stopIteration) {\n\n                } {\n                    // get next two elements from data, hash them together\n                    let data1 := mload(dataIndexPointer)\n                    let data2 := mload(add(dataIndexPointer, 0x20))\n                    let hashedPair := hashLeafPairs(data1, data2)\n                    // overwrite an element of data array with\n                    mstore(resultIndexPointer, hashedPair)\n                    // increment result pointer by 1 slot\n                    resultIndexPointer := add(0x20, resultIndexPointer)\n                    // increment data pointer by 2 slot\n                    dataIndexPointer := add(0x40, dataIndexPointer)\n                }\n                // we did not yet hash last index if odd-length\n                if oddLength {\n                    let data1 := mload(dataIndexPointer)\n                    let nextValue\n                    switch _hashOddWithZero\n                    case 0 {\n                        nextValue := data1\n                    }\n                    default {\n                        nextValue := hashLeafPairs(data1, 0)\n                    }\n                    mstore(resultIndexPointer, nextValue)\n                }\n            }\n\n            // set result pointer to free memory\n            result := mload(0x40)\n            // get pointer to first index of result\n            let resultIndexPtr := add(0x20, result)\n            // declare so we can use later\n            let newLength\n            // put length of data onto stack\n            let dataLength := mload(data)\n            for {\n                // repeat until only one element is left\n            } gt(dataLength, 1) {\n\n            } {\n                // bool if node is odd\n                let oddNodeIndex := and(node, 1)\n                // bool if node is last\n                let lastNodeIndex := eq(dataLength, add(1, node))\n                // store both bools in one value so we can switch on it\n                let switchVal := or(shl(1, lastNodeIndex), oddNodeIndex)\n                switch switchVal\n                // 00 - neither odd nor last\n                case 0 {\n                    // store data[node+1] at result[i]\n                    // get pointer to result[node+1] by adding 2 to node and multiplying by 0x20\n                    // to account for the fact that result points to array length, not first index\n                    mstore(\n                        resultIndexPtr,\n                        mload(add(data, mul(0x20, add(2, node))))\n                    )\n                }\n                // 10 - node is last\n                case 2 {\n                    // store 0 at result[i]\n                    mstore(resultIndexPtr, 0)\n                }\n                // 01 or 11 - node is odd (and possibly also last)\n                default {\n                    // store data[node-1] at result[i]\n                    mstore(resultIndexPtr, mload(add(data, mul(0x20, node))))\n                }\n                // increment result index\n                resultIndexPtr := add(0x20, resultIndexPtr)\n\n                // get new node index\n                node := div(node, 2)\n                // keep track of how long result array is\n                newLength := add(1, newLength)\n                // compute the next hash level, overwriting data, and get the new length\n                dataLength := hashLevel(data, dataLength, hashOddWithZero)\n            }\n            // store length of result array at pointer\n            mstore(result, newLength)\n            // set free mem pointer to word after end of result array\n            mstore(0x40, resultIndexPtr)\n        }\n    }\n\n    /**\n     * Hashes each element of the input array in place using keccak256\n     */\n    function _processInput(\n        uint256[] memory data\n    ) private pure returns (bool sorted) {\n        sorted = true;\n\n        // Hash inputs with keccak256\n        for (uint256 i = 0; i < data.length; ++i) {\n            assembly {\n                mstore(\n                    add(data, mul(0x20, add(1, i))),\n                    keccak256(add(data, mul(0x20, add(1, i))), 0x20)\n                )\n                // for every element after the first, hashed value must be greater than the last one\n                if and(\n                    gt(i, 0),\n                    iszero(\n                        gt(\n                            mload(add(data, mul(0x20, add(1, i)))),\n                            mload(add(data, mul(0x20, add(1, sub(i, 1)))))\n                        )\n                    )\n                ) {\n                    sorted := 0 // Elements not ordered by hash\n                }\n            }\n        }\n    }\n\n    // Sort uint256 in order of the keccak256 hashes\n    struct HashAndIntTuple {\n        uint256 num;\n        bytes32 hash;\n    }\n\n    function _sortUint256ByHash(\n        uint256[] memory values\n    ) internal pure returns (uint256[] memory sortedValues) {\n        HashAndIntTuple[] memory toSort = new HashAndIntTuple[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            toSort[i] = HashAndIntTuple(\n                values[i],\n                keccak256(abi.encode(values[i]))\n            );\n        }\n\n        _quickSort(toSort, 0, int256(toSort.length - 1));\n\n        sortedValues = new uint256[](values.length);\n        for (uint256 i = 0; i < values.length; i++) {\n            sortedValues[i] = toSort[i].num;\n        }\n    }\n\n    function _quickSort(\n        HashAndIntTuple[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        bytes32 pivot = arr[uint256(left + (right - left) / 2)].hash;\n        while (i <= j) {\n            while (arr[uint256(i)].hash < pivot) i++;\n            while (pivot < arr[uint256(j)].hash) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n}\n"
    },
    "contracts/helpers/order-validator/lib/SeaportValidatorTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nstruct ValidationConfiguration {\n    /// @notice The seaport address.\n    address seaport;\n    /// @notice Recipient for primary fee payments.\n    address primaryFeeRecipient;\n    /// @notice Bips for primary fee payments.\n    uint256 primaryFeeBips;\n    /// @notice Should creator fees be checked?\n    bool checkCreatorFee;\n    /// @notice Should strict validation be skipped?\n    bool skipStrictValidation;\n    /// @notice Short order duration in seconds\n    uint256 shortOrderDuration;\n    /// @notice Distant order expiration delta in seconds. Warning if order expires in longer than this.\n    uint256 distantOrderExpiration;\n}\n\nstruct ConsiderationItemConfiguration {\n    address primaryFeeRecipient;\n    uint256 primaryFeeBips;\n    bool checkCreatorFee;\n}\n\nenum GenericIssue {\n    InvalidOrderFormat // 100\n}\n\nenum ERC20Issue {\n    IdentifierNonZero, // 200\n    InvalidToken, // 201\n    InsufficientAllowance, // 202\n    InsufficientBalance // 203\n}\n\nenum ERC721Issue {\n    AmountNotOne, // 300\n    InvalidToken, // 301\n    IdentifierDNE, // 302\n    NotOwner, // 303\n    NotApproved, // 304\n    CriteriaNotPartialFill // 305\n}\n\nenum ERC1155Issue {\n    InvalidToken, // 400\n    NotApproved, // 401\n    InsufficientBalance // 402\n}\n\nenum ConsiderationIssue {\n    AmountZero, // 500\n    NullRecipient, // 501\n    ExtraItems, // 502\n    PrivateSaleToSelf, // 503\n    ZeroItems, // 504\n    DuplicateItem, // 505\n    OffererNotReceivingAtLeastOneItem, // 506\n    PrivateSale, // 507\n    AmountVelocityHigh, // 508\n    AmountStepLarge // 509\n}\n\nenum OfferIssue {\n    ZeroItems, // 600\n    AmountZero, // 601\n    MoreThanOneItem, // 602\n    NativeItem, // 603\n    DuplicateItem, // 604\n    AmountVelocityHigh, // 605\n    AmountStepLarge // 606\n}\n\nenum PrimaryFeeIssue {\n    Missing, // 700\n    ItemType, // 701\n    Token, // 702\n    StartAmount, // 703\n    EndAmount, // 704\n    Recipient // 705\n}\n\nenum StatusIssue {\n    Cancelled, // 800\n    FullyFilled, // 801\n    ContractOrder // 802\n}\n\nenum TimeIssue {\n    EndTimeBeforeStartTime, // 900\n    Expired, // 901\n    DistantExpiration, // 902\n    NotActive, // 903\n    ShortOrder // 904\n}\n\nenum ConduitIssue {\n    KeyInvalid, // 1000\n    MissingSeaportChannel // 1001\n}\n\nenum SignatureIssue {\n    Invalid, // 1100\n    ContractOrder, // 1101\n    LowCounter, // 1102\n    HighCounter, // 1103\n    OriginalConsiderationItems // 1104\n}\n\nenum CreatorFeeIssue {\n    Missing, // 1200\n    ItemType, // 1201\n    Token, // 1202\n    StartAmount, // 1203\n    EndAmount, // 1204\n    Recipient // 1205\n}\n\nenum NativeIssue {\n    TokenAddress, // 1300\n    IdentifierNonZero, // 1301\n    InsufficientBalance // 1302\n}\n\nenum ZoneIssue {\n    InvalidZone, // 1400\n    RejectedOrder, // 1401\n    NotSet, // 1402\n    EOAZone // 1403\n}\n\nenum MerkleIssue {\n    SingleLeaf, // 1500\n    Unsorted // 1501\n}\n\nenum ContractOffererIssue {\n    InvalidContractOfferer // 1600\n}\n\n/**\n * @title IssueParser - parse issues into integers\n * @notice Implements a `parseInt` function for each issue type.\n *    offsets the enum value to place within the issue range.\n */\nlibrary IssueParser {\n    function parseInt(GenericIssue err) internal pure returns (uint16) {\n        return uint16(err) + 100;\n    }\n\n    function parseInt(ERC20Issue err) internal pure returns (uint16) {\n        return uint16(err) + 200;\n    }\n\n    function parseInt(ERC721Issue err) internal pure returns (uint16) {\n        return uint16(err) + 300;\n    }\n\n    function parseInt(ERC1155Issue err) internal pure returns (uint16) {\n        return uint16(err) + 400;\n    }\n\n    function parseInt(ConsiderationIssue err) internal pure returns (uint16) {\n        return uint16(err) + 500;\n    }\n\n    function parseInt(OfferIssue err) internal pure returns (uint16) {\n        return uint16(err) + 600;\n    }\n\n    function parseInt(PrimaryFeeIssue err) internal pure returns (uint16) {\n        return uint16(err) + 700;\n    }\n\n    function parseInt(StatusIssue err) internal pure returns (uint16) {\n        return uint16(err) + 800;\n    }\n\n    function parseInt(TimeIssue err) internal pure returns (uint16) {\n        return uint16(err) + 900;\n    }\n\n    function parseInt(ConduitIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1000;\n    }\n\n    function parseInt(SignatureIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1100;\n    }\n\n    function parseInt(CreatorFeeIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1200;\n    }\n\n    function parseInt(NativeIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1300;\n    }\n\n    function parseInt(ZoneIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1400;\n    }\n\n    function parseInt(MerkleIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1500;\n    }\n\n    function parseInt(ContractOffererIssue err) internal pure returns (uint16) {\n        return uint16(err) + 1600;\n    }\n}\n\nlibrary IssueStringHelpers {\n    function toString(GenericIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == GenericIssue.InvalidOrderFormat) {\n            code = \"InvalidOrderFormat\";\n        }\n        return string.concat(\"GenericIssue: \", code);\n    }\n\n    function toString(ERC20Issue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == ERC20Issue.IdentifierNonZero) {\n            code = \"IdentifierNonZero\";\n        } else if (id == ERC20Issue.InvalidToken) {\n            code = \"InvalidToken\";\n        } else if (id == ERC20Issue.InsufficientAllowance) {\n            code = \"InsufficientAllowance\";\n        } else if (id == ERC20Issue.InsufficientBalance) {\n            code = \"InsufficientBalance\";\n        }\n        return string.concat(\"ERC20Issue: \", code);\n    }\n\n    function toString(ERC721Issue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == ERC721Issue.AmountNotOne) {\n            code = \"AmountNotOne\";\n        } else if (id == ERC721Issue.InvalidToken) {\n            code = \"InvalidToken\";\n        } else if (id == ERC721Issue.IdentifierDNE) {\n            code = \"IdentifierDNE\";\n        } else if (id == ERC721Issue.NotOwner) {\n            code = \"NotOwner\";\n        } else if (id == ERC721Issue.NotApproved) {\n            code = \"NotApproved\";\n        } else if (id == ERC721Issue.CriteriaNotPartialFill) {\n            code = \"CriteriaNotPartialFill\";\n        }\n        return string.concat(\"ERC721Issue: \", code);\n    }\n\n    function toString(ERC1155Issue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == ERC1155Issue.InvalidToken) {\n            code = \"InvalidToken\";\n        } else if (id == ERC1155Issue.NotApproved) {\n            code = \"NotApproved\";\n        } else if (id == ERC1155Issue.InsufficientBalance) {\n            code = \"InsufficientBalance\";\n        }\n        return string.concat(\"ERC1155Issue: \", code);\n    }\n\n    function toString(\n        ConsiderationIssue id\n    ) internal pure returns (string memory) {\n        string memory code;\n        if (id == ConsiderationIssue.AmountZero) {\n            code = \"AmountZero\";\n        } else if (id == ConsiderationIssue.NullRecipient) {\n            code = \"NullRecipient\";\n        } else if (id == ConsiderationIssue.ExtraItems) {\n            code = \"ExtraItems\";\n        } else if (id == ConsiderationIssue.PrivateSaleToSelf) {\n            code = \"PrivateSaleToSelf\";\n        } else if (id == ConsiderationIssue.ZeroItems) {\n            code = \"ZeroItems\";\n        } else if (id == ConsiderationIssue.DuplicateItem) {\n            code = \"DuplicateItem\";\n        } else if (id == ConsiderationIssue.OffererNotReceivingAtLeastOneItem) {\n            code = \"OffererNotReceivingAtLeastOneItem\";\n        } else if (id == ConsiderationIssue.PrivateSale) {\n            code = \"PrivateSale\";\n        } else if (id == ConsiderationIssue.AmountVelocityHigh) {\n            code = \"AmountVelocityHigh\";\n        } else if (id == ConsiderationIssue.AmountStepLarge) {\n            code = \"AmountStepLarge\";\n        }\n        return string.concat(\"ConsiderationIssue: \", code);\n    }\n\n    function toString(OfferIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == OfferIssue.ZeroItems) {\n            code = \"ZeroItems\";\n        } else if (id == OfferIssue.AmountZero) {\n            code = \"AmountZero\";\n        } else if (id == OfferIssue.MoreThanOneItem) {\n            code = \"MoreThanOneItem\";\n        } else if (id == OfferIssue.NativeItem) {\n            code = \"NativeItem\";\n        } else if (id == OfferIssue.DuplicateItem) {\n            code = \"DuplicateItem\";\n        } else if (id == OfferIssue.AmountVelocityHigh) {\n            code = \"AmountVelocityHigh\";\n        } else if (id == OfferIssue.AmountStepLarge) {\n            code = \"AmountStepLarge\";\n        }\n        return string.concat(\"OfferIssue: \", code);\n    }\n\n    function toString(\n        PrimaryFeeIssue id\n    ) internal pure returns (string memory) {\n        string memory code;\n        if (id == PrimaryFeeIssue.Missing) {\n            code = \"Missing\";\n        } else if (id == PrimaryFeeIssue.ItemType) {\n            code = \"ItemType\";\n        } else if (id == PrimaryFeeIssue.Token) {\n            code = \"Token\";\n        } else if (id == PrimaryFeeIssue.StartAmount) {\n            code = \"StartAmount\";\n        } else if (id == PrimaryFeeIssue.EndAmount) {\n            code = \"EndAmount\";\n        } else if (id == PrimaryFeeIssue.Recipient) {\n            code = \"Recipient\";\n        }\n        return string.concat(\"PrimaryFeeIssue: \", code);\n    }\n\n    function toString(StatusIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == StatusIssue.Cancelled) {\n            code = \"Cancelled\";\n        } else if (id == StatusIssue.FullyFilled) {\n            code = \"FullyFilled\";\n        } else if (id == StatusIssue.ContractOrder) {\n            code = \"ContractOrder\";\n        }\n        return string.concat(\"StatusIssue: \", code);\n    }\n\n    function toString(TimeIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == TimeIssue.EndTimeBeforeStartTime) {\n            code = \"EndTimeBeforeStartTime\";\n        } else if (id == TimeIssue.Expired) {\n            code = \"Expired\";\n        } else if (id == TimeIssue.DistantExpiration) {\n            code = \"DistantExpiration\";\n        } else if (id == TimeIssue.NotActive) {\n            code = \"NotActive\";\n        } else if (id == TimeIssue.ShortOrder) {\n            code = \"ShortOrder\";\n        }\n        return string.concat(\"TimeIssue: \", code);\n    }\n\n    function toString(ConduitIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == ConduitIssue.KeyInvalid) {\n            code = \"KeyInvalid\";\n        } else if (id == ConduitIssue.MissingSeaportChannel) {\n            code = \"MissingSeaportChannel\";\n        }\n        return string.concat(\"ConduitIssue: \", code);\n    }\n\n    function toString(SignatureIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == SignatureIssue.Invalid) {\n            code = \"Invalid\";\n        } else if (id == SignatureIssue.ContractOrder) {\n            code = \"ContractOrder\";\n        } else if (id == SignatureIssue.LowCounter) {\n            code = \"LowCounter\";\n        } else if (id == SignatureIssue.HighCounter) {\n            code = \"HighCounter\";\n        } else if (id == SignatureIssue.OriginalConsiderationItems) {\n            code = \"OriginalConsiderationItems\";\n        }\n        return string.concat(\"SignatureIssue: \", code);\n    }\n\n    function toString(\n        CreatorFeeIssue id\n    ) internal pure returns (string memory) {\n        string memory code;\n        if (id == CreatorFeeIssue.Missing) {\n            code = \"Missing\";\n        } else if (id == CreatorFeeIssue.ItemType) {\n            code = \"ItemType\";\n        } else if (id == CreatorFeeIssue.Token) {\n            code = \"Token\";\n        } else if (id == CreatorFeeIssue.StartAmount) {\n            code = \"StartAmount\";\n        } else if (id == CreatorFeeIssue.EndAmount) {\n            code = \"EndAmount\";\n        } else if (id == CreatorFeeIssue.Recipient) {\n            code = \"Recipient\";\n        }\n        return string.concat(\"CreatorFeeIssue: \", code);\n    }\n\n    function toString(NativeIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == NativeIssue.TokenAddress) {\n            code = \"TokenAddress\";\n        } else if (id == NativeIssue.IdentifierNonZero) {\n            code = \"IdentifierNonZero\";\n        } else if (id == NativeIssue.InsufficientBalance) {\n            code = \"InsufficientBalance\";\n        }\n        return string.concat(\"NativeIssue: \", code);\n    }\n\n    function toString(ZoneIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == ZoneIssue.InvalidZone) {\n            code = \"InvalidZone\";\n        } else if (id == ZoneIssue.RejectedOrder) {\n            code = \"RejectedOrder\";\n        } else if (id == ZoneIssue.NotSet) {\n            code = \"NotSet\";\n        } else if (id == ZoneIssue.EOAZone) {\n            code = \"EOAZone\";\n        }\n        return string.concat(\"ZoneIssue: \", code);\n    }\n\n    function toString(MerkleIssue id) internal pure returns (string memory) {\n        string memory code;\n        if (id == MerkleIssue.SingleLeaf) {\n            code = \"SingleLeaf\";\n        } else if (id == MerkleIssue.Unsorted) {\n            code = \"Unsorted\";\n        }\n        return string.concat(\"MerkleIssue: \", code);\n    }\n\n    function toString(\n        ContractOffererIssue id\n    ) internal pure returns (string memory) {\n        string memory code;\n        if (id == ContractOffererIssue.InvalidContractOfferer) {\n            code = \"InvalidContractOfferer\";\n        }\n        return string.concat(\"ContractOffererIssue: \", code);\n    }\n\n    function toIssueString(\n        uint16 issueCode\n    ) internal pure returns (string memory issueString) {\n        uint16 issue = (issueCode / 100) * 100;\n        uint8 id = uint8(issueCode % 100);\n        if (issue == 100) {\n            return toString(GenericIssue(id));\n        } else if (issue == 200) {\n            return toString(ERC20Issue(id));\n        } else if (issue == 300) {\n            return toString(ERC721Issue(id));\n        } else if (issue == 400) {\n            return toString(ERC1155Issue(id));\n        } else if (issue == 500) {\n            return toString(ConsiderationIssue(id));\n        } else if (issue == 600) {\n            return toString(OfferIssue(id));\n        } else if (issue == 700) {\n            return toString(PrimaryFeeIssue(id));\n        } else if (issue == 800) {\n            return toString(StatusIssue(id));\n        } else if (issue == 900) {\n            return toString(TimeIssue(id));\n        } else if (issue == 1000) {\n            return toString(ConduitIssue(id));\n        } else if (issue == 1100) {\n            return toString(SignatureIssue(id));\n        } else if (issue == 1200) {\n            return toString(CreatorFeeIssue(id));\n        } else if (issue == 1300) {\n            return toString(NativeIssue(id));\n        } else if (issue == 1400) {\n            return toString(ZoneIssue(id));\n        } else if (issue == 1500) {\n            return toString(MerkleIssue(id));\n        } else if (issue == 1600) {\n            return toString(ContractOffererIssue(id));\n        } else {\n            revert(\"IssueStringHelpers: Unknown issue code\");\n        }\n    }\n\n    function toIssueString(\n        uint16[] memory issueCodes\n    ) internal pure returns (string memory issueString) {\n        for (uint256 i; i < issueCodes.length; i++) {\n            issueString = string.concat(\n                issueString,\n                \"\\n    \",\n                toIssueString(issueCodes[i])\n            );\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/ContractOffererInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {ReceivedItem, Schema, SpentItem} from \"../lib/ConsiderationStructs.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\n\n/**\n * @title ContractOffererInterface\n * @notice Contains the minimum interfaces needed to interact with a contract\n *         offerer.\n */\ninterface ContractOffererInterface is IERC165 {\n    /**\n     * @dev Generates an order with the specified minimum and maximum spent\n     *      items, and optional context (supplied as extraData).\n     *\n     * @param fulfiller       The address of the fulfiller.\n     * @param minimumReceived The minimum items that the caller is willing to\n     *                        receive.\n     * @param maximumSpent    The maximum items the caller is willing to spend.\n     * @param context         Additional context of the order.\n     *\n     * @return offer         A tuple containing the offer items.\n     * @return consideration A tuple containing the consideration items.\n     */\n    function generateOrder(\n        address fulfiller,\n        SpentItem[] calldata minimumReceived,\n        SpentItem[] calldata maximumSpent,\n        bytes calldata context // encoded based on the schemaID\n    ) external returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\n\n    /**\n     * @dev Ratifies an order with the specified offer, consideration, and\n     *      optional context (supplied as extraData).\n     *\n     * @param offer         The offer items.\n     * @param consideration The consideration items.\n     * @param context       Additional context of the order.\n     * @param orderHashes   The hashes to ratify.\n     * @param contractNonce The nonce of the contract.\n     *\n     * @return ratifyOrderMagicValue The magic value returned by the contract\n     *                               offerer.\n     */\n    function ratifyOrder(\n        SpentItem[] calldata offer,\n        ReceivedItem[] calldata consideration,\n        bytes calldata context, // encoded based on the schemaID\n        bytes32[] calldata orderHashes,\n        uint256 contractNonce\n    ) external returns (bytes4 ratifyOrderMagicValue);\n\n    /**\n     * @dev View function to preview an order generated in response to a minimum\n     *      set of received items, maximum set of spent items, and context\n     *      (supplied as extraData).\n     *\n     * @param caller          The address of the caller (e.g. Seaport).\n     * @param fulfiller       The address of the fulfiller (e.g. the account\n     *                        calling Seaport).\n     * @param minimumReceived The minimum items that the caller is willing to\n     *                        receive.\n     * @param maximumSpent    The maximum items the caller is willing to spend.\n     * @param context         Additional context of the order.\n     *\n     * @return offer         A tuple containing the offer items.\n     * @return consideration A tuple containing the consideration items.\n     */\n    function previewOrder(\n        address caller,\n        address fulfiller,\n        SpentItem[] calldata minimumReceived,\n        SpentItem[] calldata maximumSpent,\n        bytes calldata context // encoded based on the schemaID\n    ) external view returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\n\n    /**\n     * @dev Gets the metadata for this contract offerer.\n     *\n     * @return name    The name of the contract offerer.\n     * @return schemas The schemas supported by the contract offerer.\n     */\n    function getSeaportMetadata() external view returns (string memory name, Schema[] memory schemas); // map to Seaport Improvement Proposal IDs\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n\n    // Additional functions and/or events based on implemented schemaIDs\n}\n"
    },
    "seaport-core/src/lib/GettersAndDerivers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OrderParameters} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {ConsiderationBase} from \"./ConsiderationBase.sol\";\n\nimport {\n    Create2AddressDerivation_length,\n    Create2AddressDerivation_ptr,\n    EIP_712_PREFIX,\n    EIP712_ConsiderationItem_size,\n    EIP712_DigestPayload_size,\n    EIP712_DomainSeparator_offset,\n    EIP712_OfferItem_size,\n    EIP712_Order_size,\n    EIP712_OrderHash_offset,\n    FreeMemoryPointerSlot,\n    information_conduitController_offset,\n    information_domainSeparator_offset,\n    information_length,\n    information_version_cd_offset,\n    information_version_offset,\n    information_versionLengthPtr,\n    information_versionWithLength,\n    MaskOverByteTwelve,\n    MaskOverLastTwentyBytes,\n    OneWord,\n    OneWordShift,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_counter_offset,\n    OrderParameters_offer_head_offset,\n    TwoWords\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\n/**\n * @title GettersAndDerivers\n * @author 0age\n * @notice ConsiderationInternal contains pure and internal view functions\n *         related to getting or deriving various values.\n */\ncontract GettersAndDerivers is ConsiderationBase {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) ConsiderationBase(conduitController) {}\n\n    /**\n     * @dev Internal view function to derive the order hash for a given order.\n     *      Note that only the original consideration items are included in the\n     *      order hash, as additional consideration items may be supplied by the\n     *      caller.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     * @param counter         The counter of the order to hash.\n     *\n     * @return orderHash The hash.\n     */\n    function _deriveOrderHash(OrderParameters memory orderParameters, uint256 counter)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        // Get length of original consideration array and place it on the stack.\n        uint256 originalConsiderationLength = (orderParameters.totalOriginalConsiderationItems);\n\n        /*\n         * Memory layout for an array of structs (dynamic or not) is similar\n         * to ABI encoding of dynamic types, with a head segment followed by\n         * a data segment. The main difference is that the head of an element\n         * is a memory pointer rather than an offset.\n         */\n\n        // Declare a variable for the derived hash of the offer array.\n        bytes32 offerHash;\n\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the offers array.\n            let offerArrPtr := mload(add(orderParameters, OrderParameters_offer_head_offset))\n\n            // Load the length.\n            let offerLength := mload(offerArrPtr)\n\n            // Set the pointer to the first offer's head.\n            offerArrPtr := add(offerArrPtr, OneWord)\n\n            // Iterate over the offer items.\n            for { let i := 0 } lt(i, offerLength) { i := add(i, 1) } {\n                // Read the pointer to the offer data and subtract one word\n                // to get typeHash pointer.\n                let ptr := sub(mload(offerArrPtr), OneWord)\n\n                // Read the current value before the offer data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                offerArrPtr := add(offerArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the offer hash using the hashes of each item.\n            offerHash := keccak256(mload(FreeMemoryPointerSlot), shl(OneWordShift, offerLength))\n        }\n\n        // Declare a variable for the derived hash of the consideration array.\n        bytes32 considerationHash;\n\n        // Read consideration item typehash from runtime code & place on stack.\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the consideration array.\n            let considerationArrPtr :=\n                add(mload(add(orderParameters, OrderParameters_consideration_head_offset)), OneWord)\n\n            // Iterate over the consideration items (not including tips).\n            for { let i := 0 } lt(i, originalConsiderationLength) { i := add(i, 1) } {\n                // Read the pointer to the consideration data and subtract one\n                // word to get typeHash pointer.\n                let ptr := sub(mload(considerationArrPtr), OneWord)\n\n                // Read the current value before the consideration data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(hashArrPtr, keccak256(ptr, EIP712_ConsiderationItem_size))\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                considerationArrPtr := add(considerationArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the consideration hash using the hashes of each item.\n            considerationHash := keccak256(mload(FreeMemoryPointerSlot), shl(OneWordShift, originalConsiderationLength))\n        }\n\n        // Read order item EIP-712 typehash from runtime code & place on stack.\n        typeHash = _ORDER_TYPEHASH;\n\n        // Utilize assembly to access derived hashes & other arguments directly.\n        assembly {\n            // Retrieve pointer to the region located just behind parameters.\n            let typeHashPtr := sub(orderParameters, OneWord)\n\n            // Store the value at that pointer location to restore later.\n            let previousValue := mload(typeHashPtr)\n\n            // Store the order item EIP-712 typehash at the typehash location.\n            mstore(typeHashPtr, typeHash)\n\n            // Retrieve the pointer for the offer array head.\n            let offerHeadPtr := add(orderParameters, OrderParameters_offer_head_offset)\n\n            // Retrieve the data pointer referenced by the offer head.\n            let offerDataPtr := mload(offerHeadPtr)\n\n            // Store the offer hash at the retrieved memory location.\n            mstore(offerHeadPtr, offerHash)\n\n            // Retrieve the pointer for the consideration array head.\n            let considerationHeadPtr := add(orderParameters, OrderParameters_consideration_head_offset)\n\n            // Retrieve the data pointer referenced by the consideration head.\n            let considerationDataPtr := mload(considerationHeadPtr)\n\n            // Store the consideration hash at the retrieved memory location.\n            mstore(considerationHeadPtr, considerationHash)\n\n            // Retrieve the pointer for the counter.\n            let counterPtr := add(orderParameters, OrderParameters_counter_offset)\n\n            // Store the counter at the retrieved memory location.\n            mstore(counterPtr, counter)\n\n            // Derive the order hash using the full range of order parameters.\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\n\n            // Restore the value previously held at typehash pointer location.\n            mstore(typeHashPtr, previousValue)\n\n            // Restore offer data pointer at the offer head pointer location.\n            mstore(offerHeadPtr, offerDataPtr)\n\n            // Restore consideration data pointer at the consideration head ptr.\n            mstore(considerationHeadPtr, considerationDataPtr)\n\n            // Restore consideration item length at the counter pointer.\n            mstore(counterPtr, originalConsiderationLength)\n        }\n    }\n\n    /**\n     * @dev Internal view function to derive the address of a given conduit\n     *      using a corresponding conduit key.\n     *\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. This value is\n     *                   the \"salt\" parameter supplied by the deployer (i.e. the\n     *                   conduit controller) when deploying the given conduit.\n     *\n     * @return conduit The address of the conduit associated with the given\n     *                 conduit key.\n     */\n    function _deriveConduit(bytes32 conduitKey) internal view returns (address conduit) {\n        // Read conduit controller address from runtime and place on the stack.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Read conduit creation code hash from runtime and place on the stack.\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\n\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Place the control character and the conduit controller in scratch\n            // space; note that eleven bytes at the beginning are left unused.\n            mstore(0, or(MaskOverByteTwelve, conduitController))\n\n            // Place the conduit key in the next region of scratch space.\n            mstore(OneWord, conduitKey)\n\n            // Place conduit creation code hash in free memory pointer location.\n            mstore(TwoWords, conduitCreationCodeHash)\n\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\n            conduit :=\n                and(\n                    // Hash the relevant region.\n                    keccak256(\n                        // The region starts at memory pointer 11.\n                        Create2AddressDerivation_ptr,\n                        // The region is 85 bytes long (1 + 20 + 32 + 32).\n                        Create2AddressDerivation_length\n                    ),\n                    // The address equals the last twenty bytes of the hash.\n                    MaskOverLastTwentyBytes\n                )\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n        }\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID ? _DOMAIN_SEPARATOR : _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to retrieve configuration information for\n     *      this contract.\n     *\n     * @return The contract version.\n     * @return The domain separator for this contract.\n     * @return The conduit Controller set for this contract.\n     */\n    function _information()\n        internal\n        view\n        returns (string memory, /* version */ bytes32, /* domainSeparator */ address /* conduitController */ )\n    {\n        // Derive the domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Declare variable as immutables cannot be accessed within assembly.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Return the version, domain separator, and conduit controller.\n        assembly {\n            mstore(information_version_offset, information_version_cd_offset)\n            mstore(information_domainSeparator_offset, domainSeparator)\n            mstore(information_conduitController_offset, conduitController)\n            mstore(information_versionLengthPtr, information_versionWithLength)\n            return(information_version_offset, information_length)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param orderHash       The order hash.\n     *\n     * @return value The hash.\n     */\n    function _deriveEIP712Digest(bytes32 domainSeparator, bytes32 orderHash) internal pure returns (bytes32 value) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the order hash in scratch space, spilling into the first\n            // two bytes of the free memory pointer  this should never be set\n            // as memory cannot be expanded to that size, and will be zeroed out\n            // after the hash is performed.\n            mstore(EIP712_OrderHash_offset, orderHash)\n\n            // Hash the relevant region (65 bytes).\n            value := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_OrderHash_offset, 0)\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/ZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {ZoneParameters, Schema} from \"../lib/ConsiderationStructs.sol\";\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title  ZoneInterface\n * @notice Contains functions exposed by a zone.\n */\ninterface ZoneInterface is IERC165 {\n    /**\n     * @dev Validates an order.\n     *\n     * @param zoneParameters The context about the order fulfillment and any\n     *                       supplied extraData.\n     *\n     * @return validOrderMagicValue The magic value that indicates a valid\n     *                              order.\n     */\n    function validateOrder(ZoneParameters calldata zoneParameters) external returns (bytes4 validOrderMagicValue);\n\n    /**\n     * @dev Returns the metadata for this zone.\n     *\n     * @return name The name of the zone.\n     * @return schemas The schemas that the zone implements.\n     */\n    function getSeaportMetadata() external view returns (string memory name, Schema[] memory schemas); // map to Seaport Improvement Proposal IDs\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool);\n}\n"
    },
    "seaport-types/src/interfaces/ConsiderationInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationInterface\n * @author 0age\n * @custom:version 1.5\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace. It minimizes external calls to the greatest extent\n *         possible and provides lightweight methods for common routes as well\n *         as more flexible methods for composing advanced orders.\n *\n * @dev ConsiderationInterface contains all external function interfaces for\n *      Consideration.\n */\ninterface ConsiderationInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        Order calldata order,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or\n     *                    native tokens will not be reflected as part of this\n     *                    array.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components. Any unspent offer item\n     *         amounts will be transferred to the designated recipient (with the\n     *         null address signifying to use the caller) and any unspent native\n     *         tokens will be returned to the caller.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts, or the caller if the null address\n     *                          is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments,\n        address recipient\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        Order[] calldata orders\n    ) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration. Note that this function costs less gas than\n     *         `fulfillBasicOrder` due to the zero bytes in the function\n     *         selector (0x00000000) which also results in earlier function\n     *         dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        OrderComponents calldata order\n    ) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "seaport-core/src/lib/Verifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OrderStatus} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {Assertions} from \"./Assertions.sol\";\n\nimport {SignatureVerification} from \"./SignatureVerification.sol\";\n\nimport {\n    _revertInvalidTime,\n    _revertOrderAlreadyFilled,\n    _revertOrderIsCancelled,\n    _revertOrderPartiallyFilled\n} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\nimport {\n    BulkOrderProof_keyShift,\n    BulkOrderProof_keySize,\n    BulkOrderProof_lengthAdjustmentBeforeMask,\n    BulkOrderProof_lengthRangeAfterMask,\n    BulkOrderProof_minSize,\n    BulkOrderProof_rangeSize,\n    ECDSA_MaxLength,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes,\n    TwoWords\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\n/**\n * @title Verifiers\n * @author 0age\n * @notice Verifiers contains functions for performing verifications.\n */\ncontract Verifiers is Assertions, SignatureVerification {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Assertions(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the current time falls within\n     *      an order's valid timespan.\n     *\n     * @param startTime       The time at which the order becomes active.\n     * @param endTime         The time at which the order becomes inactive.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order is not active.\n     *\n     * @return valid A boolean indicating whether the order is active.\n     */\n    function _verifyTime(uint256 startTime, uint256 endTime, bool revertOnInvalid) internal view returns (bool valid) {\n        // Mark as valid if order has started and has not already ended.\n        assembly {\n            valid := and(iszero(gt(startTime, timestamp())), gt(endTime, timestamp()))\n        }\n\n        // Only revert on invalid if revertOnInvalid has been supplied as true.\n        if (revertOnInvalid && !valid) {\n            _revertInvalidTime(startTime, endTime);\n        }\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param offerer   The offerer for the order.\n     * @param orderHash The order hash.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _verifySignature(address offerer, bytes32 orderHash, bytes memory signature) internal view {\n        // Determine whether the offerer is the caller.\n        bool offererIsCaller;\n        assembly {\n            offererIsCaller := eq(offerer, caller())\n        }\n\n        // Skip signature verification if the offerer is the caller.\n        if (offererIsCaller) {\n            return;\n        }\n\n        // Derive the EIP-712 domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 originalDigest = _deriveEIP712Digest(domainSeparator, orderHash);\n\n        // Read the length of the signature from memory and place on the stack.\n        uint256 originalSignatureLength = signature.length;\n\n        // Determine effective digest if signature has a valid bulk order size.\n        bytes32 digest;\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\n            // Rederive order hash and digest using bulk order proof.\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\n        } else {\n            // Supply the original digest as the effective digest.\n            digest = originalDigest;\n        }\n\n        // Ensure that the signature for the digest is valid for the offerer.\n        _assertValidSignature(offerer, digest, originalDigest, originalSignatureLength, signature);\n    }\n\n    /**\n     * @dev Determines whether the specified bulk order size is valid.\n     *\n     * @param signatureLength The signature length of the bulk order to check.\n     *\n     * @return validLength True if bulk order size is valid, false otherwise.\n     */\n    function _isValidBulkOrderSize(uint256 signatureLength) internal pure returns (bool validLength) {\n        // Utilize assembly to validate the length; the equivalent logic is\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\n        assembly {\n            validLength :=\n                and(\n                    lt(sub(signatureLength, BulkOrderProof_minSize), BulkOrderProof_rangeSize),\n                    lt(\n                        and(add(signatureLength, BulkOrderProof_lengthAdjustmentBeforeMask), ThirtyOneBytes),\n                        BulkOrderProof_lengthRangeAfterMask\n                    )\n                )\n        }\n    }\n\n    /**\n     * @dev Computes the bulk order hash for the specified proof and leaf. Note\n     *      that if an index that exceeds the number of orders in the bulk order\n     *      payload will instead \"wrap around\" and refer to an earlier index.\n     *\n     * @param proofAndSignature The proof and signature of the bulk order.\n     * @param leaf              The leaf of the bulk order tree.\n     *\n     * @return bulkOrderHash The bulk order hash.\n     */\n    function _computeBulkOrderProof(bytes memory proofAndSignature, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32 bulkOrderHash)\n    {\n        // Declare arguments for the root hash and the height of the proof.\n        bytes32 root;\n        uint256 height;\n\n        // Utilize assembly to efficiently derive the root hash using the proof.\n        assembly {\n            // Retrieve the length of the proof, key, and signature combined.\n            let fullLength := mload(proofAndSignature)\n\n            // If proofAndSignature has odd length, it is a compact signature\n            // with 64 bytes.\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\n\n            // Derive height (or depth of tree) with signature and proof length.\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\n\n            // Update the length in memory to only include the signature.\n            mstore(proofAndSignature, signatureLength)\n\n            // Derive the pointer for the key using the signature length.\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\n\n            // Retrieve the three-byte key using the derived pointer.\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\n\n            /// Retrieve pointer to first proof element by applying a constant\n            // for the key size to the derived key pointer.\n            let proof := add(keyPtr, BulkOrderProof_keySize)\n\n            // Compute level 1.\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\n            mstore(scratchPtr1, leaf)\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\n\n            // Compute remaining proofs.\n            for { let i := 1 } lt(i, height) { i := add(i, 1) } {\n                proof := add(proof, OneWord)\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\n                mstore(scratchPtr, keccak256(0, TwoWords))\n                mstore(xor(scratchPtr, OneWord), mload(proof))\n            }\n\n            // Compute root hash.\n            root := keccak256(0, TwoWords)\n        }\n\n        // Retrieve appropriate typehash constant based on height.\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\n\n        // Use the typehash and the root hash to derive final bulk order hash.\n        assembly {\n            mstore(0, rootTypeHash)\n            mstore(OneWord, root)\n            bulkOrderHash := keccak256(0, TwoWords)\n        }\n    }\n\n    /**\n     * @dev Internal view function to validate that a given order is fillable\n     *      and not cancelled based on the order status.\n     *\n     * @param orderHash       The order hash.\n     * @param orderStatus     The status of the order, including whether it has\n     *                        been cancelled and the fraction filled.\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\n     *                        are supported by the calling function.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order has been cancelled or filled beyond the\n     *                        allowable amount.\n     *\n     * @return valid A boolean indicating whether the order is valid.\n     */\n    function _verifyOrderStatus(\n        bytes32 orderHash,\n        OrderStatus storage orderStatus,\n        bool onlyAllowUnused,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Ensure that the order has not been cancelled.\n        if (orderStatus.isCancelled) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                _revertOrderIsCancelled(orderHash);\n            }\n\n            // Return false as the order status is invalid.\n            return false;\n        }\n\n        // Read order status numerator from storage and place on stack.\n        uint256 orderStatusNumerator = orderStatus.numerator;\n\n        // If the order is not entirely unused...\n        if (orderStatusNumerator != 0) {\n            // ensure the order has not been partially filled when not allowed.\n            if (onlyAllowUnused) {\n                // Always revert on partial fills when onlyAllowUnused is true.\n                _revertOrderPartiallyFilled(orderHash);\n            }\n            // Otherwise, ensure that order has not been entirely filled.\n            else if (orderStatusNumerator >= orderStatus.denominator) {\n                // Only revert if revertOnInvalid has been supplied as true.\n                if (revertOnInvalid) {\n                    _revertOrderAlreadyFilled(orderHash);\n                }\n\n                // Return false as the order status is invalid.\n                return false;\n            }\n        }\n\n        // Return true as the order status is valid.\n        valid = true;\n    }\n}\n"
    },
    "seaport-types/src/interfaces/AbridgedTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ERC20Interface\n * @notice Contains the minimum interfaces needed to interact with ERC20s.\n */\ninterface ERC20Interface {\n    /**\n     * @dev Allows an operator to transfer tokens on behalf of an owner.\n     *\n     * @param from  The address of the owner.\n     * @param to    The address of the recipient.\n     * @param value The amount of tokens to transfer.\n     *\n     * @return success True if the transfer was successful.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\n\n    /**\n     * @dev Allows an operator to approve a spender to transfer tokens on behalf\n     *      of a user.\n     *\n     * @param spender The address of the spender.\n     * @param value   The amount of tokens to approve.\n     *\n     * @return success True if the approval was successful.\n     */\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /**\n     * @dev Returns the balance of a user.\n     *\n     * @param account The address of the user.\n     *\n     * @return balance The balance of the user.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount which spender is still allowed to withdraw\n     *      from owner.\n     *\n     * @param owner   The address of the owner.\n     * @param spender The address of the spender.\n     *\n     * @return remaining The amount of tokens that the spender is allowed to\n     *                   transfer on behalf of the owner.\n     */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title ERC721Interface\n * @notice Contains the minimum interfaces needed to interact with ERC721s.\n */\ninterface ERC721Interface {\n    /**\n     * @dev Allows an operator to transfer tokens on behalf of an owner.\n     *\n     * @param from    The address of the owner.\n     * @param to      The address of the recipient.\n     * @param tokenId The ID of the token to transfer.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Allows an owner to approve an operator to transfer all tokens on a\n     *      contract on behalf of the owner.\n     *\n     * @param to       The address of the operator.\n     * @param approved Whether the operator is approved.\n     */\n    function setApprovalForAll(address to, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for tokenId token\n     *\n     * @param tokenId The tokenId to query the approval of.\n     *\n     * @return operator The approved account of the tokenId.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns whether an operator is allowed to manage all of\n     *      the assets of owner.\n     *\n     * @param owner    The address of the owner.\n     * @param operator The address of the operator.\n     *\n     * @return approved True if the operator is approved by the owner.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Returns the owner of a given token ID.\n     *\n     * @param tokenId The token ID.\n     *\n     * @return owner The owner of the token.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n}\n\n/**\n * @title ERC1155Interface\n * @notice Contains the minimum interfaces needed to interact with ERC1155s.\n */\ninterface ERC1155Interface {\n    /**\n     * @dev Allows an operator to transfer tokens on behalf of an owner.\n     *\n     * @param from   The address of the owner.\n     * @param to     The address of the recipient.\n     * @param id     The ID of the token(s) to transfer.\n     * @param amount The amount of tokens to transfer.\n     * @param data   Additional data.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Allows an operator to transfer tokens on behalf of an owner.\n     *\n     * @param from    The address of the owner.\n     * @param to      The address of the recipient.\n     * @param ids     The IDs of the token(s) to transfer.\n     * @param amounts The amounts of tokens to transfer.\n     * @param data    Additional data.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Allows an owner to approve an operator to transfer all tokens on a\n     *      contract on behalf of the owner.\n     *\n     * @param to       The address of the operator.\n     * @param approved Whether the operator is approved.\n     */\n    function setApprovalForAll(address to, bool approved) external;\n\n    /**\n     * @dev Returns the amount of token type id owned by account.\n     *\n     * @param account The address of the account.\n     * @param id      The id of the token.\n     *\n     * @return balance The amount of tokens of type id owned by account.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev Returns true if operator is approved to transfer account's tokens.\n     *\n     * @param account  The address of the account.\n     * @param operator The address of the operator.\n     *\n     * @return approved True if the operator is approved to transfer account's\n     *                  tokens.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "seaport-types/src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "seaport-core/src/lib/SignatureVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SignatureVerificationErrors} from \"seaport-types/src/interfaces/SignatureVerificationErrors.sol\";\n\nimport {LowLevelHelpers} from \"./LowLevelHelpers.sol\";\n\nimport {\n    ECDSA_MaxLength,\n    ECDSA_signature_s_offset,\n    ECDSA_signature_v_offset,\n    ECDSA_twentySeventhAndTwentyEighthBytesSet,\n    Ecrecover_args_size,\n    Ecrecover_precompile,\n    EIP1271_isValidSignature_calldata_baseLength,\n    EIP1271_isValidSignature_digest_negativeOffset,\n    EIP1271_isValidSignature_selector_negativeOffset,\n    EIP1271_isValidSignature_selector,\n    EIP1271_isValidSignature_signature_head_offset,\n    EIP2098_allButHighestBitMask,\n    MaxUint8,\n    OneWord,\n    Signature_lower_v\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {\n    BadContractSignature_error_length,\n    BadContractSignature_error_selector,\n    BadSignatureV_error_length,\n    BadSignatureV_error_selector,\n    BadSignatureV_error_v_ptr,\n    Error_selector_offset,\n    InvalidSignature_error_length,\n    InvalidSignature_error_selector,\n    InvalidSigner_error_length,\n    InvalidSigner_error_selector\n} from \"seaport-types/src/lib/ConsiderationErrorConstants.sol\";\n\n/**\n * @title SignatureVerification\n * @author 0age\n * @notice SignatureVerification contains logic for verifying signatures.\n */\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied signer.\n     *\n     * @param signer                  The signer for the order.\n     * @param digest                  The digest to verify signature against.\n     * @param originalDigest          The original digest to verify signature\n     *                                against.\n     * @param originalSignatureLength The original signature length.\n     * @param signature               A signature from the signer indicating\n     *                                that the order has been approved.\n     */\n    function _assertValidSignature(\n        address signer,\n        bytes32 digest,\n        bytes32 originalDigest,\n        uint256 originalSignatureLength,\n        bytes memory signature\n    ) internal view {\n        // Declare value for ecrecover equality or 1271 call success status.\n        bool success;\n\n        // Utilize assembly to perform optimized signature verification check.\n        assembly {\n            // Ensure that first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Get the length of the signature.\n            let signatureLength := mload(signature)\n\n            // Get the pointer to the value preceding the signature length.\n            // This will be used for temporary memory overrides - either the\n            // signature head for isValidSignature or the digest for ecrecover.\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\n\n            // Cache the current value behind the signature to restore it later.\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\n\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\n            {\n                // Take the difference between the max ECDSA signature length\n                // and the actual signature length. Overflow desired for any\n                // values > 65. If the diff is not 0 or 1, it is not a valid\n                // ECDSA signature - move on to EIP1271 check.\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\n\n                // Declare variable for recovered signer.\n                let recoveredSigner\n\n                // If diff is 0 or 1, it may be an ECDSA signature.\n                // Try to recover signer.\n                if iszero(gt(lenDiff, 1)) {\n                    // Read the signature `s` value.\n                    let originalSignatureS := mload(add(signature, ECDSA_signature_s_offset))\n\n                    // Read the first byte of the word after `s`. If the\n                    // signature is 65 bytes, this will be the real `v` value.\n                    // If not, it will need to be modified - doing it this way\n                    // saves an extra condition.\n                    let v := byte(0, mload(add(signature, ECDSA_signature_v_offset)))\n\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\n                    if lenDiff {\n                        // Extract yParity from highest bit of vs and add 27 to\n                        // get v.\n                        v := add(shr(MaxUint8, originalSignatureS), Signature_lower_v)\n\n                        // Extract canonical s from vs, all but the highest bit.\n                        // Temporarily overwrite the original `s` value in the\n                        // signature.\n                        mstore(\n                            add(signature, ECDSA_signature_s_offset),\n                            and(originalSignatureS, EIP2098_allButHighestBitMask)\n                        )\n                    }\n                    // Temporarily overwrite the signature length with `v` to\n                    // conform to the expected input for ecrecover.\n                    mstore(signature, v)\n\n                    // Temporarily overwrite the word before the length with\n                    // `digest` to conform to the expected input for ecrecover.\n                    mstore(wordBeforeSignaturePtr, digest)\n\n                    // Attempt to recover the signer for the given signature. Do\n                    // not check the call status as ecrecover will return a null\n                    // address if the signature is invalid.\n                    pop(\n                        staticcall(\n                            gas(),\n                            Ecrecover_precompile, // Call ecrecover precompile.\n                            wordBeforeSignaturePtr, // Use data memory location.\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\n                            0, // Write result to scratch space.\n                            OneWord // Provide size of returned result.\n                        )\n                    )\n\n                    // Restore cached word before signature.\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n\n                    // Restore cached signature length.\n                    mstore(signature, signatureLength)\n\n                    // Restore cached signature `s` value.\n                    mstore(add(signature, ECDSA_signature_s_offset), originalSignatureS)\n\n                    // Read the recovered signer from the buffer given as return\n                    // space for ecrecover.\n                    recoveredSigner := mload(0)\n                }\n\n                // Set success to true if the signature provided was a valid\n                // ECDSA signature and the signer is not the null address. Use\n                // gt instead of direct as success is used outside of assembly.\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\n            }\n\n            // If the signature was not verified with ecrecover, try EIP1271.\n            if iszero(success) {\n                // Reset the original signature length.\n                mstore(signature, originalSignatureLength)\n\n                // Temporarily overwrite the word before the signature length\n                // and use it as the head of the signature input to\n                // `isValidSignature`, which has a value of 64.\n                mstore(wordBeforeSignaturePtr, EIP1271_isValidSignature_signature_head_offset)\n\n                // Get pointer to use for the selector of `isValidSignature`.\n                let selectorPtr := sub(signature, EIP1271_isValidSignature_selector_negativeOffset)\n\n                // Cache the value currently stored at the selector pointer.\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\n\n                // Cache the value currently stored at the digest pointer.\n                let cachedWordOverwrittenByDigest :=\n                    mload(sub(signature, EIP1271_isValidSignature_digest_negativeOffset))\n\n                // Write the selector first, since it overlaps the digest.\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\n\n                // Next, write the original digest.\n                mstore(sub(signature, EIP1271_isValidSignature_digest_negativeOffset), originalDigest)\n\n                // Call signer with `isValidSignature` to validate signature.\n                success :=\n                    staticcall(\n                        gas(),\n                        signer,\n                        selectorPtr,\n                        add(originalSignatureLength, EIP1271_isValidSignature_calldata_baseLength),\n                        0,\n                        OneWord\n                    )\n\n                // Determine if the signature is valid on successful calls.\n                if success {\n                    // If first word of scratch space does not contain EIP-1271\n                    // signature selector, revert.\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\n                        // Revert with bad 1271 signature if signer has code.\n                        if extcodesize(signer) {\n                            // Bad contract signature.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadContractSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"BadContractSignature()\"\n                            // ))\n                            revert(Error_selector_offset, BadContractSignature_error_length)\n                        }\n\n                        // Check if signature length was invalid.\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\n                            // Revert with generic invalid signature error.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, InvalidSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"InvalidSignature()\"\n                            // ))\n                            revert(Error_selector_offset, InvalidSignature_error_length)\n                        }\n\n                        // Check if v was invalid.\n                        if and(\n                            eq(signatureLength, ECDSA_MaxLength),\n                            iszero(\n                                byte(\n                                    byte(0, mload(add(signature, ECDSA_signature_v_offset))),\n                                    ECDSA_twentySeventhAndTwentyEighthBytesSet\n                                )\n                            )\n                        ) {\n                            // Revert with invalid v value.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadSignatureV_error_selector)\n                            mstore(BadSignatureV_error_v_ptr, byte(0, mload(add(signature, ECDSA_signature_v_offset))))\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"BadSignatureV(uint8)\", v\n                            // ))\n                            revert(Error_selector_offset, BadSignatureV_error_length)\n                        }\n\n                        // Revert with generic invalid signer error message.\n                        // Store left-padded selector with push4, mem[28:32]\n                        mstore(0, InvalidSigner_error_selector)\n\n                        // revert(abi.encodeWithSignature(\"InvalidSigner()\"))\n                        revert(Error_selector_offset, InvalidSigner_error_length)\n                    }\n                }\n\n                // Restore the cached values overwritten by selector, digest and\n                // signature head.\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\n                mstore(sub(signature, EIP1271_isValidSignature_digest_negativeOffset), cachedWordOverwrittenByDigest)\n            }\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with error indicating bad contract signature.\n            assembly {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, BadContractSignature_error_selector)\n                // revert(abi.encodeWithSignature(\"BadContractSignature()\"))\n                revert(Error_selector_offset, BadContractSignature_error_length)\n            }\n        }\n    }\n}\n"
    },
    "seaport-core/src/lib/Assertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OrderParameters} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {GettersAndDerivers} from \"./GettersAndDerivers.sol\";\n\nimport {TokenTransferrerErrors} from \"seaport-types/src/interfaces/TokenTransferrerErrors.sol\";\n\nimport {CounterManager} from \"./CounterManager.sol\";\n\nimport {\n    AdditionalRecipient_size_shift,\n    AddressDirtyUpperBitThreshold,\n    BasicOrder_additionalRecipients_head_cdPtr,\n    BasicOrder_additionalRecipients_head_ptr,\n    BasicOrder_additionalRecipients_length_cdPtr,\n    BasicOrder_basicOrderType_cdPtr,\n    BasicOrder_basicOrderType_range,\n    BasicOrder_considerationToken_cdPtr,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_offerToken_cdPtr,\n    BasicOrder_parameters_cdPtr,\n    BasicOrder_parameters_ptr,\n    BasicOrder_signature_cdPtr,\n    BasicOrder_signature_ptr,\n    BasicOrder_zone_cdPtr\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    MissingItemAmount_error_length,\n    MissingItemAmount_error_selector\n} from \"seaport-types/src/lib/ConsiderationErrorConstants.sol\";\n\nimport {\n    _revertInvalidBasicOrderParameterEncoding,\n    _revertMissingOriginalConsiderationItems\n} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\n/**\n * @title Assertions\n * @author 0age\n * @notice Assertions contains logic for making various assertions that do not\n *         fit neatly within a dedicated semantic scope.\n */\ncontract Assertions is GettersAndDerivers, CounterManager, TokenTransferrerErrors {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) GettersAndDerivers(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current counter for a given order's offerer and zone and use it\n     *      to derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetOrderHash(OrderParameters memory orderParameters)\n        internal\n        view\n        returns (bytes32)\n    {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length, orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current counter for the offerer.\n        return _deriveOrderHash(orderParameters, _getCounter(orderParameters.offerer));\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            _revertMissingOriginalConsiderationItems();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given item amount is not\n     *      zero.\n     *\n     * @param amount The amount to check.\n     */\n    function _assertNonZeroAmount(uint256 amount) internal pure {\n        assembly {\n            if iszero(amount) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, MissingItemAmount_error_selector)\n\n                // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\n                revert(Error_selector_offset, MissingItemAmount_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for dynamic\n     *      types in BasicOrderParameters and other parameters. This ensures\n     *      that functions using the calldata object normally will be using the\n     *      same data as the assembly functions and that values that are bound\n     *      to a given range are within that range. Note that no parameters are\n     *      supplied as all basic order functions use the same calldata\n     *      encoding.\n     */\n    function _assertValidBasicOrderParameters() internal pure {\n        // Declare a boolean designating basic order parameter offset validity.\n        bool validOffsets;\n\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Order parameters struct offset == 0x20\n             * 2. Additional recipients arr offset == 0x240\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\n             * 5. Offerer, zone, offer token, and consideration token have no\n             *    upper dirty bits  each argument is type(uint160).max or less\n             */\n            validOffsets :=\n                and(\n                    and(\n                        and(\n                            // Order parameters at cd 0x04 must have offset of 0x20.\n                            eq(calldataload(BasicOrder_parameters_cdPtr), BasicOrder_parameters_ptr),\n                            // Additional recipients (cd 0x224) arr offset == 0x240.\n                            eq(\n                                calldataload(BasicOrder_additionalRecipients_head_cdPtr),\n                                BasicOrder_additionalRecipients_head_ptr\n                            )\n                        ),\n                        // Signature offset == 0x260 + (recipients.length * 0x40).\n                        eq(\n                            // Load signature offset from calldata 0x244.\n                            calldataload(BasicOrder_signature_cdPtr),\n                            // Expected offset is start of recipients + len * 64.\n                            add(\n                                BasicOrder_signature_ptr,\n                                shl(\n                                    // Each additional recipient has length of 0x40.\n                                    AdditionalRecipient_size_shift,\n                                    // Additional recipients length at cd 0x264.\n                                    calldataload(BasicOrder_additionalRecipients_length_cdPtr)\n                                )\n                            )\n                        )\n                    ),\n                    and(\n                        // Ensure BasicOrderType parameter is less than 0x18.\n                        lt(\n                            // BasicOrderType parameter at calldata offset 0x124.\n                            calldataload(BasicOrder_basicOrderType_cdPtr),\n                            // Value should be less than 24.\n                            BasicOrder_basicOrderType_range\n                        ),\n                        // Ensure no dirty upper bits are present on offerer, zone,\n                        // offer token, or consideration token.\n                        lt(\n                            or(\n                                or(\n                                    // Offerer parameter at calldata offset 0x84.\n                                    calldataload(BasicOrder_offerer_cdPtr),\n                                    // Zone parameter at calldata offset 0xa4.\n                                    calldataload(BasicOrder_zone_cdPtr)\n                                ),\n                                or(\n                                    // Offer token parameter at cd offset 0xc4.\n                                    calldataload(BasicOrder_offerToken_cdPtr),\n                                    // Consideration token parameter at offset 0x24.\n                                    calldataload(BasicOrder_considerationToken_cdPtr)\n                                )\n                            ),\n                            AddressDirtyUpperBitThreshold\n                        )\n                    )\n                )\n        }\n\n        // Revert with an error if basic order parameter offsets are invalid.\n        if (!validOffsets) {\n            _revertInvalidBasicOrderParameterEncoding();\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/SignatureVerificationErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title SignatureVerificationErrors\n * @author 0age\n * @notice SignatureVerificationErrors contains all errors related to signature\n *         verification.\n */\ninterface SignatureVerificationErrors {\n    /**\n     * @dev Revert with an error when a signature that does not contain a v\n     *      value of 27 or 28 has been supplied.\n     *\n     * @param v The invalid v value.\n     */\n    error BadSignatureV(uint8 v);\n\n    /**\n     * @dev Revert with an error when the signer recovered by the supplied\n     *      signature does not match the offerer or an allowed EIP-1271 signer\n     *      as specified by the offerer in the event they are a contract.\n     */\n    error InvalidSigner();\n\n    /**\n     * @dev Revert with an error when a signer cannot be recovered from the\n     *      supplied signature.\n     */\n    error InvalidSignature();\n\n    /**\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\n     */\n    error BadContractSignature();\n}\n"
    },
    "seaport-types/src/interfaces/TokenTransferrerErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title TokenTransferrerErrors\n */\ninterface TokenTransferrerErrors {\n    /**\n     * @dev Revert with an error when an ERC721 transfer with amount other than\n     *      one is attempted.\n     *\n     * @param amount The amount of the ERC721 tokens to transfer.\n     */\n    error InvalidERC721TransferAmount(uint256 amount);\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has an amount of zero.\n     */\n    error MissingItemAmount();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has unused parameters. This includes both the token and the\n     *      identifier parameters for native transfers as well as the identifier\n     *      parameter for ERC20 transfers. Note that the conduit does not\n     *      perform this check, leaving it up to the calling channel to enforce\n     *      when desired.\n     */\n    error UnusedItemParameters();\n\n    /**\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\n     *      transfer reverts.\n     *\n     * @param token      The token for which the transfer was attempted.\n     * @param from       The source of the attempted transfer.\n     * @param to         The recipient of the attempted transfer.\n     * @param identifier The identifier for the attempted transfer.\n     * @param amount     The amount for the attempted transfer.\n     */\n    error TokenTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\n     *\n     * @param token       The token for which the transfer was attempted.\n     * @param from        The source of the attempted transfer.\n     * @param to          The recipient of the attempted transfer.\n     * @param identifiers The identifiers for the attempted transfer.\n     * @param amounts     The amounts for the attempted transfer.\n     */\n    error ERC1155BatchTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256[] identifiers,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\n     *      value.\n     *\n     * @param token      The token for which the ERC20 transfer was attempted.\n     * @param from       The source of the attempted ERC20 transfer.\n     * @param to         The recipient of the attempted ERC20 transfer.\n     * @param amount     The amount for the attempted ERC20 transfer.\n     */\n    error BadReturnValueFromERC20OnTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when an account being called as an assumed\n     *      contract does not have code and returns no data.\n     *\n     * @param account The account that should contain code.\n     */\n    error NoContract(address account);\n\n    /**\n     * @dev Revert with an error when attempting to execute an 1155 batch\n     *      transfer using calldata not produced by default ABI encoding or with\n     *      different lengths for ids and amounts arrays.\n     */\n    error Invalid1155BatchTransferEncoding();\n}\n"
    },
    "contracts/helpers/order-validator/SeaportValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ItemType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\nimport {\n    Order,\n    OrderParameters,\n    BasicOrderParameters,\n    OfferItem,\n    ConsiderationItem,\n    Schema,\n    ZoneParameters\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport { ConsiderationTypeHashes } from \"./lib/ConsiderationTypeHashes.sol\";\nimport {\n    ConsiderationInterface\n} from \"seaport-types/src/interfaces/ConsiderationInterface.sol\";\nimport {\n    ConduitControllerInterface\n} from \"seaport-types/src/interfaces/ConduitControllerInterface.sol\";\nimport {\n    ContractOffererInterface\n} from \"seaport-types/src/interfaces/ContractOffererInterface.sol\";\nimport { ZoneInterface } from \"seaport-types/src/interfaces/ZoneInterface.sol\";\nimport {\n    GettersAndDerivers\n} from \"seaport-core/src/lib/GettersAndDerivers.sol\";\nimport { SeaportValidatorInterface } from \"./lib/SeaportValidatorInterface.sol\";\nimport { ZoneInterface } from \"seaport-types/src/interfaces/ZoneInterface.sol\";\nimport {\n    ERC20Interface,\n    ERC721Interface,\n    ERC1155Interface\n} from \"seaport-types/src/interfaces/AbridgedTokenInterfaces.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport { IERC2981 } from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {\n    ErrorsAndWarnings,\n    ErrorsAndWarningsLib\n} from \"./lib/ErrorsAndWarnings.sol\";\nimport { SafeStaticCall } from \"./lib/SafeStaticCall.sol\";\nimport {\n    IssueParser,\n    ValidationConfiguration,\n    TimeIssue,\n    StatusIssue,\n    OfferIssue,\n    ContractOffererIssue,\n    ConsiderationIssue,\n    PrimaryFeeIssue,\n    ERC721Issue,\n    ERC1155Issue,\n    ERC20Issue,\n    NativeIssue,\n    ZoneIssue,\n    ConduitIssue,\n    CreatorFeeIssue,\n    SignatureIssue,\n    GenericIssue,\n    ConsiderationItemConfiguration\n} from \"./lib/SeaportValidatorTypes.sol\";\nimport { Verifiers } from \"seaport-core/src/lib/Verifiers.sol\";\nimport { ReadOnlyOrderValidator } from \"./lib/ReadOnlyOrderValidator.sol\";\nimport { SeaportValidatorHelper } from \"./lib/SeaportValidatorHelper.sol\";\n\n/**\n * @title SeaportValidator\n * @author OpenSea Protocol Team\n * @notice SeaportValidator provides advanced validation to seaport orders.\n */\ncontract SeaportValidator is\n    SeaportValidatorInterface,\n    ConsiderationTypeHashes\n{\n    using ErrorsAndWarningsLib for ErrorsAndWarnings;\n    using SafeStaticCall for address;\n    using IssueParser for *;\n\n    /// @notice Cross-chain conduit controller Address\n    ConduitControllerInterface private immutable _conduitController;\n\n    SeaportValidatorHelper private immutable _helper;\n\n    ReadOnlyOrderValidator private immutable _readOnlyOrderValidator;\n\n    bytes4 public constant ERC20_INTERFACE_ID = 0x36372b07;\n\n    bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;\n\n    bytes4 public constant CONTRACT_OFFERER_INTERFACE_ID = 0x1be900b1;\n\n    bytes4 public constant ZONE_INTERFACE_ID = 0x3839be19;\n\n    constructor(\n        address readOnlyOrderValidatorAddress,\n        address seaportValidatorHelperAddress,\n        address conduitControllerAddress\n    ) {\n        _readOnlyOrderValidator = ReadOnlyOrderValidator(\n            readOnlyOrderValidatorAddress\n        );\n        _helper = SeaportValidatorHelper(seaportValidatorHelperAddress);\n        _conduitController = ConduitControllerInterface(\n            conduitControllerAddress\n        );\n    }\n\n    /**\n     * @notice Conduct a comprehensive validation of the given order.\n     *    `isValidOrder` validates simple orders that adhere to a set of rules defined below:\n     *    - The order is either a listing or an offer order (one NFT to buy or one NFT to sell).\n     *    - The first consideration is the primary consideration.\n     *    - The order pays up to two fees in the fungible token currency. First fee is primary fee, second is creator fee.\n     *    - In private orders, the last consideration specifies a recipient for the offer item.\n     *    - Offer items must be owned and properly approved by the offerer.\n     *    - There must be one offer item\n     *    - Consideration items must exist.\n     *    - The signature must be valid, or the order must be already validated on chain\n     * @param order The order to validate.\n     * @return errorsAndWarnings The errors and warnings found in the order.\n     */\n    function isValidOrder(\n        Order calldata order,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        return\n            isValidOrderWithConfiguration(\n                ValidationConfiguration(\n                    seaportAddress,\n                    address(0),\n                    0,\n                    false,\n                    false,\n                    30 minutes,\n                    26 weeks\n                ),\n                order\n            );\n    }\n\n    /**\n     * @notice Same as `isValidOrder` but allows for more configuration related to fee validation.\n     *    If `skipStrictValidation` is set order logic validation is not carried out: fees are not\n     *       checked and there may be more than one offer item as well as any number of consideration items.\n     */\n    function isValidOrderWithConfiguration(\n        ValidationConfiguration memory validationConfiguration,\n        Order memory order\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Concatenates errorsAndWarnings with the returned errorsAndWarnings\n        errorsAndWarnings.concat(\n            validateTime(\n                order.parameters,\n                validationConfiguration.shortOrderDuration,\n                validationConfiguration.distantOrderExpiration\n            )\n        );\n        errorsAndWarnings.concat(\n            validateOrderStatus(\n                order.parameters,\n                validationConfiguration.seaport\n            )\n        );\n        errorsAndWarnings.concat(\n            validateOfferItems(\n                order.parameters,\n                validationConfiguration.seaport\n            )\n        );\n        errorsAndWarnings.concat(\n            validateConsiderationItems(\n                order.parameters,\n                validationConfiguration.seaport\n            )\n        );\n        errorsAndWarnings.concat(isValidZone(order.parameters));\n        errorsAndWarnings.concat(\n            validateSignature(order, validationConfiguration.seaport)\n        );\n\n        // Skip strict validation if requested\n        if (!validationConfiguration.skipStrictValidation) {\n            errorsAndWarnings.concat(\n                validateStrictLogic(\n                    order.parameters,\n                    validationConfiguration.primaryFeeRecipient,\n                    validationConfiguration.primaryFeeBips,\n                    validationConfiguration.checkCreatorFee\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice Strict validation operates under tight assumptions. It validates primary\n     *    fee, creator fee, private sale consideration, and overall order format.\n     * @dev Only checks first fee recipient provided by CreatorFeeEngine.\n     *    Order of consideration items must be as follows:\n     *    1. Primary consideration\n     *    2. Primary fee\n     *    3. Creator fee\n     *    4. Private sale consideration\n     * @param orderParameters The parameters for the order to validate.\n     * @param primaryFeeRecipient The primary fee recipient. Set to null address for no primary fee.\n     * @param primaryFeeBips The primary fee in BIPs.\n     * @param checkCreatorFee Should check for creator fee. If true, creator fee must be present as\n     *    according to creator fee engine. If false, must not have creator fee.\n     * @return errorsAndWarnings The errors and warnings.\n     */\n    function validateStrictLogic(\n        OrderParameters memory orderParameters,\n        address primaryFeeRecipient,\n        uint256 primaryFeeBips,\n        bool checkCreatorFee\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        return\n            _helper.validateStrictLogic(\n                orderParameters,\n                primaryFeeRecipient,\n                primaryFeeBips,\n                checkCreatorFee\n            );\n    }\n\n    /**\n     * @notice Checks if a conduit key is valid.\n     * @param conduitKey The conduit key to check.\n     * @return errorsAndWarnings The errors and warnings\n     */\n    function isValidConduit(\n        bytes32 conduitKey,\n        address seaportAddress\n    ) external view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        (, errorsAndWarnings) = getApprovalAddress(conduitKey, seaportAddress);\n    }\n\n    /**\n     * @notice Checks if the zone of an order is set and implements the EIP165\n     *         zone interface\n     * @dev To validate the zone call for an order, see validateOrderWithZone\n     * @param orderParameters The order parameters to check.\n     * @return errorsAndWarnings The errors and warnings\n     */\n    function isValidZone(\n        OrderParameters memory orderParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // If not restricted, zone isn't checked\n        if (\n            uint8(orderParameters.orderType) < 2 ||\n            uint8(orderParameters.orderType) == 4\n        ) {\n            return errorsAndWarnings;\n        }\n\n        if (orderParameters.zone == address(0)) {\n            // Zone is not set\n            errorsAndWarnings.addError(ZoneIssue.NotSet.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Warn if zone is an EOA\n        if (address(orderParameters.zone).code.length == 0) {\n            errorsAndWarnings.addWarning(ZoneIssue.EOAZone.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check the EIP165 zone interface\n        if (!checkInterface(orderParameters.zone, ZONE_INTERFACE_ID)) {\n            errorsAndWarnings.addWarning(ZoneIssue.InvalidZone.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check if the zone implements SIP-5\n        try ZoneInterface(orderParameters.zone).getSeaportMetadata() {} catch {\n            errorsAndWarnings.addWarning(ZoneIssue.InvalidZone.parseInt());\n        }\n    }\n\n    /**\n     * @notice Gets the approval address for the given conduit key\n     * @param conduitKey Conduit key to get approval address for\n     * @param seaportAddress The Seaport address\n     * @return approvalAddress The address to use for approvals\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function getApprovalAddress(\n        bytes32 conduitKey,\n        address seaportAddress\n    )\n        public\n        view\n        returns (address, ErrorsAndWarnings memory errorsAndWarnings)\n    {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Zero conduit key corresponds to seaport\n        if (conduitKey == 0) return (seaportAddress, errorsAndWarnings);\n\n        // Pull conduit info from conduitController\n        (address conduitAddress, bool exists) = _conduitController.getConduit(\n            conduitKey\n        );\n\n        // Conduit does not exist\n        if (!exists) {\n            errorsAndWarnings.addError(ConduitIssue.KeyInvalid.parseInt());\n            conduitAddress = address(0); // Don't return invalid conduit\n        }\n\n        // Approval address does not have Seaport added as a channel\n        if (\n            exists &&\n            !_conduitController.getChannelStatus(conduitAddress, seaportAddress)\n        ) {\n            errorsAndWarnings.addError(\n                ConduitIssue.MissingSeaportChannel.parseInt()\n            );\n        }\n\n        return (conduitAddress, errorsAndWarnings);\n    }\n\n    /**\n     * @notice Validates the signature for the order using the offerer's current counter\n     * @dev Will also check if order is validated on chain.\n     */\n    function validateSignature(\n        Order memory order,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        // Pull current counter from seaport\n        uint256 currentCounter = ConsiderationInterface(seaportAddress)\n            .getCounter(order.parameters.offerer);\n\n        return\n            validateSignatureWithCounter(order, currentCounter, seaportAddress);\n    }\n\n    /**\n     * @notice Validates the signature for the order using the given counter\n     * @dev Will also check if order is validated on chain.\n     */\n    function validateSignatureWithCounter(\n        Order memory order,\n        uint256 counter,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Typecast Seaport address to ConsiderationInterface\n        ConsiderationInterface seaport = ConsiderationInterface(seaportAddress);\n\n        // Contract orders do not have signatures\n        if (uint8(order.parameters.orderType) == 4) {\n            errorsAndWarnings.addWarning(\n                SignatureIssue.ContractOrder.parseInt()\n            );\n        }\n\n        // Get current counter for context\n        uint256 currentCounter = seaport.getCounter(order.parameters.offerer);\n\n        if (currentCounter > counter) {\n            // Counter strictly increases\n            errorsAndWarnings.addError(SignatureIssue.LowCounter.parseInt());\n            return errorsAndWarnings;\n        } else if (currentCounter < counter) {\n            // Counter is incremented by random large number\n            errorsAndWarnings.addError(SignatureIssue.HighCounter.parseInt());\n            return errorsAndWarnings;\n        }\n\n        bytes32 orderHash = _deriveOrderHash(order.parameters, counter);\n\n        // Check if order is validated on chain\n        (bool isValid, , , ) = seaport.getOrderStatus(orderHash);\n\n        if (isValid) {\n            // Shortcut success, valid on chain\n            return errorsAndWarnings;\n        }\n\n        // Create memory array to pass into validate\n        Order[] memory orderArray = new Order[](1);\n\n        // Store order in array\n        orderArray[0] = order;\n\n        try\n            // Call validate on Seaport\n            _readOnlyOrderValidator.canValidate(seaportAddress, orderArray)\n        returns (bool success) {\n            if (!success) {\n                // Call was unsuccessful, so signature is invalid\n                errorsAndWarnings.addError(SignatureIssue.Invalid.parseInt());\n            }\n        } catch {\n            if (\n                order.parameters.consideration.length !=\n                order.parameters.totalOriginalConsiderationItems\n            ) {\n                // May help diagnose signature issues\n                errorsAndWarnings.addWarning(\n                    SignatureIssue.OriginalConsiderationItems.parseInt()\n                );\n            }\n            // Call reverted, so signature is invalid\n            errorsAndWarnings.addError(SignatureIssue.Invalid.parseInt());\n        }\n    }\n\n    /**\n     * @notice Check that a contract offerer implements the EIP165\n     *         contract offerer interface\n     * @param contractOfferer The address of the contract offerer\n     * @return errorsAndWarnings The errors and warnings\n     */\n    function validateContractOfferer(\n        address contractOfferer\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Check the EIP165 contract offerer interface\n        if (!checkInterface(contractOfferer, CONTRACT_OFFERER_INTERFACE_ID)) {\n            errorsAndWarnings.addWarning(\n                ContractOffererIssue.InvalidContractOfferer.parseInt()\n            );\n        }\n\n        // Check if the contract offerer implements SIP-5\n        try\n            ContractOffererInterface(contractOfferer).getSeaportMetadata()\n        {} catch {\n            errorsAndWarnings.addWarning(\n                ContractOffererIssue.InvalidContractOfferer.parseInt()\n            );\n        }\n\n        return errorsAndWarnings;\n    }\n\n    /**\n     * @notice Check the time validity of an order\n     * @param orderParameters The parameters for the order to validate\n     * @param shortOrderDuration The duration of which an order is considered short\n     * @param distantOrderExpiration Distant order expiration delta in seconds.\n     * @return errorsAndWarnings The errors and warnings\n     */\n    function validateTime(\n        OrderParameters memory orderParameters,\n        uint256 shortOrderDuration,\n        uint256 distantOrderExpiration\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        if (orderParameters.endTime <= orderParameters.startTime) {\n            // Order duration is zero\n            errorsAndWarnings.addError(\n                TimeIssue.EndTimeBeforeStartTime.parseInt()\n            );\n            return errorsAndWarnings;\n        }\n\n        if (orderParameters.endTime < block.timestamp) {\n            // Order is expired\n            errorsAndWarnings.addError(TimeIssue.Expired.parseInt());\n            return errorsAndWarnings;\n        } else if (\n            orderParameters.endTime > block.timestamp + distantOrderExpiration\n        ) {\n            // Order expires in a long time\n            errorsAndWarnings.addWarning(\n                TimeIssue.DistantExpiration.parseInt()\n            );\n        }\n\n        if (orderParameters.startTime > block.timestamp) {\n            // Order is not active\n            errorsAndWarnings.addWarning(TimeIssue.NotActive.parseInt());\n        }\n\n        if (\n            orderParameters.endTime -\n                (\n                    orderParameters.startTime > block.timestamp\n                        ? orderParameters.startTime\n                        : block.timestamp\n                ) <\n            shortOrderDuration\n        ) {\n            // Order has a short duration\n            errorsAndWarnings.addWarning(TimeIssue.ShortOrder.parseInt());\n        }\n    }\n\n    /**\n     * @notice Validate the status of an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateOrderStatus(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Typecast Seaport address to ConsiderationInterface\n        ConsiderationInterface seaport = ConsiderationInterface(seaportAddress);\n\n        // Cannot validate status of contract order\n        if (uint8(orderParameters.orderType) == 4) {\n            errorsAndWarnings.addWarning(StatusIssue.ContractOrder.parseInt());\n        }\n\n        // Pull current counter from seaport\n        uint256 currentOffererCounter = seaport.getCounter(\n            orderParameters.offerer\n        );\n        // Derive order hash using orderParameters and currentOffererCounter\n        bytes32 orderHash = _deriveOrderHash(\n            orderParameters,\n            currentOffererCounter\n        );\n        // Get order status from seaport\n        (, bool isCancelled, uint256 totalFilled, uint256 totalSize) = seaport\n            .getOrderStatus(orderHash);\n\n        if (isCancelled) {\n            // Order is cancelled\n            errorsAndWarnings.addError(StatusIssue.Cancelled.parseInt());\n        }\n\n        if (totalSize > 0 && totalFilled == totalSize) {\n            // Order is fully filled\n            errorsAndWarnings.addError(StatusIssue.FullyFilled.parseInt());\n        }\n    }\n\n    /**\n     * @notice Validate all offer items for an order. Ensures that\n     *         offerer has sufficient balance and approval for each item.\n     * @dev Amounts are not summed and verified, just the individual amounts.\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateOfferItems(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Iterate over each offer item and validate it\n        for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n            errorsAndWarnings.concat(\n                validateOfferItem(orderParameters, i, seaportAddress)\n            );\n\n            // Check for duplicate offer item\n            OfferItem memory offerItem1 = orderParameters.offer[i];\n\n            for (uint256 j = i + 1; j < orderParameters.offer.length; j++) {\n                // Iterate over each remaining offer item\n                // (previous items already check with this item)\n                OfferItem memory offerItem2 = orderParameters.offer[j];\n\n                // Check if token and id are the same\n                if (\n                    offerItem1.token == offerItem2.token &&\n                    offerItem1.identifierOrCriteria ==\n                    offerItem2.identifierOrCriteria\n                ) {\n                    errorsAndWarnings.addError(\n                        OfferIssue.DuplicateItem.parseInt()\n                    );\n                }\n            }\n        }\n\n        // You must have an offer item\n        if (orderParameters.offer.length == 0) {\n            errorsAndWarnings.addWarning(OfferIssue.ZeroItems.parseInt());\n        }\n\n        // Warning if there is more than one offer item\n        if (orderParameters.offer.length > 1) {\n            errorsAndWarnings.addWarning(OfferIssue.MoreThanOneItem.parseInt());\n        }\n    }\n\n    /**\n     * @notice Validates an offer item\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItem(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        // First validate the parameters (correct amount, contract, etc)\n        errorsAndWarnings = validateOfferItemParameters(\n            orderParameters,\n            offerItemIndex,\n            seaportAddress\n        );\n        if (errorsAndWarnings.hasErrors()) {\n            // Only validate approvals and balances if parameters are valid\n            return errorsAndWarnings;\n        }\n\n        // Validate approvals and balances for the offer item\n        errorsAndWarnings.concat(\n            validateOfferItemApprovalAndBalance(\n                orderParameters,\n                offerItemIndex,\n                seaportAddress\n            )\n        );\n    }\n\n    /**\n     * @notice Validates the OfferItem parameters. This includes token contract validation\n     * @dev OfferItems with criteria are currently not allowed\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Get the offer item at offerItemIndex\n        OfferItem memory offerItem = orderParameters.offer[offerItemIndex];\n\n        // Check if start amount and end amount are zero\n        if (offerItem.startAmount == 0 && offerItem.endAmount == 0) {\n            errorsAndWarnings.addError(OfferIssue.AmountZero.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check that amount velocity is not too high.\n        if (\n            offerItem.startAmount != offerItem.endAmount &&\n            orderParameters.endTime > orderParameters.startTime\n        ) {\n            // Assign larger and smaller amount values\n            (uint256 maxAmount, uint256 minAmount) = offerItem.startAmount >\n                offerItem.endAmount\n                ? (offerItem.startAmount, offerItem.endAmount)\n                : (offerItem.endAmount, offerItem.startAmount);\n\n            uint256 amountDelta = maxAmount - minAmount;\n            // delta of time that order exists for\n            uint256 timeDelta = orderParameters.endTime -\n                orderParameters.startTime;\n\n            // Velocity scaled by 1e10 for precision\n            uint256 velocity = (amountDelta * 1e10) / timeDelta;\n            // gives velocity percentage in hundredth of a basis points per second in terms of larger value\n            uint256 velocityPercentage = velocity / (maxAmount * 1e4);\n\n            // 278 * 60 * 30 ~= 500,000\n            if (velocityPercentage > 278) {\n                // Over 50% change per 30 min\n                errorsAndWarnings.addError(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n            // Over 50% change per 30 min\n            else if (velocityPercentage > 28) {\n                // Over 5% change per 30 min\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n\n            // Check for large amount steps\n            if (minAmount <= 1e15) {\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountStepLarge.parseInt()\n                );\n            }\n        }\n\n        if (offerItem.itemType == ItemType.ERC721) {\n            // ERC721 type requires amounts to be 1\n            if (offerItem.startAmount != 1 || offerItem.endAmount != 1) {\n                errorsAndWarnings.addError(ERC721Issue.AmountNotOne.parseInt());\n            }\n\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n        } else if (offerItem.itemType == ItemType.ERC721_WITH_CRITERIA) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n\n            if (offerItem.startAmount > 1 || offerItem.endAmount > 1) {\n                // Require partial fill enabled. Even orderTypes are full\n                if (uint8(orderParameters.orderType) % 2 == 0) {\n                    errorsAndWarnings.addError(\n                        ERC721Issue.CriteriaNotPartialFill.parseInt()\n                    );\n                }\n            }\n        } else if (\n            offerItem.itemType == ItemType.ERC1155 ||\n            offerItem.itemType == ItemType.ERC1155_WITH_CRITERIA\n        ) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC1155_INTERFACE_ID)) {\n                errorsAndWarnings.addError(\n                    ERC1155Issue.InvalidToken.parseInt()\n                );\n            }\n        } else if (offerItem.itemType == ItemType.ERC20) {\n            // ERC20 must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.IdentifierNonZero.parseInt()\n                );\n            }\n\n            // Validate contract, should return an uint256 if its an ERC20\n            if (\n                !offerItem.token.safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.allowance.selector,\n                        seaportAddress,\n                        seaportAddress\n                    ),\n                    0\n                )\n            ) {\n                errorsAndWarnings.addError(ERC20Issue.InvalidToken.parseInt());\n            }\n        } else {\n            // Must be native\n            // NATIVE must have `token` be zero address\n            if (offerItem.token != address(0)) {\n                errorsAndWarnings.addError(NativeIssue.TokenAddress.parseInt());\n            }\n\n            // NATIVE must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    NativeIssue.IdentifierNonZero.parseInt()\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Validates the OfferItem approvals and balances\n     * @param orderParameters The parameters for the order to validate\n     * @param offerItemIndex The index of the offerItem in offer array to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOfferItemApprovalAndBalance(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        // Note: If multiple items are of the same token, token amounts are not summed for validation\n\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Get the approval address for the given conduit key\n        (\n            address approvalAddress,\n            ErrorsAndWarnings memory ew\n        ) = getApprovalAddress(orderParameters.conduitKey, seaportAddress);\n        errorsAndWarnings.concat(ew);\n\n        if (ew.hasErrors()) {\n            // Approval address is invalid\n            return errorsAndWarnings;\n        }\n\n        // Get the offer item at offerItemIndex\n        OfferItem memory offerItem = orderParameters.offer[offerItemIndex];\n\n        if (offerItem.itemType == ItemType.ERC721) {\n            ERC721Interface token = ERC721Interface(offerItem.token);\n\n            // Check that offerer owns token\n            if (\n                !address(token).safeStaticCallAddress(\n                    abi.encodeWithSelector(\n                        ERC721Interface.ownerOf.selector,\n                        offerItem.identifierOrCriteria\n                    ),\n                    orderParameters.offerer\n                )\n            ) {\n                errorsAndWarnings.addError(ERC721Issue.NotOwner.parseInt());\n            }\n\n            // Check for approval via `getApproved`\n            if (\n                !address(token).safeStaticCallAddress(\n                    abi.encodeWithSelector(\n                        ERC721Interface.getApproved.selector,\n                        offerItem.identifierOrCriteria\n                    ),\n                    approvalAddress\n                )\n            ) {\n                // Fallback to `isApprovalForAll`\n                if (\n                    !address(token).safeStaticCallBool(\n                        abi.encodeWithSelector(\n                            ERC721Interface.isApprovedForAll.selector,\n                            orderParameters.offerer,\n                            approvalAddress\n                        ),\n                        true\n                    )\n                ) {\n                    // Not approved\n                    errorsAndWarnings.addError(\n                        ERC721Issue.NotApproved.parseInt()\n                    );\n                }\n            }\n        } else if (offerItem.itemType == ItemType.ERC721_WITH_CRITERIA) {\n            ERC721Interface token = ERC721Interface(offerItem.token);\n\n            // Check for approval\n            if (\n                !address(token).safeStaticCallBool(\n                    abi.encodeWithSelector(\n                        ERC721Interface.isApprovedForAll.selector,\n                        orderParameters.offerer,\n                        approvalAddress\n                    ),\n                    true\n                )\n            ) {\n                // Not approved\n                errorsAndWarnings.addError(ERC721Issue.NotApproved.parseInt());\n            }\n        } else if (offerItem.itemType == ItemType.ERC1155) {\n            ERC1155Interface token = ERC1155Interface(offerItem.token);\n\n            // Check for approval\n            if (\n                !address(token).safeStaticCallBool(\n                    abi.encodeWithSelector(\n                        ERC1155Interface.isApprovedForAll.selector,\n                        orderParameters.offerer,\n                        approvalAddress\n                    ),\n                    true\n                )\n            ) {\n                errorsAndWarnings.addError(ERC1155Issue.NotApproved.parseInt());\n            }\n\n            // Get min required balance (max(startAmount, endAmount))\n            uint256 minBalance = offerItem.startAmount < offerItem.endAmount\n                ? offerItem.startAmount\n                : offerItem.endAmount;\n\n            // Check for sufficient balance\n            if (\n                !address(token).safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC1155Interface.balanceOf.selector,\n                        orderParameters.offerer,\n                        offerItem.identifierOrCriteria\n                    ),\n                    minBalance\n                )\n            ) {\n                // Insufficient balance\n                errorsAndWarnings.addError(\n                    ERC1155Issue.InsufficientBalance.parseInt()\n                );\n            }\n        } else if (offerItem.itemType == ItemType.ERC1155_WITH_CRITERIA) {\n            ERC1155Interface token = ERC1155Interface(offerItem.token);\n\n            // Check for approval\n            if (\n                !address(token).safeStaticCallBool(\n                    abi.encodeWithSelector(\n                        ERC1155Interface.isApprovedForAll.selector,\n                        orderParameters.offerer,\n                        approvalAddress\n                    ),\n                    true\n                )\n            ) {\n                errorsAndWarnings.addError(ERC1155Issue.NotApproved.parseInt());\n            }\n        } else if (offerItem.itemType == ItemType.ERC20) {\n            ERC20Interface token = ERC20Interface(offerItem.token);\n\n            // Get min required balance and approval (max(startAmount, endAmount))\n            uint256 minBalanceAndAllowance = offerItem.startAmount <\n                offerItem.endAmount\n                ? offerItem.startAmount\n                : offerItem.endAmount;\n\n            // Check allowance\n            if (\n                !address(token).safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.allowance.selector,\n                        orderParameters.offerer,\n                        approvalAddress\n                    ),\n                    minBalanceAndAllowance\n                )\n            ) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.InsufficientAllowance.parseInt()\n                );\n            }\n\n            // Check balance\n            if (\n                !address(token).safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.balanceOf.selector,\n                        orderParameters.offerer\n                    ),\n                    minBalanceAndAllowance\n                )\n            ) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.InsufficientBalance.parseInt()\n                );\n            }\n        } else {\n            // Must be native\n            // Get min required balance (max(startAmount, endAmount))\n            uint256 minBalance = offerItem.startAmount < offerItem.endAmount\n                ? offerItem.startAmount\n                : offerItem.endAmount;\n\n            // Check for sufficient balance\n            if (orderParameters.offerer.balance < minBalance) {\n                errorsAndWarnings.addError(\n                    NativeIssue.InsufficientBalance.parseInt()\n                );\n            }\n\n            // Native items can not be pulled so warn\n            errorsAndWarnings.addWarning(OfferIssue.NativeItem.parseInt());\n        }\n    }\n\n    /**\n     * @notice Validate all consideration items for an order\n     * @param orderParameters The parameters for the order to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItems(\n        OrderParameters memory orderParameters,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        return\n            _helper.validateConsiderationItems(orderParameters, seaportAddress);\n    }\n\n    /**\n     * @notice Validate a consideration item\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItem(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        return\n            _helper.validateConsiderationItem(\n                orderParameters,\n                considerationItemIndex,\n                seaportAddress\n            );\n    }\n\n    /**\n     * @notice Validates the parameters of a consideration item including contract validation\n     * @param orderParameters The parameters for the order to validate\n     * @param considerationItemIndex The index of the consideration item to validate\n     * @return errorsAndWarnings  The errors and warnings\n     */\n    function validateConsiderationItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 considerationItemIndex,\n        address seaportAddress\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        return\n            _helper.validateConsiderationItemParameters(\n                orderParameters,\n                considerationItemIndex,\n                seaportAddress\n            );\n    }\n\n    /**\n     * @notice Validates the zone call for an order\n     * @param orderParameters The order parameters for the order to validate\n     * @param zoneParameters The zone parameters for the order to validate\n     * @return errorsAndWarnings An ErrorsAndWarnings structs with results\n     */\n    function validateOrderWithZone(\n        OrderParameters memory orderParameters,\n        ZoneParameters memory zoneParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Call isValidZone to check if zone is set and implements EIP165\n        errorsAndWarnings.concat(isValidZone(orderParameters));\n\n        // Call zone function `validateOrder` with the supplied ZoneParameters\n        if (\n            !orderParameters.zone.safeStaticCallBytes4(\n                abi.encodeWithSelector(\n                    ZoneInterface.validateOrder.selector,\n                    zoneParameters\n                ),\n                ZoneInterface.validateOrder.selector\n            )\n        ) {\n            // Call to validateOrder reverted or returned invalid magic value\n            errorsAndWarnings.addWarning(ZoneIssue.RejectedOrder.parseInt());\n        }\n    }\n\n    /**\n     * @notice Safely check that a contract implements an interface\n     * @param token The token address to check\n     * @param interfaceHash The interface hash to check\n     */\n    function checkInterface(\n        address token,\n        bytes4 interfaceHash\n    ) public view returns (bool) {\n        return\n            token.safeStaticCallBool(\n                abi.encodeWithSelector(\n                    IERC165.supportsInterface.selector,\n                    interfaceHash\n                ),\n                true\n            );\n    }\n\n    function isPaymentToken(ItemType itemType) public pure returns (bool) {\n        return itemType == ItemType.NATIVE || itemType == ItemType.ERC20;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Merkle Helpers\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Sorts an array of token ids by the keccak256 hash of the id. Required ordering of ids\n     *    for other merkle operations.\n     * @param includedTokens An array of included token ids.\n     * @return sortedTokens The sorted `includedTokens` array.\n     */\n    function sortMerkleTokens(\n        uint256[] memory includedTokens\n    ) public view returns (uint256[] memory sortedTokens) {\n        // Sort token ids by the keccak256 hash of the id\n        return _helper.sortMerkleTokens(includedTokens);\n    }\n\n    /**\n     * @notice Creates a merkle root for includedTokens.\n     * @dev `includedTokens` must be sorting in strictly ascending order according to the keccak256 hash of the value.\n     * @return merkleRoot The merkle root\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleRoot(\n        uint256[] memory includedTokens\n    )\n        public\n        view\n        returns (bytes32 merkleRoot, ErrorsAndWarnings memory errorsAndWarnings)\n    {\n        return _helper.getMerkleRoot(includedTokens);\n    }\n\n    /**\n     * @notice Creates a merkle proof for the the targetIndex contained in includedTokens.\n     * @dev `targetIndex` is referring to the index of an element in `includedTokens`.\n     *    `includedTokens` must be sorting in ascending order according to the keccak256 hash of the value.\n     * @return merkleProof The merkle proof\n     * @return errorsAndWarnings Errors and warnings from the operation\n     */\n    function getMerkleProof(\n        uint256[] memory includedTokens,\n        uint256 targetIndex\n    )\n        public\n        view\n        returns (\n            bytes32[] memory merkleProof,\n            ErrorsAndWarnings memory errorsAndWarnings\n        )\n    {\n        return _helper.getMerkleProof(includedTokens, targetIndex);\n    }\n\n    /**\n     * @notice Verifies a merkle proof for the value to prove and given root and proof.\n     * @dev The `valueToProve` is hashed prior to executing the proof verification.\n     * @param merkleRoot The root of the merkle tree\n     * @param merkleProof The merkle proof\n     * @param valueToProve The value to prove\n     * @return whether proof is valid\n     */\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        bytes32[] memory merkleProof,\n        uint256 valueToProve\n    ) public view returns (bool) {\n        return _helper.verifyMerkleProof(merkleRoot, merkleProof, valueToProve);\n    }\n}\n"
    },
    "contracts/helpers/order-validator/lib/ReadOnlyOrderValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\n\nimport {\n    Order,\n    OrderComponents,\n    OrderParameters,\n    OrderStatus\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport {\n    _revertConsiderationLengthNotEqualToTotalOriginal,\n    _revertMissingOriginalConsiderationItems\n} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\nimport {\n    SignatureVerification\n} from \"seaport-core/src/lib/SignatureVerification.sol\";\n\nimport {\n    _revertOrderAlreadyFilled,\n    _revertOrderIsCancelled,\n    _revertOrderPartiallyFilled\n} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\nimport { SeaportInterface } from \"seaport-sol/src/SeaportInterface.sol\";\n\nimport {\n    BulkOrder_Typehash_Height_One,\n    BulkOrder_Typehash_Height_Two,\n    BulkOrder_Typehash_Height_Three,\n    BulkOrder_Typehash_Height_Four,\n    BulkOrder_Typehash_Height_Five,\n    BulkOrder_Typehash_Height_Six,\n    BulkOrder_Typehash_Height_Seven,\n    BulkOrder_Typehash_Height_Eight,\n    BulkOrder_Typehash_Height_Nine,\n    BulkOrder_Typehash_Height_Ten,\n    BulkOrder_Typehash_Height_Eleven,\n    BulkOrder_Typehash_Height_Twelve,\n    BulkOrder_Typehash_Height_Thirteen,\n    BulkOrder_Typehash_Height_Fourteen,\n    BulkOrder_Typehash_Height_Fifteen,\n    BulkOrder_Typehash_Height_Sixteen,\n    BulkOrder_Typehash_Height_Seventeen,\n    BulkOrder_Typehash_Height_Eighteen,\n    BulkOrder_Typehash_Height_Nineteen,\n    BulkOrder_Typehash_Height_Twenty,\n    BulkOrder_Typehash_Height_TwentyOne,\n    BulkOrder_Typehash_Height_TwentyTwo,\n    BulkOrder_Typehash_Height_TwentyThree,\n    BulkOrder_Typehash_Height_TwentyFour,\n    BulkOrderProof_keyShift,\n    BulkOrderProof_keySize,\n    BulkOrderProof_lengthAdjustmentBeforeMask,\n    BulkOrderProof_lengthRangeAfterMask,\n    BulkOrderProof_minSize,\n    BulkOrderProof_rangeSize,\n    ECDSA_MaxLength,\n    EIP_712_PREFIX,\n    EIP712_DigestPayload_size,\n    EIP712_DomainSeparator_offset,\n    EIP712_OrderHash_offset,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes,\n    TwoWords\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\ncontract ReadOnlyOrderValidator is SignatureVerification {\n    function canValidate(\n        address seaport,\n        Order[] memory orders\n    ) external view returns (bool) {\n        return _validate(orders, SeaportInterface(seaport));\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(\n        Order[] memory orders,\n        SeaportInterface seaport\n    ) internal view returns (bool validated) {\n        (, bytes32 domainSeparator, ) = seaport.information();\n\n        // Declare variables outside of the loop.\n        OrderStatus memory orderStatus;\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order.\n                Order memory order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters memory orderParameters = order.parameters;\n\n                // Skip contract orders.\n                if (orderParameters.orderType == OrderType.CONTRACT) {\n                    continue;\n                }\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current counter & use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\n                    orderParameters,\n                    seaport\n                );\n\n                {\n                    // Retrieve the order status using the derived order hash.\n                    (\n                        bool isValidated,\n                        bool isCancelled,\n                        uint256 totalFilled,\n                        uint256 totalSize\n                    ) = seaport.getOrderStatus(orderHash);\n                    orderStatus = OrderStatus(\n                        isValidated,\n                        isCancelled,\n                        uint120(totalFilled),\n                        uint120(totalSize)\n                    );\n                }\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    true // Signifies to revert if the order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Ensure that consideration array length is equal to the\n                    // total original consideration items value.\n                    if (\n                        orderParameters.consideration.length !=\n                        orderParameters.totalOriginalConsiderationItems\n                    ) {\n                        _revertConsiderationLengthNotEqualToTotalOriginal();\n                    }\n\n                    // Verify the supplied signature.\n                    _verifySignature(\n                        offerer,\n                        orderHash,\n                        order.signature,\n                        domainSeparator\n                    );\n\n                    // Update order status to mark the order as valid.\n                    // orderStatus.isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    // emit OrderValidated(orderHash, orderParameters);\n                }\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to validate that a given order is fillable\n     *      and not cancelled based on the order status.\n     *\n     * @param orderHash       The order hash.\n     * @param orderStatus     The status of the order, including whether it has\n     *                        been cancelled and the fraction filled.\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\n     *                        are supported by the calling function.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order has been cancelled or filled beyond the\n     *                        allowable amount.\n     *\n     * @return valid A boolean indicating whether the order is valid.\n     */\n    function _verifyOrderStatus(\n        bytes32 orderHash,\n        OrderStatus memory orderStatus,\n        bool onlyAllowUnused,\n        bool revertOnInvalid\n    ) internal pure returns (bool valid) {\n        // Ensure that the order has not been cancelled.\n        if (orderStatus.isCancelled) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                _revertOrderIsCancelled(orderHash);\n            }\n\n            // Return false as the order status is invalid.\n            return false;\n        }\n\n        // Read order status numerator and place on stack.\n        uint256 orderStatusNumerator = orderStatus.numerator;\n\n        // If the order is not entirely unused...\n        if (orderStatusNumerator != 0) {\n            // ensure the order has not been partially filled when not allowed.\n            if (onlyAllowUnused) {\n                // Always revert on partial fills when onlyAllowUnused is true.\n                _revertOrderPartiallyFilled(orderHash);\n            }\n            // Otherwise, ensure that order has not been entirely filled.\n            else if (orderStatusNumerator >= orderStatus.denominator) {\n                // Only revert if revertOnInvalid has been supplied as true.\n                if (revertOnInvalid) {\n                    _revertOrderAlreadyFilled(orderHash);\n                }\n\n                // Return false as the order status is invalid.\n                return false;\n            }\n        }\n\n        // Return true as the order status is valid.\n        valid = true;\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param offerer   The offerer for the order.\n     * @param orderHash The order hash.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _verifySignature(\n        address offerer,\n        bytes32 orderHash,\n        bytes memory signature,\n        bytes32 domainSeparator\n    ) internal view {\n        // Determine whether the offerer is the caller.\n        bool offererIsCaller;\n        assembly {\n            offererIsCaller := eq(offerer, caller())\n        }\n\n        // Skip signature verification if the offerer is the caller.\n        if (offererIsCaller) {\n            return;\n        }\n\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 originalDigest = _deriveEIP712Digest(\n            domainSeparator,\n            orderHash\n        );\n\n        // Read the length of the signature from memory and place on the stack.\n        uint256 originalSignatureLength = signature.length;\n\n        // Determine effective digest if signature has a valid bulk order size.\n        bytes32 digest;\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\n            // Rederive order hash and digest using bulk order proof.\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\n        } else {\n            // Supply the original digest as the effective digest.\n            digest = originalDigest;\n        }\n\n        // Ensure that the signature for the digest is valid for the offerer.\n        _assertValidSignature(\n            offerer,\n            digest,\n            originalDigest,\n            originalSignatureLength,\n            signature\n        );\n    }\n\n    /**\n     * @dev Determines whether the specified bulk order size is valid.\n     *\n     * @param signatureLength The signature length of the bulk order to check.\n     *\n     * @return validLength True if bulk order size is valid, false otherwise.\n     */\n    function _isValidBulkOrderSize(\n        uint256 signatureLength\n    ) internal pure returns (bool validLength) {\n        // Utilize assembly to validate the length; the equivalent logic is\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\n        assembly {\n            validLength := and(\n                lt(\n                    sub(signatureLength, BulkOrderProof_minSize),\n                    BulkOrderProof_rangeSize\n                ),\n                lt(\n                    and(\n                        add(\n                            signatureLength,\n                            BulkOrderProof_lengthAdjustmentBeforeMask\n                        ),\n                        ThirtyOneBytes\n                    ),\n                    BulkOrderProof_lengthRangeAfterMask\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Computes the bulk order hash for the specified proof and leaf. Note\n     *      that if an index that exceeds the number of orders in the bulk order\n     *      payload will instead \"wrap around\" and refer to an earlier index.\n     *\n     * @param proofAndSignature The proof and signature of the bulk order.\n     * @param leaf              The leaf of the bulk order tree.\n     *\n     * @return bulkOrderHash The bulk order hash.\n     */\n    function _computeBulkOrderProof(\n        bytes memory proofAndSignature,\n        bytes32 leaf\n    ) internal pure returns (bytes32 bulkOrderHash) {\n        // Declare arguments for the root hash and the height of the proof.\n        bytes32 root;\n        uint256 height;\n\n        // Utilize assembly to efficiently derive the root hash using the proof.\n        assembly {\n            // Retrieve the length of the proof, key, and signature combined.\n            let fullLength := mload(proofAndSignature)\n\n            // If proofAndSignature has odd length, it is a compact signature\n            // with 64 bytes.\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\n\n            // Derive height (or depth of tree) with signature and proof length.\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\n\n            // Update the length in memory to only include the signature.\n            mstore(proofAndSignature, signatureLength)\n\n            // Derive the pointer for the key using the signature length.\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\n\n            // Retrieve the three-byte key using the derived pointer.\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\n\n            /// Retrieve pointer to first proof element by applying a constant\n            // for the key size to the derived key pointer.\n            let proof := add(keyPtr, BulkOrderProof_keySize)\n\n            // Compute level 1.\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\n            mstore(scratchPtr1, leaf)\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\n\n            // Compute remaining proofs.\n            for {\n                let i := 1\n            } lt(i, height) {\n                i := add(i, 1)\n            } {\n                proof := add(proof, OneWord)\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\n                mstore(scratchPtr, keccak256(0, TwoWords))\n                mstore(xor(scratchPtr, OneWord), mload(proof))\n            }\n\n            // Compute root hash.\n            root := keccak256(0, TwoWords)\n        }\n\n        // Retrieve appropriate typehash constant based on height.\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\n\n        // Use the typehash and the root hash to derive final bulk order hash.\n        assembly {\n            mstore(0, rootTypeHash)\n            mstore(OneWord, root)\n            bulkOrderHash := keccak256(0, TwoWords)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to look up one of twenty-four potential bulk\n     *      order typehash constants based on the height of the bulk order tree.\n     *      Note that values between one and twenty-four are supported, which is\n     *      enforced by _isValidBulkOrderSize.\n     *\n     * @param _treeHeight The height of the bulk order tree. The value must be\n     *                    between one and twenty-four.\n     *\n     * @return _typeHash The EIP-712 typehash for the bulk order type with the\n     *                   given height.\n     */\n    function _lookupBulkOrderTypehash(\n        uint256 _treeHeight\n    ) internal pure returns (bytes32 _typeHash) {\n        // Utilize assembly to efficiently retrieve correct bulk order typehash.\n        assembly {\n            // Use a Yul function to enable use of the `leave` keyword\n            // to stop searching once the appropriate type hash is found.\n            function lookupTypeHash(treeHeight) -> typeHash {\n                // Handle tree heights one through eight.\n                if lt(treeHeight, 9) {\n                    // Handle tree heights one through four.\n                    if lt(treeHeight, 5) {\n                        // Handle tree heights one and two.\n                        if lt(treeHeight, 3) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 1),\n                                BulkOrder_Typehash_Height_One,\n                                BulkOrder_Typehash_Height_Two\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height three and four via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 3),\n                            BulkOrder_Typehash_Height_Three,\n                            BulkOrder_Typehash_Height_Four\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height five and six.\n                    if lt(treeHeight, 7) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 5),\n                            BulkOrder_Typehash_Height_Five,\n                            BulkOrder_Typehash_Height_Six\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height seven and eight via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 7),\n                        BulkOrder_Typehash_Height_Seven,\n                        BulkOrder_Typehash_Height_Eight\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height nine through sixteen.\n                if lt(treeHeight, 17) {\n                    // Handle tree height nine through twelve.\n                    if lt(treeHeight, 13) {\n                        // Handle tree height nine and ten.\n                        if lt(treeHeight, 11) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 9),\n                                BulkOrder_Typehash_Height_Nine,\n                                BulkOrder_Typehash_Height_Ten\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height eleven and twelve via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 11),\n                            BulkOrder_Typehash_Height_Eleven,\n                            BulkOrder_Typehash_Height_Twelve\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height thirteen and fourteen.\n                    if lt(treeHeight, 15) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 13),\n                            BulkOrder_Typehash_Height_Thirteen,\n                            BulkOrder_Typehash_Height_Fourteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n                    // Handle height fifteen and sixteen via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 15),\n                        BulkOrder_Typehash_Height_Fifteen,\n                        BulkOrder_Typehash_Height_Sixteen\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height seventeen through twenty.\n                if lt(treeHeight, 21) {\n                    // Handle tree height seventeen and eighteen.\n                    if lt(treeHeight, 19) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 17),\n                            BulkOrder_Typehash_Height_Seventeen,\n                            BulkOrder_Typehash_Height_Eighteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height nineteen and twenty via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 19),\n                        BulkOrder_Typehash_Height_Nineteen,\n                        BulkOrder_Typehash_Height_Twenty\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height twenty-one and twenty-two.\n                if lt(treeHeight, 23) {\n                    // Utilize branchless logic to determine typehash.\n                    typeHash := ternary(\n                        eq(treeHeight, 21),\n                        BulkOrder_Typehash_Height_TwentyOne,\n                        BulkOrder_Typehash_Height_TwentyTwo\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle height twenty-three & twenty-four w/ branchless logic.\n                typeHash := ternary(\n                    eq(treeHeight, 23),\n                    BulkOrder_Typehash_Height_TwentyThree,\n                    BulkOrder_Typehash_Height_TwentyFour\n                )\n\n                // Exit the function once typehash has been located.\n                leave\n            }\n\n            // Implement ternary conditional using branchless logic.\n            function ternary(cond, ifTrue, ifFalse) -> c {\n                c := xor(ifFalse, mul(cond, xor(ifFalse, ifTrue)))\n            }\n\n            // Look up the typehash using the supplied tree height.\n            _typeHash := lookupTypeHash(_treeHeight)\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current counter for a given order's offerer and zone and use it\n     *      to derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetOrderHash(\n        OrderParameters memory orderParameters,\n        SeaportInterface seaport\n    ) internal view returns (bytes32) {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length,\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current counter for the offerer.\n        return\n            _deriveOrderHash(\n                orderParameters,\n                _getCounter(seaport, orderParameters.offerer),\n                seaport\n            );\n    }\n\n    function _getCounter(\n        SeaportInterface seaport,\n        address offerer\n    ) internal view returns (uint256) {\n        return seaport.getCounter(offerer);\n    }\n\n    function _deriveOrderHash(\n        OrderParameters memory orderParameters,\n        uint256 counter,\n        SeaportInterface seaport\n    ) internal view returns (bytes32 orderHash) {\n        return\n            seaport.getOrderHash(_toOrderComponents(orderParameters, counter));\n    }\n\n    /**\n     * @dev Converts an OrderParameters struct into an OrderComponents struct.\n     *\n     * @param parameters the OrderParameters struct to convert\n     * @param counter    the counter to use for the OrderComponents struct\n     *\n     * @return components the OrderComponents struct\n     */\n    function _toOrderComponents(\n        OrderParameters memory parameters,\n        uint256 counter\n    ) internal pure returns (OrderComponents memory components) {\n        components.offerer = parameters.offerer;\n        components.zone = parameters.zone;\n        components.offer = parameters.offer;\n        components.consideration = parameters.consideration;\n        components.orderType = parameters.orderType;\n        components.startTime = parameters.startTime;\n        components.endTime = parameters.endTime;\n        components.zoneHash = parameters.zoneHash;\n        components.salt = parameters.salt;\n        components.conduitKey = parameters.conduitKey;\n        components.counter = counter;\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param orderHash       The order hash.\n     *\n     * @return value The hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 domainSeparator,\n        bytes32 orderHash\n    ) internal pure returns (bytes32 value) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the order hash in scratch space, spilling into the first\n            // two bytes of the free memory pointer  this should never be set\n            // as memory cannot be expanded to that size, and will be zeroed out\n            // after the hash is performed.\n            mstore(EIP712_OrderHash_offset, orderHash)\n\n            // Hash the relevant region (65 bytes).\n            value := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_OrderHash_offset, 0)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            _revertMissingOriginalConsiderationItems();\n        }\n    }\n}\n"
    },
    "seaport-sol/src/SeaportInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ConsiderationInterface as SeaportInterface} from \"seaport-types/src/interfaces/ConsiderationInterface.sol\";\n"
    },
    "contracts/helpers/SeaportRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    SeaportRouterInterface\n} from \"seaport-types/src/interfaces/SeaportRouterInterface.sol\";\n\nimport {\n    SeaportInterface\n} from \"seaport-types/src/interfaces/SeaportInterface.sol\";\n\nimport { ReentrancyGuard } from \"seaport-core/src/lib/ReentrancyGuard.sol\";\n\nimport {\n    AdvancedOrder,\n    CriteriaResolver,\n    Execution,\n    FulfillmentComponent\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\n/**\n * @title  SeaportRouter\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\n * @notice A utility contract for fulfilling orders with multiple\n *         Seaport versions. DISCLAIMER: This contract only works when\n *         all consideration items across all listings are native tokens.\n */\ncontract SeaportRouter is SeaportRouterInterface, ReentrancyGuard {\n    /// @dev The allowed v1.4 contract usable through this router.\n    address private immutable _SEAPORT_V1_4;\n    /// @dev The allowed v1.5 contract usable through this router.\n    address private immutable _SEAPORT_V1_5;\n\n    /**\n     * @dev Deploy contract with the supported Seaport contracts.\n     *\n     * @param seaportV1point4 The address of the Seaport v1.4 contract.\n     * @param seaportV1point5 The address of the Seaport v1.5 contract.\n     */\n    constructor(address seaportV1point4, address seaportV1point5) {\n        _SEAPORT_V1_4 = seaportV1point4;\n        _SEAPORT_V1_5 = seaportV1point5;\n    }\n\n    /**\n     * @dev Fallback function to receive excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    receive() external payable override {\n        // Ensure we only receive ether from Seaport.\n        _assertSeaportAllowed(msg.sender);\n    }\n\n    /**\n     * @notice Fulfill available advanced orders through multiple Seaport\n     *         versions.\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\n     *\n     * @param params The parameters for fulfilling available advanced orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        FulfillAvailableAdvancedOrdersParams calldata params\n    )\n        external\n        payable\n        override\n        returns (\n            bool[][] memory availableOrders,\n            Execution[][] memory executions\n        )\n    {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(true);\n\n        // Put the number of Seaport contracts on the stack.\n        uint256 seaportContractsLength = params.seaportContracts.length;\n\n        // Set the availableOrders and executions arrays to the correct length.\n        availableOrders = new bool[][](seaportContractsLength);\n        executions = new Execution[][](seaportContractsLength);\n\n        // Track the number of order fulfillments left.\n        uint256 fulfillmentsLeft = params.maximumFulfilled;\n\n        // To help avoid stack too deep errors, we format the calldata\n        // params in a struct and put it on the stack.\n        AdvancedOrder[] memory emptyAdvancedOrders;\n        CriteriaResolver[] memory emptyCriteriaResolvers;\n        FulfillmentComponent[][] memory emptyFulfillmentComponents;\n        CalldataParams memory calldataParams = CalldataParams({\n            advancedOrders: emptyAdvancedOrders,\n            criteriaResolvers: emptyCriteriaResolvers,\n            offerFulfillments: emptyFulfillmentComponents,\n            considerationFulfillments: emptyFulfillmentComponents,\n            fulfillerConduitKey: params.fulfillerConduitKey,\n            recipient: params.recipient,\n            maximumFulfilled: fulfillmentsLeft\n        });\n\n        // If recipient is not provided assign to msg.sender.\n        if (calldataParams.recipient == address(0)) {\n            calldataParams.recipient = msg.sender;\n        }\n\n        // Iterate through the provided Seaport contracts.\n        for (uint256 i = 0; i < params.seaportContracts.length; ) {\n            // Ensure the provided Seaport contract is allowed.\n            _assertSeaportAllowed(params.seaportContracts[i]);\n\n            // Put the order params on the stack.\n            AdvancedOrderParams calldata orderParams = params\n                .advancedOrderParams[i];\n\n            // Assign the variables to the calldata params.\n            calldataParams.advancedOrders = orderParams.advancedOrders;\n            calldataParams.criteriaResolvers = orderParams.criteriaResolvers;\n            calldataParams.offerFulfillments = orderParams.offerFulfillments;\n            calldataParams.considerationFulfillments = orderParams\n                .considerationFulfillments;\n\n            // Execute the orders, collecting availableOrders and executions.\n            // This is wrapped in a try/catch in case a single order is\n            // executed that is no longer available, leading to a revert\n            // with `NoSpecifiedOrdersAvailable()` that can be ignored.\n            try\n                SeaportInterface(params.seaportContracts[i])\n                    .fulfillAvailableAdvancedOrders{\n                    value: orderParams.etherValue\n                }(\n                    calldataParams.advancedOrders,\n                    calldataParams.criteriaResolvers,\n                    calldataParams.offerFulfillments,\n                    calldataParams.considerationFulfillments,\n                    calldataParams.fulfillerConduitKey,\n                    calldataParams.recipient,\n                    calldataParams.maximumFulfilled\n                )\n            returns (\n                bool[] memory newAvailableOrders,\n                Execution[] memory newExecutions\n            ) {\n                availableOrders[i] = newAvailableOrders;\n                executions[i] = newExecutions;\n\n                // Subtract the number of orders fulfilled.\n                uint256 newAvailableOrdersLength = newAvailableOrders.length;\n                for (uint256 j = 0; j < newAvailableOrdersLength; ) {\n                    if (newAvailableOrders[j]) {\n                        unchecked {\n                            --fulfillmentsLeft;\n                            ++j;\n                        }\n                    }\n                }\n\n                // Break if the maximum number of executions has been reached.\n                if (fulfillmentsLeft == 0) {\n                    break;\n                }\n            } catch (bytes memory data) {\n                // Set initial value of first four bytes of revert data\n                // to the mask.\n                bytes4 customErrorSelector = bytes4(0xffffffff);\n\n                // Utilize assembly to read first four bytes\n                // (if present) directly.\n                assembly {\n                    // Combine original mask with first four bytes of\n                    // revert data.\n                    customErrorSelector := and(\n                        // Data begins after length offset.\n                        mload(add(data, 0x20)),\n                        customErrorSelector\n                    )\n                }\n\n                // Pass through the custom error if the error is\n                // not NoSpecifiedOrdersAvailable()\n                if (\n                    customErrorSelector != NoSpecifiedOrdersAvailable.selector\n                ) {\n                    assembly {\n                        revert(add(data, 32), mload(data))\n                    }\n                }\n            }\n\n            // Update fulfillments left.\n            calldataParams.maximumFulfilled = fulfillmentsLeft;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Throw an error if no orders were fulfilled.\n        if (fulfillmentsLeft == params.maximumFulfilled) {\n            revert NoSpecifiedOrdersAvailable();\n        }\n\n        // Return excess ether that may not have been used or was sent back.\n        if (address(this).balance > 0) {\n            _returnExcessEther();\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Returns the Seaport contracts allowed to be used through this\n     *         router.\n     */\n    function getAllowedSeaportContracts()\n        external\n        view\n        override\n        returns (address[] memory seaportContracts)\n    {\n        seaportContracts = new address[](2);\n        seaportContracts[0] = _SEAPORT_V1_4;\n        seaportContracts[1] = _SEAPORT_V1_5;\n    }\n\n    /**\n     * @dev Reverts if the provided Seaport contract is not allowed.\n     */\n    function _assertSeaportAllowed(address seaport) internal view {\n        if (\n            _cast(seaport == _SEAPORT_V1_4) | _cast(seaport == _SEAPORT_V1_5) ==\n            0\n        ) {\n            revert SeaportNotAllowed(seaport);\n        }\n    }\n\n    /**\n     * @dev Function to return excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    function _returnExcessEther() private {\n        // Send received funds back to msg.sender.\n        (bool success, bytes memory data) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n\n        // Revert with an error if the ether transfer failed.\n        if (!success) {\n            revert EtherReturnTransferFailed(\n                msg.sender,\n                address(this).balance,\n                data\n            );\n        }\n    }\n}\n"
    },
    "seaport-types/src/interfaces/SeaportRouterInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    CriteriaResolver,\n    FulfillmentComponent\n} from \"../lib/ConsiderationStructs.sol\";\n\nimport { Execution } from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title  SeaportRouterInterface\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\n * @notice A utility contract for fulfilling orders with multiple\n *         Seaport versions. DISCLAIMER: This contract only works when\n *         all consideration items across all listings are native tokens.\n */\ninterface SeaportRouterInterface {\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n\n    /**\n     * @dev Advanced order parameters for use through the\n     *      FulfillAvailableAdvancedOrdersParams struct.\n     */\n    struct AdvancedOrderParams {\n        AdvancedOrder[] advancedOrders;\n        CriteriaResolver[] criteriaResolvers;\n        FulfillmentComponent[][] offerFulfillments;\n        FulfillmentComponent[][] considerationFulfillments;\n        uint256 etherValue; /// The ether value to send with the set of orders.\n    }\n\n    /**\n     * @dev Parameters for using fulfillAvailableAdvancedOrders\n     *      through SeaportRouter.\n     */\n    struct FulfillAvailableAdvancedOrdersParams {\n        address[] seaportContracts;\n        AdvancedOrderParams[] advancedOrderParams;\n        bytes32 fulfillerConduitKey;\n        address recipient;\n        uint256 maximumFulfilled;\n    }\n\n    /**\n     * @dev Calldata params for calling FulfillAvailableAdvancedOrders.\n     */\n    struct CalldataParams {\n        AdvancedOrder[] advancedOrders;\n        CriteriaResolver[] criteriaResolvers;\n        FulfillmentComponent[][] offerFulfillments;\n        FulfillmentComponent[][] considerationFulfillments;\n        bytes32 fulfillerConduitKey;\n        address recipient;\n        uint256 maximumFulfilled;\n    }\n\n    /**\n     * @dev Revert with an error if a provided Seaport contract is not allowed\n     *      to be used in the router.\n     */\n    error SeaportNotAllowed(address seaport);\n\n    /**\n     * @dev Revert with an error if an ether transfer back to the fulfiller\n     *      fails.\n     */\n    error EtherReturnTransferFailed(\n        address recipient,\n        uint256 amount,\n        bytes returnData\n    );\n\n    /**\n     * @dev Fallback function to receive excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    receive() external payable;\n\n    /**\n     * @notice Fulfill available advanced orders through multiple Seaport\n     *         versions.\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\n     *\n     * @param params The parameters for fulfilling available advanced orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        FulfillAvailableAdvancedOrdersParams calldata params\n    )\n        external\n        payable\n        returns (\n            bool[][] memory availableOrders,\n            Execution[][] memory executions\n        );\n\n    /**\n     * @notice Returns the Seaport contracts allowed to be used through this\n     *         router.\n     */\n    function getAllowedSeaportContracts()\n        external\n        view\n        returns (address[] memory);\n}\n"
    },
    "seaport-types/src/interfaces/SeaportInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title SeaportInterface\n * @author 0age\n * @custom:version 1.5\n * @notice Seaport is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace. It minimizes external calls to the greatest extent\n *         possible and provides lightweight methods for common routes as well\n *         as more flexible methods for composing advanced orders.\n *\n * @dev SeaportInterface contains all external function interfaces for Seaport.\n */\ninterface SeaportInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        Order calldata order,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or\n     *                    native tokens will not be reflected as part of this\n     *                    array.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components. Any unspent offer item\n     *         amounts will be transferred to the designated recipient (with the\n     *         null address signifying to use the caller) and any unspent native\n     *         tokens will be returned to the caller.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts, or the caller if the null address\n     *                          is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments,\n        address recipient\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        Order[] calldata orders\n    ) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration. Note that this function costs less gas than\n     *         `fulfillBasicOrder` due to the zero bytes in the function\n     *         selector (0x00000000) which also results in earlier function\n     *         dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        OrderComponents calldata order\n    ) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n"
    },
    "contracts/interfaces/ZoneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ZoneParameters,\n    Schema\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\nimport { IERC165 } from \"seaport-types/src/interfaces/IERC165.sol\";\n\n/**\n * @title  ZoneInterface\n * @notice Contains functions exposed by a zone.\n */\ninterface ZoneInterface is IERC165 {\n    /**\n     * @dev Validates an order.\n     *\n     * @param zoneParameters The context about the order fulfillment and any\n     *                       supplied extraData.\n     *\n     * @return validOrderMagicValue The magic value that indicates a valid\n     *                              order.\n     */\n    function validateOrder(\n        ZoneParameters calldata zoneParameters\n    ) external returns (bytes4 validOrderMagicValue);\n\n    /**\n     * @dev Returns the metadata for this zone.\n     *\n     * @return name The name of the zone.\n     * @return schemas The schemas that the zone implements.\n     */\n    function getSeaportMetadata()\n        external\n        view\n        returns (\n            string memory name,\n            Schema[] memory schemas // map to Seaport Improvement Proposal IDs\n        );\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view override returns (bool);\n}\n"
    },
    "seaport-types/src/conduit/lib/ConduitStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ConduitItemType } from \"./ConduitEnums.sol\";\n\n/**\n * @dev A ConduitTransfer is a struct that contains the information needed for a\n *      conduit to transfer an item from one address to another.\n */\nstruct ConduitTransfer {\n    ConduitItemType itemType;\n    address token;\n    address from;\n    address to;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A ConduitBatch1155Transfer is a struct that contains the information\n *      needed for a conduit to transfer a batch of ERC-1155 tokens from one\n *      address to another.\n */\nstruct ConduitBatch1155Transfer {\n    address token;\n    address from;\n    address to;\n    uint256[] ids;\n    uint256[] amounts;\n}\n"
    },
    "seaport-types/src/conduit/lib/ConduitEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum ConduitItemType {\n    NATIVE, // unused\n    ERC20,\n    ERC721,\n    ERC1155\n}\n"
    },
    "seaport-types/src/helpers/TransferHelperStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ConduitItemType } from \"../conduit/lib/ConduitEnums.sol\";\n\n/**\n * @dev A TransferHelperItem specifies the itemType (ERC20/ERC721/ERC1155),\n *      token address, token identifier, and amount of the token to be\n *      transferred via the TransferHelper. For ERC20 tokens, identifier\n *      must be 0. For ERC721 tokens, amount must be 1.\n */\nstruct TransferHelperItem {\n    ConduitItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A TransferHelperItemsWithRecipient specifies the tokens to transfer\n *      via the TransferHelper, their intended recipient, and a boolean flag\n *      indicating whether onERC721Received should be called on a recipient\n *      contract.\n */\nstruct TransferHelperItemsWithRecipient {\n    TransferHelperItem[] items;\n    address recipient;\n    bool validateERC721Receiver;\n}\n"
    },
    "seaport-types/src/interfaces/TransferHelperInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    TransferHelperItemsWithRecipient\n} from \"../helpers/TransferHelperStructs.sol\";\n\ninterface TransferHelperInterface {\n    /**\n     * @notice Transfer multiple items to a single recipient.\n     *\n     * @param items The items to transfer.\n     * @param conduitKey  The key of the conduit performing the bulk transfer.\n     */\n    function bulkTransfer(\n        TransferHelperItemsWithRecipient[] calldata items,\n        bytes32 conduitKey\n    ) external returns (bytes4);\n}\n"
    },
    "seaport-types/src/interfaces/ConduitInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ConduitBatch1155Transfer,\n    ConduitTransfer\n} from \"../conduit/lib/ConduitStructs.sol\";\n\n/**\n * @title ConduitInterface\n * @author 0age\n * @notice ConduitInterface contains all external function interfaces, events,\n *         and errors for conduit contracts.\n */\ninterface ConduitInterface {\n    /**\n     * @dev Revert with an error when attempting to execute transfers using a\n     *      caller that does not have an open channel.\n     */\n    error ChannelClosed(address channel);\n\n    /**\n     * @dev Revert with an error when attempting to update a channel to the\n     *      current status of that channel.\n     */\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\n\n    /**\n     * @dev Revert with an error when attempting to execute a transfer for an\n     *      item that does not have an ERC20/721/1155 item type.\n     */\n    error InvalidItemType();\n\n    /**\n     * @dev Revert with an error when attempting to update the status of a\n     *      channel from a caller that is not the conduit controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Emit an event whenever a channel is opened or closed.\n     *\n     * @param channel The channel that has been updated.\n     * @param open    A boolean indicating whether the conduit is open or not.\n     */\n    event ChannelUpdated(address indexed channel, bool open);\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(\n        ConduitTransfer[] calldata transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external;\n}\n"
    },
    "seaport-types/src/interfaces/TransferHelperErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title TransferHelperErrors\n */\ninterface TransferHelperErrors {\n    /**\n     * @dev Revert with an error when attempting to execute transfers with a\n     *      NATIVE itemType.\n     */\n    error InvalidItemType();\n\n    /**\n     * @dev Revert with an error when an ERC721 transfer with amount other than\n     *      one is attempted.\n     *\n     * @param amount The amount of the ERC721 tokens to transfer.\n     */\n    error InvalidERC721TransferAmount(uint256 amount);\n\n    /**\n     * @dev Revert with an error when attempting to execute an ERC721 transfer\n     *      to an invalid recipient.\n     */\n    error InvalidERC721Recipient(address recipient);\n\n    /**\n     * @dev Revert with an error when a call to an ERC721 receiver reverts with\n     *      bytes data.\n     */\n    error ERC721ReceiverErrorRevertBytes(\n        bytes reason,\n        address receiver,\n        address sender,\n        uint256 identifier\n    );\n\n    /**\n     * @dev Revert with an error when a call to an ERC721 receiver reverts with\n     *      string reason.\n     */\n    error ERC721ReceiverErrorRevertString(\n        string reason,\n        address receiver,\n        address sender,\n        uint256 identifier\n    );\n\n    /**\n     * @dev Revert with an error when an ERC20 token has an invalid identifier.\n     */\n    error InvalidERC20Identifier();\n\n    /**\n     * @dev Revert with an error if the recipient is the zero address.\n     */\n    error RecipientCannotBeZeroAddress();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order referencing an\n     *      invalid conduit (i.e. one that has not been deployed).\n     */\n    error InvalidConduit(bytes32 conduitKey, address conduit);\n\n    /**\n     * @dev Revert with an error when a call to a conduit reverts with a\n     *      reason string.\n     */\n    error ConduitErrorRevertString(\n        string reason,\n        bytes32 conduitKey,\n        address conduit\n    );\n\n    /**\n     * @dev Revert with an error when a call to a conduit reverts with bytes\n     *      data.\n     */\n    error ConduitErrorRevertBytes(\n        bytes reason,\n        bytes32 conduitKey,\n        address conduit\n    );\n}\n"
    },
    "seaport-types/src/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n *      from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an ERC721 token is transferred to this contract via\n     *      safeTransferFrom, this function is called.\n     *\n     * @param operator  The address of the operator.\n     * @param from      The address of the sender.\n     * @param tokenId   The ID of the ERC721.\n     * @param data      Additional data.\n     *\n     * @return bytes4 The magic value, unless throwing.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ImmutableCreate2FactoryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ImmutableCreate2FactoryInterface\n * @author 0age\n * @notice This contract provides a safeCreate2 function that takes a salt value\n *         and a block of initialization code as arguments and passes them into\n *         inline assembly. The contract prevents redeploys by maintaining a\n *         mapping of all contracts that have already been deployed, and\n *         prevents frontrunning or other collisions by requiring that the first\n *         20 bytes of the salt are equal to the address of the caller (this can\n *         be bypassed by setting the first 20 bytes to the null address). There\n *         is also a view function that computes the address of the contract\n *         that will be created when submitting a given salt or nonce along with\n *         a given block of initialization code.\n */\ninterface ImmutableCreate2FactoryInterface {\n    /**\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\n     *      along with the initialization code for the contract. Note that the\n     *      first 20 bytes of the salt must match those of the calling address,\n     *      which prevents contract creation events from being submitted by\n     *      unintended parties.\n     *\n     * @param salt               The nonce that will be passed into the CREATE2\n     *                           call.\n     * @param initializationCode The initialization code that will be passed\n     *                           into the CREATE2 call.\n     *\n     * @return deploymentAddress Address of the contract that will be created.\n     */\n    function safeCreate2(\n        bytes32 salt,\n        bytes calldata initializationCode\n    ) external payable returns (address deploymentAddress);\n\n    /**\n     * @dev Compute the address of the contract that will be created when\n     *      submitting a given salt or nonce to the contract along with the\n     *      contract's initialization code. The CREATE2 address is computed in\n     *      accordance with EIP-1014, and adheres to the formula therein of\n     *      `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]`\n     *      when performing the computation. The computed address is then\n     *      checked for any existing contract code - if so, the null address\n     *      will be returned instead.\n     *\n     * @param salt     The nonce passed into the CREATE2 address calculation.\n     * @param initCode The contract initialization code to be used that will be\n     *                 passed into the CREATE2 address calculation.\n     *\n     * @return deploymentAddress Address of the contract that will be created,\n     *                           or the null address if a contract already\n     *                           exists at that address.\n     */\n    function findCreate2Address(\n        bytes32 salt,\n        bytes calldata initCode\n    ) external view returns (address deploymentAddress);\n\n    /**\n     * @dev Compute the address of the contract that will be created when\n     *      submitting a given salt or nonce to the contract along with the\n     *      keccak256 hash of the contract's initialization code. The CREATE2\n     *      address is computed in accordance with EIP-1014, and adheres to the\n     *      `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]`\n     *      formula when performing the computation. The computed address is\n     *      then checked for any existing contract code - if so, the null\n     *      address will be returned instead.\n     *\n     * @param salt         The nonce passed into the CREATE2 address\n     *                     calculation.\n     * @param initCodeHash The keccak256 hash of the initialization code that\n     *                     will be passed into the CREATE2 address calculation.\n     *\n     * @return deploymentAddress Address of the contract that will be created,\n     *                           or the null address if a contract already\n     *                           exists at that address.\n     */\n    function findCreate2AddressViaHash(\n        bytes32 salt,\n        bytes32 initCodeHash\n    ) external view returns (address deploymentAddress);\n\n    /**\n     * @dev Determine if a contract has already been deployed by the factory to\n     *      a given address.\n     *\n     * @param deploymentAddress The contract address to check.\n     *\n     * @return True if the contract has been deployed, false otherwise.\n     */\n    function hasBeenDeployed(\n        address deploymentAddress\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ZoneInteractionErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ZoneInteractionErrors\n * @author 0age\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\n */\ninterface ZoneInteractionErrors {\n    /**\n     * @dev Revert with an error when attempting to fill an order that specifies\n     *      a restricted submitter as its order type when not submitted by\n     *      either the offerer or the order's zone or approved as valid by the\n     *      zone in question via a call to `isValidOrder`.\n     *\n     * @param orderHash The order hash for the invalid restricted order.\n     */\n    error InvalidRestrictedOrder(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a contract order that\n     *      fails to generate an order successfully, that does not adhere to the\n     *      requirements for minimum spent or maximum received supplied by the\n     *      fulfiller, or that fails the post-execution `ratifyOrder` check..\n     *\n     * @param orderHash The order hash for the invalid contract order.\n     */\n    error InvalidContractOrder(bytes32 orderHash);\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 99999999
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}