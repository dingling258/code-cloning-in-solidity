{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "src/treasure/tokens/l1/MagicTIP39Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20 } from './dependencies/solidstate/token/ERC20/ERC20.sol';\nimport { OwnableInternal } from './dependencies/solidstate/accesscontrol/OwnableInternal.sol';\n\nimport { IMagicTIP39Facet } from './interfaces/IMagicTIP39Facet.sol';\n\n// This Diamond facet implements the upgraded L1 MAGIC token as ratified by the governance deicion in TIP-39.\n//\n// Link to Snapshot:\n//     https://snapshot.org/#/treasuregaming.eth/proposal/0x8331c1bba176a259c4fea705eb2f902c1a03972d112c9874502198414fc48bbd\n//\n// Namely, the adminMint(), adminTransfer(), and adminBurn() functions are removed. Implementation is consolidated\n// into this one facet.\ncontract MagicTIP39Facet is IMagicTIP39Facet, ERC20, OwnableInternal {\n    // Used to store the team's mint amount. No longer used.\n    //\n    uint256 private DEPRECATED_1;\n    // Used to store those that were whitelist. The whitelist got moved to a different storage slot.\n    // Eventually, whitelisting and minting were removed.\n    //\n    mapping(address => bool) private DEPRECATED_2;\n\n    // Old functions adminMint(), adminTransfer(), and adminBurn() have been removed.\n}\n"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/accesscontrol/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/accesscontrol/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {\n\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(address holder, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from '../IERC20.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(address holder, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][\n            msg.sender\n        ];\n        require(\n            currentAllowance >= amount,\n            'ERC20: transfer amount exceeds allowance'\n        );\n        unchecked {\n            _approve(holder, msg.sender, currentAllowance - amount);\n        }\n        _transfer(holder, recipient, amount);\n        return true;\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from '../IERC20Internal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(address account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        require(\n            holderBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base, ERC20BaseStorage } from '../base/ERC20Base.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is ERC20Base {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                allowance + amount >= allowance,\n                'ERC20Extended: excessive allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance + amount\n            );\n\n            return true;\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                amount <= allowance,\n                'ERC20Extended: insufficient allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance - amount\n            );\n\n            return true;\n        }\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\nimport { IERC20Metadata } from './IERC20Metadata.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setName(Layout storage l, string memory name) internal {\n        l.name = name;\n    }\n\n    function setSymbol(Layout storage l, string memory symbol) internal {\n        l.symbol = symbol;\n    }\n\n    function setDecimals(Layout storage l, uint8 decimals) internal {\n        l.decimals = decimals;\n    }\n}"
    },
    "src/treasure/tokens/l1/dependencies/solidstate/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "src/treasure/tokens/l1/interfaces/IMagicTIP39Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from '../dependencies/solidstate/token/ERC20/IERC20.sol';\n\ninterface IMagicTIP39Facet is IERC20 { }\n"
    }
  }
}}