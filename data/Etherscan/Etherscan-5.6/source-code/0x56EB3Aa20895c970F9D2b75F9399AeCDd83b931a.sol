{{
  "sources": {
    "IDEXV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\ninterface IDEXRouterV2 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n  function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n}\r\n\r\ninterface IDEXFactoryV2 {\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n  function getPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\ninterface IERC20 {\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address to, uint256 amount) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "CF_ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport \"./CF_Common.sol\";\r\n\r\nabstract contract CF_ERC20 is CF_Common {\r\n  string internal _name;\r\n  string internal _symbol;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function name() external view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() external view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() external view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address account) external view returns (uint256) {\r\n    return _balance[account];\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return _allowance[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool) {\r\n    _approve(msg.sender, spender, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function transfer(address to, uint256 amount) external returns (bool) {\r\n    _transfer(msg.sender, to, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 amount) external returns (bool) {\r\n    _spendAllowance(from, msg.sender, amount);\r\n    _transfer(from, to, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n    unchecked {\r\n      _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n    uint256 currentAllowance = allowance(msg.sender, spender);\r\n\r\n    require(currentAllowance >= subtractedValue, \"Negative allowance\");\r\n\r\n    unchecked {\r\n      _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    _allowance[owner][spender] = amount;\r\n\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n\r\n    require(currentAllowance >= amount, \"Insufficient allowance\");\r\n\r\n    unchecked {\r\n      _approve(owner, spender, currentAllowance - amount);\r\n    }\r\n  }\r\n\r\n  function _transfer(address from, address to, uint256 amount) internal virtual {\r\n    require(from != address(0) && to != address(0), \"Transfer from/to zero address\");\r\n    require(_balance[from] >= amount, \"Exceeds balance\");\r\n\r\n    if (amount > 0) {\r\n      unchecked {\r\n        _balance[from] -= amount;\r\n        _balance[to] += amount;\r\n      }\r\n    }\r\n\r\n    emit Transfer(from, to, amount);\r\n  }\r\n}\r\n"
    },
    "CF_Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport \"./IDEXV2.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\nabstract contract CF_Common {\r\n  string internal constant _version = \"1.0.3\";\r\n\r\n  mapping(address => uint256) internal _balance;\r\n  mapping(address => mapping(address => uint256)) internal _allowance;\r\n  mapping(address => holderAccount) internal _holder;\r\n  mapping(uint8 => taxBeneficiary) internal _taxBeneficiary;\r\n  mapping(address => uint256) internal _tokensForTaxDistribution;\r\n\r\n  address[] internal _holders;\r\n\r\n  bool internal _autoSwapEnabled;\r\n  bool internal _swapping;\r\n  bool internal _suspendTaxes;\r\n  bool internal _distributing;\r\n  bool internal immutable _initialized;\r\n\r\n  uint8 internal immutable _decimals;\r\n  uint24 internal constant _denominator = 1000;\r\n  uint24 internal _totalTxTax;\r\n  uint24 internal _totalBuyTax;\r\n  uint24 internal _totalSellTax;\r\n  uint24 internal _totalPenaltyTxTax;\r\n  uint24 internal _totalPenaltyBuyTax;\r\n  uint24 internal _totalPenaltySellTax;\r\n  uint24 internal _minAutoSwapPercent;\r\n  uint24 internal _maxAutoSwapPercent;\r\n  uint24 internal _minAutoAddLiquidityPercent;\r\n  uint24 internal _maxAutoAddLiquidityPercent;\r\n  uint32 internal _lastTaxDistribution;\r\n  uint32 internal _tradingEnabled;\r\n  uint32 internal _lastSwap;\r\n  uint32 internal _earlyPenaltyTime;\r\n  uint256 internal _totalSupply;\r\n  uint256 internal _totalBurned;\r\n  uint256 internal _minAutoSwapAmount;\r\n  uint256 internal _maxAutoSwapAmount;\r\n  uint256 internal _minAutoAddLiquidityAmount;\r\n  uint256 internal _maxAutoAddLiquidityAmount;\r\n  uint256 internal _amountForLiquidity;\r\n  uint256 internal _ethForLiquidity;\r\n  uint256 internal _totalTaxCollected;\r\n  uint256 internal _totalTaxUnclaimed;\r\n  uint256 internal _amountForTaxDistribution;\r\n  uint256 internal _amountSwappedForTaxDistribution;\r\n  uint256 internal _ethForTaxDistribution;\r\n\r\n  struct Renounced {\r\n    bool Taxable;\r\n    bool DEXRouterV2;\r\n  }\r\n\r\n  struct holderAccount {\r\n    bool exists;\r\n    bool penalty;\r\n  }\r\n\r\n  struct taxBeneficiary {\r\n    bool exists;\r\n    address account;\r\n    uint24[3] percent; // 0: tx, 1: buy, 2: sell\r\n    uint24[3] penalty;\r\n    uint256 unclaimed;\r\n  }\r\n\r\n  struct DEXRouterV2 {\r\n    address router;\r\n    address pair;\r\n    address token0;\r\n    address WETH;\r\n    address receiver;\r\n  }\r\n\r\n  Renounced internal _renounced;\r\n  IERC20 internal _taxToken;\r\n  DEXRouterV2 internal _dex;\r\n\r\n  function _percentage(uint256 amount, uint256 bps) internal pure returns (uint256) {\r\n    unchecked {\r\n      return (amount * bps) / (100 * uint256(_denominator));\r\n    }\r\n  }\r\n\r\n  function _timestamp() internal view returns (uint32) {\r\n    unchecked {\r\n      return uint32(block.timestamp % 2**32);\r\n    }\r\n  }\r\n\r\n  function denominator() external pure returns (uint24) {\r\n    return _denominator;\r\n  }\r\n\r\n  function version() external pure returns (string memory) {\r\n    return _version;\r\n  }\r\n}\r\n"
    },
    "CF_Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\nimport \"./CF_Common.sol\";\r\n\r\npragma solidity 0.8.25;\r\n\r\nabstract contract CF_Ownable is CF_Common {\r\n  address internal _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == msg.sender, \"Unauthorized\");\r\n\r\n    _;\r\n  }\r\n\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  function renounceOwnership() external onlyOwner {\r\n    _renounced.Taxable = true;\r\n    _renounced.DEXRouterV2 = true;\r\n\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(newOwner != address(0));\r\n\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n"
    },
    "CF_Taxable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport \"./CF_Common.sol\";\r\nimport \"./CF_Ownable.sol\";\r\nimport \"./CF_ERC20.sol\";\r\n\r\nabstract contract CF_Taxable is CF_Common, CF_Ownable, CF_ERC20 {\r\n  event SetTaxBeneficiary(uint8 slot, address account, uint24[3] percent, uint24[3] penalty);\r\n  event SetEarlyPenaltyTime(uint32 time);\r\n  event TaxDistributed(uint256 amount);\r\n  event RenouncedTaxable();\r\n\r\n  struct taxBeneficiaryView {\r\n    address account;\r\n    uint24[3] percent;\r\n    uint24[3] penalty;\r\n    uint256 unclaimed;\r\n  }\r\n\r\n  modifier lockDistributing {\r\n    _distributing = true;\r\n    _;\r\n    _distributing = false;\r\n  }\r\n\r\n  /// @notice Permanently renounce and prevent the owner from being able to update the tax features\r\n  /// @dev Existing settings will continue to be effective\r\n  function renounceTaxable() external onlyOwner {\r\n    _renounced.Taxable = true;\r\n\r\n    emit RenouncedTaxable();\r\n  }\r\n\r\n  /// @notice Total amount of taxes collected so far\r\n  function totalTaxCollected() external view returns (uint256) {\r\n    return _totalTaxCollected;\r\n  }\r\n  /// @notice Tax applied per transfer\r\n  /// @dev Taking in consideration your wallet address\r\n  function txTax() external view returns (uint24) {\r\n    return txTax(msg.sender);\r\n  }\r\n\r\n  /// @notice Tax applied per transfer\r\n  /// @param from Sender address\r\n  function txTax(address from) public view returns (uint24) {\r\n    unchecked {\r\n      return from == address(this) || from == _dex.pair ? 0 : (_holder[from].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltyTxTax : _totalTxTax);\r\n    }\r\n  }\r\n\r\n  /// @notice Tax applied for buying\r\n  /// @dev Taking in consideration your wallet address\r\n  function buyTax() external view returns (uint24) {\r\n    return buyTax(msg.sender);\r\n  }\r\n\r\n  /// @notice Tax applied for buying\r\n  /// @param from Buyer's address\r\n  function buyTax(address from) public view returns (uint24) {\r\n    if (_suspendTaxes) { return 0; }\r\n\r\n    unchecked {\r\n      return from == address(this) || from == _dex.pair ? 0 : (_holder[from].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltyBuyTax : _totalBuyTax);\r\n    }\r\n  }\r\n  /// @notice Tax applied for selling\r\n  /// @dev Taking in consideration your wallet address\r\n  function sellTax() external view returns (uint24) {\r\n    return sellTax(msg.sender);\r\n  }\r\n\r\n  /// @notice Tax applied for selling\r\n  /// @param to Seller's address\r\n  function sellTax(address to) public view returns (uint24) {\r\n    if (_suspendTaxes) { return 0; }\r\n\r\n    unchecked {\r\n      return to == address(this) || to == _owner || to == _dex.pair || to == _dex.router ? 0 : (_holder[to].penalty || _tradingEnabled + _earlyPenaltyTime >= _timestamp() ? _totalPenaltySellTax : _totalSellTax);\r\n    }\r\n  }\r\n\r\n  /// @notice List of all tax beneficiaries and their assigned percentage, according to type of transfer\r\n  /// @custom:return `list[].account` Beneficiary address\r\n  /// @custom:return `list[].percent[3]` Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\r\n  /// @custom:return `list[].penalty[3]` Index 0 is for tx penalty, 1 is for buy penalty, 2 is for sell penalty, multiplied by denominator\r\n  function listTaxBeneficiaries() external view returns (taxBeneficiaryView[] memory list) {\r\n    list = new taxBeneficiaryView[](6);\r\n\r\n    unchecked {\r\n      for (uint8 i; i < 6; i++) { list[i] = taxBeneficiaryView(_taxBeneficiary[i].account, _taxBeneficiary[i].percent, _taxBeneficiary[i].penalty, _taxBeneficiary[i].unclaimed); }\r\n    }\r\n  }\r\n\r\n  /// @notice Sets a tax beneficiary\r\n  /// @dev Maximum of 5 wallets can be assigned\r\n  /// @dev Slot 0 is reserved for ChainFactory revenue\r\n  /// @param slot Slot number (1 to 5)\r\n  /// @param account Beneficiary address\r\n  /// @param percent[3] Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\r\n  /// @param penalty[3] Index 0 is for tx penalty, 1 is for buy penalty, 2 is for sell penalty, multiplied by denominator\r\n  function setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent, uint24[3] memory penalty) external onlyOwner {\r\n    require(!_renounced.Taxable);\r\n    require(slot >= 1 && slot <= 5, \"Reserved\");\r\n\r\n    _setTaxBeneficiary(slot, account, percent, penalty);\r\n  }\r\n\r\n  function _setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent, uint24[3] memory penalty) internal {\r\n    require(slot <= 5);\r\n    require(account != address(this) && account != address(0));\r\n\r\n    taxBeneficiary storage taxBeneficiarySlot = _taxBeneficiary[slot];\r\n\r\n    if (slot > 0 && account == address(0xdEaD) && taxBeneficiarySlot.unclaimed > 0) { revert(\"Unclaimed taxes\"); }\r\n\r\n    unchecked {\r\n      _totalTxTax += percent[0] - taxBeneficiarySlot.percent[0];\r\n      _totalBuyTax += percent[1] - taxBeneficiarySlot.percent[1];\r\n      _totalSellTax += percent[2] - taxBeneficiarySlot.percent[2];\r\n      _totalPenaltyTxTax += penalty[0] - taxBeneficiarySlot.penalty[0];\r\n      _totalPenaltyBuyTax += penalty[1] - taxBeneficiarySlot.penalty[1];\r\n      _totalPenaltySellTax += penalty[2] - taxBeneficiarySlot.penalty[2];\r\n\r\n      require(_totalTxTax <= 25 * _denominator && ((_totalBuyTax <= 25 * _denominator && _totalSellTax <= 25 * _denominator) && (_totalBuyTax + _totalSellTax <= 25 * _denominator)), \"High Tax\");\r\n      require(_totalPenaltyTxTax <= 90 * _denominator && _totalPenaltyBuyTax <= 90 * _denominator && _totalPenaltySellTax <= 90 * _denominator, \"Invalid Penalty\");\r\n\r\n      taxBeneficiarySlot.account = account;\r\n      taxBeneficiarySlot.percent = percent;\r\n\r\n      if (_initialized && slot > 0) { _setTaxBeneficiary(0, _taxBeneficiary[0].account, [ uint24(0), uint24(0), uint24(0) ], [ _taxBeneficiary[0].penalty[0] + uint24((penalty[0] * 10 / 100) - (taxBeneficiarySlot.penalty[0] * 10 / 100)), _taxBeneficiary[0].penalty[1] + uint24((penalty[1] * 10 / 100) - (taxBeneficiarySlot.penalty[1] * 10 / 100)), _taxBeneficiary[0].penalty[2] + uint24((penalty[2] * 10 / 100) - (taxBeneficiarySlot.penalty[2] * 10 / 100)) ]); }\r\n\r\n      taxBeneficiarySlot.penalty = penalty;\r\n    }\r\n\r\n    if (!taxBeneficiarySlot.exists) { taxBeneficiarySlot.exists = true; }\r\n\r\n    emit SetTaxBeneficiary(slot, account, percent, penalty);\r\n  }\r\n\r\n  /// @notice Triggers the tax distribution\r\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution\r\n  function autoTaxDistribute() external onlyOwner {\r\n    require(!_swapping && !_distributing);\r\n\r\n    _autoTaxDistribute();\r\n  }\r\n\r\n  function _autoTaxDistribute() internal lockDistributing {\r\n    if (_totalTaxUnclaimed == 0) { return; }\r\n\r\n    unchecked {\r\n      uint256 distributedTaxes;\r\n\r\n      for (uint8 i; i < 6; i++) {\r\n        taxBeneficiary storage taxBeneficiarySlot = _taxBeneficiary[i];\r\n        address account = taxBeneficiarySlot.account;\r\n\r\n        if (taxBeneficiarySlot.unclaimed == 0 || account == address(0xdEaD) || account == _dex.pair) { continue; }\r\n\r\n        uint256 unclaimed = _percentage(address(_taxToken) == address(this) ? _amountForTaxDistribution : _amountSwappedForTaxDistribution, (100 * uint256(_denominator) * taxBeneficiarySlot.unclaimed) / _totalTaxUnclaimed);\r\n        uint256 _distributedTaxes = _distribute(account, unclaimed);\r\n\r\n        if (_distributedTaxes > 0) {\r\n          taxBeneficiarySlot.unclaimed -= _distributedTaxes;\r\n          distributedTaxes += _distributedTaxes;\r\n        }\r\n      }\r\n\r\n      _lastTaxDistribution = _timestamp();\r\n\r\n      if (distributedTaxes > 0) {\r\n        _totalTaxUnclaimed -= distributedTaxes;\r\n\r\n        emit TaxDistributed(distributedTaxes);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _distribute(address account, uint256 unclaimed) private returns (uint256) {\r\n    if (unclaimed == 0) { return 0; }\r\n\r\n    unchecked {\r\n      if (address(_taxToken) == address(this)) {\r\n        super._transfer(address(this), account, unclaimed);\r\n\r\n        _amountForTaxDistribution -= unclaimed;\r\n      } else {\r\n        uint256 percent = (100 * uint256(_denominator) * unclaimed) / _amountSwappedForTaxDistribution;\r\n        uint256 amount;\r\n\r\n        if (address(_taxToken) == _dex.WETH) {\r\n          amount = _percentage(_ethForTaxDistribution, percent);\r\n\r\n          (bool success, ) = payable(account).call{ value: amount, gas: 30000 }(\"\");\r\n\r\n          if (!success) { return 0; }\r\n\r\n          _ethForTaxDistribution -= amount;\r\n        } else {\r\n          amount = _percentage(_tokensForTaxDistribution[address(_taxToken)], percent);\r\n\r\n          try _taxToken.transfer(account, amount) { _tokensForTaxDistribution[address(_taxToken)] -= amount; } catch { return 0; }\r\n        }\r\n\r\n        _amountSwappedForTaxDistribution -= unclaimed;\r\n      }\r\n    }\r\n\r\n    return unclaimed;\r\n  }\r\n\r\n  /// @notice Suspend or reinstate tax collection\r\n  /// @dev Also applies to early penalties\r\n  /// @param status True to suspend, False to reinstate existent taxes\r\n  function suspendTaxes(bool status) external onlyOwner {\r\n    require(!_renounced.Taxable);\r\n\r\n    _suspendTaxes = status;\r\n  }\r\n\r\n  /// @notice Checks if tax collection is currently suspended\r\n  function taxesSuspended() external view returns (bool) {\r\n    return _suspendTaxes;\r\n  }\r\n\r\n  /// @notice Removes the penalty status of a wallet\r\n  /// @param account Address to depenalize\r\n  function removePenalty(address account) external onlyOwner {\r\n    require(!_renounced.Taxable);\r\n\r\n    _holder[account].penalty = false;\r\n  }\r\n\r\n  /// @notice Check if a wallet is penalized due to an early transaction\r\n  /// @param account Address to check\r\n  function isPenalized(address account) external view returns (bool) {\r\n    return _holder[account].penalty;\r\n  }\r\n\r\n  /// @notice Returns the period of time during which early buyers will be penalized from the time trading was enabled\r\n  function getEarlyPenaltyTime() external view returns (uint32) {\r\n    return _earlyPenaltyTime;\r\n  }\r\n\r\n  /// @notice Defines the period of time during which early buyers will be penalized from the time trading was enabled\r\n  /// @dev Must be less or equal to 1 hour\r\n  /// @param time Time, in seconds\r\n  function setEarlyPenaltyTime(uint32 time) external onlyOwner {\r\n    require(!_renounced.Taxable);\r\n    require(time <= 600);\r\n\r\n    _setEarlyPenaltyTime(time);\r\n  }\r\n\r\n  function _setEarlyPenaltyTime(uint32 time) internal {\r\n    _earlyPenaltyTime = time;\r\n\r\n    emit SetEarlyPenaltyTime(time);\r\n  }\r\n}\r\n"
    },
    "CF_Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport \"./CF_Common.sol\";\r\nimport \"./CF_ERC20.sol\";\r\n\r\nabstract contract CF_Burnable is CF_Common, CF_ERC20 {\r\n  /// @notice Total amount of tokens burned so far\r\n  function totalBurned() external view returns (uint256) {\r\n    return _totalBurned;\r\n  }\r\n\r\n  function burn(uint256 amount) external {\r\n    _burn(msg.sender, amount);\r\n  }\r\n\r\n  function burnFrom(address account, uint256 amount) external {\r\n    _spendAllowance(account, msg.sender, amount);\r\n    _burn(account, amount);\r\n  }\r\n\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(_balance[account] >= amount, \"Exceeds balance\");\r\n\r\n    unchecked {\r\n      _balance[account] -= amount;\r\n      _totalSupply -= amount;\r\n      _totalBurned += amount;\r\n    }\r\n\r\n    emit Transfer(account, address(0xdEaD), amount);\r\n  }\r\n}\r\n"
    },
    "CF_DEXRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport \"./CF_Common.sol\";\r\nimport \"./CF_Ownable.sol\";\r\nimport \"./CF_ERC20.sol\";\r\n\r\nabstract contract CF_DEXRouterV2 is CF_Common, CF_Ownable, CF_ERC20 {\r\n  event AddedLiquidity(uint256 tokenAmount, uint256 ethAmount, uint256 liquidity);\r\n  event SwappedTokensForNative(uint256 tokenAmount, uint256 ethAmount);\r\n  event SwappedTokensForTokens(address token, uint256 token0Amount, uint256 token1Amount);\r\n  event SetDEXRouterV2(address indexed router, address indexed pair);\r\n  event TradingEnabled();\r\n  event RenouncedDEXRouterV2();\r\n\r\n  modifier lockSwapping {\r\n    _swapping = true;\r\n    _;\r\n    _swapping = false;\r\n  }\r\n\r\n  /// @notice Permanently renounce and prevent the owner from being able to update the DEX features\r\n  /// @dev Existing settings will continue to be effective\r\n  function renounceDEXRouterV2() external onlyOwner {\r\n    _renounced.DEXRouterV2 = true;\r\n\r\n    emit RenouncedDEXRouterV2();\r\n  }\r\n\r\n  function _setDEXRouterV2(address router, address token0, address receiver) internal {\r\n    IDEXRouterV2 _router = IDEXRouterV2(router);\r\n    IDEXFactoryV2 factory = IDEXFactoryV2(_router.factory());\r\n    address pair = factory.createPair(address(this), token0);\r\n\r\n    _dex = DEXRouterV2(router, pair, token0, _router.WETH(), receiver);\r\n\r\n    emit SetDEXRouterV2(router, _dex.pair);\r\n  }\r\n\r\n  /// @notice Returns the DEX router currently in use\r\n  function getDEXRouterV2() external view returns (address) {\r\n    return _dex.router;\r\n  }\r\n\r\n  /// @notice Returns the trading pair\r\n  function getDEXPairV2() external view returns (address) {\r\n    return _dex.pair;\r\n  }\r\n\r\n  /// @notice Checks whether the token can be traded through the assigned DEX\r\n  function isTradingEnabled() external view returns (bool) {\r\n    return _tradingEnabled > 0;\r\n  }\r\n\r\n  /// @notice Returns address of the LP tokens receiver\r\n  /// @dev Used for automated liquidity injection through taxes\r\n  function getDEXLPTokenReceiver() external view returns (address) {\r\n    return _dex.receiver;\r\n  }\r\n\r\n  /// @notice Set the address of the LP tokens receiver\r\n  /// @dev Used for automated liquidity injection through taxes\r\n  function setDEXLPTokenReceiver(address receiver) external onlyOwner {\r\n    _setDEXLPTokenReceiver(receiver);\r\n  }\r\n\r\n  function _setDEXLPTokenReceiver(address receiver) internal {\r\n    _dex.receiver = receiver;\r\n  }\r\n\r\n  /// @notice Checks the status of the auto-swapping feature\r\n  function isAutoSwapEnabled() external view returns (bool) {\r\n    return _autoSwapEnabled;\r\n  }\r\n\r\n  /// @notice Returns the percentage range of the total supply over which the auto-swap will operate when accumulating taxes in the contract balance\r\n  function getAutoSwapPercent() external view returns (uint24 min, uint24 max) {\r\n    return (_minAutoSwapPercent, _maxAutoSwapPercent);\r\n  }\r\n\r\n  /// @notice Sets the percentage range of the total supply over which the auto-swap will operate when accumulating taxes in the contract balance\r\n  /// @param min Desired min. percentage to trigger the auto-swap, multiplied by denominator (0.001% to 1% of total supply)\r\n  /// @param max Desired max. percentage to limit the auto-swap, multiplied by denominator (0.001% to 1% of total supply)\r\n  function setAutoSwapPercent(uint24 min, uint24 max) external onlyOwner {\r\n    require(!_renounced.DEXRouterV2);\r\n    require(min >= 1 && min <= 1000, \"0.001% to 1%\");\r\n    require(max >= min && max <= 1000, \"0.001% to 1%\");\r\n\r\n    _setAutoSwapPercent(min, max);\r\n  }\r\n\r\n  function _setAutoSwapPercent(uint24 min, uint24 max) internal {\r\n    _minAutoSwapPercent = min;\r\n    _maxAutoSwapPercent = max;\r\n    _minAutoSwapAmount = _percentage(_totalSupply, uint256(min));\r\n    _maxAutoSwapAmount = _percentage(_totalSupply, uint256(max));\r\n  }\r\n\r\n  /// @notice Enables or disables the auto-swap function\r\n  /// @param status True to enable, False to disable\r\n  function enableAutoSwap(bool status) external onlyOwner {\r\n    require(!_renounced.DEXRouterV2);\r\n    require(!status || _dex.router != address(0), \"No DEX\");\r\n\r\n    _autoSwapEnabled = status;\r\n  }\r\n\r\n  /// @notice Swaps the assigned amount to inject liquidity and prepare collected taxes for its distribution\r\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution and the min. threshold has been reached\r\n  function autoSwap() external {\r\n    require(_autoSwapEnabled && !_swapping && !_distributing);\r\n\r\n    _autoSwap(false);\r\n  }\r\n\r\n  /// @notice Swaps the assigned amount to inject liquidity and prepare collected taxes for its distribution\r\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution and the min. threshold has been reached unless forced\r\n  /// @param force Ignore the min. and max. threshold amount\r\n  function autoSwap(bool force) external onlyOwner {\r\n    require((force || _autoSwapEnabled) && !_swapping && !_distributing);\r\n\r\n    _autoSwap(force);\r\n  }\r\n\r\n  function _autoSwap(bool force) internal lockSwapping {\r\n    if (!force && !_autoSwapEnabled) { return; }\r\n\r\n    unchecked {\r\n      uint256 amountForLiquidityToSwap = _amountForLiquidity > 0 ? _amountForLiquidity / 2 : 0;\r\n      uint256 amountForTaxDistributionToSwap = (address(_taxToken) == _dex.WETH ? _amountForTaxDistribution : 0);\r\n      uint256 amountToSwap = amountForTaxDistributionToSwap + amountForLiquidityToSwap;\r\n\r\n      if (!force && amountToSwap > _maxAutoSwapAmount) {\r\n        amountForLiquidityToSwap = amountForLiquidityToSwap > 0 ? _percentage(_maxAutoSwapAmount, (100 * uint256(_denominator) * amountForLiquidityToSwap) / amountToSwap) : 0;\r\n        amountForTaxDistributionToSwap = amountForTaxDistributionToSwap > 0 ? _percentage(_maxAutoSwapAmount, (100 * uint256(_denominator) * amountForTaxDistributionToSwap) / amountToSwap) : 0;\r\n        amountToSwap = amountForTaxDistributionToSwap + amountForLiquidityToSwap;\r\n      }\r\n\r\n      if ((force || amountToSwap >= _minAutoSwapAmount) && _balance[address(this)] >= amountToSwap + amountForLiquidityToSwap) {\r\n        uint256 ethBalance = address(this).balance;\r\n        address[] memory pathToSwapExactTokensForNative = new address[](2);\r\n        pathToSwapExactTokensForNative[0] = address(this);\r\n        pathToSwapExactTokensForNative[1] = _dex.WETH;\r\n\r\n        _approve(address(this), _dex.router, amountToSwap);\r\n\r\n        try IDEXRouterV2(_dex.router).swapExactTokensForETHSupportingFeeOnTransferTokens(amountToSwap, 0, pathToSwapExactTokensForNative, address(this), block.timestamp) {\r\n          if (_amountForLiquidity > 0) { _amountForLiquidity -= amountForLiquidityToSwap; }\r\n\r\n          uint256 ethAmount = address(this).balance - ethBalance;\r\n\r\n          emit SwappedTokensForNative(amountToSwap, ethAmount);\r\n\r\n          if (ethAmount > 0) {\r\n            _ethForLiquidity += _percentage(ethAmount, (100 * uint256(_denominator) * amountForLiquidityToSwap) / amountToSwap);\r\n\r\n            if (address(_taxToken) == _dex.WETH) {\r\n              _ethForTaxDistribution += _percentage(ethAmount, (100 * uint256(_denominator) * amountForTaxDistributionToSwap) / amountToSwap);\r\n              _amountSwappedForTaxDistribution += amountForTaxDistributionToSwap;\r\n              _amountForTaxDistribution -= amountForTaxDistributionToSwap;\r\n            }\r\n          }\r\n        } catch {\r\n          _approve(address(this), _dex.router, 0);\r\n        }\r\n      }\r\n\r\n      if (address(_taxToken) != address(this) && address(_taxToken) != _dex.WETH) {\r\n        amountForTaxDistributionToSwap = _amountForTaxDistribution;\r\n\r\n        if (!force && amountForTaxDistributionToSwap > _maxAutoSwapAmount) { amountForTaxDistributionToSwap = _maxAutoSwapAmount; }\r\n\r\n        if ((force || amountForTaxDistributionToSwap >= _minAutoSwapAmount) && _balance[address(this)] >= amountForTaxDistributionToSwap) {\r\n          uint256 tokenAmount = _swapTokensForTokens(_taxToken, amountForTaxDistributionToSwap);\r\n\r\n          if (tokenAmount > 0) {\r\n            _tokensForTaxDistribution[address(_taxToken)] += tokenAmount;\r\n            _amountSwappedForTaxDistribution += amountForTaxDistributionToSwap;\r\n            _amountForTaxDistribution -= amountForTaxDistributionToSwap;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    _addLiquidity(force);\r\n    _lastSwap = _timestamp();\r\n  }\r\n\r\n  function _swapTokensForTokens(IERC20 token, uint256 amount) private returns (uint256 tokenAmount) {\r\n    uint256 tokenBalance = token.balanceOf(address(this));\r\n    address[] memory pathToSwapExactTokensForTokens = new address[](3);\r\n    pathToSwapExactTokensForTokens[0] = address(this);\r\n    pathToSwapExactTokensForTokens[1] = _dex.WETH;\r\n    pathToSwapExactTokensForTokens[2] = address(token);\r\n\r\n    _approve(address(this), _dex.router, amount);\r\n\r\n    try IDEXRouterV2(_dex.router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, pathToSwapExactTokensForTokens, address(this), block.timestamp) {\r\n      tokenAmount = token.balanceOf(address(this)) - tokenBalance;\r\n\r\n      emit SwappedTokensForTokens(address(token), amount, tokenAmount);\r\n    } catch {\r\n      _approve(address(this), _dex.router, 0);\r\n    }\r\n  }\r\n\r\n  function _addLiquidity(bool force) private {\r\n    if (!force && (_amountForLiquidity < _minAutoAddLiquidityAmount || _ethForLiquidity == 0)) { return; }\r\n\r\n    unchecked {\r\n      uint256 amountForLiquidityToAdd = !force && _amountForLiquidity > _maxAutoAddLiquidityAmount ? _maxAutoAddLiquidityAmount : _amountForLiquidity;\r\n      uint256 ethForLiquidityToAdd = !force && _amountForLiquidity > _maxAutoAddLiquidityAmount ? _percentage(_ethForLiquidity, 100 * uint256(_denominator) * (_maxAutoAddLiquidityAmount / _amountForLiquidity)) : _ethForLiquidity;\r\n\r\n      _approve(address(this), _dex.router, amountForLiquidityToAdd);\r\n\r\n      try IDEXRouterV2(_dex.router).addLiquidityETH{ value: ethForLiquidityToAdd }(address(this), amountForLiquidityToAdd, 0, 0, _dex.receiver, block.timestamp) returns (uint256 tokenAmount, uint256 ethAmount, uint256 liquidity) {\r\n        emit AddedLiquidity(tokenAmount, ethAmount, liquidity);\r\n\r\n        _amountForLiquidity -= amountForLiquidityToAdd;\r\n        _ethForLiquidity -= ethForLiquidityToAdd;\r\n      } catch {\r\n        _approve(address(this), _dex.router, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Returns the percentage range of the total supply over which the auto add liquidity will operate when accumulating taxes in the contract balance\r\n  /// @dev Applies only if a Tax Beneficiary is the liquidity pool\r\n  function getAutoAddLiquidityPercent() external view returns (uint24 min, uint24 max) {\r\n    return (_minAutoAddLiquidityPercent, _maxAutoAddLiquidityPercent);\r\n  }\r\n\r\n  /// @notice Sets the percentage range of the total supply over which the auto add liquidity will operate when accumulating taxes in the contract balance\r\n  /// @param min Desired min. percentage to trigger the auto add liquidity, multiplied by denominator (0.01% to 100% of total supply)\r\n  /// @param max Desired max. percentage to limit the auto add liquidity, multiplied by denominator (0.01% to 100% of total supply)\r\n  function setAutoAddLiquidityPercent(uint24 min, uint24 max) external onlyOwner {\r\n    require(!_renounced.DEXRouterV2);\r\n    require(min >= 10 && min <= 100 * _denominator, \"0.01% to 100%\");\r\n    require(max >= min && max <= 100 * _denominator, \"0.01% to 100%\");\r\n\r\n    _setAutoAddLiquidityPercent(min, max);\r\n  }\r\n\r\n  function _setAutoAddLiquidityPercent(uint24 min, uint24 max) internal {\r\n    _minAutoAddLiquidityPercent = min;\r\n    _maxAutoAddLiquidityPercent = max;\r\n    _minAutoAddLiquidityAmount = _percentage(_totalSupply, uint256(min));\r\n    _maxAutoAddLiquidityAmount = _percentage(_totalSupply, uint256(max));\r\n  }\r\n\r\n  /// @notice Returns the token for tax distribution\r\n  function getTaxToken() external view returns (address) {\r\n    return address(_taxToken);\r\n  }\r\n\r\n  function _setTaxToken(address token) internal {\r\n    require((!_initialized && token == address(0)) || token == address(this) || token == _dex.WETH || IDEXFactoryV2(IDEXRouterV2(_dex.router).factory()).getPair(_dex.WETH, token) != address(0), \"No Pair\");\r\n\r\n    _taxToken = IERC20(token == address(0) ? address(this) : token);\r\n  }\r\n\r\n  /// @notice Enables the trading capability via the DEX set up\r\n  /// @dev Once enabled, it cannot be reverted\r\n  function enableTrading() external onlyOwner {\r\n    require(!_renounced.DEXRouterV2);\r\n    require(_tradingEnabled == 0, \"Already enabled\");\r\n\r\n    _tradingEnabled = _timestamp();\r\n\r\n    emit TradingEnabled();\r\n  }\r\n}\r\n"
    },
    "ChainFactory_ERC20.sol": {
      "content": "/*\n\n  Wormhole0x\n\n  Wormhole0x is an underground, disturbing and WTF platform that shares premium paid content from crypto influencers for free.\n  \n  Web: https://wormhole0x.net/\n  X: https://twitter.com/Wormhole0x_ETH\n  Telegram: https://t.me/Wormhole0xChannel\n\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport \"./CF_Common.sol\";\nimport \"./CF_Ownable.sol\";\nimport \"./CF_ERC20.sol\";\nimport \"./CF_Burnable.sol\";\nimport \"./CF_Taxable.sol\";\nimport \"./CF_DEXRouterV2.sol\";\n\ncontract ChainFactory_ERC20 is CF_Common, CF_Ownable, CF_ERC20, CF_Burnable, CF_Taxable, CF_DEXRouterV2 {\n  constructor() {\n    _name = unicode\"Wormhole0x\";\n    _symbol = unicode\"WORMX\";\n    _decimals = 18;\n    _totalSupply = 100000000000000000000000000; // 100,000,000 WORMX\n    _transferOwnership(0xe728950F3Ba427639529E249273889f9F3354FaA);\n    _transferInitialSupply(0xe728950F3Ba427639529E249273889f9F3354FaA, 100000); // 100%\n    _setDEXRouterV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0x0000000000000000000000000000000000000000);\n    _setEarlyPenaltyTime(300); // 5min\n    _setTaxToken(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    _autoSwapEnabled = true;\n    _setAutoSwapPercent(50, 250); // 0.05% -> 0.25% of total supply\n    _setAutoAddLiquidityPercent(100, 100000); // 0.1% -> 100% of total supply\n\n    _setTaxBeneficiary(0, 0x8881d9869aC7C7840971cAac043D7f4D144Abd10, [ uint24(0), uint24(0), uint24(0) ], [ uint24(0), uint24(3000), uint24(3000) ]); // ChainFactory Anti-Sniper revenue (10%)\n    _setTaxBeneficiary(1, 0xe3e9A129e13801E2198C87Ba27b4afe342E476A3, [ uint24(0), uint24(2000), uint24(2000) ], [ uint24(0), uint24(15000), uint24(15000) ]); // Team Wallet\n    _setTaxBeneficiary(2, 0x65bfb6B5EAAC50E47Fc93A5b050da2A0C3308bFB, [ uint24(0), uint24(2000), uint24(2000) ], [ uint24(0), uint24(15000), uint24(15000) ]);\n\n    _initialized = true;\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual override {\n    if (to == address(0xdEaD)) {\n      _burn(from, amount);\n\n      return;\n    }\n\n    if (!_distributing && !_swapping && (from != _dex.pair && from != _dex.router)) {\n      _autoSwap(false);\n      _autoTaxDistribute();\n    }\n\n    if (amount > 0 && from != _owner && to != _owner && from != address(this) && to != address(this) && to != _dex.router) {\n      require((from != _dex.pair && to != _dex.pair) || ((from == _dex.pair || to == _dex.pair) && _tradingEnabled > 0), \"Trading disabled\");\n\n      unchecked {\n        if (!_suspendTaxes && !_distributing && !_swapping) {\n          uint256 appliedTax;\n          uint8 taxType;\n\n          if (from == _dex.pair || to == _dex.pair) { taxType = from == _dex.pair ? 1 : 2; }\n\n          address _account = taxType == 1 ? to : from;\n\n          if (_tradingEnabled + _earlyPenaltyTime >= _timestamp() && !_holder[_account].penalty) { _holder[_account].penalty = true; }\n\n          for (uint8 i; i < 6; i++) {\n            uint256 percent = uint256(taxType > 0 ? (taxType == 1 ? (_holder[_account].penalty ? _taxBeneficiary[i].penalty[1] : _taxBeneficiary[i].percent[1]) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[2] : _taxBeneficiary[i].percent[2])) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[0] : _taxBeneficiary[i].percent[0]));\n\n            if (percent == 0) { continue; }\n\n            uint256 taxAmount = _percentage(amount, percent);\n\n            super._transfer(from, address(this), taxAmount);\n\n            if (_taxBeneficiary[i].account == _dex.pair) {\n              _amountForLiquidity += taxAmount;\n            } else if (_taxBeneficiary[i].account == address(0xdEaD)) {\n              _burn(address(this), taxAmount);\n            } else {\n              _taxBeneficiary[i].unclaimed += taxAmount;\n              _amountForTaxDistribution += taxAmount;\n              _totalTaxUnclaimed += taxAmount;\n            }\n\n            appliedTax += taxAmount;\n          }\n\n          if (appliedTax > 0) {\n            _totalTaxCollected += appliedTax;\n\n            amount -= appliedTax;\n          }\n        }\n      }\n    }\n\n    super._transfer(from, to, amount);\n  }\n\n  function _transferInitialSupply(address account, uint24 percent) private {\n    require(!_initialized);\n\n    uint256 amount = _percentage(_totalSupply, uint256(percent));\n\n    _balance[account] = amount;\n\n    emit Transfer(address(0), account, amount);\n  }\n\n  /// @notice Returns a list specifying the renounce status of each feature\n  function renounced() external view returns (bool DEXRouterV2, bool Taxable) {\n    return (_renounced.DEXRouterV2, _renounced.Taxable);\n  }\n\n  /// @notice Returns basic information about this Smart-Contract\n  function info() external view returns (string memory name, string memory symbol, uint8 decimals, address owner, uint256 totalSupply, string memory version) {\n    return (_name, _symbol, _decimals, _owner, _totalSupply, _version);\n  }\n\n  receive() external payable { }\n  fallback() external payable { }\n}\n\n/*\n   ________          _       ______           __                  \n  / ____/ /_  ____ _(_)___  / ____/___ ______/ /_____  _______  __\n / /   / __ \\/ __ `/ / __ \\/ /_  / __ `/ ___/ __/ __ \\/ ___/ / / /\n/ /___/ / / / /_/ / / / / / __/ / /_/ / /__/ /_/ /_/ / /  / /_/ / \n\\____/_/ /_/\\__,_/_/_/ /_/_/    \\__,_/\\___/\\__/\\____/_/   \\__, /  \n                                                         /____/   \n\n  Smart-Contract generated by ChainFactory.app\n\n  By using this Smart-Contract generated by ChainFactory.app, you\n  acknowledge and agree that ChainFactory shall not be liable for\n  any damages arising from the use of this Smart-Contract,\n  including but not limited to any damages resulting from any\n  malicious or illegal use of the Smart-Contract by any third\n  party or by the owner.\n\n  The owner of the Smart-Contract generated by ChainFactory.app\n  agrees not to misuse the Smart-Contract, including but not\n  limited to:\n\n  - Using the Smart-Contract to engage in any illegal or\n    fraudulent activity, including but not limited to scams,\n    theft, or money laundering.\n\n  - Using the Smart-Contract in any manner that could cause harm\n    to others, including but not limited to disrupting financial\n    markets or causing financial loss to others.\n\n  - Using the Smart-Contract to infringe upon the intellectual\n    property rights of others, including but not limited to\n    copyright, trademark, or patent infringement.\n\n  The owner of the Smart-Contract generated by ChainFactory.app\n  acknowledges that any misuse of the Smart-Contract may result in\n  legal action, and agrees to indemnify and hold harmless\n  ChainFactory from any and all claims, damages, or expenses\n  arising from any such misuse.\n\n*/\n"
    }
  },
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "runs": 200,
      "enabled": true
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}