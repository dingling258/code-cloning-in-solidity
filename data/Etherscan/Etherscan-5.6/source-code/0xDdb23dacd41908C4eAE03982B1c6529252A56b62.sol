{{
  "language": "Solidity",
  "sources": {
    "lib/openmesh-admin/lib/ens-reverse-claimable/src/ENSReverseClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSReverseClaimable {\n    /// @notice ENS reverse name resolution is claimable by the owner of the contract.\n    function owner() external pure virtual returns (address) {\n        return 0x2309762aAcA0a8F689463a42c0A6A84BE3A7ea51; // plopmenz.eth\n    }\n}\n"
    },
    "lib/openmesh-admin/src/Openmesh.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Openmesh {\n    address constant OPENMESH_ADMIN = 0x24496D746Fd003397790E41d0d1Ce61F4F7fd61f;\n}\n"
    },
    "lib/openmesh-admin/src/OpenmeshENSReverseClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ENSReverseClaimable} from \"../lib/ens-reverse-claimable/src/ENSReverseClaimable.sol\";\nimport {Openmesh} from \"./Openmesh.sol\";\n\ncontract OpenmeshENSReverseClaimable is Openmesh, ENSReverseClaimable {\n    /// @inheritdoc ENSReverseClaimable\n    function owner() external pure override returns (address) {\n        return OPENMESH_ADMIN;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "src/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Escrow {\r\n    using SafeERC20 for IERC20;\r\n\r\n    error AlreadyInitialized();\r\n    error NotOwner();\r\n    error NativeTransferFailed();\r\n\r\n    address internal owner;\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    /// @notice Initializes the Escrow with the sender of the transaction as owner.\r\n    /// @dev This should be called in the same transaction as deploying the escrow, to prevent front running.\r\n    function __Escrow_init() public payable {\r\n        if (owner != address(0)) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of ERC20 token to a given address. Can only be called by the owner.\r\n    /// @param token The ERC20 contract address.\r\n    /// @param to The address to receive the tokens.\r\n    /// @param amount The amount of ERC20 token to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transfer(IERC20 token, address to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            token.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of native currency to a given address. Can only be called by the owner.\r\n    /// @param to The address to receive the currency.\r\n    /// @param amount The amount of native currency to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transferNative(address payable to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            // Use call instead of transfer for correct gas estimation to smart contracts\r\n            (bool success,) = to.call{value: amount}(\"\");\r\n            if (!success) {\r\n                revert NativeTransferFailed();\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "src/ITasks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Escrow, IERC20} from \"./Escrow.sol\";\r\n\r\ninterface ITasks {\r\n    error TaskDoesNotExist();\r\n    error TaskNotOpen();\r\n    error TaskNotTaken();\r\n    error TaskNotClosed();\r\n    error TaskClosed();\r\n\r\n    error NotManager();\r\n    error NotExecutor();\r\n    error NotDisputeManager();\r\n\r\n    error RewardAboveBudget();\r\n    error RewardDoesntEndWithNextToken();\r\n    error NotEnoughNativeCurrencyAttached();\r\n    error ApplicationDoesNotExist();\r\n    error NotYourApplication();\r\n    error ApplicationNotAccepted();\r\n    error SubmissionDoesNotExist();\r\n    error SubmissionAlreadyJudged();\r\n    error JudgementNone();\r\n\r\n    error RequestDoesNotExist();\r\n    error RequestAlreadyAccepted();\r\n    error RequestNotAccepted();\r\n    error RequestAlreadyExecuted();\r\n\r\n    error Overflow();\r\n    error ManualBudgetIncreaseNeeded();\r\n    error PartialRewardAboveFullReward();\r\n    error NativeTransferFailed();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    // The budget here represents the call of the funder to the escrow, the actual value in the escrow (actual budget) might differ in case of transfer fees / rewards.\r\n    event TaskCreated(\r\n        uint256 indexed taskId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        address manager,\r\n        address disputeManager,\r\n        address creator,\r\n        uint96 nativeBudget,\r\n        ERC20Transfer[] budget,\r\n        Escrow escrow\r\n    );\r\n    event ApplicationCreated(\r\n        uint256 indexed taskId,\r\n        uint32 indexed applicationId,\r\n        string metadata,\r\n        address applicant,\r\n        NativeReward[] nativeReward,\r\n        Reward[] reward\r\n    );\r\n    event ApplicationAccepted(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event TaskTaken(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event SubmissionCreated(uint256 indexed taskId, uint8 indexed submissionId, string metadata);\r\n    event SubmissionReviewed(\r\n        uint256 indexed taskId, uint8 indexed submissionId, SubmissionJudgement judgement, string feedback\r\n    );\r\n    event TaskCompleted(uint256 indexed taskId, TaskCompletionSource source);\r\n\r\n    event CancelTaskRequested(uint256 indexed taskId, uint8 indexed requestId, string metadata);\r\n    event TaskCancelled(uint256 indexed taskId, string metadata);\r\n    event RequestAccepted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId);\r\n    event RequestExecuted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId, address by);\r\n\r\n    event DeadlineChanged(uint256 indexed taskId, uint64 newDeadline);\r\n    event BudgetChanged(uint256 indexed taskId); // Quite expensive to transfer budget into a datastructure to emit\r\n    event RewardIncreased(\r\n        uint256 indexed taskId, uint32 indexed applicationId, uint96[] nativeIncrease, uint88[] increase\r\n    );\r\n    event MetadataChanged(uint256 indexed taskId, string newMetadata);\r\n    event ManagerChanged(uint256 indexed taskId, address newManager);\r\n    event PartialPayment(uint256 indexed taskId, uint96[] partialNativeReward, uint88[] partialReward);\r\n\r\n    /// @notice A container for ERC20 transfer information.\r\n    /// @param tokenContract ERC20 token to transfer.\r\n    /// @param amount How much of this token should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct ERC20Transfer {\r\n        IERC20 tokenContract;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a native reward payout.\r\n    /// @param to Whom the native reward should be transfered to.\r\n    /// @param amount How much native reward should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct NativeReward {\r\n        address to;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a reward payout.\r\n    /// @param nextToken If this reward is payed out in the next ERC20 token.\r\n    /// @dev IERC20 (address) is a lot of storage, rather just keep those only in budget.\r\n    /// @notice nextToken should always be true for the last entry\r\n    /// @param to Whom this token should be transfered to.\r\n    /// @param amount How much of this token should be transfered. uint88 to keep struct packed into a single uint256.\r\n    struct Reward {\r\n        bool nextToken;\r\n        address to;\r\n        uint88 amount;\r\n    }\r\n\r\n    /// @notice A container for a task application.\r\n    /// @param metadata Metadata of the application. (IPFS hash)\r\n    /// @param applicant Who has submitted this application.\r\n    /// @param accepted If the application has been accepted by the manager.\r\n    /// @param nativeReward How much native currency the applicant wants for completion.\r\n    /// @param reward How much rewards the applicant wants for completion.\r\n    struct Application {\r\n        string metadata;\r\n        // Storage block separator\r\n        address applicant;\r\n        bool accepted;\r\n        uint8 nativeRewardCount;\r\n        uint8 rewardCount;\r\n        // Storage block separator\r\n        mapping(uint8 => NativeReward) nativeReward;\r\n        mapping(uint8 => Reward) reward;\r\n    }\r\n\r\n    struct OffChainApplication {\r\n        string metadata;\r\n        address applicant;\r\n        bool accepted;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    /// @notice For approving people on task creation (they are not required to make an application).\r\n    struct PreapprovedApplication {\r\n        address applicant;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    enum SubmissionJudgement {\r\n        None,\r\n        Accepted,\r\n        Rejected\r\n    }\r\n\r\n    /// @notice A container for a task submission.\r\n    /// @param metadata Metadata of the submission. (IPFS hash)\r\n    /// @param judgement Judgement cast on the submission.\r\n    /// @param feedback A response from the manager. (IPFS hash)\r\n    struct Submission {\r\n        string metadata;\r\n        string feedback;\r\n        SubmissionJudgement judgement;\r\n    }\r\n\r\n    // This is for future expansion of the request system\r\n    enum RequestType {\r\n        CancelTask\r\n    }\r\n\r\n    /// @notice A container for shared request information.\r\n    /// @param accepted If the request was accepted.\r\n    /// @param executed If the request was executed.\r\n    struct Request {\r\n        bool accepted;\r\n        bool executed;\r\n    }\r\n\r\n    /// @notice A container for a request to cancel the task.\r\n    /// @param request Request information.\r\n    /// @param metadata Metadata of the request. (IPFS hash, Why the task should be cancelled)\r\n    struct CancelTaskRequest {\r\n        Request request;\r\n        string metadata;\r\n    }\r\n\r\n    enum TaskState {\r\n        Open,\r\n        Taken,\r\n        Closed\r\n    }\r\n\r\n    /// @notice A container for task-related information.\r\n    /// @param metadata Metadata of the task. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the task expires if not completed.\r\n    /// @param escrow The address of the escrow which holds the budget funds.\r\n    /// @param budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param nativeBudget Maximum native currency reward that can be earned by completing the task.\r\n    /// @param creator Who has created the task.\r\n    /// @param disputeManager Who has the permission to complete the task without the managers approval.\r\n    /// @param manager Who has the permission to manage the task.\r\n    /// @param state Current state the task is in.\r\n    /// @param applications Applications to take the job.\r\n    /// @param executorApplication Index of the application that will execute the task.\r\n    /// @param submissions Submission made to finish the task.\r\n    struct Task {\r\n        string metadata;\r\n        // Storage block separator\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        // Storage block separator\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        // Storage block separator\r\n        address disputeManager;\r\n        // Storage block separator\r\n        address manager;\r\n        TaskState state;\r\n        uint32 executorApplication;\r\n        uint8 budgetCount;\r\n        uint32 applicationCount;\r\n        uint8 submissionCount;\r\n        uint8 cancelTaskRequestCount;\r\n        // Storage block separator\r\n        mapping(uint8 => ERC20Transfer) budget;\r\n        mapping(uint32 => Application) applications;\r\n        mapping(uint8 => Submission) submissions;\r\n        mapping(uint8 => CancelTaskRequest) cancelTaskRequests;\r\n    }\r\n\r\n    struct OffChainTask {\r\n        string metadata;\r\n        uint64 deadline;\r\n        uint32 executorApplication;\r\n        address manager;\r\n        address disputeManager;\r\n        address creator;\r\n        TaskState state;\r\n        Escrow escrow;\r\n        uint96 nativeBudget;\r\n        ERC20Transfer[] budget;\r\n        OffChainApplication[] applications;\r\n        Submission[] submissions;\r\n        CancelTaskRequest[] cancelTaskRequests;\r\n    }\r\n\r\n    enum TaskCompletionSource {\r\n        SubmissionAccepted,\r\n        Dispute\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created tasks.\r\n    function taskCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all task information by id.\r\n    /// @param _taskId Id of the task.\r\n    function getTask(uint256 _taskId) external view returns (OffChainTask memory);\r\n\r\n    /// @notice Retrieves multiple tasks in a single call.\r\n    /// @param _taskIds Ids of the tasks.\r\n    function getTasks(uint256[] calldata _taskIds) external view returns (OffChainTask[] memory);\r\n\r\n    /// @notice Create a new task.\r\n    /// @param _metadata Metadata of the task. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the task expires if not completed.\r\n    /// @param _manager Who will manage the task (become the manager).\r\n    /// @param _disputeManager Who will manage the disputes (handle situations where the manager and executor are in disagreement).\r\n    /// @param _budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param _preapprove List of addresses (with reward) that are able to take the task without creating an application themselves.\r\n    /// @return taskId Id of the newly created task.\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        address _manager,\r\n        address _disputeManager,\r\n        ERC20Transfer[] calldata _budget,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId);\r\n\r\n    /// @notice Apply to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of your application.\r\n    /// @param _nativeReward Wanted native currency for completing the task.\r\n    /// @param _reward Wanted rewards for completing the task.\r\n    /// @return applicationId Id of the newly created application.\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        NativeReward[] calldata _nativeReward,\r\n        Reward[] calldata _reward\r\n    ) external returns (uint32 applicationId);\r\n\r\n    /// @notice Accept application to allow them to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationIds Indexes of the applications to accept.\r\n    /// @dev Will revert if applicant reward is higher than the budget. increaseBudget should be called beforehand.\r\n    function acceptApplications(uint256 _taskId, uint32[] calldata _applicationIds) external;\r\n\r\n    /// @notice Take the task after your application has been accepted.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Index of application you made that has been accepted.\r\n    function takeTask(uint256 _taskId, uint32 _applicationId) external;\r\n\r\n    /// @notice Create a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of the submission. (IPFS hash)\r\n    /// @return submissionId Id of the newly created submission.\r\n    function createSubmission(uint256 _taskId, string calldata _metadata) external returns (uint8 submissionId);\r\n\r\n    /// @notice Review a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _submissionId Index of the submission that is reviewed.\r\n    /// @param _judgement Outcome of the review.\r\n    /// @param _feedback Reasoning of the reviewer. (IPFS hash)\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external;\r\n\r\n    /// @notice Cancels a task. This can be used to close a task and receive back the budget.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Why the task was cancelled. (IPFS hash)\r\n    /// @return cancelTaskRequestId Id of the newly created request for task cancellation.\r\n    function cancelTask(uint256 _taskId, string calldata _metadata) external returns (uint8 cancelTaskRequestId);\r\n\r\n    /// @notice Accepts a request, executing the proposed action.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    /// @param _execute If the request should also be executed in this transaction.\r\n    function acceptRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId, bool _execute) external;\r\n\r\n    /// @notice Executes an accepted request, allows anyone to pay for the gas costs of the execution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    function executeRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId) external;\r\n\r\n    /// @notice Extend the deadline of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _extension How much to extend the deadline by.\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external;\r\n\r\n    /// @notice Increase the budget of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    /// @dev Any attached native reward will also be used to increase the budget.\r\n    function increaseBudget(uint256 _taskId, uint96[] calldata _increase) external payable;\r\n\r\n    /// @notice Increase the reward of an application of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Id of the application.\r\n    /// @param _nativeIncrease How much to increase each native amount by.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    function increaseReward(\r\n        uint256 _taskId,\r\n        uint32 _applicationId,\r\n        uint96[] calldata _nativeIncrease,\r\n        uint88[] calldata _increase\r\n    ) external;\r\n\r\n    /// @notice Edit the metadata of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newMetadata New metadata of the task.\r\n    /// @dev This metadata update might change the task completely. Show a warning to people who applied before the change.\r\n    function editMetadata(uint256 _taskId, string calldata _newMetadata) external;\r\n\r\n    /// @notice Transfers the manager role to a different address.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newManager What address should become the manager.\r\n    function transferManagement(uint256 _taskId, address _newManager) external;\r\n\r\n    /// @notice Completes the task through dispute resolution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint96[] calldata _partialNativeReward,\r\n        uint88[] calldata _partialReward\r\n    ) external;\r\n\r\n    /// @notice Releases a part of the reward to the executor without marking the task as complete.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    /// @dev Will fetch balanceOf to set the budget afterwards, can be used in case funds where sent manually to the escrow to sync the budget.\r\n    function partialPayment(uint256 _taskId, uint96[] calldata _partialNativeReward, uint88[] calldata _partialReward)\r\n        external;\r\n}\r\n"
    },
    "src/Tasks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {OpenmeshENSReverseClaimable} from \"../lib/openmesh-admin/src/OpenmeshENSReverseClaimable.sol\";\r\n\r\nimport {ITasks, IERC20, Escrow} from \"./ITasks.sol\";\r\nimport {TasksUtils, SafeERC20} from \"./TasksUtils.sol\";\r\n\r\ncontract Tasks is TasksUtils, OpenmeshENSReverseClaimable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice The incremental ID for tasks.\r\n    uint256 internal taskCounter;\r\n\r\n    /// @notice A mapping between task IDs and task information.\r\n    mapping(uint256 => Task) private tasks;\r\n\r\n    /// @notice The base escrow contract that will be cloned for every task.\r\n    address internal immutable escrowImplementation;\r\n\r\n    constructor() OpenmeshENSReverseClaimable() {\r\n        escrowImplementation = address(new Escrow());\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function taskCount() external view returns (uint256) {\r\n        return taskCounter;\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function getTask(uint256 _taskId) public view returns (OffChainTask memory offchainTask) {\r\n        Task storage task = _getTask(_taskId);\r\n        offchainTask = _toOffchainTask(task);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function getTasks(uint256[] memory _taskIds) external view returns (OffChainTask[] memory) {\r\n        OffChainTask[] memory offchainTasks = new OffChainTask[](_taskIds.length);\r\n        for (uint256 i; i < _taskIds.length;) {\r\n            offchainTasks[i] = getTask(_taskIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return offchainTasks;\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        address _manager,\r\n        address _disputeManager,\r\n        ERC20Transfer[] calldata _budget,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId) {\r\n        taskId = taskCounter++;\r\n        Task storage task = tasks[taskId];\r\n        task.metadata = _metadata;\r\n        task.deadline = _deadline;\r\n        Escrow escrow = Escrow(payable(clone(escrowImplementation)));\r\n        escrow.__Escrow_init{value: msg.value}();\r\n        task.escrow = escrow;\r\n\r\n        // Gas optimization\r\n        uint96 msgValue = _toUint96(msg.value);\r\n        if (msg.value != 0) {\r\n            task.nativeBudget = msgValue;\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_budget.length != 0) {\r\n            task.budgetCount = _toUint8(_budget.length);\r\n            for (uint8 i; i < uint8(_budget.length);) {\r\n                // Please mind that this external user specified \"token contract\" could be used for reentrancies. As all funds are held in separate escrows (this contract has none), this should not be an issue.\r\n                // Possible \"attack\": create an application, accept it and take the task inside the safeTransferFrom call, the preapproved application can be used to overwrite the reward (although limited by the budget).\r\n                // This all happens in a single transaction, which means realistically the proposer could achieve the same result anyhow.\r\n                _budget[i].tokenContract.safeTransferFrom(msg.sender, address(escrow), _budget[i].amount);\r\n                // use balanceOf in case there is a fee assosiated with the transfer\r\n                task.budget[i] = ERC20Transfer(\r\n                    _budget[i].tokenContract, _toUint96(_budget[i].tokenContract.balanceOf(address(escrow)))\r\n                );\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        task.manager = _manager;\r\n        if (_disputeManager != address(0)) {\r\n            task.disputeManager = _disputeManager;\r\n        }\r\n        task.creator = msg.sender;\r\n\r\n        // Default values are already correct (save gas)\r\n        // task.state = TaskState.Open;\r\n\r\n        emit TaskCreated(taskId, _metadata, _deadline, _manager, _disputeManager, msg.sender, msgValue, _budget, escrow);\r\n\r\n        // Gas optimization\r\n        if (_preapprove.length != 0) {\r\n            task.applicationCount = _toUint32(_preapprove.length);\r\n            for (uint32 i; i < uint32(_preapprove.length);) {\r\n                Application storage application = task.applications[i];\r\n                application.applicant = _preapprove[i].applicant;\r\n                application.accepted = true;\r\n                _ensureRewardEndsWithNextToken(_preapprove[i].reward);\r\n                _setRewardBellowBudget(task, application, _preapprove[i].nativeReward, _preapprove[i].reward);\r\n\r\n                emit ApplicationCreated(\r\n                    taskId, i, \"\", _preapprove[i].applicant, _preapprove[i].nativeReward, _preapprove[i].reward\r\n                );\r\n                emit ApplicationAccepted(taskId, i);\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        NativeReward[] calldata _nativeReward,\r\n        Reward[] calldata _reward\r\n    ) external returns (uint32 applicationId) {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureRewardEndsWithNextToken(_reward);\r\n\r\n        applicationId = task.applicationCount++;\r\n        Application storage application = task.applications[applicationId];\r\n        application.metadata = _metadata;\r\n        application.applicant = msg.sender;\r\n\r\n        // Gas optimization\r\n        if (_nativeReward.length != 0) {\r\n            application.nativeRewardCount = _toUint8(_nativeReward.length);\r\n            for (uint8 i; i < uint8(_nativeReward.length);) {\r\n                application.nativeReward[i] = _nativeReward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_reward.length != 0) {\r\n            application.rewardCount = _toUint8(_reward.length);\r\n            for (uint8 i; i < uint8(_reward.length);) {\r\n                application.reward[i] = _reward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit ApplicationCreated(_taskId, applicationId, _metadata, msg.sender, _nativeReward, _reward);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function acceptApplications(uint256 _taskId, uint32[] calldata _applicationIds) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        for (uint32 i; i < _applicationIds.length;) {\r\n            _ensureApplicationExists(task, _applicationIds[i]);\r\n\r\n            Application storage application = task.applications[_applicationIds[i]];\r\n            _ensureRewardBellowBudget(\r\n                task,\r\n                application.nativeRewardCount,\r\n                application.rewardCount,\r\n                application.nativeReward,\r\n                application.reward\r\n            );\r\n            application.accepted = true;\r\n\r\n            emit ApplicationAccepted(_taskId, _applicationIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function takeTask(uint256 _taskId, uint32 _applicationId) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureApplicationExists(task, _applicationId);\r\n\r\n        Application storage application = task.applications[_applicationId];\r\n        _ensureSenderIsApplicant(application);\r\n        _ensureApplicationIsAccepted(application);\r\n\r\n        task.executorApplication = _applicationId;\r\n        task.state = TaskState.Taken;\r\n\r\n        emit TaskTaken(_taskId, _applicationId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function createSubmission(uint256 _taskId, string calldata _metadata) external returns (uint8 submissionId) {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsExecutor(task);\r\n\r\n        submissionId = task.submissionCount++;\r\n        Submission storage submission = task.submissions[submissionId];\r\n        submission.metadata = _metadata;\r\n\r\n        emit SubmissionCreated(_taskId, submissionId, _metadata);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsManager(task);\r\n        _ensureSubmissionExists(task, _submissionId);\r\n\r\n        Submission storage submission = task.submissions[_submissionId];\r\n        _ensureSubmissionNotJudged(submission);\r\n        _ensureJudgementNotNone(_judgement);\r\n        submission.judgement = _judgement;\r\n        submission.feedback = _feedback;\r\n\r\n        if (_judgement == SubmissionJudgement.Accepted) {\r\n            _payoutTask(task);\r\n            emit TaskCompleted(_taskId, TaskCompletionSource.SubmissionAccepted);\r\n        }\r\n\r\n        emit SubmissionReviewed(_taskId, _submissionId, _judgement, _feedback);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function cancelTask(uint256 _taskId, string calldata _metadata) external returns (uint8 cancelTaskRequestId) {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        if (task.state == TaskState.Open || task.deadline <= uint64(block.timestamp)) {\r\n            // Task is open or deadline past\r\n            _refundCreator(task);\r\n\r\n            emit TaskCancelled(_taskId, _metadata);\r\n\r\n            // Max means no request\r\n            cancelTaskRequestId = type(uint8).max;\r\n        } else {\r\n            // Task is taken and deadline has not past\r\n            cancelTaskRequestId = task.cancelTaskRequestCount++; // Will overflow if it would be max (guarantees max means no request)\r\n            CancelTaskRequest storage request = task.cancelTaskRequests[cancelTaskRequestId];\r\n            request.metadata = _metadata;\r\n\r\n            emit CancelTaskRequested(_taskId, cancelTaskRequestId, _metadata);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function acceptRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId, bool _execute) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsExecutor(task);\r\n\r\n        //if (_requestType == RequestType.CancelTask) {\r\n        {\r\n            _ensureCancelTaskRequestExists(task, _requestId);\r\n\r\n            CancelTaskRequest storage cancelTaskRequest = task.cancelTaskRequests[_requestId];\r\n            _ensureRequestNotAccepted(cancelTaskRequest.request);\r\n            cancelTaskRequest.request.accepted = true;\r\n\r\n            if (_execute) {\r\n                // use executeRequest in the body instead? (more gas due to all the checks, but less code duplication)\r\n                _refundCreator(task);\r\n\r\n                emit TaskCancelled(_taskId, cancelTaskRequest.metadata);\r\n                cancelTaskRequest.request.executed = true;\r\n\r\n                emit RequestExecuted(_taskId, _requestType, _requestId, msg.sender);\r\n            }\r\n        }\r\n\r\n        emit RequestAccepted(_taskId, _requestType, _requestId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function executeRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n\r\n        //if (_requestType == RequestType.CancelTask) {\r\n        {\r\n            _ensureCancelTaskRequestExists(task, _requestId);\r\n\r\n            CancelTaskRequest storage cancelTaskRequest = task.cancelTaskRequests[_requestId];\r\n            _ensureRequestAccepted(cancelTaskRequest.request);\r\n            _ensureRequestNotExecuted(cancelTaskRequest.request);\r\n\r\n            _refundCreator(task);\r\n\r\n            emit TaskCancelled(_taskId, cancelTaskRequest.metadata);\r\n            cancelTaskRequest.request.executed = true;\r\n        }\r\n\r\n        emit RequestExecuted(_taskId, _requestType, _requestId, msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        task.deadline += _extension;\r\n\r\n        emit DeadlineChanged(_taskId, task.deadline);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function increaseBudget(uint256 _taskId, uint96[] calldata _increase) external payable {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _increaseNativeBudget(task);\r\n        _increaseBudget(task, _increase);\r\n\r\n        emit BudgetChanged(_taskId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function increaseReward(\r\n        uint256 _taskId,\r\n        uint32 _applicationId,\r\n        uint96[] calldata _nativeIncrease,\r\n        uint88[] calldata _increase\r\n    ) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureApplicationExists(task, _applicationId);\r\n        Application storage application = task.applications[_applicationId];\r\n        uint8 nativeRewardCount = application.nativeRewardCount;\r\n        for (uint8 i; i < nativeRewardCount;) {\r\n            application.nativeReward[i].amount += _nativeIncrease[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        uint8 rewardCount = application.rewardCount;\r\n        for (uint8 i; i < rewardCount;) {\r\n            application.reward[i].amount += _increase[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        _ensureRewardBellowBudget(task, nativeRewardCount, rewardCount, application.nativeReward, application.reward);\r\n\r\n        emit RewardIncreased(_taskId, _applicationId, _nativeIncrease, _increase);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function editMetadata(uint256 _taskId, string calldata _newMetadata) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        task.metadata = _newMetadata;\r\n\r\n        emit MetadataChanged(_taskId, _newMetadata);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function transferManagement(uint256 _taskId, address _newManager) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        task.manager = _newManager;\r\n\r\n        emit ManagerChanged(_taskId, _newManager);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint96[] calldata _partialNativeReward,\r\n        uint88[] calldata _partialReward\r\n    ) external {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsDisputeManager(task);\r\n\r\n        _payoutTaskPartially(task, _partialNativeReward, _partialReward);\r\n        _refundCreator(task);\r\n\r\n        emit PartialPayment(_taskId, _partialNativeReward, _partialReward);\r\n        emit TaskCompleted(_taskId, TaskCompletionSource.Dispute);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function partialPayment(uint256 _taskId, uint96[] calldata _partialNativeReward, uint88[] calldata _partialReward)\r\n        external\r\n    {\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _payoutTaskPartially(task, _partialNativeReward, _partialReward);\r\n\r\n        emit BudgetChanged(_taskId);\r\n        emit PartialPayment(_taskId, _partialNativeReward, _partialReward);\r\n    }\r\n\r\n    /// @notice To save any native funds stuck in the escrow\r\n    function rescueNative(uint256 _taskId, address payable to, uint256 amount) external {\r\n        if (_taskId == type(uint256).max && msg.sender == OPENMESH_ADMIN) {\r\n            // Save funds from this contract itself (done by Openmesh community)\r\n            (bool success,) = to.call{value: amount}(\"\");\r\n            if (!success) {\r\n                revert NativeTransferFailed();\r\n            }\r\n        } else {\r\n            // Save funds from the escrow contract of a task (done by the task manager)\r\n            Task storage task = _getTask(_taskId);\r\n            _ensureTaskClosed(task);\r\n            _ensureSenderIsManager(task);\r\n\r\n            task.escrow.transferNative(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice To save any erc20 funds stuck in the escrow\r\n    function rescue(uint256 _taskId, IERC20 token, address to, uint256 amount) external {\r\n        if (_taskId == type(uint256).max && msg.sender == OPENMESH_ADMIN) {\r\n            // Save funds from this contract itself (done by Openmesh community)\r\n            token.transfer(to, amount);\r\n        } else {\r\n            // Save funds from the escrow contract of a task (done by the task manager)\r\n            Task storage task = _getTask(_taskId);\r\n            _ensureTaskClosed(task);\r\n            _ensureSenderIsManager(task);\r\n\r\n            task.escrow.transfer(token, to, amount);\r\n        }\r\n    }\r\n\r\n    function _getTask(uint256 _taskId) internal view returns (Task storage task) {\r\n        if (_taskId >= taskCounter) {\r\n            revert TaskDoesNotExist();\r\n        }\r\n\r\n        task = tasks[_taskId];\r\n    }\r\n}\r\n"
    },
    "src/TasksEnsure.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ITasks, Escrow} from \"./ITasks.sol\";\r\n\r\n/*\r\n  Functions to ensure a certain precondition is met.\r\n*/\r\nabstract contract TasksEnsure is ITasks {\r\n    function _ensureTaskIsOpen(Task storage task) internal view {\r\n        if (task.state != TaskState.Open) {\r\n            revert TaskNotOpen();\r\n        }\r\n    }\r\n\r\n    function _ensureTaskIsTaken(Task storage task) internal view {\r\n        if (task.state != TaskState.Taken) {\r\n            revert TaskNotTaken();\r\n        }\r\n    }\r\n\r\n    function _ensureTaskClosed(Task storage task) internal view {\r\n        if (task.state != TaskState.Closed) {\r\n            revert TaskNotClosed();\r\n        }\r\n    }\r\n\r\n    function _ensureTaskNotClosed(Task storage task) internal view {\r\n        if (task.state == TaskState.Closed) {\r\n            revert TaskClosed();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsManager(Task storage task) internal view {\r\n        if (msg.sender != task.manager) {\r\n            revert NotManager();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsDisputeManager(Task storage task) internal view {\r\n        if (msg.sender != task.disputeManager) {\r\n            revert NotDisputeManager();\r\n        }\r\n    }\r\n\r\n    /// @dev Should only be called if the task is not open!\r\n    function _ensureSenderIsExecutor(Task storage task) internal view {\r\n        if (msg.sender != task.applications[task.executorApplication].applicant) {\r\n            revert NotExecutor();\r\n        }\r\n    }\r\n\r\n    function _ensureRewardEndsWithNextToken(Reward[] memory reward) internal pure {\r\n        unchecked {\r\n            if (reward.length != 0 && !reward[reward.length - 1].nextToken) {\r\n                revert RewardDoesntEndWithNextToken();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _ensureApplicationExists(Task storage task, uint32 _applicationId) internal view {\r\n        if (_applicationId >= task.applicationCount) {\r\n            revert ApplicationDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsApplicant(Application storage application) internal view {\r\n        if (msg.sender != application.applicant) {\r\n            revert NotYourApplication();\r\n        }\r\n    }\r\n\r\n    function _ensureApplicationIsAccepted(Application storage application) internal view {\r\n        if (!application.accepted) {\r\n            revert ApplicationNotAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureSubmissionExists(Task storage task, uint8 _submissionId) internal view {\r\n        if (_submissionId >= task.submissionCount) {\r\n            revert SubmissionDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureSubmissionNotJudged(Submission storage submission) internal view {\r\n        if (submission.judgement != SubmissionJudgement.None) {\r\n            revert SubmissionAlreadyJudged();\r\n        }\r\n    }\r\n\r\n    function _ensureJudgementNotNone(SubmissionJudgement judgement) internal pure {\r\n        if (judgement == SubmissionJudgement.None) {\r\n            revert JudgementNone();\r\n        }\r\n    }\r\n\r\n    function _ensureCancelTaskRequestExists(Task storage task, uint8 _requestId) internal view {\r\n        if (_requestId >= task.cancelTaskRequestCount) {\r\n            revert RequestDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestNotAccepted(Request storage request) internal view {\r\n        if (request.accepted) {\r\n            revert RequestAlreadyAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestAccepted(Request storage request) internal view {\r\n        if (!request.accepted) {\r\n            revert RequestNotAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestNotExecuted(Request storage request) internal view {\r\n        if (request.executed) {\r\n            revert RequestAlreadyExecuted();\r\n        }\r\n    }\r\n\r\n    function _toUint8(uint256 value) internal pure returns (uint8) {\r\n        if (value > type(uint8).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint8(value);\r\n    }\r\n\r\n    function _toUint32(uint256 value) internal pure returns (uint32) {\r\n        if (value > type(uint32).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint32(value);\r\n    }\r\n\r\n    function _toUint96(uint256 value) internal pure returns (uint96) {\r\n        if (value > type(uint96).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint96(value);\r\n    }\r\n}\r\n"
    },
    "src/TasksUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Escrow, TasksEnsure} from \"./TasksEnsure.sol\";\r\n\r\nimport {IERC20} from \"./ITasks.sol\";\r\nimport {SafeERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/*\r\n  Higher level functions to allow the Tasks file to be more readable.\r\n*/\r\nabstract contract TasksUtils is TasksEnsure {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function _toOffchainTask(Task storage task) internal view returns (OffChainTask memory offchainTask) {\r\n        offchainTask.metadata = task.metadata;\r\n        offchainTask.deadline = task.deadline;\r\n        offchainTask.executorApplication = task.executorApplication;\r\n        offchainTask.creator = task.creator;\r\n        offchainTask.manager = task.manager;\r\n        offchainTask.disputeManager = task.disputeManager;\r\n        offchainTask.state = task.state;\r\n        offchainTask.escrow = task.escrow;\r\n        offchainTask.nativeBudget = task.nativeBudget;\r\n\r\n        offchainTask.budget = new ERC20Transfer[](task.budgetCount);\r\n        for (uint8 i; i < offchainTask.budget.length;) {\r\n            offchainTask.budget[i] = task.budget[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.applications = new OffChainApplication[](task.applicationCount);\r\n        for (uint32 i; i < offchainTask.applications.length;) {\r\n            Application storage application = task.applications[i];\r\n            offchainTask.applications[i].metadata = application.metadata;\r\n            offchainTask.applications[i].applicant = application.applicant;\r\n            offchainTask.applications[i].accepted = application.accepted;\r\n\r\n            offchainTask.applications[i].nativeReward = new NativeReward[](application.nativeRewardCount);\r\n            for (uint8 j; j < offchainTask.applications[i].nativeReward.length;) {\r\n                offchainTask.applications[i].nativeReward[j] = application.nativeReward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n\r\n            offchainTask.applications[i].reward = new Reward[](application.rewardCount);\r\n            for (uint8 j; j < offchainTask.applications[i].reward.length;) {\r\n                offchainTask.applications[i].reward[j] = application.reward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.submissions = new Submission[](task.submissionCount);\r\n        for (uint8 i; i < offchainTask.submissions.length;) {\r\n            offchainTask.submissions[i] = task.submissions[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.cancelTaskRequests = new CancelTaskRequest[](task.cancelTaskRequestCount);\r\n        for (uint8 i; i < offchainTask.cancelTaskRequests.length;) {\r\n            offchainTask.cancelTaskRequests[i] = task.cancelTaskRequests[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _ensureRewardBellowBudget(\r\n        Task storage task,\r\n        uint8 _nativeLength,\r\n        uint8 _length,\r\n        mapping(uint8 => NativeReward) storage _nativeReward,\r\n        mapping(uint8 => Reward) storage _reward\r\n    ) internal view {\r\n        // Gas optimization\r\n        if (_nativeLength != 0) {\r\n            uint256 needed;\r\n            for (uint8 i; i < _nativeLength;) {\r\n                unchecked {\r\n                    needed += _nativeReward[i].amount;\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            if (needed > task.nativeBudget) {\r\n                revert RewardAboveBudget();\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_length != 0) {\r\n            uint8 j;\r\n            ERC20Transfer memory erc20Transfer = task.budget[0];\r\n            uint256 needed;\r\n            for (uint8 i; i < _length;) {\r\n                unchecked {\r\n                    needed += _reward[i].amount;\r\n                }\r\n\r\n                if (_reward[i].nextToken) {\r\n                    if (needed > erc20Transfer.amount) {\r\n                        revert RewardAboveBudget();\r\n                    }\r\n\r\n                    needed = 0;\r\n                    unchecked {\r\n                        erc20Transfer = task.budget[++j];\r\n                    }\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // In addition to _ensureRewardBellowBudget also sets the storage (and works with calldata arrays)\r\n    function _setRewardBellowBudget(\r\n        Task storage task,\r\n        Application storage application,\r\n        NativeReward[] calldata _nativeReward,\r\n        Reward[] calldata _reward\r\n    ) internal {\r\n        // Gas optimization\r\n        if (_nativeReward.length != 0) {\r\n            application.nativeRewardCount = _toUint8(_nativeReward.length);\r\n\r\n            uint256 needed;\r\n            for (uint8 i; i < uint8(_nativeReward.length);) {\r\n                unchecked {\r\n                    needed += _nativeReward[i].amount;\r\n                }\r\n\r\n                application.nativeReward[i] = _nativeReward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            if (needed > task.nativeBudget) {\r\n                revert RewardAboveBudget();\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_reward.length != 0) {\r\n            application.rewardCount = _toUint8(_reward.length);\r\n\r\n            uint8 j;\r\n            ERC20Transfer memory erc20Transfer = task.budget[0];\r\n            uint256 needed;\r\n            for (uint8 i; i < uint8(_reward.length);) {\r\n                unchecked {\r\n                    needed += _reward[i].amount;\r\n                }\r\n\r\n                application.reward[i] = _reward[i];\r\n\r\n                if (_reward[i].nextToken) {\r\n                    if (needed > erc20Transfer.amount) {\r\n                        revert RewardAboveBudget();\r\n                    }\r\n\r\n                    needed = 0;\r\n                    unchecked {\r\n                        erc20Transfer = task.budget[++j];\r\n                    }\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _increaseNativeBudget(Task storage task) internal {\r\n        // Gas optimization\r\n        if (msg.value != 0) {\r\n            (bool success,) = address(task.escrow).call{value: msg.value}(\"\");\r\n            if (!success) {\r\n                revert NativeTransferFailed();\r\n            }\r\n\r\n            task.nativeBudget = _toUint96(task.nativeBudget + msg.value);\r\n        }\r\n    }\r\n\r\n    function _increaseBudget(Task storage task, uint96[] calldata _increase) internal {\r\n        for (uint8 i; i < uint8(_increase.length);) {\r\n            // Gas optimization\r\n            if (_increase[i] != 0) {\r\n                ERC20Transfer storage transfer = task.budget[i];\r\n                transfer.tokenContract.safeTransferFrom(msg.sender, address(task.escrow), _increase[i]);\r\n                // Use balanceOf as there could be a fee in transferFrom\r\n\r\n                transfer.amount = _toUint96(transfer.tokenContract.balanceOf(address(task.escrow)));\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _payoutTask(Task storage task) internal {\r\n        Application storage executor = task.applications[task.executorApplication];\r\n        address creator = task.creator;\r\n        Escrow escrow = task.escrow;\r\n\r\n        // Gas optimization\r\n        uint256 nativeBudget = task.nativeBudget;\r\n        if (nativeBudget != 0) {\r\n            uint96 paidOut;\r\n\r\n            // Gas optimization\r\n            uint8 nativeRewardCount = executor.nativeRewardCount;\r\n            if (nativeRewardCount != 0) {\r\n                for (uint8 i; i < nativeRewardCount;) {\r\n                    escrow.transferNative(payable(executor.nativeReward[i].to), executor.nativeReward[i].amount);\r\n                    unchecked {\r\n                        paidOut += executor.nativeReward[i].amount;\r\n                    }\r\n\r\n                    unchecked {\r\n                        ++i;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Gas optimzation\r\n            if (paidOut < nativeBudget) {\r\n                unchecked {\r\n                    escrow.transferNative(payable(creator), nativeBudget - paidOut);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        uint8 budgetCount = task.budgetCount;\r\n        if (budgetCount != 0) {\r\n            // Gas optimization\r\n            uint8 rewardCount = executor.rewardCount;\r\n            uint8 j;\r\n            for (uint8 i; i < budgetCount;) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                while (j < rewardCount) {\r\n                    Reward memory reward = executor.reward[j];\r\n                    escrow.transfer(erc20Transfer.tokenContract, reward.to, reward.amount);\r\n\r\n                    unchecked {\r\n                        erc20Transfer.amount -= reward.amount;\r\n                        ++j;\r\n                    }\r\n\r\n                    if (reward.nextToken) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Gas optimization\r\n                if (erc20Transfer.amount != 0) {\r\n                    escrow.transfer(erc20Transfer.tokenContract, creator, erc20Transfer.amount);\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        task.state = TaskState.Closed;\r\n    }\r\n\r\n    function _refundCreator(Task storage task) internal {\r\n        Escrow escrow = task.escrow;\r\n        address creator = task.creator;\r\n\r\n        // Gas optimization\r\n        if (task.nativeBudget != 0) {\r\n            escrow.transferNative(payable(creator), task.nativeBudget);\r\n        }\r\n\r\n        // Gas optimization\r\n        uint8 budgetCount = task.budgetCount;\r\n        if (budgetCount != 0) {\r\n            for (uint8 i; i < budgetCount;) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                escrow.transfer(erc20Transfer.tokenContract, creator, erc20Transfer.amount);\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        task.state = TaskState.Closed;\r\n    }\r\n\r\n    function _payoutTaskPartially(\r\n        Task storage task,\r\n        uint96[] calldata _partialNativeReward,\r\n        uint88[] calldata _partialReward\r\n    ) internal {\r\n        Application storage executor = task.applications[task.executorApplication];\r\n        Escrow escrow = task.escrow;\r\n\r\n        // Gas optimization\r\n        uint8 nativeRewardCount = executor.nativeRewardCount;\r\n        if (nativeRewardCount != 0) {\r\n            for (uint8 i; i < nativeRewardCount;) {\r\n                if (_partialNativeReward[i] > executor.nativeReward[i].amount) {\r\n                    revert PartialRewardAboveFullReward();\r\n                }\r\n\r\n                escrow.transferNative(payable(executor.nativeReward[i].to), _partialNativeReward[i]);\r\n\r\n                unchecked {\r\n                    executor.nativeReward[i].amount -= _partialNativeReward[i];\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                task.nativeBudget = _toUint96(address(escrow).balance);\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        uint8 rewardCount = executor.rewardCount;\r\n        if (rewardCount != 0) {\r\n            uint8 j;\r\n            uint8 budgetCount = task.budgetCount;\r\n            for (uint8 i; i < budgetCount;) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                while (j < rewardCount) {\r\n                    Reward memory reward = executor.reward[j];\r\n                    if (_partialReward[j] > reward.amount) {\r\n                        revert PartialRewardAboveFullReward();\r\n                    }\r\n\r\n                    escrow.transfer(erc20Transfer.tokenContract, reward.to, _partialReward[j]);\r\n\r\n                    unchecked {\r\n                        executor.reward[j].amount = reward.amount - _partialReward[j];\r\n                        ++j;\r\n                    }\r\n\r\n                    if (reward.nextToken) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                task.budget[i].amount = _toUint96(erc20Transfer.tokenContract.balanceOf(address(escrow)));\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "ens-reverse-claimable/=lib/openmesh-admin/lib/ens-reverse-claimable/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openmesh-admin/=lib/openmesh-admin/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "smart-account/=lib/openmesh-admin/lib/smart-account/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "shanghai",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}