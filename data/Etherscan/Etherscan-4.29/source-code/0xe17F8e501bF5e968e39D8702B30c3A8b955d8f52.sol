{{
  "language": "Solidity",
  "sources": {
    "BrineBridger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.9.0;\nimport {Initializable, ContextUpgradeable} from \"Initializable.sol\";\nimport \"TransferHelper.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n\n/**\n * Brine bridger for cross-chain interoperability\n */\ncontract BrineDepositContract is OwnableUpgradeable {\n    mapping(address => bool) public authorized;\n    mapping(string => bool) public processedWithdrawalIds;\n\n    modifier _isAuthorized() {\n        require(authorized[msg.sender], \"UNAUTHORIZED\");\n        _;\n    }\n\n    modifier _validateWithdrawalId(string calldata withdrawalId) {\n        require(bytes(withdrawalId).length > 0, \"Withdrawal ID is required\");\n        require(\n            !processedWithdrawalIds[withdrawalId],\n            \"Withdrawal ID Already processed\"\n        );\n        _;\n    }\n\n    event BridgedDeposit(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n    event BridgedWithdrawal(\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        string withdrawalId\n    );\n\n    function initialize() public initializer {\n        __Ownable_init();\n        authorized[_msgSender()] = true;\n    }\n\n    /**\n     * @dev Deposit ERC20 tokens into the contract address, must be approved\n     */\n    function deposit(address token, uint256 amount) external {\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this),\n            amount\n        );\n        emit BridgedDeposit(msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Deposit native chain currency into contract address\n     */\n    function depositNative() external payable {\n        emit BridgedDeposit(msg.sender, address(0), msg.value); // Maybe create new events for ETH deposit/withdraw\n    }\n\n    /**\n     * @dev Deposit ERC20 token into the contract address\n     * NOTE: Restricted deposit function for rebalancing\n     */\n    function addFunds(address token, uint256 amount) external _isAuthorized {\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @dev Deposit native chain currency into the contract address\n     * NOTE: Restricted deposit function for rebalancing\n     */\n    function addFundsNative() external payable _isAuthorized {}\n\n    /**\n     * @dev withdraw ERC20 tokens from the contract address\n     * NOTE: only for authorized users\n     */\n    function withdraw(\n        address token,\n        address to,\n        uint256 amount,\n        string calldata withdrawalId\n    ) external _isAuthorized _validateWithdrawalId(withdrawalId) {\n        processedWithdrawalIds[withdrawalId] = true;\n        TransferHelper.safeTransfer(token, to, amount);\n        emit BridgedWithdrawal(to, token, amount, withdrawalId);\n    }\n\n    /**\n     * @dev withdraw native chain currency from the contract address\n     * NOTE: only for authorized users\n     */\n    function withdrawNative(\n        address payable to,\n        uint256 amount,\n        string calldata withdrawalId\n    ) external _isAuthorized _validateWithdrawalId(withdrawalId) {\n        processedWithdrawalIds[withdrawalId] = true;\n        removeFundsNative(to, amount);\n        emit BridgedWithdrawal(to, address(0), amount, withdrawalId);\n    }\n\n    /**\n     * @dev withdraw ERC20 token from the contract address\n     * NOTE: only for authorized users for rebalancing\n     */\n    function removeFunds(\n        address token,\n        address to,\n        uint256 amount\n    ) external _isAuthorized {\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /**\n     * @dev withdraw native chain currency from the contract address\n     * NOTE: only for authorized users for rebalancing\n     */\n    function removeFundsNative(address payable to, uint256 amount)\n        public\n        _isAuthorized\n    {\n        require(address(this).balance >= amount, \"INSUFFICIENT_BALANCE\");\n        to.transfer(amount);\n    }\n\n    /**\n     * @dev add or remove authorized users\n     * NOTE: only owner\n     */\n    function authorize(address user, bool value) external onlyOwner {\n        authorized[user] = value;\n    }\n\n    function transferOwner(address newOwner) external onlyOwner {\n        authorized[newOwner] = true;\n        authorized[owner()] = false;\n        transferOwnership(newOwner);\n    }\n\n    function renounceOwnership() public view override onlyOwner {\n        require(false, \"Unable to renounce ownership\");\n    }\n}\n"
    },
    "Initializable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            _initializing || !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {}\n\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0;\n\n// Source: UniswapV2\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "BrineBridger.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}