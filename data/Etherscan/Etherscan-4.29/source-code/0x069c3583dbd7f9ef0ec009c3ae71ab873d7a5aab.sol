{{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "remappings": [
      "ds-test/=./lib/forge-std/lib/ds-test/src/",
      "forge-std/=./lib/forge-std/src/",
      "@solady=./lib/solady/",
      "@uniswap/v2-core=./lib/v2-core/",
      "@uniswap/v2-periphery=./lib/v2-periphery/",
      "@uniswap/v3-periphery=./lib/v3-periphery/",
      "@uniswap/v3-core=./lib/v3-core/",
      "@openzeppelin=./lib/openzeppelin/"
    ]
  },
  "sources": {
    "src/renderers/HBHRendererHidden.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\nimport {IRenderer} from \"../interfaces/IRenderer.sol\";\r\nimport {Renderer} from \"./Renderer.sol\";\r\nimport {HBHART} from \"../utils/Addresses.sol\";\r\nimport {LibString} from \"@solady/src/utils/LibString.sol\";\r\nimport {CERTIFICATERENDERER} from \"./Addresses.sol\";\r\nimport {ICertificateRenderer} from \"./ICertificateRenderer.sol\";\r\nimport {Base64} from \"@solady/src/utils/Base64.sol\";\r\n\r\nICertificateRenderer constant CERTRENDERER = ICertificateRenderer(CERTIFICATERENDERER);\r\n\r\n/* solhint-disable quotes */\r\n/* solhint-disable max-line-length */\r\n/* solhint-disable max-states-count */\r\ncontract HBHRendererHidden is Renderer, IRenderer {\r\n    bytes IPFS_HASH = \"bafybeihkc7zkyqk4ydyhbjkxke7f7h2lrev4mtt3kufzy2rmxuaj6itpi4\";\r\n    string description =\r\n        \"Awaiting Discovery: This enigmatic art piece, currently veiled in mystery, is accompanied by a steadfast companion, hinting at the unique character of the hero yet to be revealed. Each companion, a loyal ally in the Web3 maze, offers a glimpse into the diverse and extraordinary traits of its unseen hero. Unveiling awaits, where the full story of Hero and companion will come to light, completing this unique web3 journey.\";\r\n    string[] private _companions = [\r\n        \"\",\r\n        \"Cubix Mastermind\",\r\n        \"Nibbled Nemo\",\r\n        \"Sonic Shouter\",\r\n        \"Spectral Wobble\",\r\n        \"Starfish Stroller\",\r\n        \"Moby Zoom\",\r\n        \"Meditative Maverick\",\r\n        \"Mystic Magus\",\r\n        \"Pianosaur Rex\",\r\n        \"Orbit Lifter\",\r\n        \"Oracle Eight\",\r\n        \"Zesty Warrior\",\r\n        \"Lookout Lurker\",\r\n        \"Broadcast Baron\",\r\n        \"Illumina-Tri\",\r\n        \"Deli Delight\",\r\n        \"Yolk Watcher\",\r\n        \"Regal Hoot\"\r\n    ];\r\n\r\n    constructor() {\r\n        _approveCaller(HBHART);\r\n    }\r\n\r\n    function contractURI() external view returns (string memory) {\r\n        string memory website = CERTRENDERER.getWebsite();\r\n        return string(\r\n            abi.encodePacked(\r\n                \"data:application/json;base64,\",\r\n                Base64.encode(\r\n                    abi.encodePacked(\r\n                        '\"name\": \"Half Baked Heroes\",\"description\": \"Half Baked Heroes is a creative NFT collection that celebrates the personalities and journeys of the Web3 community. With 15,000 unique characters, each NFT depicts a different personality that is navigating through a maze that represents the challenges and opportunities of Web3. Each NFT in the Half Baked Heroes collection is a unique work of art, created by a talented artist who has brought their own vision and interpretation to the project.\",\"image\": \"',\r\n                        website,\r\n                        '\"img/logo-hbh.png\", external_link\": \"',\r\n                        website,\r\n                        '\"}'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory uri) {\r\n        uint16 companionId = CERTRENDERER.getCompanionId(uint16(tokenId));\r\n        string memory companionIdString = LibString.toString(companionId);\r\n        string memory tokenIdString = LibString.toString(tokenId);\r\n        uri = string(\r\n            abi.encodePacked(\r\n                \"data:application/json;base64,\",\r\n                Base64.encode(\r\n                    abi.encodePacked(\r\n                        '{\"description\":\"',\r\n                        description,\r\n                        '\", \"external_url\": \"',\r\n                        CERTRENDERER.getWebsite(),\r\n                        \"hero/\",\r\n                        tokenIdString,\r\n                        '\", \"name\": \"Unrevealed Hero #',\r\n                        tokenIdString,\r\n                        \" accompanied by \",\r\n                        _companions[companionId],\r\n                        '\",\"image\":\"ipfs://',\r\n                        IPFS_HASH,\r\n                        \"/\",\r\n                        companionIdString,\r\n                        '\", \"attributes\": [',\r\n                        CERTRENDERER.getAttributes(uint16(tokenId)),\r\n                        \"]}\"\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n"
    },
    "./lib/solady//src/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Library to encode strings in Base64.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\r\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\r\nlibrary Base64 {\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\r\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\r\n    /// @param noPadding Whether to strip away the padding.\r\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let dataLength := mload(data)\r\n\r\n            if dataLength {\r\n                // Multiply by 4/3 rounded up.\r\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\r\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\r\n\r\n                // Set `result` to point to the start of the free memory.\r\n                result := mload(0x40)\r\n\r\n                // Store the table into the scratch space.\r\n                // Offsetted by -1 byte so that the `mload` will load the character.\r\n                // We will rewrite the free memory pointer at `0x40` later with\r\n                // the allocated size.\r\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\r\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\r\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\r\n\r\n                // Skip the first slot, which stores the length.\r\n                let ptr := add(result, 0x20)\r\n                let end := add(ptr, encodedLength)\r\n\r\n                // Run over the input, 3 bytes at a time.\r\n                for {} 1 {} {\r\n                    data := add(data, 3) // Advance 3 bytes.\r\n                    let input := mload(data)\r\n\r\n                    // Write 4 bytes. Optimized for fewer stack operations.\r\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\r\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\r\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\r\n                    mstore8(3, mload(and(input, 0x3F)))\r\n                    mstore(ptr, mload(0x00))\r\n\r\n                    ptr := add(ptr, 4) // Advance 4 bytes.\r\n                    if iszero(lt(ptr, end)) { break }\r\n                }\r\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\r\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\r\n                let o := div(2, mod(dataLength, 3))\r\n                // Offset `ptr` and pad with '='. We can simply write over the end.\r\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\r\n                // Set `o` to zero if there is padding.\r\n                o := mul(iszero(iszero(noPadding)), o)\r\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\r\n                mstore(result, sub(encodedLength, o)) // Store the length.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// Equivalent to `encode(data, false, false)`.\r\n    function encode(bytes memory data) internal pure returns (string memory result) {\r\n        result = encode(data, false, false);\r\n    }\r\n\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// Equivalent to `encode(data, fileSafe, false)`.\r\n    function encode(bytes memory data, bool fileSafe)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = encode(data, fileSafe, false);\r\n    }\r\n\r\n    /// @dev Decodes base64 encoded `data`.\r\n    ///\r\n    /// Supports:\r\n    /// - RFC 4648 (both standard and file-safe mode).\r\n    /// - RFC 3501 (63: ',').\r\n    ///\r\n    /// Does not support:\r\n    /// - Line breaks.\r\n    ///\r\n    /// Note: For performance reasons,\r\n    /// this function will NOT revert on invalid `data` inputs.\r\n    /// Outputs for invalid inputs will simply be undefined behaviour.\r\n    /// It is the user's responsibility to ensure that the `data`\r\n    /// is a valid base64 encoded string.\r\n    function decode(string memory data) internal pure returns (bytes memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let dataLength := mload(data)\r\n\r\n            if dataLength {\r\n                let decodedLength := mul(shr(2, dataLength), 3)\r\n\r\n                for {} 1 {} {\r\n                    // If padded.\r\n                    if iszero(and(dataLength, 3)) {\r\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\r\n                        // forgefmt: disable-next-item\r\n                        decodedLength := sub(\r\n                            decodedLength,\r\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\r\n                        )\r\n                        break\r\n                    }\r\n                    // If non-padded.\r\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\r\n                    break\r\n                }\r\n                result := mload(0x40)\r\n\r\n                // Write the length of the bytes.\r\n                mstore(result, decodedLength)\r\n\r\n                // Skip the first slot, which stores the length.\r\n                let ptr := add(result, 0x20)\r\n                let end := add(ptr, decodedLength)\r\n\r\n                // Load the table into the scratch space.\r\n                // Constants are optimized for smaller bytecode with zero gas overhead.\r\n                // `m` also doubles as the mask of the upper 6 bits.\r\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\r\n                mstore(0x5b, m)\r\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\r\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\r\n\r\n                for {} 1 {} {\r\n                    // Read 4 bytes.\r\n                    data := add(data, 4)\r\n                    let input := mload(data)\r\n\r\n                    // Write 3 bytes.\r\n                    // forgefmt: disable-next-item\r\n                    mstore(ptr, or(\r\n                        and(m, mload(byte(28, input))),\r\n                        shr(6, or(\r\n                            and(m, mload(byte(29, input))),\r\n                            shr(6, or(\r\n                                and(m, mload(byte(30, input))),\r\n                                shr(6, mload(byte(31, input)))\r\n                            ))\r\n                        ))\r\n                    ))\r\n                    ptr := add(ptr, 3)\r\n                    if iszero(lt(ptr, end)) { break }\r\n                }\r\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\r\n                mstore(end, 0) // Zeroize the slot after the bytes.\r\n                mstore(0x60, 0) // Restore the zero slot.\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "src/renderers/ICertificateRenderer.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\ninterface ICertificateRenderer {\r\n    function getAttributes(uint16 heroId) external view returns (bytes memory);\r\n    function getCompanionId(uint256 heroId) external pure returns (uint16 companionId);\r\n    function getWebsite() external view returns (string memory);\r\n}\r\n"
    },
    "src/renderers/Addresses.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\naddress constant VALHALLA0 = 0x06990CBcE3aef7cf389951cf02017A52918d8385;\r\naddress constant VALHALLA1 = 0x069029377E91b118fb176963A21aDab329215d63;\r\naddress constant VALHALLA2 = 0x06927a77AbB09088A6971ab3536f1Ae3621f21E2;\r\naddress constant VALHALLA3 = 0x0695117B8706b1f8891577b6EF3aCb6CF3703Dde;\r\n\r\n// Salts used for deterministic contract creation, ensuring secure and predictable deployment of the associated contracts.\r\nbytes32 constant VALHALLA0_SALT = bytes32(uint256(201722));\r\nbytes32 constant VALHALLA1_SALT = bytes32(uint256(298611));\r\nbytes32 constant VALHALLA2_SALT = bytes32(uint256(421287));\r\nbytes32 constant VALHALLA3_SALT = bytes32(uint256(100432));\r\n\r\nstring constant VALHALLA0_CODE = \"Valhalla0.sol:Valhalla0\";\r\nstring constant VALHALLA1_CODE = \"Valhalla1.sol:Valhalla1\";\r\nstring constant VALHALLA2_CODE = \"Valhalla2.sol:Valhalla2\";\r\nstring constant VALHALLA3_CODE = \"Valhalla3.sol:Valhalla3\";\r\n\r\naddress constant HBHRENDERERHIDDEN = 0x069C3583dbD7f9eF0Ec009c3ae71ab873d7a5AAb;\r\naddress constant HBHRENDERERREVEALED = 0x069b690361Ae7Ca502b0D585CD7726F95e511B33;\r\n\r\nbytes32 constant HBHRENDERERHIDDEN_SALT = bytes32(uint256(432623));\r\nbytes32 constant HBHRENDERERREVEALED_SALT = bytes32(uint256(504815));\r\n\r\nstring constant HBHRENDERERHIDDEN_CODE = \"HBHRendererHidden.sol:HBHRendererHidden\";\r\nstring constant HBHRENDERERREVEALED_CODE = \"HBHRendererRevealed.sol:HBHRendererRevealed\";\r\n\r\naddress constant CERTIFICATERENDERER = 0x069f37B130a5dA522e6BF858026E6B0dF26af5Dc;\r\nbytes32 constant CERTIFICATERENDERER_SALT = bytes32(uint256(549450));\r\nstring constant CERTIFICATERENDERER_CODE = \"CertificateRenderer.sol:CertificateRenderer\";\r\n\r\naddress constant CERTIFICATECOMPANIONRENDERER1 = 0x069b1828e959Bc2a7a691e2768C3e16350BAA757;\r\naddress constant CERTIFICATECOMPANIONRENDERER2 = 0x069D1CDe655CaCF02119000DED2ad3c800e36E88;\r\naddress constant CERTIFICATECOMPANIONRENDERER3 = 0x069F3226D56A252bb809759BC7C2f8cd9ad9dE1E;\r\naddress constant CERTIFICATECOMPANIONRENDERER4 = 0x069EF1c2fF3E5d92D03B0Cf18eB127e0F9FE3E8D;\r\naddress constant CERTIFICATECOMPANIONRENDERER5 = 0x069b3d533ad17D8Ce7C33761bb960F13f676b01F;\r\naddress constant CERTIFICATECOMPANIONRENDERER6 = 0x069FA283E51Efb711CBBa1652e6961101B8Aa37E;\r\naddress constant CERTIFICATECOMPANIONRENDERER7 = 0x069df9CfaA7F6BBF551232c3728f6da332E7C808;\r\naddress constant CERTIFICATECOMPANIONRENDERER8 = 0x0696de31B2239c7bb0eBf63fdf2Ad336c9dA3538;\r\naddress constant CERTIFICATECOMPANIONRENDERER9 = 0x069681cC7C7a233aD00085ac807500DD18cf696e;\r\n\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER1_SALT = bytes32(uint256(917690));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER2_SALT = bytes32(uint256(750668));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER3_SALT = bytes32(uint256(766618));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER4_SALT = bytes32(uint256(798854));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER5_SALT = bytes32(uint256(817672));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER6_SALT = bytes32(uint256(835726));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER7_SALT = bytes32(uint256(588244));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER8_SALT = bytes32(uint256(600631));\r\nbytes32 constant CERTIFICATECOMPANIONRENDERER9_SALT = bytes32(uint256(864562));\r\n\r\nstring constant CERTIFICATECOMPANIONRENDERER1_CODE = \"CertificateCompanionRenderer1.sol:CertificateCompanionRenderer1\";\r\nstring constant CERTIFICATECOMPANIONRENDERER2_CODE = \"CertificateCompanionRenderer2.sol:CertificateCompanionRenderer2\";\r\nstring constant CERTIFICATECOMPANIONRENDERER3_CODE = \"CertificateCompanionRenderer3.sol:CertificateCompanionRenderer3\";\r\nstring constant CERTIFICATECOMPANIONRENDERER4_CODE = \"CertificateCompanionRenderer4.sol:CertificateCompanionRenderer4\";\r\nstring constant CERTIFICATECOMPANIONRENDERER5_CODE = \"CertificateCompanionRenderer5.sol:CertificateCompanionRenderer5\";\r\nstring constant CERTIFICATECOMPANIONRENDERER6_CODE = \"CertificateCompanionRenderer6.sol:CertificateCompanionRenderer6\";\r\nstring constant CERTIFICATECOMPANIONRENDERER7_CODE = \"CertificateCompanionRenderer7.sol:CertificateCompanionRenderer7\";\r\nstring constant CERTIFICATECOMPANIONRENDERER8_CODE = \"CertificateCompanionRenderer8.sol:CertificateCompanionRenderer8\";\r\nstring constant CERTIFICATECOMPANIONRENDERER9_CODE = \"CertificateCompanionRenderer9.sol:CertificateCompanionRenderer9\";\r\n"
    },
    "./lib/solady//src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Library for converting numbers into strings and other string operations.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\r\nlibrary LibString {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The `length` of the output is too small to contain all the hex digits.\r\n    error HexLengthInsufficient();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The constant returned when the `search` is not found in the string.\r\n    uint256 internal constant NOT_FOUND = type(uint256).max;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                     DECIMAL OPERATIONS                     */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits.\r\n            str := add(mload(0x40), 0x80)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            let w := not(0) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 1)`.\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(int256 value) internal pure returns (string memory str) {\r\n        if (value >= 0) {\r\n            return toString(uint256(value));\r\n        }\r\n        unchecked {\r\n            str = toString(uint256(-value));\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We still have some spare memory space on the left,\r\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\r\n            let length := mload(str) // Load the string length.\r\n            mstore(str, 0x2d) // Store the '-' character.\r\n            str := sub(str, 1) // Move back the string pointer by a byte.\r\n            mstore(str, add(length, 1)) // Update the string length.\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   HEXADECIMAL OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2 + 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value, length);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexStringNoPrefix(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory str)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\r\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\r\n            // We add 0x20 to the total and round down to a multiple of 0x20.\r\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\r\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let start := sub(str, add(length, length))\r\n            let w := not(1) // Tsk.\r\n            let temp := value\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for {} 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(xor(str, start)) { break }\r\n            }\r\n\r\n            if temp {\r\n                // Store the function selector of `HexLengthInsufficient()`.\r\n                mstore(0x00, 0x2194895a)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2 + 2` bytes.\r\n    function toHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\".\r\n    /// The output excludes leading \"0\" from the `toHexString` output.\r\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\r\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\r\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\r\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\r\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := mload(str) // Get the length.\r\n            str := add(str, o) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2` bytes.\r\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\r\n            str := add(mload(0x40), 0x80)\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let w := not(1) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\r\n    /// and the alphabets are capitalized conditionally according to\r\n    /// https://eips.ethereum.org/EIPS/eip-55\r\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\r\n        str = toHexString(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\r\n            let o := add(str, 0x22)\r\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\r\n            let t := shl(240, 136) // `0b10001000 << 240`\r\n            for { let i := 0 } 1 {} {\r\n                mstore(add(i, i), mul(t, byte(i, hashed)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\r\n            o := add(o, 0x20)\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(address value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            str := mload(0x40)\r\n\r\n            // Allocate the memory.\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\r\n            mstore(0x40, add(str, 0x80))\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            str := add(str, 2)\r\n            mstore(str, 40)\r\n\r\n            let o := add(str, 0x20)\r\n            mstore(add(o, 40), 0)\r\n\r\n            value := shl(96, value)\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let i := 0 } 1 {} {\r\n                let p := add(o, add(i, i))\r\n                let temp := byte(i, value)\r\n                mstore8(add(p, 1), mload(and(temp, 15)))\r\n                mstore8(p, mload(shr(4, temp)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(raw);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(raw)\r\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\r\n            mstore(str, add(length, length)) // Store the length of the output.\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let o := add(str, 0x20)\r\n            let end := add(raw, length)\r\n\r\n            for {} iszero(eq(raw, end)) {} {\r\n                raw := add(raw, 1)\r\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\r\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\r\n                o := add(o, 2)\r\n            }\r\n            mstore(o, 0) // Zeroize the slot after the string.\r\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   RUNE STRING OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the number of UTF characters in the string.\r\n    function runeCount(string memory s) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mload(s) {\r\n                mstore(0x00, div(not(0), 255))\r\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\r\n                let o := add(s, 0x20)\r\n                let end := add(o, mload(s))\r\n                for { result := 1 } 1 { result := add(result, 1) } {\r\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if this string is a 7-bit ASCII string.\r\n    /// (i.e. all characters codes are in [0..127])\r\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(7, div(not(0), 255))\r\n            result := 1\r\n            let n := mload(s)\r\n            if n {\r\n                let o := add(s, 0x20)\r\n                let end := add(o, n)\r\n                let last := mload(end)\r\n                mstore(end, 0)\r\n                for {} 1 {} {\r\n                    if and(mask, mload(o)) {\r\n                        result := 0\r\n                        break\r\n                    }\r\n                    o := add(o, 0x20)\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n                mstore(end, last)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   BYTE STRING OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    // For performance and bytecode compactness, all indices of the following operations\r\n    // are byte (ASCII) offsets, not UTF character offsets.\r\n\r\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\r\n    function replace(string memory subject, string memory search, string memory replacement)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n            let replacementLength := mload(replacement)\r\n\r\n            subject := add(subject, 0x20)\r\n            search := add(search, 0x20)\r\n            replacement := add(replacement, 0x20)\r\n            result := add(mload(0x40), 0x20)\r\n\r\n            let subjectEnd := add(subject, subjectLength)\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                mstore(result, t)\r\n                                result := add(result, 1)\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Copy the `replacement` one word at a time.\r\n                        for { let o := 0 } 1 {} {\r\n                            mstore(add(result, o), mload(add(replacement, o)))\r\n                            o := add(o, 0x20)\r\n                            if iszero(lt(o, replacementLength)) { break }\r\n                        }\r\n                        result := add(result, replacementLength)\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    mstore(result, t)\r\n                    result := add(result, 1)\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n            }\r\n\r\n            let resultRemainder := result\r\n            result := add(mload(0x40), 0x20)\r\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\r\n            // Copy the rest of the string one word at a time.\r\n            for {} lt(subject, subjectEnd) {} {\r\n                mstore(resultRemainder, mload(subject))\r\n                resultRemainder := add(resultRemainder, 0x20)\r\n                subject := add(subject, 0x20)\r\n            }\r\n            result := sub(result, 0x20)\r\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            mstore(result, k) // Store the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for { let subjectLength := mload(subject) } 1 {} {\r\n                if iszero(mload(search)) {\r\n                    if iszero(gt(from, subjectLength)) {\r\n                        result := from\r\n                        break\r\n                    }\r\n                    result := subjectLength\r\n                    break\r\n                }\r\n                let searchLength := mload(search)\r\n                let subjectStart := add(subject, 0x20)\r\n\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                subject := add(subjectStart, from)\r\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\r\n\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(add(search, 0x20))\r\n\r\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\r\n\r\n                if iszero(lt(searchLength, 0x20)) {\r\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                        if iszero(shr(m, xor(mload(subject), s))) {\r\n                            if eq(keccak256(subject, searchLength), h) {\r\n                                result := sub(subject, subjectStart)\r\n                                break\r\n                            }\r\n                        }\r\n                        subject := add(subject, 1)\r\n                        if iszero(lt(subject, end)) { break }\r\n                    }\r\n                    break\r\n                }\r\n                for {} 1 {} {\r\n                    if iszero(shr(m, xor(mload(subject), s))) {\r\n                        result := sub(subject, subjectStart)\r\n                        break\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = indexOf(subject, search, 0);\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {} 1 {} {\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n                let searchLength := mload(search)\r\n                if gt(searchLength, mload(subject)) { break }\r\n                let w := result\r\n\r\n                let fromMax := sub(mload(subject), searchLength)\r\n                if iszero(gt(fromMax, from)) { from := fromMax }\r\n\r\n                let end := add(add(subject, 0x20), w)\r\n                subject := add(add(subject, 0x20), from)\r\n                if iszero(gt(subject, end)) { break }\r\n                // As this function is not too often used,\r\n                // we shall simply use keccak256 for smaller bytecode size.\r\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                    if eq(keccak256(subject, searchLength), h) {\r\n                        result := sub(subject, add(end, 1))\r\n                        break\r\n                    }\r\n                    subject := add(subject, w) // `sub(subject, 1)`.\r\n                    if iszero(gt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns whether `subject` starts with `search`.\r\n    function startsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                iszero(gt(searchLength, mload(subject))),\r\n                eq(\r\n                    keccak256(add(subject, 0x20), searchLength),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `subject` ends with `search`.\r\n    function endsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            let subjectLength := mload(subject)\r\n            // Whether `search` is not longer than `subject`.\r\n            let withinRange := iszero(gt(searchLength, subjectLength))\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                withinRange,\r\n                eq(\r\n                    keccak256(\r\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\r\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\r\n                        searchLength\r\n                    ),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `subject` repeated `times`.\r\n    function repeat(string memory subject, uint256 times)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(or(iszero(times), iszero(subjectLength))) {\r\n                subject := add(subject, 0x20)\r\n                result := mload(0x40)\r\n                let output := add(result, 0x20)\r\n                for {} 1 {} {\r\n                    // Copy the `subject` one word at a time.\r\n                    for { let o := 0 } 1 {} {\r\n                        mstore(add(output, o), mload(add(subject, o)))\r\n                        o := add(o, 0x20)\r\n                        if iszero(lt(o, subjectLength)) { break }\r\n                    }\r\n                    output := add(output, subjectLength)\r\n                    times := sub(times, 1)\r\n                    if iszero(times) { break }\r\n                }\r\n                mstore(output, 0) // Zeroize the slot after the string.\r\n                let resultLength := sub(output, add(result, 0x20))\r\n                mstore(result, resultLength) // Store the length.\r\n                // Allocate the memory.\r\n                mstore(0x40, add(result, add(resultLength, 0x20)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\r\n    /// `start` and `end` are byte offsets.\r\n    function slice(string memory subject, uint256 start, uint256 end)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\r\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\r\n            if lt(start, end) {\r\n                result := mload(0x40)\r\n                let resultLength := sub(end, start)\r\n                mstore(result, resultLength)\r\n                subject := add(subject, start)\r\n                let w := not(0x1f)\r\n                // Copy the `subject` one word at a time, backwards.\r\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\r\n                    mstore(add(result, o), mload(add(subject, o)))\r\n                    o := add(o, w) // `sub(o, 0x20)`.\r\n                    if iszero(o) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(add(add(result, 0x20), resultLength), 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\r\n    /// `start` is a byte offset.\r\n    function slice(string memory subject, uint256 start)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = slice(subject, start, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns all the indices of `search` in `subject`.\r\n    /// The indices are byte offsets.\r\n    function indicesOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                subject := add(subject, 0x20)\r\n                search := add(search, 0x20)\r\n                result := add(mload(0x40), 0x20)\r\n\r\n                let subjectStart := subject\r\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Append to `result`.\r\n                        mstore(result, sub(subject, subjectStart))\r\n                        result := add(result, 0x20)\r\n                        // Advance `subject` by `searchLength`.\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                let resultEnd := result\r\n                // Assign `result` to the free memory pointer.\r\n                result := mload(0x40)\r\n                // Store the length of `result`.\r\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\r\n                // Allocate memory for result.\r\n                // We allocate one more word, so this array can be recycled for {split}.\r\n                mstore(0x40, add(resultEnd, 0x20))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\r\n    function split(string memory subject, string memory delimiter)\r\n        internal\r\n        pure\r\n        returns (string[] memory result)\r\n    {\r\n        uint256[] memory indices = indicesOf(subject, delimiter);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            let indexPtr := add(indices, 0x20)\r\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\r\n            mstore(add(indicesEnd, w), mload(subject))\r\n            mstore(indices, add(mload(indices), 1))\r\n            let prevIndex := 0\r\n            for {} 1 {} {\r\n                let index := mload(indexPtr)\r\n                mstore(indexPtr, 0x60)\r\n                if iszero(eq(index, prevIndex)) {\r\n                    let element := mload(0x40)\r\n                    let elementLength := sub(index, prevIndex)\r\n                    mstore(element, elementLength)\r\n                    // Copy the `subject` one word at a time, backwards.\r\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\r\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\r\n                        o := add(o, w) // `sub(o, 0x20)`.\r\n                        if iszero(o) { break }\r\n                    }\r\n                    // Zeroize the slot after the string.\r\n                    mstore(add(add(element, 0x20), elementLength), 0)\r\n                    // Allocate memory for the length and the bytes,\r\n                    // rounded up to a multiple of 32.\r\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\r\n                    // Store the `element` into the array.\r\n                    mstore(indexPtr, element)\r\n                }\r\n                prevIndex := add(index, mload(delimiter))\r\n                indexPtr := add(indexPtr, 0x20)\r\n                if iszero(lt(indexPtr, indicesEnd)) { break }\r\n            }\r\n            result := indices\r\n            if iszero(mload(delimiter)) {\r\n                result := add(indices, 0x20)\r\n                mstore(result, sub(mload(indices), 2))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a concatenated string of `a` and `b`.\r\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\r\n    function concat(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            result := mload(0x40)\r\n            let aLength := mload(a)\r\n            // Copy `a` one word at a time, backwards.\r\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\r\n                mstore(add(result, o), mload(add(a, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let bLength := mload(b)\r\n            let output := add(result, aLength)\r\n            // Copy `b` one word at a time, backwards.\r\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\r\n                mstore(add(output, o), mload(add(b, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let totalLength := add(aLength, bLength)\r\n            let last := add(add(result, 0x20), totalLength)\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Stores the length.\r\n            mstore(result, totalLength)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 0x1f), w))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function toCase(string memory subject, bool toUpper)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(subject)\r\n            if length {\r\n                result := add(mload(0x40), 0x20)\r\n                subject := add(subject, 1)\r\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\r\n                let w := not(0)\r\n                for { let o := length } 1 {} {\r\n                    o := add(o, w)\r\n                    let b := and(0xff, mload(add(subject, o)))\r\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\r\n                    if iszero(o) { break }\r\n                }\r\n                result := mload(0x40)\r\n                mstore(result, length) // Store the length.\r\n                let last := add(add(result, 0x20), length)\r\n                mstore(last, 0) // Zeroize the slot after the string.\r\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a string from a small bytes32 string.\r\n    /// `smallString` must be null terminated, or behavior will be undefined.\r\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\r\n        if (smallString == bytes32(0)) return result;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            let n := 0\r\n            for {} 1 {} {\r\n                n := add(n, 1)\r\n                if iszero(byte(n, smallString)) { break } // Scan for '\\0'.\r\n            }\r\n            mstore(result, n)\r\n            let o := add(result, 0x20)\r\n            mstore(o, smallString)\r\n            mstore(add(o, n), 0)\r\n            mstore(0x40, add(result, 0x40))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a lowercased copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function lower(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, false);\r\n    }\r\n\r\n    /// @dev Returns an UPPERCASED copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function upper(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, true);\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within HTML tags.\r\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let end := add(s, mload(s))\r\n            result := add(mload(0x40), 0x20)\r\n            // Store the bytes of the packed offsets and strides into the scratch space.\r\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\r\n            mstore(0x1f, 0x900094)\r\n            mstore(0x08, 0xc0000000a6ab)\r\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\r\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\r\n            for {} iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\r\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\r\n                    mstore8(result, c)\r\n                    result := add(result, 1)\r\n                    continue\r\n                }\r\n                let t := shr(248, mload(c))\r\n                mstore(result, mload(and(t, 0x1f)))\r\n                result := add(result, shr(5, t))\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\r\n    function escapeJSON(string memory s, bool addDoubleQuotes)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let end := add(s, mload(s))\r\n            result := add(mload(0x40), 0x20)\r\n            if addDoubleQuotes {\r\n                mstore8(result, 34)\r\n                result := add(1, result)\r\n            }\r\n            // Store \"\\\\u0000\" in scratch space.\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\r\n            // into the scratch space.\r\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\r\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\r\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\r\n            for {} iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                if iszero(lt(c, 0x20)) {\r\n                    if iszero(and(shl(c, 1), e)) {\r\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\r\n                        mstore8(result, c)\r\n                        result := add(result, 1)\r\n                        continue\r\n                    }\r\n                    mstore8(result, 0x5c) // \"\\\\\".\r\n                    mstore8(add(result, 1), c)\r\n                    result := add(result, 2)\r\n                    continue\r\n                }\r\n                if iszero(and(shl(c, 1), 0x3700)) {\r\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\r\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\r\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\r\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\r\n                    result := add(result, 6)\r\n                    continue\r\n                }\r\n                mstore8(result, 0x5c) // \"\\\\\".\r\n                mstore8(add(result, 1), mload(add(c, 8)))\r\n                result := add(result, 2)\r\n            }\r\n            if addDoubleQuotes {\r\n                mstore8(result, 34)\r\n                result := add(1, result)\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\r\n        result = escapeJSON(s, false);\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`.\r\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\r\n    /// `b` must be null terminated, or behavior will be undefined.\r\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // These should be evaluated on compile time, as far as possible.\r\n            let x := and(b, add(not(b), 1))\r\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\r\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Packs a single string with its length into a single word.\r\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\r\n    function packOne(string memory a) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We don't need to zero right pad the string,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes.\r\n                    mload(add(a, 0x1f)),\r\n                    // `length != 0 && length < 32`. Abuses underflow.\r\n                    // Assumes that the length is valid and within the block gas limit.\r\n                    lt(sub(mload(a), 1), 0x1f)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks a string packed using {packOne}.\r\n    /// Returns the empty string if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\r\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            result := mload(0x40)\r\n            // Allocate 2 words (1 for the length, 1 for the bytes).\r\n            mstore(0x40, add(result, 0x40))\r\n            // Zeroize the length slot.\r\n            mstore(result, 0)\r\n            // Store the length and bytes.\r\n            mstore(add(result, 0x1f), packed)\r\n            // Right pad with zeroes.\r\n            mstore(add(add(result, 0x20), mload(result)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Packs two strings with their lengths into a single word.\r\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\r\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let aLength := mload(a)\r\n            // We don't need to zero right pad the strings,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes of `a` and `b`.\r\n                    or(\r\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\r\n                        mload(sub(add(b, 0x1e), aLength))\r\n                    ),\r\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\r\n                    // Assumes that the lengths are valid and within the block gas limit.\r\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks strings packed using {packTwo}.\r\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\r\n    function unpackTwo(bytes32 packed)\r\n        internal\r\n        pure\r\n        returns (string memory resultA, string memory resultB)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            resultA := mload(0x40)\r\n            resultB := add(resultA, 0x40)\r\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\r\n            mstore(0x40, add(resultB, 0x40))\r\n            // Zeroize the length slots.\r\n            mstore(resultA, 0)\r\n            mstore(resultB, 0)\r\n            // Store the lengths and bytes.\r\n            mstore(add(resultA, 0x1f), packed)\r\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\r\n            // Right pad with zeroes.\r\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\r\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Directly returns `a` without copying.\r\n    function directReturn(string memory a) internal pure {\r\n        assembly {\r\n            // Assumes that the string does not start from the scratch space.\r\n            let retStart := sub(a, 0x20)\r\n            let retSize := add(mload(a), 0x40)\r\n            // Right pad with zeroes. Just in case the string is produced\r\n            // by a method that doesn't zero right pad.\r\n            mstore(add(retStart, retSize), 0)\r\n            // Store the return offset.\r\n            mstore(retStart, 0x20)\r\n            // End the transaction, returning the string.\r\n            return(retStart, retSize)\r\n        }\r\n    }\r\n}\r\n"
    },
    "src/utils/Addresses.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\nimport {IUniswapV3Factory} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\r\n\r\n// Administrative control address with full privileges for initial setup and configuration of the contract ecosystem.\r\naddress constant INITIAL_OWNER = 0x5cA1e1Ab50E1c9765F02B01FD2Ed340f394c5DDA;\r\n// Exclusive deployer address for the HalfBakedHeroes collection, to deploy smart contracts with pre-fixed addresses.\r\naddress constant HBH_DEPLOYER = 0x35a782Af7355BC5fA4452831B15442d3DEFB1d77;\r\naddress constant DEVS_HBH_MULTISIG = 0x5fe156F51443AE995300efC719DDeAE1D2C76730;\r\naddress constant MINE_HBH_MULTISIG = 0xCF598d75EA9194850EB8e429f43F109665196dFa;\r\naddress constant VIBES_HBH_MULTISIG = 0xeDDcb711569d5d93ad0b4CCb689658eF38c7cA4c;\r\n\r\naddress payable constant HBHART = payable(0x069220F5F85aE9B82371a29f5F9c70E0cBdcBf69);\r\naddress constant MEMENTOS = 0x069f85562F20e3c8120CbC8880cf67976992eA83;\r\naddress payable constant CERT_HBH = payable(0x069376a7d55C202Aa79565B25E167B97016D9168);\r\naddress payable constant LM_HBH = payable(0x069D89AE50Da299e3Caa5BD6e8a777C59fB9BEe8);\r\naddress constant G3PASS = 0xD5cfc0d7EE0d53ba192E2521e2a2C387bACE19Bb;\r\nuint256 constant G3PASSID = 1;\r\n\r\n// Salts used for deterministic contract creation, ensuring secure and predictable deployment of the associated contracts.\r\nbytes32 constant HBHART_SALT = bytes32(uint256(261411));\r\nbytes32 constant MEMENTOS_SALT = bytes32(uint256(678014));\r\nbytes32 constant CERT_HBH_SALT = bytes32(uint256(3077067));\r\nbytes32 constant LM_HBH_SALT = bytes32(uint256(2575142));\r\n\r\nstring constant HBHART_CODE = \"HalfBakedHeroes.sol:HalfBakedHeroes\";\r\nstring constant MEMENTOS_CODE = \"Mementos.sol:Mementos\";\r\nstring constant CERT_HBH_CODE = \"Certificate.sol:CertificateOfAuthenticity\";\r\nstring constant LM_HBH_CODE = \"LiquidityManager.sol:LiquidityManager\";\r\n\r\n// Address for Uniswap V3's Rocket Pool ETH-WETH 500 Pool, a liquidity pool for RETH-WETH swaps.\r\naddress constant UNISWAPV3_RETH_WETH_500_POOL = 0xa4e0faA58465A2D369aa21B3e42d43374c6F9613;\r\n// Address for the Uniswap V2 Factory, a central component of the Uniswap protocol used for creating new liquidity pools.\r\naddress constant UNISWAPV2FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n// The burn address, commonly used to remove tokens from circulation by sending them to an unrecoverable address.\r\naddress constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n// The Uniswap V3 Factory interface, a core contract for Uniswap V3 pools creation and management.\r\nIUniswapV3Factory constant POOL_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\r\naddress constant POSITION_MANAGER = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\r\n\r\naddress constant UNISWAPV2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\naddress constant UNISWAPV3ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n\r\naddress constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\naddress constant ROCKET_POOL_STAKED_ETH = 0xae78736Cd615f374D3085123A210448E74Fc6393;\r\n"
    },
    "src/renderers/Renderer.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\nimport {Ownable} from \"../abstract/Ownable.sol\";\r\nimport {INITIAL_OWNER} from \"../utils/Addresses.sol\";\r\n\r\nabstract contract Renderer is Ownable {\r\n    event CallerApproval(address indexed caller);\r\n\r\n    mapping(address => bool) public allowedCallers;\r\n\r\n    constructor() {\r\n        _initializeOwner(INITIAL_OWNER);\r\n    }\r\n\r\n    function approveCaller(address caller) external onlyOwner {\r\n        _approveCaller(caller);\r\n    }\r\n\r\n    function _approveCaller(address caller) internal {\r\n        allowedCallers[caller] = true;\r\n        emit CallerApproval(caller);\r\n    }\r\n}\r\n"
    },
    "src/interfaces/IRenderer.sol": {
      "content": "// Copyright (c) 2023 David Gokhshtein. All rights reserved.\r\n// David Gokhshtein licenses this file to you under the Apache 2.0 license.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity 0.8.21;\r\n\r\ninterface IRenderer {\r\n    function contractURI() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
    },
    "./lib/v3-core//contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title The interface for the Uniswap V3 Factory\r\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\r\ninterface IUniswapV3Factory {\r\n    /// @notice Emitted when the owner of the factory is changed\r\n    /// @param oldOwner The owner before the owner was changed\r\n    /// @param newOwner The owner after the owner was changed\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @notice Emitted when a pool is created\r\n    /// @param token0 The first token of the pool by address sort order\r\n    /// @param token1 The second token of the pool by address sort order\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\r\n    /// @param pool The address of the created pool\r\n    event PoolCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint24 indexed fee,\r\n        int24 tickSpacing,\r\n        address pool\r\n    );\r\n\r\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip\r\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\r\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\r\n\r\n    /// @notice Returns the current owner of the factory\r\n    /// @dev Can be changed by the current owner via setOwner\r\n    /// @return The address of the factory owner\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\r\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\r\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\r\n    /// @return The tick spacing\r\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\r\n\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    /// @notice Creates a pool for the given two tokens and fee\r\n    /// @param tokenA One of the two tokens in the desired pool\r\n    /// @param tokenB The other of the two tokens in the desired pool\r\n    /// @param fee The desired fee for the pool\r\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\r\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\r\n    /// are invalid.\r\n    /// @return pool The address of the newly created pool\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n\r\n    /// @notice Updates the owner of the factory\r\n    /// @dev Must be called by the current owner\r\n    /// @param _owner The new owner of the factory\r\n    function setOwner(address _owner) external;\r\n\r\n    /// @notice Enables a fee amount with the given tickSpacing\r\n    /// @dev Fee amounts may never be removed once enabled\r\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\r\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\r\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\r\n}\r\n"
    },
    "src/abstract/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.21;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n///\r\n/// @dev Note:\r\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\r\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\r\n///\r\n/// While the ownable portion follows\r\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\r\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\r\n//slither-disable-start assembly\r\nabstract contract Ownable {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The caller is not authorized to call the function.\r\n    error Unauthorized();\r\n\r\n    /// @dev The `newOwner` cannot be the zero address.\r\n    error NewOwnerIsZeroAddress();\r\n\r\n    /// @dev The `pendingOwner` does not have a valid handover request.\r\n    error NoHandoverRequest();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n    /// despite it not being as lightweight as a single argument event.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The owner slot is given by:\r\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\r\n    /// It is intentionally chosen to be a high value\r\n    /// to avoid collision with lower slots.\r\n    /// The choice of manual storage layout is to enable compatibility\r\n    /// with both regular and upgradeable contracts.\r\n    bytes32 internal constant _OWNER_SLOT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                     INTERNAL FUNCTIONS                     */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Initializes the owner directly without authorization guard.\r\n    /// This function must be called upon initialization,\r\n    /// regardless of whether the contract is upgradeable or not.\r\n    /// This is to enable generalization to both regular and upgradeable contracts,\r\n    /// and to save gas in case the initial owner is not the caller.\r\n    /// For performance reasons, this function will not check if there\r\n    /// is an existing owner.\r\n    function _initializeOwner(address newOwner) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Store the new value.\r\n            sstore(_OWNER_SLOT, newOwner)\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner directly without authorization guard.\r\n    function _setOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ownerSlot := _OWNER_SLOT\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n            // Store the new value.\r\n            sstore(ownerSlot, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Throws if the sender is not the owner.\r\n    function _checkOwner() internal view virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the caller is not the stored owner, revert.\r\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\r\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(shl(96, newOwner)) {\r\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows the owner to renounce their ownership.\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   PUBLIC READ FUNCTIONS                    */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_OWNER_SLOT)\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                         MODIFIERS                          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Marks a function as only callable by the owner.\r\n    modifier onlyOwner() virtual {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n}\r\n\r\n//slither-disable-end assembly\r\n"
    }
  }
}}