{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/IssuerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IIssuerRegistry, Issuer, PublicKey, PublicKeyStatus, SignatureState } from \"./interfaces/IIssuerRegistry.sol\";\n\n// IssuerRegistry is a contract that manages the issuers and their public keys and signature state.\ncontract IssuerRegistry is IIssuerRegistry {\n    error IssuerAlreadyExists();\n    error IssuerNotExists();\n    error PublicKeyNotExists();\n    error PublicKeyAlreadyExists();\n    error NotIssuerOwner(address owner);\n    error NotOwner();\n    error InvalidName();\n\n    /// @dev all issuers, isser id = uint256(caller)\n    // mapping issuer id to issuer.\n    mapping(uint256 isserId => Issuer issuer) private _issuers;\n\n    // (issuerId, publickeyId) => PublicKey\n    mapping(uint256 issuerId => mapping(uint256 publicKeyId => PublicKey publicKey)) private _issuerPublicKeys;\n\n    // mapping of hash(credentialType, contextId, issuerId) => SignatureState.\n    mapping(uint256 credHashValue => SignatureState sigStatus) private _revocableSigStates;\n\n    /// @dev only issuer owner can call this function\n    modifier onlyIssuerAdmin(uint256 issuerId) {\n        _onlyIssuerAdmin(issuerId);\n        _;\n    }\n\n    /// @dev only issuer owner can call this function\n    function _onlyIssuerAdmin(uint256 issuerId) private view {\n        if (!_issuerExists(issuerId)) {\n            revert IssuerNotExists();\n        }\n        if (msg.sender != _issuers[issuerId].admin) {\n            revert NotIssuerOwner(_issuers[issuerId].admin);\n        }\n    }\n\n    /// @dev register a new issuer\n    // @notice the issuerId is the address of the caller, so 1 address can only have 1 issuer.\n    function registerIssuer(\n        string calldata name,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external override returns (uint256) {\n        uint256 issuerId = uint256(uint160(msg.sender));\n        // register new issuer\n        _registerNewIssuer(issuerId, name);\n        // add public key\n        _setPublicKey(issuerId, verificationStackId, publicKeyId, publicKeyRaw);\n        // transfer ownership\n        return issuerId;\n    }\n\n    /// @dev transfer the admin of the issuer\n    function transferIssuerAdmin(uint256 issuerId, address newOwner) external override onlyIssuerAdmin(issuerId) {\n        _issuers[issuerId].admin = newOwner;\n        emit IssuerAdminTransferred(issuerId, msg.sender, newOwner);\n    }\n\n    /// @dev add a new public key to the issuer.\n    // @param issuerId the id of the issuer\n    // @param verificationStackId the id of the verification stack\n    // @param publicKeyId the id of the public key\n    // @param publicKeyRaw the raw public key\n    // @notice only the issuer admin can call this function\n    // @notice the public key can only be added once, if incorrect, use a new key.\n    function addPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyAlreadyExists();\n        }\n        _setPublicKey(issuerId, verificationStackId, publicKeyId, publicKeyRaw);\n    }\n\n    /// @dev update the status of the public key.\n    function updatePublicKeyStatus(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        PublicKeyStatus status\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n\n        _issuerPublicKeys[issuerId][publicKeyId].status = status;\n        emit PublicKeyStatusUpdated(issuerId, publicKeyId, status);\n    }\n\n    /// @dev update the status of the public key.\n    function updatePublicKeyVerificationStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId,\n        bool enabled\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n\n        _issuerPublicKeys[issuerId][publicKeyId].enabledVerificationStacks[verificationStackId] = enabled;\n        emit PublicKeyVerificationStackUpdated(issuerId, publicKeyId, verificationStackId, enabled);\n    }\n\n    /// @dev set the signature state URI\n    function updateSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key].treeURI = treeURI;\n        emit SignatureStateURIUpdated(typeId, contextId, issuerId, treeURI);\n    }\n\n    /// @dev set the signature state root\n    function updateSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        bytes32 root\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key].root = root;\n        emit SignatureStateRootUpdated(typeId, contextId, issuerId, root);\n    }\n\n    /// @dev set both the signature state URI and root.\n    function setSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI,\n        bytes32 root\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key] = SignatureState({ treeURI: treeURI, root: root });\n        emit SignatureStateURIUpdated(typeId, contextId, issuerId, treeURI);\n        emit SignatureStateRootUpdated(typeId, contextId, issuerId, root);\n    }\n\n    /// @dev calculate the hash of the credential, which is the key of the revocableSigStates.\n    function _calculateCredentialHash(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) private pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(typeId, contextId, issuerId)));\n    }\n\n    /// @dev register a new issuer\n    // @param issuerId the id of the issuer\n    // @param name the name of the issuer\n    function _registerNewIssuer(uint256 issuerId, string calldata name) private {\n        if (bytes(name).length == 0) {\n            revert InvalidName();\n        }\n        if (_issuerExists(issuerId)) {\n            revert IssuerAlreadyExists();\n        }\n\n        _issuers[issuerId] = Issuer({ name: name, admin: msg.sender });\n        emit IssuerRegistered(issuerId, name);\n        emit IssuerAdminTransferred(issuerId, address(0), msg.sender);\n    }\n\n    /// @dev add a new public key to the issuer\n    // @param issuerId the id of the issuer\n    // @param verificationStackId the id of the verification stack\n    // @param publicKeyId the id of the public key\n    // @param publicKeyRaw the raw public key\n    function _setPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) private {\n        mapping(uint256 => PublicKey) storage keys = _issuerPublicKeys[issuerId];\n        keys[publicKeyId].enabledVerificationStacks[verificationStackId] = true;\n        keys[publicKeyId].status = PublicKeyStatus.ACTIVE;\n        keys[publicKeyId].raw = publicKeyRaw;\n\n        emit PublicKeyStatusUpdated(issuerId, publicKeyId, PublicKeyStatus.ACTIVE);\n        emit PublicKeyVerificationStackUpdated(issuerId, publicKeyId, verificationStackId, true);\n    }\n\n    /// @dev return the issuer, if not exists, revert.\n    function getIssuer(uint256 issuerId) external view override returns (Issuer memory) {\n        if (!_issuerExists(issuerId)) {\n            revert IssuerNotExists();\n        }\n        return _issuers[issuerId];\n    }\n\n    /// @dev return the public key, if not exists, revert.\n    function getPublicKeyRaw(uint256 issuerId, uint256 publicKeyId) external view override returns (bytes memory) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n        return _issuerPublicKeys[issuerId][publicKeyId].raw;\n    }\n\n    /// @dev return if public key is active. If public key is not exists, return false.\n    function isPublicKeyActive(uint256 issuerId, uint256 publicKeyId) external view override returns (bool) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            return false;\n        }\n        return _issuerPublicKeys[issuerId][publicKeyId].status == PublicKeyStatus.ACTIVE;\n    }\n\n    /// @dev return if public key is active for the verification stack. If public key is not exists, return false.\n    function isPublicKeyActiveForStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId\n    ) external view override returns (bool) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            return false;\n        }\n        return\n            _issuerPublicKeys[issuerId][publicKeyId].enabledVerificationStacks[verificationStackId] &&\n            _issuerPublicKeys[issuerId][publicKeyId].status == PublicKeyStatus.ACTIVE;\n    }\n\n    /// @dev return the status of the public key, if not exists, returns UNINITIALIZED.\n    function getSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (SignatureState memory) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)];\n    }\n\n    /// @dev return the status of the public key, if not exists, returns empty string.\n    function getSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (string memory) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)].treeURI;\n    }\n\n    /// @dev return the root of the signature state, if not exists, returns empty bytes.\n    function getSignatureStateRoot(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (bytes32) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)].root;\n    }\n\n    /// @dev internal function to check if the public key exists.\n    function _publicKeyExists(uint256 issuerId, uint256 publicKeyId) internal view returns (bool) {\n        return _issuerPublicKeys[issuerId][publicKeyId].status != PublicKeyStatus.UNINITIALIZED;\n    }\n\n    /// @dev internal function to check if the issuer exists.\n    function _issuerExists(uint256 issuerId) internal view returns (bool) {\n        return bytes(_issuers[issuerId].name).length != 0;\n    }\n}\n"
    },
    "contracts/interfaces/IIssuerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @dev The status of the public key, only active public key can be used for verification.\nenum PublicKeyStatus {\n    UNINITIALIZED,\n    REVOKED,\n    ACTIVE\n}\n\n/// @dev The public key struct\nstruct PublicKey {\n    /// @dev the verification stack id that the public key is enabled for.\n    mapping(uint8 => bool) enabledVerificationStacks;\n    /// @dev the status of the public key\n    PublicKeyStatus status;\n    /// @dev the raw bytes of the public key. Not used in the contract, only for off-chain usage.\n    /// The spec for marshalling the public key is defined by the issuer.\n    bytes raw;\n}\n\n/// @dev The revoked signature ID in a sparsed merkle tree.\nstruct SignatureState {\n    /// @dev the root hash of the sparsed merkle tree.\n    bytes32 root;\n    /// @dev uri to the sparsed merkle tree, representing the revoked signature ids.\n    string treeURI;\n}\n\n/// @dev The issuer struct\nstruct Issuer {\n    /// @dev the name of the issuer\n    string name;\n    /// @dev the admin of the issuer, who can add or revoke public keys.\n    address admin;\n}\n\n/// @title IIssuerRegistry\n/// @dev The interface for the issuer registry contract.\ninterface IIssuerRegistry {\n    /// @notice Emitted when a new issuer is registered in the registry.\n    /// @param issuerId Unique identifier for the newly registered issuer.\n    /// @param name Name of the issuer registered.\n    event IssuerRegistered(uint256 indexed issuerId, string name);\n\n    /// @notice Emitted when an issuer's administrative role is transferred to a new address.\n    /// @param issuerId ID of issuer whose admin is being transferred.\n    /// @param oldAdmin Address of the current admin being replaced.\n    /// @param newAdmin Address of the new admin taking over.\n    event IssuerAdminTransferred(uint256 indexed issuerId, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Emitted when the status of a public key is updated.\n    /// @param issuerId ID for the issuer to whom the public key belongs.\n    /// @param publicKeyId ID for the public key being updated.\n    /// @param status New status of the public key.\n    event PublicKeyStatusUpdated(uint256 indexed issuerId, uint256 indexed publicKeyId, PublicKeyStatus status);\n\n    /// @notice Emitted when the verification stack for a public key is updated.\n    /// @param issuerId Unique identifier for the issuer to whom the public key belongs.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack being updated.\n    /// @param enabled Boolean indicating whether the stack is enabled or disabled for the public key.\n    event PublicKeyVerificationStackUpdated(\n        uint256 indexed issuerId,\n        uint256 indexed publicKeyId,\n        uint256 indexed verificationStackId,\n        bool enabled\n    );\n\n    /// @notice Emitted when the signature state URI is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newTreeURI New URI for the signature state tree.\n    event SignatureStateURIUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        string newTreeURI\n    );\n\n    /// @notice Emitted when the signature state root is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newRoot New root hash for the signature state tree.\n    event SignatureStateRootUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        bytes32 newRoot\n    );\n\n    /// @dev Registers a new issuer along with their first public key and enabled verification stack.\n    /// @param name Name of the issuer to register.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId  Identifier for the issuer's public key.\n    /// @param publicKeyRaw The raw public key data.\n    /// @return The unique identifier for the newly registered issuer.\n    function registerIssuer(\n        string calldata name,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external returns (uint256);\n\n    /// @dev Transfers the administrative role of an issuer to a new owner.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param newOwner Address of the new administrator.\n    function transferIssuerAdmin(uint256 issuerId, address newOwner) external;\n\n    /// @dev Adds a new public key for an issuer and enables it for a specified verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId Unique identifier for the new public key.\n    /// @param publicKeyRaw The raw public key data.\n    function addPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external;\n\n    /// @dev Updates the status (active/revoked) of an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param status New status for the public key.\n    // only the issuer admin can call this function\n    function updatePublicKeyStatus(uint256 issuerId, uint256 publicKeyId, PublicKeyStatus status) external;\n\n    /// @dev Updates the verification stack association for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId New verification stack identifier for the public key.\n    /// @param enabled Boolean indicating whether the stack is enabled for the public key.\n    function updatePublicKeyVerificationStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId,\n        bool enabled\n    ) external;\n\n    /// @dev Updates the signature state URI for a given type and context.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    function updateSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI\n    ) external;\n\n    /// @dev Updates the signature SMT root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param root New root hash for the revoked SMT.\n    function updateSignatureState(uint160 typeId, uint160 contextId, uint256 issuerId, bytes32 root) external;\n\n    /// @dev Sets both the signature SMT URI and root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    /// @param root New root hash for the signature state.\n    function setSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI,\n        bytes32 root\n    ) external;\n\n    /// @dev Retrieves the issuer data, reverts if the issuer does not exist.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return Issuer data structure containing issuer details.\n    function getIssuer(uint256 issuerId) external view returns (Issuer memory);\n\n    /// @dev Retrieves the raw public key data for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return The raw public key data.\n    function getPublicKeyRaw(uint256 issuerId, uint256 publicKeyId) external view returns (bytes memory);\n\n    /// @dev Checks if an issuer's public key is active.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return True if the public key is active, false otherwise.\n    function isPublicKeyActive(uint256 issuerId, uint256 publicKeyId) external view returns (bool);\n\n    /// @dev Checks if an issuer's public key is active and enabled for a specific verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @return True if the public key is active and enabled for the stack, false otherwise.\n    function isPublicKeyActiveForStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId\n    ) external view returns (bool);\n\n    /// @dev Retrieves the signature state for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The signature state.\n    function getSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (SignatureState memory);\n\n    /// @dev Retrieves the signature state URI for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The URI of the signature state.\n    function getSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (string memory);\n\n    /// @dev Retrieves the signature state root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The root hash of the signature state.\n    function getSignatureStateRoot(uint160 typeId, uint160 contextId, uint256 issuerId) external view returns (bytes32);\n}\n"
    }
  }
}}