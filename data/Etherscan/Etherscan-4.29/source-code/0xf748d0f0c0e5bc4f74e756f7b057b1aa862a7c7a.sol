{"ChickenGenius.sol":{"content":"/*\r\nCHICKEN GENIUS\r\nTG: https://t.me/ChickenGenius\r\nX: https://twitter.com/ChicknGeniusERC\r\nWebsite: https://chickengenius.xyz/\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.25;\r\n\r\nimport {IERC20} from \"./IERC20.sol\";\r\nimport {Ownable} from \"./Ownable.sol\";\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\nimport {IDEXRouter} from \"./IDEXRouter.sol\";\r\nimport {IDEXFactory} from \"./IDEXFactory.sol\";\r\n\r\ncontract CHICKENGENIUS is Ownable, IERC20 {\r\n    using SafeMath for uint256;\r\n    \r\n    address WETH;\r\n\r\n    mapping (address =\u003e uint256) _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\r\n\r\n    string _name = \"Chicken Genius\";\r\n    string _symbol = \"PAKPAKCHICKEN\";\r\n    uint8 constant _decimals = 9;\r\n    uint256 public _totalSupply = 690000000000 * (10 ** _decimals);\r\n    uint256 public _maxWallet = _totalSupply.mul(5).div(100); \r\n    uint256 public _maxTxAmount = _totalSupply.mul(5).div(100);\r\n\r\n    address private marketing;\r\n\r\n    mapping (address =\u003e bool) excludeFee;\r\n    mapping (address =\u003e bool) excludeMaxTxn;\r\n    \r\n    uint256 public totalTrade = 0;\r\n\tuint256 public finalBuyTax = 0;\r\n\tuint256 public finalSellTax = 0;\r\n\r\n\tuint256 public initialBuyTax = 10;\r\n\tuint256 public initialSellTax = 10;\r\n    uint256 feeDenominator = 100;\r\n    \r\n    uint256 public resetTaxAfter = 100;\r\n    IDEXRouter public router;\r\n    address pair;\r\n\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply.mul(25).div(100000); // 0.025%\r\n    bool inSwap;\r\n    \r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () {\r\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        WETH = router.WETH();\r\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\r\n        _allowances[address(this)][address(router)] = ~uint256(0);\r\n\r\n        address owner_ = msg.sender;\r\n        marketing = owner_;\r\n\r\n        excludeMaxTxn[owner_] = true;\r\n        excludeMaxTxn[pair] = true;\r\n        excludeMaxTxn[address(this)] = true;\r\n        \r\n        excludeFee[owner_] = true;\r\n        excludeFee[address(this)] = true;\r\n        \r\n        _balances[owner_] = _totalSupply;\r\n        emit Transfer(address(0), owner_, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external view override returns (string memory) { return _symbol; }\r\n    function name() external view override returns (string memory) { return _name; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\t\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, ~uint256(0));\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != ~uint256(0)){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal  returns (bool) {\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n        \r\n        checkTxLimit(sender, recipient, amount);\r\n\r\n        if(canSwap())\r\n            swapBack();\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        uint256 amountReceived = takeFee(sender, recipient, amount);\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {\r\n        require(amount \u003c= _maxTxAmount || excludeMaxTxn[sender] || excludeMaxTxn[recipient], \"TX Limit Exceeded\");\r\n        uint256 currentBalance = balanceOf(recipient);\r\n        require(excludeMaxTxn[recipient] || (currentBalance + amount \u003c= _maxWallet));\r\n    }\r\n\r\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if (excludeFee[sender] || excludeFee[recipient]) \r\n            return amount;\r\n        \r\n        uint256 totalFee;\r\n        uint256 currentBuyTax = initialBuyTax;\r\n        uint256 currentSellTax = initialSellTax;\r\n\r\n        if(totalTrade \u003e resetTaxAfter){\r\n            currentBuyTax = finalBuyTax;\r\n            currentSellTax = finalSellTax;\r\n\r\n            _maxWallet = _totalSupply;\r\n            _maxTxAmount = _totalSupply;\r\n        }\r\n\r\n        if(sender == pair)\r\n            totalFee = currentBuyTax;\r\n        else\r\n            totalFee = currentSellTax;\r\n        totalTrade++;\r\n            \r\n        uint256 feeAmount = amount.mul(totalFee).div(feeDenominator);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function removeLimit() external onlyOwner {\r\n        //Trigger Set Tax to 0/0 and Remove The Limit\r\n        totalTrade = 10000;\r\n    }\r\n\r\n    function canSwap() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        \u0026\u0026 !inSwap\r\n        \u0026\u0026 swapEnabled\r\n        \u0026\u0026 _balances[address(this)] \u003e= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 swapAmount = _balances[address(this)];\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WETH;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            swapAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        \r\n        uint256 amountMarketing = address(this).balance;\r\n        payable(marketing).transfer(amountMarketing);\r\n    }\r\n}"},"IDEXFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.5.0;\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}"},"IDEXRouter.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.6.2;\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\r\npragma solidity ^0.8.20;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}"}}