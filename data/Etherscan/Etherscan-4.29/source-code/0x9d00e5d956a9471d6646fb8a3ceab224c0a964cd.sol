{"BlockedList.sol":{"content":"pragma solidity ^0.7.0;\n\n//SPDX-License-Identifier: MIT\nimport \"./OwnableIf.sol\";\nimport \"./ccTokenControllerIf.sol\";\n/// @title BlockedList - Maintian the BlockedList, only the owner can add or remove BlockedList addresses.\nabstract contract BlockedList is OwnableIf, ERC20ControllerViewIf {\n    mapping(address =\u003e bool) public blockedList;\n\n    event Blocked(\n        address indexed _who,\n        bool indexed status\n    );\n\n    function _block(address _who, bool _blocked) public onlyOwner {\n        require(_who != (address)(0x0), \"0 address\");\n        blockedList[_who] = _blocked;\n        emit Blocked(_who, _blocked);\n    }\n\n    function blocked(address _who) override view public returns (bool){\n        return blockedList[_who];\n    }\n}\n"},"BurnableToken.sol":{"content":"pragma solidity ^0.7.0;\n\n//SPDX-License-Identifier: MIT\n\nimport \"./ERC20Basic.sol\";\n\n/// @title BurnableToken\ncontract BurnableToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    event Burn(address indexed burner, uint256 value);\n\n    function burn(uint256 _value) public returns (bool){\n        address _who = msg.sender;\n        require(_value \u003c= balances[_who]);\n\n        balances[_who] = balances[_who].sub(_value);\n        totalSupply_ = totalSupply_.sub(_value);\n        emit Burn(_who, _value);\n        emit Transfer(_who, address(0), _value);\n\n        return true;\n    }\n}\n"},"CanReclaimToken.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ERC20If.sol\";\nimport \"./OwnableIf.sol\";\n\n/// @title CanReclaimToken\nabstract contract CanReclaimToken is OwnableIf {\n\n    function reclaimToken(ERC20If _token) external onlyOwner {\n        uint256 balance = _token.balanceOf((address)(this));\n        require(_token.transfer(_owner(), balance));\n    }\n\n}\n\n"},"ccBCH.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ccToken.sol\";\n\n/// @title ccBCH\ncontract ccBCH is ccToken {\n    constructor() ccToken(\"Cross-Chain BCH\", \"ccBCH\", 8, (ERC20ControllerViewIf)(0)){}\n}\n"},"ccBTC.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ccToken.sol\";\n\n/// @title ccBTC\ncontract ccBTC is ccToken {\n    constructor() ccToken(\"Cross-Chain BTC\", \"ccBTC\", 8, (ERC20ControllerViewIf)(0)){}\n}\n"},"ccToken.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ccTokenControllerIf.sol\";\nimport \"./NamedERC20.sol\";\nimport \"./MintableERC20.sol\";\nimport \"./BurnableToken.sol\";\nimport \"./Claimable.sol\";\nimport \"./CanReclaimToken.sol\";\n\n/// @title ccToken\ncontract ccToken is NamedERC20, Claimable, MintableERC20, BurnableToken, CanReclaimToken {\n    using SafeMath for uint256;\n\n    ERC20ControllerViewIf public erc20Controller;\n    constructor(string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        ERC20ControllerViewIf _erc20Controller\n    ) NamedERC20(_name, _symbol, _decimals){\n        erc20Controller = _erc20Controller;\n    }\n\n    function hasController() view public returns (bool){\n        return (address)(erc20Controller) != (address)(0);\n    }\n\n    function _notPaused() override internal view returns (bool){\n        if (hasController()) {\n            return !erc20Controller.paused();\n        }\n        return true;\n    }\n\n    function _notBlocked(address _who) override internal view returns (bool){\n        if (hasController()) {\n            return !erc20Controller.blocked(_who);\n        }\n        return true;\n    }\n\n    function setController(ERC20ControllerViewIf newController) public onlyOwner {\n        erc20Controller = newController;\n    }\n\n    event BurnBlocked(address indexed burner, uint256 value);\n\n    function burnBlocked(address addrBlocked, uint256 amount) public onlyOwner returns (bool){\n        address _who = addrBlocked;\n        require(!_notBlocked(_who), \"addr not blocked\");\n\n        uint256 _value = amount;\n        if (_value \u003e balances[_who]) {\n            _value = balances[_who];\n        }\n\n        balances[_who] = balances[_who].sub(_value);\n        totalSupply_ = totalSupply_.sub(_value);\n        emit BurnBlocked(_who, _value);\n        emit Transfer(_who, address(0), _value);\n\n        return true;\n    }\n\n}\n"},"ccTokenController.sol":{"content":"pragma solidity ^0.7.0;\n\n//SPDX-License-Identifier: MIT\nimport \"./Claimable.sol\";\nimport \"./ccToken.sol\";\nimport \"./BlockedList.sol\";\nimport \"./ccTokenControllerIf.sol\";\nimport \"./MemberMgrIf.sol\";\nimport \"./MintFactory.sol\";\nimport \"./CanReclaimToken.sol\";\n\n/// @title ccTokenController\ncontract ccTokenController is ccTokenControllerIf, Claimable, BlockedList, CanReclaimToken {\n    ccToken public token;\n    MemberMgrIf public members;\n    address public factory;\n\n    function getToken() view override external returns (ERC20If){\n        return token;\n    }\n\n    function requireCustodian(address _who) override public view {\n        members.requireCustodian(_who);\n    }\n\n    function requireMerchant(address _who) override public view {\n        members.requireMerchant(_who);\n    }\n\n    event MembersSet(MemberMgrIf indexed members);\n\n    function setMembers(MemberMgrIf _members) external onlyOwner returns (bool) {\n        require((address)(_members) != address(0), \"invalid _members address\");\n        members = _members;\n        emit MembersSet(members);\n        return true;\n    }\n\n    event FactorySet(address indexed factory);\n\n    function setFactory(address _factory) external onlyOwner returns (bool) {\n        require(_factory != address(0), \"invalid _factory address\");\n        factory = _factory;\n        emit FactorySet(factory);\n        return true;\n    }\n\n    event Paused(bool indexed status);\n\n    bool public _paused = false;\n\n    constructor(ccToken _token){\n        token = _token;\n        factory = (address)(new MintFactory());\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"sender not authorized for minting or burning.\");\n        _;\n    }\n\n    function transferOwnershipOfOwned(address _newOwner, Ownable owned) public onlyOwner {\n        owned.transferOwnership(_newOwner);\n    }\n\n    function reclaimTokenOfOwned(ERC20If _token, CanReclaimToken owned) external onlyOwner {\n        owned.reclaimToken(_token);\n    }\n\n    function claimOwnershipOfToken() public onlyOwner {\n        token.claimOwnership();\n        token.setController((ERC20ControllerViewIf)(this));\n    }\n\n    function paused() override public view returns (bool){\n        return _paused;\n    }\n\n    function setPaused(bool status) public onlyOwner {\n        _paused = status;\n        emit Paused(status);\n    }\n\n    // only factory actions on token\n    function mint(address to, uint amount) override external onlyFactory returns (bool) {\n        require(to != address(0), \"invalid to address\");\n        require(!paused(), \"paused.\");\n        require(token.mint(to, amount), \"minting failed.\");\n        return true;\n    }\n\n    function burn(uint value) override external onlyFactory returns (bool) {\n        require(!paused(), \"token is paused.\");\n        require(token.burn(value));\n        return true;\n    }\n\n    function burnBlocked(address addrBlocked, uint256 amount) public onlyOwner returns (bool){\n        require(token.burnBlocked(addrBlocked,amount), \"burnBlocked failed\");\n        return true;\n    }\n\n}\n\n"},"ccTokenControllerIf.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./MemberMgrIf.sol\";\nimport \"./ERC20If.sol\";\n/// @title ERC20ControllerViewIf\nabstract contract ERC20ControllerViewIf {\n    function blocked(address _who) virtual public view returns (bool);\n\n    function paused() virtual public view returns (bool);\n}\n\n/// @title ccTokenControllerIf\nabstract contract ccTokenControllerIf is MemberMgrIf, ERC20ControllerViewIf {\n    function mint(address to, uint amount) virtual external returns (bool);\n\n    function burn(uint value) virtual external returns (bool);\n\n    function getToken() virtual external returns (ERC20If);\n}\n"},"Claimable.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Ownable.sol\";\n\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n    address public pendingOwner;\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingOwner.\n     */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"no permission\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to set the pendingOwner address.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) override public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n     * @dev Allows the pendingOwner address to finalize the transfer.\n     */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n"},"ERC20Basic.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ERC20If.sol\";\nimport \"./SafeMathLib.sol\";\n\n/// @title ERC20Basic\ncontract ERC20Basic is ERC20If {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) internal balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal allowed;\n\n    uint256 internal totalSupply_;\n\n    function _notPaused() virtual internal view returns (bool){return false;}\n\n    function _notBlocked(address) virtual internal view returns (bool){return false;}\n\n    modifier notPaused() {\n        require(_notPaused(), \"contract has been paused\");\n        _;\n    }\n\n    modifier notBlocked() {\n        require(_notBlocked(msg.sender), \"sender has been blocked\");\n        _;\n    }\n\n    function totalSupply() override public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function transfer(address _to, uint256 _value) override public notPaused notBlocked returns (bool) {\n        require(_notBlocked(_to), \"to-address has been blocked\");\n        require(_value \u003c= balances[msg.sender], \"insufficient balance\");\n        require(_to != address(0), \"invalid to-address\");\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    override public notPaused notBlocked\n    returns (bool)\n    {\n        require(_notBlocked(_from), \"from-address has been blocked\");\n        require(_notBlocked(_to), \"to-address has been blocked\");\n        require(_value \u003c= balances[_from], \"insufficient balance\");\n        require(_to != address(0), \"invalid to-address\");\n        if (_from == msg.sender){\n            balances[_from] = balances[_from].sub(_value);\n            balances[_to] = balances[_to].add(_value);\n            return true;\n        }\n\n        require(_value \u003c= allowed[_from][msg.sender], \"value \u003e allowed\");\n\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value)\n    override public notPaused notBlocked\n    returns (bool) {\n        require(_notBlocked(_spender), \"spender-address has been blocked\");\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n    public notPaused notBlocked\n    returns (bool)\n    {\n        require(_notBlocked(_spender), \"spender-address has been blocked\");\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint _subtractedValue\n    )\n    public\n    notPaused notBlocked\n    returns (bool success)\n    {\n        require(_notBlocked(_spender), \"spender-address has been blocked\");\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue \u003e= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    )\n    override\n    public\n    view\n    returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n}\n"},"ERC20If.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/// @title ERC20If\nabstract contract ERC20If {\n    function totalSupply() virtual public view returns (uint256);\n\n    function balanceOf(address _who) virtual public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function allowance(address _owner, address _spender) virtual public view returns (uint256);\n\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool);\n\n    function approve(address _spender, uint256 _value) virtual public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n"},"MemberMgr.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./MemberMgrIf.sol\";\nimport \"./Claimable.sol\";\nimport \"./CanReclaimToken.sol\";\n\n/// @title MemberMgr - add, delete, suspend and resume merchant and it’s eth address; reset the custodian’s eth address.\ncontract MemberMgr is Claimable, MemberMgrIf, CanReclaimToken {\n    address public custodian;\n    enum MerchantStatus {STOPPED, VALID}\n    struct MerchantStatusData {\n        MerchantStatus status;\n        bool _exist;\n    }\n\n    function getStatusString(MerchantStatusData memory data) internal pure returns (string memory) {\n        if (!data._exist) return \"not-exist\";\n        if (data.status == MerchantStatus.STOPPED) {\n            return \"stopped\";\n        } else if (data.status == MerchantStatus.VALID) {\n            return \"valid\";\n        } else {\n            return \"not-exist\";\n        }\n    }\n\n    mapping(address =\u003e MerchantStatusData) public merchantStatus;\n    address[] merchantList;\n\n    function getMerchantNumber() public view returns (uint){\n        return merchantList.length;\n    }\n\n    function getMerchantState(uint index) public view returns (address _addr, string memory _status){\n        require(index \u003c merchantList.length, \"invalid index\");\n        address addr = merchantList[index];\n        MerchantStatusData memory data = merchantStatus[addr];\n        _addr = addr;\n        _status = getStatusString(data);\n    }\n\n    function requireMerchant(address _who) override public view {\n        MerchantStatusData memory merchantState = merchantStatus[_who];\n        require (merchantState._exist, \"not a merchant\");\n\n        require (merchantState.status != MerchantStatus.STOPPED, \"merchant has been stopped\");\n\n        require(merchantState.status == MerchantStatus.VALID, \"merchant not valid\");\n    }\n\n\n    function requireCustodian(address _who) override public view {\n        require(_who == custodian, \"not custodian\");\n    }\n\n    event CustodianSet(address indexed custodian);\n\n    function setCustodian(address _custodian) external onlyOwner returns (bool) {\n        require(_custodian != address(0), \"invalid custodian address\");\n        custodian = _custodian;\n\n        emit CustodianSet(_custodian);\n        return true;\n    }\n\n    event NewMerchant(address indexed merchant);\n\n    function addMerchant(address merchant) external onlyOwner returns (bool) {\n        require(merchant != address(0), \"invalid merchant address\");\n        MerchantStatusData memory data = merchantStatus[merchant];\n        require(!data._exist, \"merchant exists\");\n        merchantStatus[merchant] = MerchantStatusData({\n            status : MerchantStatus.VALID,\n            _exist : true\n            });\n\n        merchantList.push(merchant);\n        emit NewMerchant(merchant);\n        return true;\n    }\n\n    event MerchantStopped(address indexed merchant);\n\n    function stopMerchant(address merchant) external onlyOwner returns (bool) {\n        require(merchant != address(0), \"invalid merchant address\");\n        MerchantStatusData memory data = merchantStatus[merchant];\n        require(data._exist, \"merchant not exists\");\n        require(data.status == MerchantStatus.VALID, \"invalid status\");\n        merchantStatus[merchant].status = MerchantStatus.STOPPED;\n\n        emit MerchantStopped(merchant);\n        return true;\n    }\n\n    event MerchantResumed(address indexed merchant);\n\n    function resumeMerchant(address merchant) external onlyOwner returns (bool) {\n        require(merchant != address(0), \"invalid merchant address\");\n        MerchantStatusData memory data = merchantStatus[merchant];\n        require(data._exist, \"merchant not exists\");\n        require(data.status == MerchantStatus.STOPPED, \"invalid status\");\n        merchantStatus[merchant].status = MerchantStatus.VALID;\n\n        emit MerchantResumed(merchant);\n        return true;\n    }\n\n    function isCustodian(address addr) external view returns (bool) {\n        return (addr == custodian);\n    }\n\n    function isMerchant(address addr) external view returns (bool) {\n        return merchantStatus[addr]._exist \u0026\u0026 merchantStatus[addr].status == MerchantStatus.VALID;\n    }\n}\n"},"MemberMgrIf.sol":{"content":"pragma solidity ^0.7.0;\n\n//SPDX-License-Identifier: MIT\n/// @title MemberMgrIf\nabstract contract MemberMgrIf {\n    function requireMerchant(address _who) virtual public view;\n\n    function requireCustodian(address _who) virtual public view;\n}\n"},"MintableERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ERC20Basic.sol\";\nimport \"./OwnableIf.sol\";\n\n/// @title MintableERC20\nabstract contract MintableERC20 is ERC20Basic, OwnableIf {\n    using SafeMath for uint256;\n\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished(bool indexed finished);\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished, \"can\u0027t mint\");\n        _;\n    }\n\n    modifier hasMintPermission() {\n        require(msg.sender == _owner(), \"no permission...\");\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n    public\n    hasMintPermission\n    canMint\n    notPaused\n    returns (bool)\n    {\n        require(_notBlocked(_to), \"to-address has been blocked\");\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Function to stop minting new tokens.\n     * @return True if the operation was successful.\n     */\n    function finishMinting(bool finished)\n    public\n    onlyOwner\n    returns (bool) {\n        mintingFinished = finished;\n        emit MintFinished(mintingFinished);\n        return true;\n    }\n}\n"},"MintFactory.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n//pragma experimental ABIEncoderV2;\nimport \"./Ownable.sol\";\nimport \"./ccTokenControllerIf.sol\";\nimport \"./MintFactoryIfView.sol\";\nimport \"./CanReclaimToken.sol\";\n\n/// @title MintFactory\ncontract MintFactory is Ownable, MintFactoryIfView, CanReclaimToken {\n    function getStatusString(RequestStatus status) internal pure returns (string memory) {\n        if (status == RequestStatus.PENDING) {\n            return \"pending\";\n        } else if (status == RequestStatus.CANCELED) {\n            return \"canceled\";\n        } else if (status == RequestStatus.APPROVED) {\n            return \"approved\";\n        } else if (status == RequestStatus.REJECTED) {\n            return \"rejected\";\n        } else {\n            // unreachable.\n            return \"unknown\";\n        }\n    }\n\n    function getMintRequest(uint seq) override\n    external\n    view\n    returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status,\n        bytes32 requestHash\n    )\n    {\n        require(seq \u003e 0, \"seq from 1\");\n        require(seq \u003c mintRequests.length, \"invalid seq\");\n        Request memory request = mintRequests[seq];\n        string memory statusString = getStatusString(request.status);\n\n        requestSeq = seq;\n        requester = request.requester;\n        amount = request.amount;\n        btcAddress = request.btcAddress;\n        btcTxId = request.btcTxId;\n        requestBlockNo = request.requestBlockNo;\n        confirmedBlockNo = request.confirmedBlockNo;\n        status = statusString;\n        requestHash = calcRequestHash(request);\n    }\n\n    function getMintRequestsLength() override external view returns (uint length) {\n        return mintRequests.length;\n    }\n\n    function getBurnRequest(uint seq) override\n    external\n    view\n    returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status,\n        bytes32 requestHash\n    )\n    {\n        require(seq \u003e 0, \"seq from 1\");\n        require(seq \u003c burnRequests.length, \"invalid seq\");\n        Request storage request = burnRequests[seq];\n        string memory statusString = getStatusString(request.status);\n\n        requestSeq = seq;\n        requester = request.requester;\n        amount = request.amount;\n        btcAddress = request.btcAddress;\n        btcTxId = request.btcTxId;\n        requestBlockNo = request.requestBlockNo;\n        confirmedBlockNo = request.confirmedBlockNo;\n        status = statusString;\n        requestHash = calcRequestHash(request);\n    }\n\n    function getBurnRequestsLength() override external view returns (uint length) {\n        return burnRequests.length;\n    }\n\n    constructor() {\n        controller = (ccTokenControllerIf)(owner);\n\n        Request memory request = Request({\n            requester : (address)(0),\n            amount : 0,\n            btcAddress : \"invalid.address\",\n            btcTxId : \"invalid.tx\",\n            seq : 0,\n            requestBlockNo : 0,\n            confirmedBlockNo : 0,\n            status : RequestStatus.REJECTED\n            });\n\n        mintRequests.push(request);\n        burnRequests.push(request);\n    }\n\n    modifier onlyMerchant() {\n        controller.requireMerchant(msg.sender);\n        _;\n    }\n\n    modifier onlyCustodian() {\n        controller.requireCustodian(msg.sender);\n        _;\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        }\n        for (uint i = 0; i \u003c bytes(a).length; i ++) {\n            if (bytes(a)[i] != bytes(b)[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function isEmptyString(string memory a) internal pure returns (bool) {\n        return (compareStrings(a, \"\"));\n    }\n\n    event CustodianBtcAddressForMerchantSet(address indexed merchant,\n        address indexed sender,\n        string btcDepositAddress);\n\n    function setCustodianBtcAddressForMerchant(\n        address merchant,\n        string  memory btcAddress\n    )\n    external\n    onlyCustodian\n    returns (bool)\n    {\n        require((address)(merchant) != address(0), \"invalid merchant address\");\n        controller.requireMerchant(merchant);\n        require(!isEmptyString(btcAddress), \"invalid btc address\");\n\n        custodianBtcAddressForMerchant[merchant] = btcAddress;\n        emit CustodianBtcAddressForMerchantSet(merchant, msg.sender, btcAddress);\n        return true;\n    }\n\n    event BtcDepositAddressOfMerchantSet(address indexed merchant,\n        string btcDepositAddress);\n\n    function setMerchantBtcDepositAddress(string  memory btcAddress)\n    external\n    onlyMerchant\n    returns (bool) {\n        require(!isEmptyString(btcAddress), \"invalid btc address\");\n\n        btcDepositAddressOfMerchant[msg.sender] = btcAddress;\n        emit BtcDepositAddressOfMerchantSet(msg.sender, btcAddress);\n        return true;\n    }\n\n    event NewMintRequest(\n        uint indexed seq,\n        address indexed requester,\n        string btcAddress,\n        string btcTxId,\n        uint blockNo,\n        bytes32 requestHash\n    );\n\n    function requestMint(\n        uint amount,\n        string memory btcTxId\n    )\n    external\n    onlyMerchant\n    returns (bool)\n    {\n        require(!isEmptyString(btcTxId), \"invalid btcTxId\");\n        require(!isEmptyString(custodianBtcAddressForMerchant[msg.sender]), \"invalid btc deposit address\");\n\n        uint seq = mintRequests.length;\n        uint blockNo = block.number;\n\n        Request memory request = Request({\n            requester : msg.sender,\n            amount : amount,\n            btcAddress : custodianBtcAddressForMerchant[msg.sender],\n            btcTxId : btcTxId,\n            seq : seq,\n            requestBlockNo : blockNo,\n            confirmedBlockNo : 0,\n            status : RequestStatus.PENDING\n            });\n\n        bytes32 requestHash = calcRequestHash(request);\n        mintRequestSeqMap[requestHash] = seq;\n        mintRequests.push(request);\n\n        emit NewMintRequest(seq, msg.sender, request.btcAddress, btcTxId, blockNo, requestHash);\n        return true;\n    }\n\n    function calcRequestHash(Request memory request) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                request.requester,\n                request.btcAddress,\n                request.btcTxId,\n                request.seq,\n                request.requestBlockNo\n            ));\n    }\n\n    event MintRequestCancel(uint indexed seq, address indexed requester, bytes32 requestHash);\n\n    function getPendingMintRequest(bytes32 _requestHash) view private returns (Request memory) {\n        uint seq = mintRequestSeqMap[_requestHash];\n        require(mintRequests.length \u003e seq, \"invalid seq\");\n        require(seq \u003e 0, \"invalid requestHash\");\n        Request memory request = mintRequests[seq];\n        require(request.status == RequestStatus.PENDING, \"status not pending.\");\n        require(_requestHash == calcRequestHash(request), \"invalid hash\");\n\n        return request;\n    }\n\n    function getPendingMintRequestV(bytes32 _requestHash) override view public returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status) {\n        Request memory request = getPendingMintRequest(_requestHash);\n\n        requestSeq = request.seq;\n        requester = request.requester;\n        amount = request.amount;\n        btcAddress = request.btcAddress;\n        btcTxId = request.btcTxId;\n        requestBlockNo = request.requestBlockNo;\n        confirmedBlockNo = request.confirmedBlockNo;\n        status = getStatusString(request.status);\n    }\n\n\n    function cancelMintRequest(bytes32 requestHash) external onlyMerchant returns (bool) {\n        Request memory request = getPendingMintRequest(requestHash);\n        uint seq = request.seq;\n        require(msg.sender == request.requester, \"cancel sender is different than pending request initiator\");\n\n        mintRequests[seq].status = RequestStatus.CANCELED;\n\n        emit MintRequestCancel(request.seq, msg.sender, calcRequestHash(request));\n        return true;\n    }\n\n    event MintConfirmed(\n        uint indexed seq,\n        address indexed requester,\n        uint amount,\n        string btcDepositAddress,\n        string btcTxid,\n        uint blockNo,\n        bytes32 requestHash\n    );\n\n    function confirmMintRequest(bytes32 requestHash) external onlyCustodian returns (bool) {\n        uint blockNo = block.number;\n        Request memory request = getPendingMintRequest(requestHash);\n        require(blockNo \u003e request.requestBlockNo, \"confirmMintRequest failed\");\n\n        require(blockNo - 20 \u003e= request.requestBlockNo, \"confirmMintRequest failed, wait for 20 blocks\");\n        uint seq = request.seq;\n        mintRequests[seq].status = RequestStatus.APPROVED;\n        uint amount = mintRequests[seq].amount;\n        mintRequests[seq].confirmedBlockNo = blockNo;\n\n        require(controller.mint(request.requester, amount), \"mint failed\");\n        emit MintConfirmed(\n            request.seq,\n            request.requester,\n            amount,\n            request.btcAddress,\n            request.btcTxId,\n            blockNo,\n            calcRequestHash(request)\n        );\n        return true;\n    }\n\n    event MintRejected(\n        uint indexed seq,\n        address indexed requester,\n        uint amount,\n        string btcDepositAddress,\n        string btcTxid,\n        uint blockNo,\n        bytes32 requestHash\n    );\n\n    function rejectMintRequest(bytes32 requestHash) external onlyCustodian returns (bool) {\n        Request memory request = getPendingMintRequest(requestHash);\n        uint seq = request.seq;\n\n        mintRequests[seq].status = RequestStatus.REJECTED;\n        uint blockNo = block.number;\n        mintRequests[seq].confirmedBlockNo = blockNo;\n\n        emit MintRejected(\n            request.seq,\n            request.requester,\n            request.amount,\n            request.btcAddress,\n            request.btcTxId,\n            blockNo,\n            calcRequestHash(request)\n        );\n        return true;\n    }\n\n    event Burned(\n        uint indexed seq,\n        address indexed requester,\n        uint amount,\n        string btcAddress,\n        uint blockNo,\n        bytes32 requestHash\n    );\n\n    function burn(uint amount) external onlyMerchant returns (bool) {\n        string memory btcDepositAddress = btcDepositAddressOfMerchant[msg.sender];\n        require(!isEmptyString(btcDepositAddress), \"merchant btc deposit address was not set\");\n\n        uint seq = burnRequests.length;\n        uint blockNo = block.number;\n\n        Request memory request = Request({\n            requester : msg.sender,\n            amount : amount,\n            btcAddress : btcDepositAddress,\n            btcTxId : \"\",\n            seq : seq,\n            requestBlockNo : blockNo,\n            confirmedBlockNo : 0,\n            status : RequestStatus.PENDING\n            });\n\n        bytes32 requestHash = calcRequestHash(request);\n        burnRequestSeqMap[requestHash] = seq;\n        burnRequests.push(request);\n\n        require(controller.getToken().transferFrom(msg.sender, (address)(controller), amount), \"trasnfer tokens to burn failed\");\n        require(controller.burn(amount), \"burn failed\");\n\n        emit Burned(seq, msg.sender, amount, btcDepositAddress, blockNo, requestHash);\n        return true;\n    }\n\n    event BurnConfirmed(\n        uint indexed seq,\n        address indexed requester,\n        uint amount,\n        string btcAddress,\n        string btcTxId,\n        uint blockNo\n    );\n\n    function confirmBurnRequest(bytes32 requestHash, string memory btcTxId) external onlyCustodian returns (bool) {\n        uint seq = burnRequestSeqMap[requestHash];\n        require(burnRequests.length \u003e seq, \"invalid seq\");\n        require(seq \u003e 0, \"invalid requestHash\");\n        Request memory request = burnRequests[seq];\n        require(requestHash == calcRequestHash(request), \"invalid requestHash\");\n        require(request.status == RequestStatus.PENDING, \"status not pending.\");\n\n        burnRequests[seq].btcTxId = btcTxId;\n        burnRequests[seq].status = RequestStatus.APPROVED;\n        uint blockNo = block.number;\n        burnRequests[seq].confirmedBlockNo = blockNo;\n        request.btcTxId = btcTxId;\n        burnRequestSeqMap[calcRequestHash(request)] = seq;\n\n        emit BurnConfirmed(\n            request.seq,\n            request.requester,\n            request.amount,\n            request.btcAddress,\n            btcTxId,\n            blockNo\n        );\n        return true;\n    }\n}\n"},"MintFactoryIfView.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n//pragma experimental ABIEncoderV2;\nimport \"./Ownable.sol\";\nimport \"./ccTokenControllerIf.sol\";\n\n/// @title MintFactoryIfView\nabstract contract MintFactoryIfView {\n    ccTokenControllerIf public controller;\n\n    mapping(address =\u003e string) public custodianBtcAddressForMerchant;\n\n    mapping(address =\u003e string) public btcDepositAddressOfMerchant;\n\n    enum RequestStatus {PENDING, CANCELED, APPROVED, REJECTED}\n    struct Request {\n        address requester;\n        uint amount;\n        string btcAddress;\n        string btcTxId;\n        uint seq;\n        uint requestBlockNo;\n        uint confirmedBlockNo;\n        RequestStatus status;\n    }\n\n    mapping(bytes32 =\u003e uint) public mintRequestSeqMap;\n\n    mapping(bytes32 =\u003e uint) public burnRequestSeqMap;\n\n    Request[] public mintRequests;\n\n    Request[] public burnRequests;\n\n    function getMintRequest(uint seq)\n    external\n    view\n    virtual\n    returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status,\n        bytes32 requestHash\n    );\n\n    function getMintRequestsLength() virtual external view returns (uint length);\n\n    function getBurnRequest(uint seq)\n    external\n    view\n    virtual\n    returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status,\n        bytes32 requestHash\n    );\n\n    function getBurnRequestsLength() virtual external view returns (uint length);\n\n    function getPendingMintRequestV(bytes32 _requestHash)\n    virtual\n    view public returns (\n        uint requestSeq,\n        address requester,\n        uint amount,\n        string memory btcAddress,\n        string memory btcTxId,\n        uint requestBlockNo,\n        uint confirmedBlockNo,\n        string  memory status);\n\n\n}\n"},"MultiSigWallet.sol":{"content":"pragma solidity ^0.7.0;\n\n//SPDX-License-Identifier: lgplv3\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author https://github.com/gnosis/MultiSigWallet\ncontract MultiSigWallet {\n\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    /*\n     *  Constants\n     */\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping(uint =\u003e Transaction) public transactions;\n    mapping(uint =\u003e mapping(address =\u003e bool)) public confirmations;\n    mapping(address =\u003e bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != (address)(0));\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != (address)(0));\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        require(ownerCount \u003c= MAX_OWNER_COUNT\n        \u0026\u0026 _required \u003c= ownerCount\n        \u0026\u0026 _required != 0\n        \u0026\u0026 ownerCount != 0);\n        _;\n    }\n    /// @dev Fallback function allows to deposit ether.\n    fallback() external payable\n    {\n        if (msg.value \u003e 0)\n            emit  Deposit(msg.sender, msg.value);\n    }\n\n    receive() external payable\n    {\n        if (msg.value \u003e 0)\n            emit Deposit(msg.sender, msg.value);\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    constructor(address[] memory _owners, uint _required)\n    validRequirement(_owners.length, _required)\n    {\n        for (uint i = 0; i \u003c _owners.length; i++) {\n            require(!isOwner[_owners[i]] \u0026\u0026 _owners[i] != (address)(0));\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n    public\n    onlyWallet\n    ownerDoesNotExist(owner)\n    notNull(owner)\n    validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n    public\n    onlyWallet\n    ownerExists(owner)\n    {\n        require (owners.length \u003e 1, \"owners.length must larger than 1\");\n        isOwner[owner] = false;\n        for (uint i = 0; i \u003c owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                owners.pop();\n                break;\n            }\n        //        owners.length -= 1;\n\n        if (required \u003e owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param newOwner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n    public\n    onlyWallet\n    ownerExists(owner)\n    ownerDoesNotExist(newOwner)\n    {\n        for (uint i = 0; i \u003c owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint _required)\n    public\n    onlyWallet\n    validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function submitTransaction(address destination, uint value, bytes memory data)\n    public\n    returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n    public payable\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit  Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n    public payable\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n                emit  Execution(transactionId);\n            else {\n                emit  ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    // call has been separated into its own function in order to take advantage\n    // of the Solidity\u0027s code generator to produce a loop that copies tx.data into memory.\n    function external_call(address destination, uint value, uint dataLength, bytes memory data) internal returns (bool) {\n        //return tx.destination.call.gas(gasleft()-34710).value(tx.value)(tx.data);\n        bool result;\n        uint __gas = gasleft() - 34710;\n        assembly {\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n        // 34710 is the value that solidity is currently emitting\n        // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n        // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n            result := call(\n            __gas,\n            destination,\n            value,\n            d,\n            dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n            x,\n            0                  // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n    public\n    view\n    returns (bool)\n    {\n        uint count = 0;\n        for (uint i = 0; i \u003c owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return transactionId Returns transaction ID.\n    function addTransaction(address destination, uint value, bytes memory data)\n    internal\n    notNull(destination)\n    returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination : destination,\n            value : value,\n            data : data,\n            executed : false\n            });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return count Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n    public\n    view\n    returns (uint count)\n    {\n        for (uint i = 0; i \u003c owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return count Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n    public\n    view\n    returns (uint count)\n    {\n        for (uint i = 0; i \u003c transactionCount; i++)\n            if (pending \u0026\u0026 !transactions[i].executed\n            || executed \u0026\u0026 transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n    public\n    view\n    returns (address[] memory)\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return _confirmations Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n    public\n    view\n    returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i = 0; i \u003c owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i = 0; i \u003c count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return _transactionIds Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n    public\n    view\n    returns (uint[] memory _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i = 0; i \u003c transactionCount; i++)\n            if (pending \u0026\u0026 !transactions[i].executed\n            || executed \u0026\u0026 transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i = from; i \u003c to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}\n"},"NamedERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/// @title NamedERC20\ncontract NamedERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n}\n"},"Ownable.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./OwnableIf.sol\";\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable is OwnableIf {\n    address public owner;\n\n    function _owner() view override public returns (address){\n        return owner;\n    }\n\n    //    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    //    /**\n    //     * @dev Throws if called by any account other than the owner.\n    //     */\n    //    modifier onlyOwner() {\n    //        require(msg.sender == owner);\n    //        _;\n    //    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    //   function renounceOwnership() public onlyOwner {\n    //     emit OwnershipRenounced(owner);\n    //     owner = address(0);\n    //   }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) virtual public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"invalid _newOwner\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n\n\n"},"OwnableIf.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract OwnableIf {\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner(), \"not owner......\");\n        _;\n    }\n\n    function _owner() view virtual public returns (address);\n}\n"},"SafeMathLib.sol":{"content":"\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}