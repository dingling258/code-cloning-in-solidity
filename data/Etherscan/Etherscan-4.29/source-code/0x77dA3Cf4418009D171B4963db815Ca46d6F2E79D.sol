{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/TypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { ITypeRegistry, CredentialType, CredentialTypeMiscConfig } from \"./interfaces/ITypeRegistry.sol\";\nimport { IProofVerifier } from \"./interfaces/IProofVerifier.sol\";\nimport { IPublicSignalGetter } from \"./interfaces/IPublicSignalGetter.sol\";\n\n/**\n * @title TypeRegistry\n * @dev A contract that allows the registration of credential types.\n *      Credential types are unique per creator and type name.\n * @notice Getters in this contract does not do any parameter validation,\n *         so callers should validate the inputs and outputs and uninitialized values will be zero.\n */\ncontract TypeRegistry is ITypeRegistry, Ownable {\n    error TypeAlreadyExists();\n    error TypeDoesNotExist();\n    error InvalidTypeName();\n    error NotTypeOwner();\n\n    /// @dev mapping from typeID to CredentialType.\n    mapping(uint160 typeId => CredentialType credType) private _credTypes;\n\n    /// @dev mapping from typeID to its verification stack's verifier.\n    /// @dev verifier typeID => verificationStackID => verifier\n    mapping(uint160 typeId => mapping(uint8 veriStackId => IProofVerifier verifier)) private _verifiers;\n\n    /// @dev mapping from typeID to its verification stack's intrinsic value .\n    /// @dev verifier typeID => verificationStackID => verifier\n    mapping(uint160 typeId => mapping(uint8 veriStackId => IPublicSignalGetter psGetter)) private _psGetters;\n\n    /// @param admin admin of the contract\n    constructor(address admin) {\n        transferOwnership(admin);\n    }\n\n    /// @notice set a primitive type, only callable by the admin.\n    /// @param typeId the type id of the primitive type\n    /// @param name name of the type\n    /// @param definition definition string\n    /// @param description description of the type\n    /// @param resourceURI mutable resource URI of the type\n    /// @param config misc config for the type\n    function setPrimitiveType(\n        uint160 typeId,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        CredentialTypeMiscConfig calldata config\n    ) external override onlyOwner {\n        // check if the type is already set by others.\n        // primitive type will have its creator as 0x0.\n        if (bytes(_credTypes[typeId].name).length != 0) {\n            revert TypeAlreadyExists();\n        }\n        if (bytes(name).length == 0) {\n            revert InvalidTypeName();\n        }\n        // save type info\n        _credTypes[typeId] = CredentialType({\n            revocable: config.revocable,\n            admin: address(0),\n            name: name,\n            definition: definition,\n            description: description,\n            resourceURI: resourceURI\n        });\n        emit TypeRegistered(typeId, address(0), name, definition, description, resourceURI);\n        // add verifier and public signal getter\n        _verifiers[typeId][config.verificationStackId] = config.verifier;\n        emit TypeVerifierUpdated(typeId, config.verificationStackId, address(config.verifier));\n        _psGetters[typeId][config.verificationStackId] = config.publicSignalGetter;\n        emit TypePublicSignalGetterUpdated(typeId, config.verificationStackId, address(config.publicSignalGetter));\n    }\n\n    /// @dev register a new type by msg.sender\n    /// @param name type name\n    /// @param definition type definition string, immutable\n    /// @param description description of the type, immutable\n    /// @param resourceURI resource URI of the type, mutable\n    /// @return typeID of the registered type\n    function registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) external override returns (uint160) {\n        return _registerType(revocable, name, definition, description, resourceURI);\n    }\n\n    /// @notice Register a new type by `msg.sender` with verifier and public signal getter set for a specific verification stack.\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param verifier verifier for the type\n    /// @param publicSignalGetter public signal getter for the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType1Step(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        uint8 verificationStackId,\n        IProofVerifier verifier,\n        IPublicSignalGetter publicSignalGetter\n    ) external override returns (uint160) {\n        uint160 typeId = _registerType(revocable, name, definition, description, resourceURI);\n        // add verifier and public signal getter\n        _verifiers[typeId][verificationStackId] = verifier;\n        emit TypeVerifierUpdated(typeId, verificationStackId, address(verifier));\n        _psGetters[typeId][verificationStackId] = publicSignalGetter;\n        emit TypePublicSignalGetterUpdated(typeId, verificationStackId, address(publicSignalGetter));\n        return typeId;\n    }\n\n    /// @dev register a new type by msg.sender\n    /// @param name type name\n    /// @param definition type definition string, immutable\n    /// @param description description of the type, immutable\n    /// @param resourceURI resource URI of the type, mutable\n    /// @return typeID of the registered type\n    function _registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) internal returns (uint160) {\n        uint160 credTypeID = _calcTypeID(msg.sender, name);\n        if (bytes(_credTypes[credTypeID].name).length != 0) {\n            revert TypeAlreadyExists();\n        }\n        if (bytes(name).length == 0) {\n            revert InvalidTypeName();\n        }\n        CredentialType memory credType = CredentialType({\n            revocable: revocable,\n            admin: msg.sender,\n            name: name,\n            definition: definition,\n            description: description,\n            resourceURI: resourceURI\n        });\n        _credTypes[credTypeID] = credType;\n        emit TypeRegistered(\n            credTypeID,\n            credType.admin,\n            credType.name,\n            credType.definition,\n            credType.description,\n            credType.resourceURI\n        );\n        return credTypeID;\n    }\n\n    /// @dev check if the type is fully initialized for the given verification stack.\n    /// @param typeId id of the type\n    /// @param verificationStackId id the verification stack\n    function isTypeFullyInitializedForStack(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view override returns (bool) {\n        return\n            _typeExists(typeId) &&\n            _verifiers[typeId][verificationStackId] != IProofVerifier(address(0)) &&\n            _psGetters[typeId][verificationStackId] != IPublicSignalGetter(address(0));\n    }\n\n    /// @dev transfer the ownership of a type.\n    /// @param typeId type id of the type\n    /// @param newAdmin address of the new admin\n    function transferTypeAdmin(uint160 typeId, address newAdmin) external override onlyTypeOwner(typeId) {\n        if (_credTypes[typeId].admin == address(0)) {\n            // primitive type doesn't have an admin, so the owner can't transfer it.\n            return;\n        }\n        _credTypes[typeId].admin = newAdmin;\n        emit TypeAdminTransferred(typeId, msg.sender, newAdmin);\n    }\n\n    /// @dev update the resource URI of a type\n    /// @param typeId of the type\n    /// @param uri new resource URI\n    /// TODO: resource URI specifcation: support multiple verification stack.\n    function updateTypeResourceURI(uint160 typeId, string calldata uri) external override onlyTypeOwner(typeId) {\n        emit TypeResourceURIUpdated(typeId, _credTypes[typeId].resourceURI, uri);\n        _credTypes[typeId].resourceURI = uri;\n    }\n\n    /// @dev update the verifier for a type\n    function updateTypeVerifier(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IProofVerifier verifier\n    ) external override onlyTypeOwner(typeId) {\n        _verifiers[typeId][verificationStackId] = verifier;\n        emit TypeVerifierUpdated(typeId, verificationStackId, address(verifier));\n    }\n\n    /// @dev update the public signal getter for a type\n    /// @param typeId id of the type\n    /// @param verificationStackId id of the verification stack\n    /// @param getter the address of the public signal getter\n    function updateTypePublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IPublicSignalGetter getter\n    ) external override onlyTypeOwner(typeId) {\n        _psGetters[typeId][verificationStackId] = getter;\n        emit TypePublicSignalGetterUpdated(typeId, verificationStackId, address(getter));\n    }\n\n    /// @dev get the type for the given typeID\n    function getType(uint160 _id) external view override returns (CredentialType memory) {\n        return _credTypes[_id];\n    }\n\n    /// @dev Retrieve the admin of a type\n    /// @param typeId type id of the type\n    /// @return address of the admin of the type\n    function getTypeAdmin(uint160 typeId) external view override returns (address) {\n        /// uninitialized type, return 0x0\n        if (!_typeExists(typeId)) {\n            return address(0);\n        }\n        if (_credTypes[typeId].admin != address(0)) {\n            return _credTypes[typeId].admin;\n        }\n        return owner();\n    }\n\n    /// @dev check if the type is revocable\n    function isRevocable(uint160 typeId) external view override returns (bool) {\n        return _credTypes[typeId].revocable;\n    }\n\n    /// @dev get the verifier for the given typeID and verificationStackID.\n    function getVerifier(uint160 typeId, uint8 verificationStackId) external view override returns (IProofVerifier) {\n        return _verifiers[typeId][verificationStackId];\n    }\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getPublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view override returns (IPublicSignalGetter) {\n        return _psGetters[typeId][verificationStackId];\n    }\n\n    /// @dev calculate the typeID of a type\n    function calcTypeID(address creator, string calldata name) external pure override returns (uint160) {\n        return _calcTypeID(creator, name);\n    }\n\n    /// @dev calculate the typeID of a type\n    function _calcTypeID(address creator, string calldata name) private pure returns (uint160) {\n        return uint160(uint256(keccak256(abi.encodePacked(creator, name))));\n    }\n\n    /// @dev check if the type exists\n    function _typeExists(uint160 typeId) private view returns (bool) {\n        return bytes(_credTypes[typeId].name).length != 0;\n    }\n\n    /// @dev check if the caller is the owner of the type\n    function _onlyTypeOwner(uint160 typeId) private view {\n        if (!_typeExists(typeId)) {\n            revert TypeDoesNotExist();\n        }\n        // primitive type will have its creator as 0x0, so only the admin can update it.\n        if (_credTypes[typeId].admin == address(0)) {\n            if (msg.sender != owner()) {\n                revert NotTypeOwner();\n            }\n            return;\n        }\n        if (_credTypes[typeId].admin != msg.sender) {\n            revert NotTypeOwner();\n        }\n    }\n\n    modifier onlyTypeOwner(uint160 typeId) {\n        _onlyTypeOwner(typeId);\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title IProofVerifier\n/// @dev Interface for static verification of zero-knowledge proofs.\ninterface IProofVerifier {\n    /// @notice Retrieves the verification keys.\n    /// @dev This function is used to get the verification keys that are necessary for verifying proofs.\n    /// @return An array of `uint` representing the verification keys.\n    function getVerificationKeys() external view returns (uint256[] memory);\n\n    /// @dev Checks if the public signals are aliased. Aliased signals should never be used in proofs.\n    ///      This is useful when using proof aggregators that does not check for signal aliasing.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating if any public signal is aliased (`true`) or not (`false`).\n    function isAliased(uint256[] calldata _pubSignals) external view returns (bool);\n\n    /// @dev This function takes a cryptographic proof and public signals to verify the proof's validity.\n    /// @notice It verifies the proof and check if public signals were aliased.\n    /// @param _proofs An array of `uint` representing the proof.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating whether the proof is valid (`true`) or not (`false`).\n    function verifyProof(uint256[] calldata _proofs, uint256[] calldata _pubSignals) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPublicSignalGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title Intrinsic Signal enum\nenum IntrinsicSignalName {\n    TYPE,\n    CONTEXT,\n    NULLIFIER,\n    EXTERNAL_NULLIFIER,\n    REVEAL_IDENTITY,\n    EXPIRATION_LB,\n    KEY_ID,\n    ID_EQUALS_TO,\n    SIG_REVOCATION_SMT_ROOT\n}\n\n/// @title Public Signal Getter Interface\n/// @dev Public signals (inputs) are represented as an array of uints in galxe identity protocol.\n///      To find the public signal for a given signal name, type designer should set a contract\n///      in the type registry that implements this interface.\ninterface IPublicSignalGetter {\n    /// @dev get the public signal for the signal name, represented as the given enum (represented as uint8), based on the public signals.\n    /// @notice Implementation must be able to handle intrinsic signals, defiend in IntrinsicSignalName enum.\n    ///         Type-specific signals support is optional.\n    /// @param name The signal name, represented as the given enum (converted to uint8).\n    /// @param publicSignals The public signals.\n    function getPublicSignal(uint8 name, uint256[] calldata publicSignals) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { IPublicSignalGetter } from \"./IPublicSignalGetter.sol\";\n\n/// @title Credential Type\n/// @dev Defines the structure of a credential type.\nstruct CredentialType {\n    // @dev This flag indicates if the credential type support revocation.\n    bool revocable;\n    // @dev The address of the admin of the credential type, initially set to the creator.\n    address admin;\n    // @dev Provides a human-readable identifier for the credential.\n    string name;\n    // @dev The type specification of Galxe Identity Credential Type Schema.\n    string definition;\n    // @dev Additional context or information about the type.\n    string description;\n    // @dev A URI to an external JSON file of more information about the credential.\n    // See whitepaper for the JSON schema specification.\n    string resourceURI;\n}\n\n/// @title Credential Type Config, miscellanous.\n/// @notice To save stack space, we use this struct to store the verifier and public signal getter.\nstruct CredentialTypeMiscConfig {\n    bool revocable;\n    uint8 verificationStackId;\n    IProofVerifier verifier;\n    IPublicSignalGetter publicSignalGetter;\n}\n\n/// @title Interface for Type Registration Contract\n/// @notice This interface defines the functions for registering and managing types by users.\ninterface ITypeRegistry {\n    /// @dev Emitted when a new type is registered\n    /// @param typeID Unique identifier for the registered type\n    /// @param admin Address of the admin of the type.\n    /// @param name Name of the type\n    /// @param definition Immutable definition of the type\n    /// @param description Immutable description of the type\n    /// @param resourceURI Mutable resource URI for the type\n    event TypeRegistered(\n        uint160 indexed typeID,\n        address indexed admin,\n        string name,\n        string definition,\n        string description,\n        string resourceURI\n    );\n\n    /// @dev Emitted when the resource URI of a type is updated\n    /// @param typeID Unique identifier for the type being updated\n    /// @param oldResourceURI The previous resource URI\n    /// @param newResourceURI The new resource URI\n    event TypeResourceURIUpdated(uint160 indexed typeID, string oldResourceURI, string newResourceURI);\n\n    /// @dev Emitted when a proof verifier is updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param verifier address of the verifier\n    event TypeVerifierUpdated(uint160 indexed typeID, uint8 indexed verificationStackID, address indexed verifier);\n\n    /// @dev Emitted when the intrinsic signal indexes are updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param publicSignalGetter  address of the public signal getter\n    event TypePublicSignalGetterUpdated(\n        uint160 indexed typeID,\n        uint8 indexed verificationStackID,\n        address indexed publicSignalGetter\n    );\n\n    /// @dev Emitted when the admin of a type is transferred\n    /// @param typeID type id\n    /// @param oldAdmin address of the old admin\n    /// @param newAdmin address of the new admin\n    event TypeAdminTransferred(uint160 indexed typeID, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @dev transfer the ownership of a type.\n    /// @param typeId type id of the type\n    /// @param newAdmin address of the new admin\n    function transferTypeAdmin(uint160 typeId, address newAdmin) external;\n\n    /// @notice set a primitive type, only callable by the admin.\n    /// @param typeId the type id of the primitive type\n    /// @param name name of the type\n    /// @param definition definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param config revocable, verifier and public signal getter.\n    function setPrimitiveType(\n        uint160 typeId,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        CredentialTypeMiscConfig calldata config\n    ) external;\n\n    /// @notice Register a new type by `msg.sender`\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) external returns (uint160);\n\n    /// @notice Register a new type by `msg.sender` with verifier and public signal getter set for a specific verification stack.\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param verifier verifier for the type\n    /// @param publicSignalGetter public signal getter for the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType1Step(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        uint8 verificationStackId,\n        IProofVerifier verifier,\n        IPublicSignalGetter publicSignalGetter\n    ) external returns (uint160);\n\n    /// @notice Update the resource URI of a type\n    /// @dev Can only be called by the type owner (`msg.sender`)\n    /// @param _id ID of the type to update\n    /// @param _resourceURI New resource URI for the type\n    function updateTypeResourceURI(uint160 _id, string calldata _resourceURI) external;\n\n    /// @dev update the verifier for a type\n    function updateTypeVerifier(uint160 typeId, uint8 verificationStackId, IProofVerifier verifier) external;\n\n    /// @dev update the verifier for a type\n    function updateTypePublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IPublicSignalGetter getter\n    ) external;\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getVerifier(uint160 typeId, uint8 verificationStackId) external view returns (IProofVerifier);\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getPublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view returns (IPublicSignalGetter);\n\n    /// @dev check if the type is fully initialized for the given verification stack.\n    /// @param typeId id of the type\n    /// @param verificationStackId id the verification stack\n    function isTypeFullyInitializedForStack(uint160 typeId, uint8 verificationStackId) external view returns (bool);\n\n    /// @dev Retrieve details of a type for the given typeID\n    /// @param _id ID of the type to retrieve\n    /// @return A `CredentialType` struct containing details of the type\n    function getType(uint160 _id) external view returns (CredentialType memory);\n\n    /// @dev Retrieve the admin of a type\n    /// @param typeId type id of the type\n    /// @return address of the admin of the type\n    function getTypeAdmin(uint160 typeId) external view returns (address);\n\n    /// @dev check if the type is revocable\n    function isRevocable(uint160 typeId) external view returns (bool);\n\n    /// @notice Calculate the typeID of a type, typeID is keccak256(creator, name) in uint160.\n    /// @param creator Address of the type creator\n    /// @param name Name of the type\n    /// @return The calculated typeID based on the creator address and type name\n    function calcTypeID(address creator, string calldata name) external pure returns (uint160);\n}\n"
    }
  }
}}