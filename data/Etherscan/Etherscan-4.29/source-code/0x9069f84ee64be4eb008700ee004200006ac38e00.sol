{{
  "language": "Solidity",
  "sources": {
    "contracts/helpers/SeaportRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    SeaportRouterInterface\n} from \"seaport-types/src/interfaces/SeaportRouterInterface.sol\";\n\nimport {\n    SeaportInterface\n} from \"seaport-types/src/interfaces/SeaportInterface.sol\";\n\nimport { ReentrancyGuard } from \"seaport-core/src/lib/ReentrancyGuard.sol\";\n\nimport {\n    AdvancedOrder,\n    CriteriaResolver,\n    Execution,\n    FulfillmentComponent\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\n/**\n * @title  SeaportRouter\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\n * @notice A utility contract for fulfilling orders with multiple\n *         Seaport versions. DISCLAIMER: This contract only works when\n *         all consideration items across all listings are native tokens.\n */\ncontract SeaportRouter is SeaportRouterInterface, ReentrancyGuard {\n    /// @dev The allowed v1.5 contract usable through this router.\n    address private immutable _SEAPORT_V1_5;\n    /// @dev The allowed v1.6 contract usable through this router.\n    address private immutable _SEAPORT_V1_6;\n\n    /**\n     * @dev Deploy contract with the supported Seaport contracts.\n     *\n     * @param seaportV1point5 The address of the Seaport v1.5 contract.\n     * @param seaportV1point6 The address of the Seaport v1.6 contract.\n     */\n    constructor(address seaportV1point5, address seaportV1point6) {\n        _SEAPORT_V1_5 = seaportV1point5;\n        _SEAPORT_V1_6 = seaportV1point6;\n    }\n\n    /**\n     * @dev Fallback function to receive excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    receive() external payable override {\n        // Ensure we only receive ether from Seaport.\n        _assertSeaportAllowed(msg.sender);\n    }\n\n    /**\n     * @notice Fulfill available advanced orders through multiple Seaport\n     *         versions.\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\n     *\n     * @param params The parameters for fulfilling available advanced orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        FulfillAvailableAdvancedOrdersParams calldata params\n    )\n        external\n        payable\n        override\n        returns (\n            bool[][] memory availableOrders,\n            Execution[][] memory executions\n        )\n    {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(true);\n\n        // Put the number of Seaport contracts on the stack.\n        uint256 seaportContractsLength = params.seaportContracts.length;\n\n        // Set the availableOrders and executions arrays to the correct length.\n        availableOrders = new bool[][](seaportContractsLength);\n        executions = new Execution[][](seaportContractsLength);\n\n        // Track the number of order fulfillments left.\n        uint256 fulfillmentsLeft = params.maximumFulfilled;\n\n        // To help avoid stack too deep errors, we format the calldata\n        // params in a struct and put it on the stack.\n        AdvancedOrder[] memory emptyAdvancedOrders;\n        CriteriaResolver[] memory emptyCriteriaResolvers;\n        FulfillmentComponent[][] memory emptyFulfillmentComponents;\n        CalldataParams memory calldataParams = CalldataParams({\n            advancedOrders: emptyAdvancedOrders,\n            criteriaResolvers: emptyCriteriaResolvers,\n            offerFulfillments: emptyFulfillmentComponents,\n            considerationFulfillments: emptyFulfillmentComponents,\n            fulfillerConduitKey: params.fulfillerConduitKey,\n            recipient: params.recipient,\n            maximumFulfilled: fulfillmentsLeft\n        });\n\n        // If recipient is not provided assign to msg.sender.\n        if (calldataParams.recipient == address(0)) {\n            calldataParams.recipient = msg.sender;\n        }\n\n        // Iterate through the provided Seaport contracts.\n        for (uint256 i = 0; i < params.seaportContracts.length; ) {\n            // Ensure the provided Seaport contract is allowed.\n            _assertSeaportAllowed(params.seaportContracts[i]);\n\n            // Put the order params on the stack.\n            AdvancedOrderParams calldata orderParams = params\n                .advancedOrderParams[i];\n\n            // Assign the variables to the calldata params.\n            calldataParams.advancedOrders = orderParams.advancedOrders;\n            calldataParams.criteriaResolvers = orderParams.criteriaResolvers;\n            calldataParams.offerFulfillments = orderParams.offerFulfillments;\n            calldataParams.considerationFulfillments = orderParams\n                .considerationFulfillments;\n\n            // Execute the orders, collecting availableOrders and executions.\n            // This is wrapped in a try/catch in case a single order is\n            // executed that is no longer available, leading to a revert\n            // with `NoSpecifiedOrdersAvailable()` that can be ignored.\n            try\n                SeaportInterface(params.seaportContracts[i])\n                    .fulfillAvailableAdvancedOrders{\n                    value: orderParams.etherValue\n                }(\n                    calldataParams.advancedOrders,\n                    calldataParams.criteriaResolvers,\n                    calldataParams.offerFulfillments,\n                    calldataParams.considerationFulfillments,\n                    calldataParams.fulfillerConduitKey,\n                    calldataParams.recipient,\n                    calldataParams.maximumFulfilled\n                )\n            returns (\n                bool[] memory newAvailableOrders,\n                Execution[] memory newExecutions\n            ) {\n                availableOrders[i] = newAvailableOrders;\n                executions[i] = newExecutions;\n\n                // Subtract the number of orders fulfilled.\n                uint256 newAvailableOrdersLength = newAvailableOrders.length;\n                for (uint256 j = 0; j < newAvailableOrdersLength; ) {\n                    if (newAvailableOrders[j]) {\n                        unchecked {\n                            --fulfillmentsLeft;\n                            ++j;\n                        }\n                    }\n                }\n\n                // Break if the maximum number of executions has been reached.\n                if (fulfillmentsLeft == 0) {\n                    break;\n                }\n            } catch (bytes memory data) {\n                // Set initial value of first four bytes of revert data\n                // to the mask.\n                bytes4 customErrorSelector = bytes4(0xffffffff);\n\n                // Utilize assembly to read first four bytes\n                // (if present) directly.\n                assembly {\n                    // Combine original mask with first four bytes of\n                    // revert data.\n                    customErrorSelector := and(\n                        // Data begins after length offset.\n                        mload(add(data, 0x20)),\n                        customErrorSelector\n                    )\n                }\n\n                // Pass through the custom error if the error is\n                // not NoSpecifiedOrdersAvailable()\n                if (\n                    customErrorSelector != NoSpecifiedOrdersAvailable.selector\n                ) {\n                    assembly {\n                        revert(add(data, 32), mload(data))\n                    }\n                }\n            }\n\n            // Update fulfillments left.\n            calldataParams.maximumFulfilled = fulfillmentsLeft;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Throw an error if no orders were fulfilled.\n        if (fulfillmentsLeft == params.maximumFulfilled) {\n            revert NoSpecifiedOrdersAvailable();\n        }\n\n        // Return excess ether that may not have been used or was sent back.\n        if (address(this).balance > 0) {\n            _returnExcessEther();\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n    }\n\n    /**\n     * @notice Returns the Seaport contracts allowed to be used through this\n     *         router.\n     */\n    function getAllowedSeaportContracts()\n        external\n        view\n        override\n        returns (address[] memory seaportContracts)\n    {\n        seaportContracts = new address[](2);\n        seaportContracts[0] = _SEAPORT_V1_5;\n        seaportContracts[1] = _SEAPORT_V1_6;\n    }\n\n    /**\n     * @dev Reverts if the provided Seaport contract is not allowed.\n     */\n    function _assertSeaportAllowed(address seaport) internal view {\n        if (\n            _cast(seaport == _SEAPORT_V1_5) | _cast(seaport == _SEAPORT_V1_6) ==\n            0\n        ) {\n            revert SeaportNotAllowed(seaport);\n        }\n    }\n\n    /**\n     * @dev Function to return excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    function _returnExcessEther() private {\n        // Send received funds back to msg.sender.\n        (bool success, bytes memory data) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n\n        // Revert with an error if the ether transfer failed.\n        if (!success) {\n            revert EtherReturnTransferFailed(\n                msg.sender,\n                address(this).balance,\n                data\n            );\n        }\n    }\n}\n"
    },
    "lib/seaport-types/src/interfaces/SeaportRouterInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    CriteriaResolver,\n    FulfillmentComponent\n} from \"../lib/ConsiderationStructs.sol\";\n\nimport { Execution } from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title  SeaportRouterInterface\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\n * @notice A utility contract for fulfilling orders with multiple\n *         Seaport versions. DISCLAIMER: This contract only works when\n *         all consideration items across all listings are native tokens.\n */\ninterface SeaportRouterInterface {\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n\n    /**\n     * @dev Advanced order parameters for use through the\n     *      FulfillAvailableAdvancedOrdersParams struct.\n     */\n    struct AdvancedOrderParams {\n        AdvancedOrder[] advancedOrders;\n        CriteriaResolver[] criteriaResolvers;\n        FulfillmentComponent[][] offerFulfillments;\n        FulfillmentComponent[][] considerationFulfillments;\n        uint256 etherValue; /// The ether value to send with the set of orders.\n    }\n\n    /**\n     * @dev Parameters for using fulfillAvailableAdvancedOrders\n     *      through SeaportRouter.\n     */\n    struct FulfillAvailableAdvancedOrdersParams {\n        address[] seaportContracts;\n        AdvancedOrderParams[] advancedOrderParams;\n        bytes32 fulfillerConduitKey;\n        address recipient;\n        uint256 maximumFulfilled;\n    }\n\n    /**\n     * @dev Calldata params for calling FulfillAvailableAdvancedOrders.\n     */\n    struct CalldataParams {\n        AdvancedOrder[] advancedOrders;\n        CriteriaResolver[] criteriaResolvers;\n        FulfillmentComponent[][] offerFulfillments;\n        FulfillmentComponent[][] considerationFulfillments;\n        bytes32 fulfillerConduitKey;\n        address recipient;\n        uint256 maximumFulfilled;\n    }\n\n    /**\n     * @dev Revert with an error if a provided Seaport contract is not allowed\n     *      to be used in the router.\n     */\n    error SeaportNotAllowed(address seaport);\n\n    /**\n     * @dev Revert with an error if an ether transfer back to the fulfiller\n     *      fails.\n     */\n    error EtherReturnTransferFailed(\n        address recipient,\n        uint256 amount,\n        bytes returnData\n    );\n\n    /**\n     * @dev Fallback function to receive excess ether, in case total amount of\n     *      ether sent is more than the amount required to fulfill the order.\n     */\n    receive() external payable;\n\n    /**\n     * @notice Fulfill available advanced orders through multiple Seaport\n     *         versions.\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\n     *\n     * @param params The parameters for fulfilling available advanced orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        FulfillAvailableAdvancedOrdersParams calldata params\n    )\n        external\n        payable\n        returns (\n            bool[][] memory availableOrders,\n            Execution[][] memory executions\n        );\n\n    /**\n     * @notice Returns the Seaport contracts allowed to be used through this\n     *         router.\n     */\n    function getAllowedSeaportContracts()\n        external\n        view\n        returns (address[] memory);\n}\n"
    },
    "lib/seaport-types/src/interfaces/SeaportInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title SeaportInterface\n * @author 0age\n * @custom:version 1.6\n * @notice Seaport is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace. It minimizes external calls to the greatest extent\n *         possible and provides lightweight methods for common routes as well\n *         as more flexible methods for composing advanced orders.\n *\n * @dev SeaportInterface contains all external function interfaces for Seaport.\n */\ninterface SeaportInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        Order calldata order,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Seaport.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or\n     *                    native tokens will not be reflected as part of this\n     *                    array.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components. Any unspent offer item\n     *         amounts will be transferred to the designated recipient (with the\n     *         null address signifying to use the caller) and any unspent native\n     *         tokens will be returned to the caller.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts, or the caller if the null address\n     *                          is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments,\n        address recipient\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        Order[] calldata orders\n    ) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration. Note that this function costs less gas than\n     *         `fulfillBasicOrder` due to the zero bytes in the function\n     *         selector (0x00000000) which also results in earlier function\n     *         dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        OrderComponents calldata order\n    ) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n"
    },
    "lib/seaport-core/src/lib/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    ReentrancyErrors\n} from \"seaport-types/src/interfaces/ReentrancyErrors.sol\";\n\nimport { LowLevelHelpers } from \"./LowLevelHelpers.sol\";\n\nimport {\n    _revertInvalidMsgValue,\n    _revertNoReentrantCalls\n} from \"seaport-types/src/lib/ConsiderationErrors.sol\";\n\nimport {\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE,\n    _ENTERED_SSTORE,\n    _NOT_ENTERED_SSTORE,\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE,\n    _ENTERED_TSTORE,\n    _NOT_ENTERED_TSTORE,\n    _TSTORE_ENABLED_SSTORE,\n    _REENTRANCY_GUARD_SLOT,\n    _TLOAD_TEST_PAYLOAD,\n    _TLOAD_TEST_PAYLOAD_OFFSET,\n    _TLOAD_TEST_PAYLOAD_LENGTH\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_value_ptr,\n    NoReentrantCalls_error_selector,\n    NoReentrantCalls_error_length,\n    Error_selector_offset\n} from \"seaport-types/src/lib/ConsiderationErrorConstants.sol\";\n\n/**\n * @title ReentrancyGuard\n * @author 0age\n * @notice ReentrancyGuard contains a storage variable (or a transient storage\n *         variable in EVM environments that support it once activated) and\n *         related functionality for protecting against reentrancy.\n */\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\n    // Declare an immutable variable to store the initial TSTORE support status.\n    bool private immutable _tstoreInitialSupport;\n\n    // Declare an immutable variable to store the tstore test contract address.\n    address private immutable _tloadTestContract;\n\n    /**\n     * @dev Initialize the reentrancy guard during deployment. This involves\n     *      attempting to deploy a contract that utilizes TLOAD as part of the\n     *      contract construction bytecode, and configuring initial support for\n     *      using TSTORE in place of SSTORE for the reentrancy lock based on the\n     *      result.\n     */\n    constructor() {\n        // Deploy the contract testing TLOAD support and store the address.\n        address tloadTestContract = _prepareTloadTest();\n\n        // Ensure the deployment was successful.\n        if (tloadTestContract == address(0)) {\n            revert TloadTestContractDeploymentFailed();\n        }\n\n        // Determine if TSTORE is supported.\n        bool tstoreInitialSupport = _testTload(tloadTestContract);\n\n        // Store the result as an immutable.\n        _tstoreInitialSupport = tstoreInitialSupport;\n\n        // Set the address of the deployed TLOAD test contract as an immutable.\n        _tloadTestContract = tloadTestContract;\n\n        // If not using TSTORE (where _NOT_ENTERED_TSTORE = 0), set initial\n        // sentinel value (where _NOT_ENTERED_SSTORE = 1).\n        if (!tstoreInitialSupport) {\n            // Initialize storage for the reentrancy guard in a cleared state.\n            assembly {\n                sstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_SSTORE)\n            }\n        }\n    }\n\n    /**\n     * @dev External function to activate TSTORE usage for the reentrancy guard.\n     *      Does not need to be called if TSTORE is supported from deployment,\n     *      and only needs to be called once. Reverts if TSTORE has already been\n     *      activated, if the opcode is not available, or if the reentrancy\n     *      guard is currently set.\n     */\n    function __activateTstore() external {\n        // Determine if TSTORE can potentially be activated. If it has already\n        // been activated, or if the reentrancy guard is currently set, then\n        // it cannot be activated.\n        bool tstoreActivatable;\n        assembly {\n            tstoreActivatable := eq(\n                sload(_REENTRANCY_GUARD_SLOT),\n                _NOT_ENTERED_SSTORE\n            )\n        }\n\n        // Revert if TSTORE is already activated or not activatable.\n        if (_tstoreInitialSupport || !tstoreActivatable) {\n            revert TStoreAlreadyActivated();\n        }\n\n        // Determine if TSTORE can be activated and revert if not.\n        if (!_testTload(_tloadTestContract)) {\n            revert TStoreNotSupported();\n        }\n\n        // Mark TSTORE as activated.\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, _TSTORE_ENABLED_SSTORE)\n        }\n    }\n\n    /**\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\n     *      guard is not currently set and, if not, to set a sentinel value for\n     *      the reentrancy guard based on whether or not native tokens may be\n     *      received during execution or not.\n     *\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\n     *                           be received during execution or not.\n     */\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to set the reentrancy guard based on tstore support.\n        assembly {\n            // \"Loop\" over three possible cases for setting the reentrancy guard\n            // based on tstore support and state, exiting once the respective\n            // state has been identified and a corresponding guard has been set.\n            for {} 1 {} {\n                // 1: handle case where tstore is supported from the start.\n                if tstoreInitialSupport {\n                    // Ensure that the reentrancy guard is not already set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n\n                    // Set the reentrancy guard. A value of 1 indicates that\n                    // native tokens may not be accepted during execution,\n                    // whereas a value of 2 indicates that they will be accepted\n                    // (returning any remaining native tokens to the caller).\n                    tstore(\n                        _REENTRANCY_GUARD_SLOT,\n                        add(_ENTERED_TSTORE, acceptNativeTokens)\n                    )\n\n                    // Exit the loop.\n                    break\n                }\n\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure that the reentrancy guard is not already set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n\n                    // Set the reentrancy guard. A value of 1 indicates that\n                    // native tokens may not be accepted during execution,\n                    // whereas a value of 2 indicates that they will be accepted\n                    // (returning any remaining native tokens to the caller).\n                    tstore(\n                        _REENTRANCY_GUARD_SLOT,\n                        add(_ENTERED_TSTORE, acceptNativeTokens)\n                    )\n\n                    // Exit the loop.\n                    break\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure that the reentrancy guard is not already set.\n                if iszero(eq(reentrancyGuard, _NOT_ENTERED_SSTORE)) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n\n                // Set the reentrancy guard. A value of 2 indicates that native\n                // tokens may not be accepted during execution, whereas a value\n                // of 3 indicates that they will be accepted (with any remaining\n                // native tokens returned to the caller).\n                sstore(\n                    _REENTRANCY_GUARD_SLOT,\n                    add(_ENTERED_SSTORE, acceptNativeTokens)\n                )\n\n                // Exit the loop.\n                break\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to unset the reentrancy guard sentinel value.\n     */\n    function _clearReentrancyGuard() internal {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to clear reentrancy guard based on tstore support.\n        assembly {\n            // \"Loop\" over three possible cases for clearing reentrancy guard\n            // based on tstore support and state, exiting once the respective\n            // state has been identified and corresponding guard cleared.\n            for {} 1 {} {\n                // 1: handle case where tstore is supported from the start.\n                if tstoreInitialSupport {\n                    // Clear the reentrancy guard.\n                    tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_TSTORE)\n\n                    // Exit the loop.\n                    break\n                }\n\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Clear the reentrancy guard.\n                    tstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_TSTORE)\n\n                    // Exit the loop.\n                    break\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Clear the reentrancy guard.\n                sstore(_REENTRANCY_GUARD_SLOT, _NOT_ENTERED_SSTORE)\n\n                // Exit the loop.\n                break\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that a sentinel value for the\n     *      reentrancy guard is not currently set.\n     */\n    function _assertNonReentrant() internal view {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to check reentrancy guard based on tstore support.\n        assembly {\n            // 1: handle case where tstore is supported from the start.\n            if tstoreInitialSupport {\n                // Ensure that the reentrancy guard is not currently set.\n                if tload(_REENTRANCY_GUARD_SLOT) {\n                    // Store left-padded selector with push4,\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n            }\n\n            // Handle cases where tstore is not initially supported.\n            if iszero(tstoreInitialSupport) {\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure that the reentrancy guard is not currently set.\n                    if tload(_REENTRANCY_GUARD_SLOT) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, NoReentrantCalls_error_selector)\n\n                        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                        revert(\n                            Error_selector_offset,\n                            NoReentrantCalls_error_length\n                        )\n                    }\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure that the reentrancy guard is not currently set.\n                if gt(reentrancyGuard, _NOT_ENTERED_SSTORE) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, NoReentrantCalls_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n                    revert(Error_selector_offset, NoReentrantCalls_error_length)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that the sentinel value indicating\n     *      native tokens may be received during execution is currently set.\n     */\n    function _assertAcceptingNativeTokens() internal view {\n        // Place immutable variable on the stack access within inline assembly.\n        bool tstoreInitialSupport = _tstoreInitialSupport;\n\n        // Utilize assembly to check reentrancy guard based on tstore support.\n        assembly {\n            // 1: handle case where tstore is supported from the start.\n            if tstoreInitialSupport {\n                // Ensure reentrancy guard is set to accept native tokens.\n                if iszero(\n                    eq(\n                        tload(_REENTRANCY_GUARD_SLOT),\n                        _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE\n                    )\n                ) {\n                    // Store left-padded selector with push4,\n                    // mem[28:32] = selector\n                    mstore(0, InvalidMsgValue_error_selector)\n\n                    // Store argument.\n                    mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                    // revert(abi.encodeWithSignature(\n                    //   \"InvalidMsgValue(uint256)\", value)\n                    // )\n                    revert(Error_selector_offset, InvalidMsgValue_error_length)\n                }\n            }\n\n            // Handle cases where tstore is not initially supported.\n            if iszero(tstoreInitialSupport) {\n                // Retrieve the reentrancy guard sentinel value.\n                let reentrancyGuard := sload(_REENTRANCY_GUARD_SLOT)\n\n                // 2: handle tstore support that was activated post-deployment.\n                if iszero(reentrancyGuard) {\n                    // Ensure reentrancy guard is set to accept native tokens.\n                    if iszero(\n                        eq(\n                            tload(_REENTRANCY_GUARD_SLOT),\n                            _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE\n                        )\n                    ) {\n                        // Store left-padded selector with push4,\n                        // mem[28:32] = selector\n                        mstore(0, InvalidMsgValue_error_selector)\n\n                        // Store argument.\n                        mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                        // revert(abi.encodeWithSignature(\n                        //   \"InvalidMsgValue(uint256)\", value)\n                        // )\n                        revert(\n                            Error_selector_offset,\n                            InvalidMsgValue_error_length\n                        )\n                    }\n                }\n\n                // 3: handle case where tstore support has not been activated.\n                // Ensure reentrancy guard is set to accepting native tokens.\n                if and(\n                    iszero(iszero(reentrancyGuard)),\n                    iszero(\n                        eq(\n                            reentrancyGuard,\n                            _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE\n                        )\n                    )\n                ) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, InvalidMsgValue_error_selector)\n\n                    // Store argument.\n                    mstore(InvalidMsgValue_error_value_ptr, callvalue())\n\n                    // revert(abi.encodeWithSignature(\n                    //   \"InvalidMsgValue(uint256)\", value)\n                    // )\n                    revert(Error_selector_offset, InvalidMsgValue_error_length)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to deploy a test contract that utilizes TLOAD as\n     *      part of its fallback logic.\n     */\n    function _prepareTloadTest() private returns (address contractAddress) {\n        // Utilize assembly to deploy a contract testing TLOAD support.\n        assembly {\n            // Write the contract deployment code payload to scratch space.\n            mstore(0, _TLOAD_TEST_PAYLOAD)\n\n            // Deploy the contract.\n            contractAddress := create(\n                0,\n                _TLOAD_TEST_PAYLOAD_OFFSET,\n                _TLOAD_TEST_PAYLOAD_LENGTH\n            )\n        }\n    }\n\n    /**\n     * @dev Private view function to determine if TSTORE/TLOAD are supported by\n     *      the current EVM implementation by attempting to call the test\n     *      contract, which utilizes TLOAD as part of its fallback logic.\n     */\n    function _testTload(\n        address tloadTestContract\n    ) private view returns (bool ok) {\n        // Call the test contract, which will perform a TLOAD test. If the call\n        // does not revert, then TLOAD/TSTORE is supported. Do not forward all\n        // available gas, as all forwarded gas will be consumed on revert.\n        (ok, ) = tloadTestContract.staticcall{ gas: gasleft() / 10 }(\"\");\n    }\n}\n"
    },
    "lib/seaport-types/src/lib/ConsiderationStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BasicOrderType,\n    ItemType,\n    OrderType,\n    Side\n} from \"./ConsiderationEnums.sol\";\n\nimport {\n    CalldataPointer,\n    MemoryPointer\n} from \"../helpers/PointerLibraries.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n\nusing StructPointers for OrderComponents global;\nusing StructPointers for OfferItem global;\nusing StructPointers for ConsiderationItem global;\nusing StructPointers for SpentItem global;\nusing StructPointers for ReceivedItem global;\nusing StructPointers for BasicOrderParameters global;\nusing StructPointers for AdditionalRecipient global;\nusing StructPointers for OrderParameters global;\nusing StructPointers for Order global;\nusing StructPointers for AdvancedOrder global;\nusing StructPointers for OrderStatus global;\nusing StructPointers for CriteriaResolver global;\nusing StructPointers for Fulfillment global;\nusing StructPointers for FulfillmentComponent global;\nusing StructPointers for Execution global;\nusing StructPointers for ZoneParameters global;\n\n/**\n * @dev This library provides a set of functions for converting structs to\n *      pointers.\n */\nlibrary StructPointers {\n    /**\n     * @dev Get a MemoryPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderComponents memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderComponents calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OfferItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OfferItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ConsiderationItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ConsiderationItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        SpentItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        SpentItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ReceivedItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ReceivedItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        BasicOrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        BasicOrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdditionalRecipient memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdditionalRecipient calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Order memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Order calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdvancedOrder memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdvancedOrder calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderStatus memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderStatus calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        CriteriaResolver memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        CriteriaResolver calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Fulfillment memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Fulfillment calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        FulfillmentComponent memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        FulfillmentComponent calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Execution memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Execution calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ZoneParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ZoneParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n}\n"
    },
    "lib/seaport-types/src/interfaces/ReentrancyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ReentrancyErrors\n * @author 0age\n * @notice ReentrancyErrors contains errors related to reentrancy.\n */\ninterface ReentrancyErrors {\n    /**\n     * @dev Revert with an error when a caller attempts to reenter a protected\n     *      function.\n     */\n    error NoReentrantCalls();\n\n    /**\n     * @dev Revert with an error when attempting to activate the TSTORE opcode\n     *      when it is already active.\n     */\n    error TStoreAlreadyActivated();\n\n    /**\n     * @dev Revert with an error when attempting to activate the TSTORE opcode\n     *      in an EVM environment that does not support it.\n     */\n    error TStoreNotSupported();\n\n    /**\n     * @dev Revert with an error when deployment of the contract for testing\n     *      TSTORE support fails.\n     */\n    error TloadTestContractDeploymentFailed();\n}\n"
    },
    "lib/seaport-core/src/lib/LowLevelHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {\n    CostPerWord,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    MemoryExpansionCoefficientShift,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes\n} from \"seaport-types/src/lib/ConsiderationConstants.sol\";\n\nimport {\n    MemoryPointer,\n    MemoryPointerLib\n} from \"seaport-types/src/helpers/PointerLibraries.sol\";\n\nimport {\n    AdvancedOrder,\n    Execution\n} from \"seaport-types/src/lib/ConsiderationStructs.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := shr(\n                    OneWordShift,\n                    add(returndatasize(), ThirtyOneBytes)\n                )\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := shr(\n                    OneWordShift,\n                    mload(FreeMemoryPointerSlot)\n                )\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            shr(\n                                MemoryExpansionCoefficientShift,\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                )\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to branchlessly select either the caller (if\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\n     *      that recipient is a nonzero value).\n     *\n     * @param recipient The supplied recipient.\n     *\n     * @return updatedRecipient The updated recipient.\n     */\n    function _substituteCallerForEmptyRecipient(\n        address recipient\n    ) internal view returns (address updatedRecipient) {\n        // Utilize assembly to perform a branchless operation on the recipient.\n        assembly {\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\n     *\n     * @param b The `bool` value to cast.\n     *\n     * @return u The `uint256` value.\n     */\n    function _cast(bool b) internal pure returns (uint256 u) {\n        assembly {\n            u := b\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast the `pptrOffset` function from\n     *      `MemoryPointerLib` to a function that takes a memory array of\n     *      `AdvancedOrder` and an offset in memory and returns the\n     *      `AdvancedOrder` whose pointer is stored at that offset from the\n     *      array length.\n     */\n    function _getReadAdvancedOrderByOffset()\n        internal\n        pure\n        returns (\n            function(AdvancedOrder[] memory, uint256)\n                internal\n                pure\n                returns (AdvancedOrder memory) fn2\n        )\n    {\n        function(MemoryPointer, uint256)\n            internal\n            pure\n            returns (MemoryPointer) fn1 = MemoryPointerLib.pptrOffset;\n\n        assembly {\n            fn2 := fn1\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast the `pptrOffset` function from\n     *      `MemoryPointerLib` to a function that takes a memory array of\n     *      `Execution` and an offset in memory and returns the\n     *      `Execution` whose pointer is stored at that offset from the\n     *      array length.\n     */\n    function _getReadExecutionByOffset()\n        internal\n        pure\n        returns (\n            function(Execution[] memory, uint256)\n                internal\n                pure\n                returns (Execution memory) fn2\n        )\n    {\n        function(MemoryPointer, uint256)\n            internal\n            pure\n            returns (MemoryPointer) fn1 = MemoryPointerLib.pptrOffset;\n\n        assembly {\n            fn2 := fn1\n        }\n    }\n\n    /**\n     * @dev Internal pure function to return a `true` value that solc\n     *      will not recognize as a compile time constant.\n     *\n     *      This function is used to bypass function specialization for\n     *      functions which take a constant boolean as an input parameter.\n     *\n     *      This should only be used in cases where specialization has a\n     *      negligible impact on the gas cost of the function.\n     *\n     *      Note: assumes the calldatasize is non-zero.\n     */\n    function _runTimeConstantTrue() internal pure returns (bool) {\n        return msg.data.length > 0;\n    }\n\n    /**\n     * @dev Internal pure function to return a `false` value that solc\n     *      will not recognize as a compile time constant.\n     *\n     *      This function is used to bypass function specialization for\n     *      functions which take a constant boolean as an input parameter.\n     *\n     *      This should only be used in cases where specialization has a\n     *      negligible impact on the gas cost of the function.\n     *\n     *      Note: assumes the calldatasize is non-zero.\n     */\n    function _runTimeConstantFalse() internal pure returns (bool) {\n        return msg.data.length == 0;\n    }\n}\n"
    },
    "lib/seaport-types/src/lib/ConsiderationErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Side } from \"./ConsiderationEnums.sol\";\n\nimport {\n    BadFraction_error_length,\n    BadFraction_error_selector,\n    CannotCancelOrder_error_length,\n    CannotCancelOrder_error_selector,\n    ConsiderationLengthNotEqualToTotalOriginal_error_length,\n    ConsiderationLengthNotEqualToTotalOriginal_error_selector,\n    ConsiderationNotMet_error_considerationIndex_ptr,\n    ConsiderationNotMet_error_length,\n    ConsiderationNotMet_error_orderIndex_ptr,\n    ConsiderationNotMet_error_selector,\n    ConsiderationNotMet_error_shortfallAmount_ptr,\n    CriteriaNotEnabledForItem_error_length,\n    CriteriaNotEnabledForItem_error_selector,\n    Error_selector_offset,\n    InsufficientNativeTokensSupplied_error_length,\n    InsufficientNativeTokensSupplied_error_selector,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidCallToConduit_error_conduit_ptr,\n    InvalidCallToConduit_error_length,\n    InvalidCallToConduit_error_selector,\n    InvalidConduit_error_conduit_ptr,\n    InvalidConduit_error_conduitKey_ptr,\n    InvalidConduit_error_length,\n    InvalidConduit_error_selector,\n    InvalidContractOrder_error_length,\n    InvalidContractOrder_error_orderHash_ptr,\n    InvalidContractOrder_error_selector,\n    InvalidERC721TransferAmount_error_amount_ptr,\n    InvalidERC721TransferAmount_error_length,\n    InvalidERC721TransferAmount_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_value_ptr,\n    InvalidNativeOfferItem_error_length,\n    InvalidNativeOfferItem_error_selector,\n    InvalidProof_error_length,\n    InvalidProof_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n    MismatchedOfferAndConsiderationComponents_error_length,\n    MismatchedOfferAndConsiderationComponents_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_length,\n    MissingFulfillmentComponentOnAggregation_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_side_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    NoReentrantCalls_error_length,\n    NoReentrantCalls_error_selector,\n    NoSpecifiedOrdersAvailable_error_length,\n    NoSpecifiedOrdersAvailable_error_selector,\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\n    OrderAlreadyFilled_error_length,\n    OrderAlreadyFilled_error_orderHash_ptr,\n    OrderAlreadyFilled_error_selector,\n    OrderCriteriaResolverOutOfRange_error_length,\n    OrderCriteriaResolverOutOfRange_error_selector,\n    OrderCriteriaResolverOutOfRange_error_side_ptr,\n    OrderIsCancelled_error_length,\n    OrderIsCancelled_error_orderHash_ptr,\n    OrderIsCancelled_error_selector,\n    OrderPartiallyFilled_error_length,\n    OrderPartiallyFilled_error_orderHash_ptr,\n    OrderPartiallyFilled_error_selector,\n    PartialFillsNotEnabledForOrder_error_length,\n    PartialFillsNotEnabledForOrder_error_selector,\n    UnresolvedConsiderationCriteria_error_length,\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n    UnresolvedConsiderationCriteria_error_selector,\n    UnresolvedOfferCriteria_error_length,\n    UnresolvedOfferCriteria_error_offerIndex_ptr,\n    UnresolvedOfferCriteria_error_orderIndex_ptr,\n    UnresolvedOfferCriteria_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @dev Reverts the current transaction with a \"BadFraction\" error message.\n */\nfunction _revertBadFraction() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, BadFraction_error_selector)\n\n        // revert(abi.encodeWithSignature(\"BadFraction()\"))\n        revert(Error_selector_offset, BadFraction_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"ConsiderationNotMet\" error\n *      message, including the provided order index, consideration index, and\n *      shortfall amount.\n *\n * @param orderIndex         The index of the order that did not meet the\n *                           consideration criteria.\n * @param considerationIndex The index of the consideration item that did not\n *                           meet its criteria.\n * @param shortfallAmount    The amount by which the consideration criteria were\n *                           not met.\n */\nfunction _revertConsiderationNotMet(\n    uint256 orderIndex,\n    uint256 considerationIndex,\n    uint256 shortfallAmount\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationNotMet_error_selector)\n\n        // Store arguments.\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\n        mstore(\n            ConsiderationNotMet_error_considerationIndex_ptr, considerationIndex\n        )\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationNotMet(uint256,uint256,uint256)\",\n        //     orderIndex,\n        //     considerationIndex,\n        //     shortfallAmount\n        // ))\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"CriteriaNotEnabledForItem\" error\n *      message.\n */\nfunction _revertCriteriaNotEnabledForItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CriteriaNotEnabledForItem()\"))\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InsufficientNativeTokensSupplied\" error message.\n */\nfunction _revertInsufficientNativeTokensSupplied() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InsufficientNativeTokensSupplied()\"))\n        revert(\n            Error_selector_offset, InsufficientNativeTokensSupplied_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InvalidBasicOrderParameterEncoding\" error message.\n */\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidBasicOrderParameterEncoding()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            InvalidBasicOrderParameterEncoding_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidCallToConduit\" error\n *      message, including the provided address of the conduit that was called\n *      improperly.\n *\n * @param conduit The address of the conduit that was called improperly.\n */\nfunction _revertInvalidCallToConduit(address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidCallToConduit_error_selector)\n\n        // Store argument.\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidCallToConduit(address)\",\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"CannotCancelOrder\" error\n *      message.\n */\nfunction _revertCannotCancelOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CannotCancelOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CannotCancelOrder()\"))\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidConduit\" error message,\n *      including the provided key and address of the invalid conduit.\n *\n * @param conduitKey    The key of the invalid conduit.\n * @param conduit       The address of the invalid conduit.\n */\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidConduit_error_selector)\n\n        // Store arguments.\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidConduit(bytes32,address)\",\n        //     conduitKey,\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidERC721TransferAmount\"\n *      error message.\n *\n * @param amount The invalid amount.\n */\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidERC721TransferAmount_error_selector)\n\n        // Store argument.\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidERC721TransferAmount(uint256)\",\n        //     amount\n        // ))\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidMsgValue\" error message,\n *      including the invalid value that was sent in the transaction's\n *      `msg.value` field.\n *\n * @param value The invalid value that was sent in the transaction's `msg.value`\n *              field.\n */\nfunction _revertInvalidMsgValue(uint256 value) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidMsgValue_error_selector)\n\n        // Store argument.\n        mstore(InvalidMsgValue_error_value_ptr, value)\n\n        // revert(abi.encodeWithSignature(\"InvalidMsgValue(uint256)\", value))\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidNativeOfferItem\" error\n *      message.\n */\nfunction _revertInvalidNativeOfferItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidNativeOfferItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidNativeOfferItem()\"))\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidProof\" error message.\n */\nfunction _revertInvalidProof() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidProof_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidProof()\"))\n        revert(Error_selector_offset, InvalidProof_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidContractOrder\" error\n *      message.\n *\n * @param orderHash The hash of the contract order that caused the error.\n */\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidContractOrder_error_selector)\n\n        // Store arguments.\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidContractOrder(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidTime\" error message.\n *\n * @param startTime       The time at which the order becomes active.\n * @param endTime         The time at which the order becomes inactive.\n */\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidTime_error_selector)\n\n        // Store arguments.\n        mstore(InvalidTime_error_startTime_ptr, startTime)\n        mstore(InvalidTime_error_endTime_ptr, endTime)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidTime(uint256,uint256)\",\n        //     startTime,\n        //     endTime\n        // ))\n        revert(Error_selector_offset, InvalidTime_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingFulfillmentComponentOnAggregation\"\n *       error message.\n *\n * @param side The side of the fulfillment component that is missing (0 for\n *             offer, 1 for consideration).\n *\n */\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\n\n        // Store argument.\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingFulfillmentComponentOnAggregation(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingFulfillmentComponentOnAggregation_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingOriginalConsiderationItems\" error\n *      message.\n */\nfunction _revertMissingOriginalConsiderationItems() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingOriginalConsiderationItems()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingOriginalConsiderationItems_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoReentrantCalls\" error message.\n */\nfunction _revertNoReentrantCalls() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoReentrantCalls_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoSpecifiedOrdersAvailable\" error message.\n */\nfunction _revertNoSpecifiedOrdersAvailable() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoSpecifiedOrdersAvailable()\"))\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderAlreadyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been filled.\n */\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderAlreadyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderAlreadyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderCriteriaResolverOutOfRange\" error\n *      message.\n *\n * @param side The side of the criteria that is missing (0 for offer, 1 for\n *             consideration).\n *\n */\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\n\n        // Store argument.\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderCriteriaResolverOutOfRange(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset, OrderCriteriaResolverOutOfRange_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderIsCancelled\" error message.\n *\n * @param orderHash The hash of the order that has already been cancelled.\n */\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderIsCancelled_error_selector)\n\n        // Store argument.\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderIsCancelled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderPartiallyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been partially\n *                  filled.\n */\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderPartiallyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderPartiallyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"PartialFillsNotEnabledForOrder\" error message.\n */\nfunction _revertPartialFillsNotEnabledForOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"PartialFillsNotEnabledForOrder()\"))\n        revert(\n            Error_selector_offset, PartialFillsNotEnabledForOrder_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnusedItemParameters\" error message.\n */\nfunction _revertUnusedItemParameters() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnusedItemParameters_error_selector)\n\n        // revert(abi.encodeWithSignature(\"UnusedItemParameters()\"))\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"ConsiderationLengthNotEqualToTotalOriginal\"\n *      error message.\n */\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationLengthNotEqualToTotalOriginal()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\n        )\n    }\n}\n"
    },
    "lib/seaport-types/src/lib/ConsiderationConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term \"pointer\" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix \"_ptr\" refers to a memory pointer.\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\n *\n *    - The term \"offset\" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\n// Declare constants for name, version, and reentrancy sentinel values.\n\n// Name is right padded, so it touches the length which is left padded. This\n// enables writing both values at once. Length goes at byte 95 in memory, and\n// name fills bytes 96-109, so both values can be written left-padded to 77.\nuint256 constant NameLengthPtr = 0x4D;\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\n\nuint256 constant information_version_offset = 0;\nuint256 constant information_version_cd_offset = 0x60;\nuint256 constant information_domainSeparator_offset = 0x20;\nuint256 constant information_conduitController_offset = 0x40;\nuint256 constant information_versionLengthPtr = 0x63;\nuint256 constant information_versionWithLength = 0x03312e36; // 1.6\nuint256 constant information_length = 0xa0;\n\n// uint256(uint32(bytes4(keccak256(\"_REENTRANCY_GUARD_SLOT\"))))\nuint256 constant _REENTRANCY_GUARD_SLOT = 0x929eee14;\n\n/*\n *\n * --------------------------------------------------------------------------+\n * Opcode      | Mnemonic         | Stack               | Memory             |\n * --------------------------------------------------------------------------|\n * 60 0x02     | PUSH1 0x02       | 0x02                |                    |\n * 60 0x1e     | PUSH1 0x1e       | 0x1e 0x02           |                    |\n * 61 0x3d5c   | PUSH2 0x3d5c     | 0x3d5c 0x1e 0x02    |                    |\n * 3d          | RETURNDATASIZE   | 0 0x3d5c 0x1e 0x02  |                    |\n *                                                                           |\n * ::: store deployed bytecode in memory: (3d) RETURNDATASIZE (5c) TLOAD ::: |\n * 52          | MSTORE           | 0x1e 0x02           | [0..0x20): 0x3d5c  |\n * f3          | RETURN           |                     | [0..0x20): 0x3d5c  |\n * --------------------------------------------------------------------------+\n */\nuint256 constant _TLOAD_TEST_PAYLOAD = 0x6002_601e_613d5c_3d_52_f3;\nuint256 constant _TLOAD_TEST_PAYLOAD_LENGTH = 0x0a;\nuint256 constant _TLOAD_TEST_PAYLOAD_OFFSET = 0x16;\nuint256 constant _NOT_ENTERED_TSTORE = 0;\nuint256 constant _ENTERED_TSTORE = 1;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_TSTORE = 2;\nuint256 constant _TSTORE_ENABLED_SSTORE = 0;\nuint256 constant _NOT_ENTERED_SSTORE = 1;\nuint256 constant _ENTERED_SSTORE = 2;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS_SSTORE = 3;\n\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts =\n    (0x60);\n\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\n\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\n\n// Common Offsets\n// Offsets for identically positioned fields shared by:\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\n\nuint256 constant Selector_length = 0x4;\n\nuint256 constant Common_token_offset = 0x20;\nuint256 constant Common_identifier_offset = 0x40;\nuint256 constant Common_amount_offset = 0x60;\nuint256 constant Common_endAmount_offset = 0x80;\n\nuint256 constant SpentItem_size = 0x80;\nuint256 constant SpentItem_size_shift = 0x7;\n\nuint256 constant OfferItem_size = 0xa0;\nuint256 constant OfferItem_size_with_head_pointer = 0xc0;\n\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\nuint256 constant ReceivedItem_size = 0xa0;\nuint256 constant ReceivedItem_amount_offset = 0x60;\nuint256 constant ReceivedItem_recipient_offset = 0x80;\n\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\n\nuint256 constant ConsiderationItem_size = 0xc0;\nuint256 constant ConsiderationItem_size_with_head_pointer = 0xe0;\n\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\n// Store the same constant in an abbreviated format for a line length fix.\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\n\nuint256 constant Execution_offerer_offset = 0x20;\nuint256 constant Execution_conduit_offset = 0x40;\n\n// uint256 constant OrderParameters_offerer_offset = 0x00;\nuint256 constant OrderParameters_zone_offset = 0x20;\nuint256 constant OrderParameters_offer_head_offset = 0x40;\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\n// uint256 constant OrderParameters_orderType_offset = 0x80;\nuint256 constant OrderParameters_startTime_offset = 0xa0;\nuint256 constant OrderParameters_endTime_offset = 0xc0;\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\nuint256 constant OrderParameters_salt_offset = 0x100;\nuint256 constant OrderParameters_conduit_offset = 0x120;\nuint256 constant OrderParameters_counter_offset = 0x140;\n\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\n\nuint256 constant AdvancedOrder_head_size = 0xa0;\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\nuint256 constant AdvancedOrder_signature_offset = 0x60;\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\n\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\nuint256 constant OrderStatus_ValidatedAndNotCancelledAndFullyFilled = (\n    0x0000000000000000000000000000010000000000000000000000000000010001\n);\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant SixtyThreeBytes = 0x3f;\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\n\nuint256 constant BasicOrder_common_params_size = 0xa0;\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\nuint256 constant BasicOrder_receivedItemByteMap =\n    (0x0000010102030000000000000000000000000000000000000000000000000000);\nuint256 constant BasicOrder_offeredItemByteMap =\n    (0x0203020301010000000000000000000000000000000000000000000000000000);\nuint256 constant BasicOrder_consideration_offset_from_offer = 0xa0;\n\nbytes32 constant OrdersMatchedTopic0 =\n    (0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7);\n\nuint256 constant EIP712_Order_size = 0x180;\nuint256 constant EIP712_OfferItem_size = 0xc0;\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\nuint256 constant AdditionalRecipient_size = 0x40;\nuint256 constant AdditionalRecipient_size_shift = 0x6;\n\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_OrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\n\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\nuint256 constant EIP712_domainData_size = 0xa0;\n\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\n// 768 for 24 siblings.\n\nuint256 constant BulkOrderProof_minSize = 0x63;\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\nuint256 constant BulkOrderProof_keyShift = 0xe8;\nuint256 constant BulkOrderProof_keySize = 0x3;\n\nuint256 constant BulkOrder_Typehash_Height_One =\n    (0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32);\nuint256 constant BulkOrder_Typehash_Height_Two =\n    (0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30);\nuint256 constant BulkOrder_Typehash_Height_Three =\n    (0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d);\nuint256 constant BulkOrder_Typehash_Height_Four =\n    (0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1);\nuint256 constant BulkOrder_Typehash_Height_Five =\n    (0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6);\nuint256 constant BulkOrder_Typehash_Height_Six =\n    (0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55);\nuint256 constant BulkOrder_Typehash_Height_Seven =\n    (0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c);\nuint256 constant BulkOrder_Typehash_Height_Eight =\n    (0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14);\nuint256 constant BulkOrder_Typehash_Height_Nine =\n    (0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a);\nuint256 constant BulkOrder_Typehash_Height_Ten =\n    (0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05);\nuint256 constant BulkOrder_Typehash_Height_Eleven =\n    (0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53);\nuint256 constant BulkOrder_Typehash_Height_Twelve =\n    (0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f);\nuint256 constant BulkOrder_Typehash_Height_Thirteen =\n    (0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e);\nuint256 constant BulkOrder_Typehash_Height_Fourteen =\n    (0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590);\nuint256 constant BulkOrder_Typehash_Height_Fifteen =\n    (0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9);\nuint256 constant BulkOrder_Typehash_Height_Sixteen =\n    (0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8);\nuint256 constant BulkOrder_Typehash_Height_Seventeen =\n    (0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222);\nuint256 constant BulkOrder_Typehash_Height_Eighteen =\n    (0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877);\nuint256 constant BulkOrder_Typehash_Height_Nineteen =\n    (0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d);\nuint256 constant BulkOrder_Typehash_Height_Twenty =\n    (0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017);\nuint256 constant BulkOrder_Typehash_Height_TwentyOne =\n    (0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719);\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo =\n    (0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d);\nuint256 constant BulkOrder_Typehash_Height_TwentyThree =\n    (0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76);\nuint256 constant BulkOrder_Typehash_Height_TwentyFour =\n    (0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c);\n\nuint256 constant receivedItemsHash_ptr = 0x60;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  data for OrderFulfilled\n *\n *   event OrderFulfilled(\n *     bytes32 orderHash,\n *     address indexed offerer,\n *     address indexed zone,\n *     address fulfiller,\n *     SpentItem[] offer,\n *       > (itemType, token, id, amount)\n *     ReceivedItem[] consideration\n *       > (itemType, token, id, amount, recipient)\n *   )\n *\n *  - 0x00: orderHash\n *  - 0x20: fulfiller\n *  - 0x40: offer offset (0x80)\n *  - 0x60: consideration offset (0x120)\n *  - 0x80: offer.length (1)\n *  - 0xa0: offerItemType\n *  - 0xc0: offerToken\n *  - 0xe0: offerIdentifier\n *  - 0x100: offerAmount\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\n *  - 0x140: considerationItemType\n *  - 0x160: considerationToken\n *  - 0x180: considerationIdentifier\n *  - 0x1a0: considerationAmount\n *  - 0x1c0: considerationRecipient\n *  - ...\n */\n\n// Minimum length of the OrderFulfilled event data.\n// Must be added to the size of the ReceivedItem array for additionalRecipients\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\nuint256 constant OrderFulfilled_selector =\n    (0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31);\n\n// Minimum offset in memory to OrderFulfilled event data.\n// Must be added to the size of the EIP712 hash array for additionalRecipients\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\nuint256 constant OrderFulfilled_baseOffset = 0x180;\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\n\nuint256 constant OrderFulfilled_offer_length_offset_relativeTo_baseOffset = (\n    0x80\n);\nuint256 constant OrderFulfilled_offer_itemType_offset_relativeTo_baseOffset = (\n    0xa0\n);\nuint256 constant OrderFulfilled_offer_token_offset_relativeTo_baseOffset = 0xc0;\n\n// Related constants used for restricted order checks on basic orders.\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\n\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\n\n/*\n * 3 memory slots/words for `authorizeOrder` and `validateOrder` calldata\n * to be used for tails of extra data (length 0) and order hashes (length 1)\n */\nuint256 constant OrderFulfilled_post_memory_region_reservedBytes = 0x60;\n\n/*\n * OrderFulfilled_offer_length_baseOffset - 12 * 0x20\n * we back up 12 words from where the `OrderFulfilled`'s data\n * for spent items start to be rewritten for `authorizeOrder`\n * and `validateOrder`. Let the reference pointer be `ptr`\n * pointing to the `OrderFulfilled`'s spent item array's length memory\n * position then we would have:\n *\n * ptr - 0x0180 : zero-padded calldata selector\n * ptr - 0x0160 : ZoneParameter's struct head (0x20)\n * ptr - 0x0140 : order hash\n * ptr - 0x0120 : fulfiller (msg.sender)\n * ptr - 0x0100 : offerer\n * ptr - 0x00e0 : spent items' head\n * ptr - 0x00c0 : received items' head\n * ptr - 0x00a0 : extra data / context head\n * ptr - 0x0080 : order hashes head\n * ptr - 0x0060 : start time\n * ptr - 0x0040 : end time\n * ptr - 0x0020 : zone hash\n * ptr - 0x0000 : offer.length (1)\n * ...\n *\n * Note that the padded calldata selector will be at minimum at the\n * 0x80 memory slot.\n */\nuint256 constant authorizeOrder_calldata_baseOffset = (\n    OrderFulfilled_offer_length_baseOffset - 0x180\n);\n\n// BasicOrderParameters\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_basicOrderParameters_cd_offset = 0x24;\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_addlRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\nuint256 constant BasicOrder_parameters_ptr = 0x20;\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for ConsiderationItem\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n *   - 0xa0: itemType\n *   - 0xc0: token\n *   - 0xe0: identifier\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n *   - 0x140: recipient\n */\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for OfferItem\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\n *   - 0xa0:  itemType\n *   - 0xc0:  token\n *   - 0xe0:  identifier (reused for offeredItemsHash)\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n */\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for Order\n *   - 0x80:   Order EIP-712 typehash (constant)\n *   - 0xa0:   orderParameters.offerer\n *   - 0xc0:   orderParameters.zone\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n *   - 0x120:  orderType\n *   - 0x140:  startTime\n *   - 0x160:  endTime\n *   - 0x180:  zoneHash\n *   - 0x1a0:  salt\n *   - 0x1c0:  conduit\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n */\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\nuint256 constant BasicOrder_signature_ptr = 0x260;\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\n\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\n\nuint256 constant Counter_blockhash_shift = 0x80;\n\n// Signature-related\nbytes32 constant EIP2098_allButHighestBitMask =\n    (0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet =\n    (0x0000000000000000000000000000000000000000000000000000000101000000);\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\nbytes32 constant EIP1271_isValidSignature_selector =\n    (0x1626ba7e00000000000000000000000000000000000000000000000000000000);\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\n\nuint256 constant EIP_712_PREFIX =\n    (0x1901000000000000000000000000000000000000000000000000000000000000);\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\nuint256 constant Create2AddressDerivation_length = 0x55;\n\nuint256 constant MaskOverByteTwelve =\n    (0x0000000000000000000000ff0000000000000000000000000000000000000000);\nuint256 constant MaskOverLastTwentyBytes =\n    (0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff);\nuint256 constant AddressDirtyUpperBitThreshold =\n    (0x0000000000000000000000010000000000000000000000000000000000000000);\nuint256 constant MaskOverFirstFourBytes =\n    (0xffffffff00000000000000000000000000000000000000000000000000000000);\n\nuint256 constant Conduit_execute_signature =\n    (0x4ce34aa200000000000000000000000000000000000000000000000000000000);\n\nuint256 constant MaxUint8 = 0xff;\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\n\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\n\nuint256 constant OneConduitExecute_size = 0x104;\n\n// Sentinel value to indicate that the conduit accumulator is not armed.\nuint256 constant AccumulatorDisarmed = 0x20;\nuint256 constant AccumulatorArmed = 0x40;\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\nuint256 constant Accumulator_selector_ptr = 0x40;\nuint256 constant Accumulator_array_offset_ptr = 0x44;\nuint256 constant Accumulator_array_length_ptr = 0x64;\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\nuint256 constant Accumulator_array_offset = 0x20;\n\nuint256 constant Conduit_transferItem_size = 0xc0;\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\n\nuint256 constant Ecrecover_precompile = 0x1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant Signature_lower_v = 27;\n\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\nuint256 constant NonMatchSelector_MagicMask =\n    (0x4000000000000000000000000000000000000000000000000000000000);\n\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\n// indicates that a non match selector has been called.\nuint256 constant NonMatchSelector_InvalidErrorValue =\n    (0x4000000000000000000000000000000000000000000000000000000001);\n\n/**\n * @dev Selector and offsets for generateOrder\n *\n * function generateOrder(\n *   address fulfiller,\n *   SpentItem[] calldata minimumReceived,\n *   SpentItem[] calldata maximumSpent,\n *   bytes calldata context\n * )\n */\nuint256 constant generateOrder_selector = 0x98919765;\nuint256 constant generateOrder_selector_offset = 0x1c;\nuint256 constant generateOrder_head_offset = 0x04;\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\nuint256 constant generateOrder_context_head_offset = 0x60;\nuint256 constant generateOrder_base_tail_offset = 0x80;\nuint256 constant generateOrder_maximum_returned_array_length = 0xffff;\n\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\nuint256 constant ratifyOrder_selector_offset = 0x1c;\nuint256 constant ratifyOrder_head_offset = 0x04;\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\nuint256 constant ratifyOrder_context_head_offset = 0x40;\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\n\nuint256 constant validateOrder_selector = 0x17b1f942;\nuint256 constant validateOrder_selector_offset = 0x1c;\nuint256 constant validateOrder_head_offset = 0x04;\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\n\nuint256 constant authorizeOrder_selector = 0x01e4d72a;\nuint256 constant authorizeOrder_selector_offset = 0x1c;\nuint256 constant authorizeOrder_head_offset = 0x04;\nuint256 constant authorizeOrder_zoneParameters_offset = 0x20;\n\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\nuint256 constant ZoneParameters_offerer_offset = 0x40;\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\nuint256 constant ZoneParameters_endTime_offset = 0x100;\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x44;\n\n// ConsiderationDecoder Constants\nuint256 constant OrderParameters_head_size = 0x0160;\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\n    0x0140\n);\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\n\nuint256 constant Order_signature_offset = 0x20;\nuint256 constant Order_head_size = 0x40;\n\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\n\nuint256 constant CriteriaResolver_head_size = 0xa0;\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\n\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\nuint256 constant Fulfillment_head_size = 0x40;\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\n\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\n"
    },
    "lib/seaport-types/src/lib/ConsiderationErrorConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nuint256 constant Error_selector_offset = 0x1c;\n\n/*\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\n    0x375c24c1\n);\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\n\n/*\n *  error OfferAndConsiderationRequiredOnFulfillment()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\n    0x98e9db6e\n);\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\n\n/*\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\n *      uint256 fulfillmentIndex\n *  )\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: fulfillmentIndex\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\n    0xbced929d\n);\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\n\n/*\n *  error InvalidFulfillmentComponentData()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\n\n/*\n *  error InexactFraction()\n *    - Defined in AmountDerivationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\nuint256 constant InexactFraction_error_length = 0x04;\n\n/*\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\n\n/*\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: offerIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\n\n/*\n *  error UnresolvedConsiderationCriteria(\n *      uint256 orderIndex,\n *      uint256 considerationIndex\n *  )\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedConsiderationCriteria_error_itemIndex_ptr = 0x40;\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\n\n/*\n *  error OfferCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\n// uint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error ConsiderationCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\n    0x6088d7de\n);\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\n    0x6088d7de\n);\n// uint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error CriteriaNotEnabledForItem()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\n\n/*\n *  error InvalidProof()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidProof_error_selector = 0x09bde339;\nuint256 constant InvalidProof_error_length = 0x04;\n\n/*\n *  error InvalidRestrictedOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\n\n/*\n *  error InvalidContractOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidContractOrder_error_length = 0x24;\n\n/*\n *  error BadSignatureV(uint8 v)\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: v\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\nuint256 constant BadSignatureV_error_length = 0x24;\n\n/*\n *  error InvalidSigner()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\nuint256 constant InvalidSigner_error_length = 0x04;\n\n/*\n *  error InvalidSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\nuint256 constant InvalidSignature_error_length = 0x04;\n\n/*\n *  error BadContractSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\nuint256 constant BadContractSignature_error_length = 0x04;\n\n/*\n *  error InvalidERC721TransferAmount(uint256 amount)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: amount\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\n\n/*\n *  error MissingItemAmount()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\nuint256 constant MissingItemAmount_error_length = 0x04;\n\n/*\n *  error UnusedItemParameters()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\nuint256 constant UnusedItemParameters_error_length = 0x04;\n\n/*\n *  error NoReentrantCalls()\n *    - Defined in ReentrancyErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\nuint256 constant NoReentrantCalls_error_length = 0x04;\n\n/*\n *  error OrderAlreadyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\n\n/*\n *  error InvalidTime(uint256 startTime, uint256 endTime)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: startTime\n *    - 0x40: endTime\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\nuint256 constant InvalidTime_error_length = 0x44;\n\n/*\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduitKey\n *    - 0x40: conduit\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\nuint256 constant InvalidConduit_error_length = 0x44;\n\n/*\n *  error MissingOriginalConsiderationItems()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\n\n/*\n *  error InvalidCallToConduit(address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduit\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\nuint256 constant InvalidCallToConduit_error_length = 0x24;\n\n/*\n *  error ConsiderationNotMet(\n *      uint256 orderIndex,\n *      uint256 considerationIndex,\n *      uint256 shortfallAmount\n *  )\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n *    - 0x60: shortfallAmount\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\nuint256 constant ConsiderationNotMet_error_length = 0x64;\n\n/*\n *  error InsufficientNativeTokensSupplied()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\n\n/*\n *  error NativeTokenTransferGenericFailure(address account, uint256 amount)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: account\n *    - 0x40: amount\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\n\n/*\n *  error PartialFillsNotEnabledForOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\n\n/*\n *  error OrderIsCancelled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\nuint256 constant OrderIsCancelled_error_length = 0x24;\n\n/*\n *  error OrderPartiallyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\n\n/*\n *  error CannotCancelOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\nuint256 constant CannotCancelOrder_error_length = 0x04;\n\n/*\n *  error BadFraction()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadFraction_error_selector = 0x5a052b32;\nuint256 constant BadFraction_error_length = 0x04;\n\n/*\n *  error InvalidMsgValue(uint256 value)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: value\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\nuint256 constant InvalidMsgValue_error_length = 0x24;\n\n/*\n *  error InvalidBasicOrderParameterEncoding()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\n\n/*\n *  error NoSpecifiedOrdersAvailable()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\n\n/*\n *  error InvalidNativeOfferItem()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\n\n/*\n *  error ConsiderationLengthNotEqualToTotalOriginal()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\n    0x2165628a\n);\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\n\n/*\n *  error Panic(uint256 code)\n *    - Built-in Solidity error\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: code\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant Panic_error_selector = 0x4e487b71;\nuint256 constant Panic_error_code_ptr = 0x20;\nuint256 constant Panic_error_length = 0x24;\n\nuint256 constant Panic_arithmetic = 0x11;\n// uint256 constant Panic_resource = 0x41;\n"
    },
    "lib/seaport-types/src/lib/ConsiderationEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}\n"
    },
    "lib/seaport-types/src/helpers/PointerLibraries.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype CalldataPointer is uint256;\n\ntype ReturndataPointer is uint256;\n\ntype MemoryPointer is uint256;\n\nusing CalldataPointerLib for CalldataPointer global;\nusing MemoryPointerLib for MemoryPointer global;\nusing ReturndataPointerLib for ReturndataPointer global;\n\nusing CalldataReaders for CalldataPointer global;\nusing ReturndataReaders for ReturndataPointer global;\nusing MemoryReaders for MemoryPointer global;\nusing MemoryWriters for MemoryPointer global;\n\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\nMemoryPointer constant ZeroSlotPtr = MemoryPointer.wrap(0x60);\nuint256 constant IdentityPrecompileAddress = 0x4;\nuint256 constant OffsetOrLengthMask = 0xffffffff;\nuint256 constant _OneWord = 0x20;\nuint256 constant _FreeMemoryPointerSlot = 0x40;\n\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\n///    and returns the memory pointer to the first byte of the allocated region.\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\n    assembly {\n        mPtr := mload(_FreeMemoryPointerSlot)\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\n    }\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\n    FreeMemoryPPtr.write(mPtr);\n}\n\nlibrary CalldataPointerLib {\n    function lt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `cdPtr + headOffset`.\n    function pptrOffset(\n        CalldataPointer cdPtr,\n        uint256 headOffset\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\n    ///      first member, e.g. `struct { bytes data; }`\n    function pptr(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\n    function next(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        CalldataPointer cdPtr,\n        uint256 _offset\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\n    ///      `dst`.\n    function copy(\n        CalldataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            calldatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary ReturndataPointerLib {\n    function lt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `rdPtr + headOffset`.\n    function pptrOffset(\n        ReturndataPointer rdPtr,\n        uint256 headOffset\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\n    function next(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        ReturndataPointer rdPtr,\n        uint256 _offset\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\n    /// `dst`.\n    function copy(\n        ReturndataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            returndatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary MemoryPointerLib {\n    function copy(\n        MemoryPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal view {\n        assembly {\n            let success := staticcall(\n                gas(),\n                IdentityPrecompileAddress,\n                src,\n                size,\n                dst,\n                size\n            )\n            if or(iszero(returndatasize()), iszero(success)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function lt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    function hash(\n        MemoryPointer ptr,\n        uint256 length\n    ) internal pure returns (bytes32 _hash) {\n        assembly {\n            _hash := keccak256(ptr, length)\n        }\n    }\n\n    /// @dev Returns the memory pointer one word after `mPtr`.\n    function next(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\n    function offset(\n        MemoryPointer mPtr,\n        uint256 _offset\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _offset)\n        }\n    }\n\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\n    ///    type's pointer stored at `mPtr + headOffset`.\n    function pptrOffset(\n        MemoryPointer mPtr,\n        uint256 headOffset\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\n    }\n\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\n    ///    `mPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.readMemoryPointer();\n    }\n}\n\nlibrary CalldataReaders {\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\n    ///    last 4 bytes.\n    function readMaskedUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `cdPtr` in calldata.\n    function readBool(\n        CalldataPointer cdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the address at `cdPtr` in calldata.\n    function readAddress(\n        CalldataPointer cdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\n    function readBytes1(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\n    function readBytes2(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\n    function readBytes3(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\n    function readBytes4(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\n    function readBytes5(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\n    function readBytes6(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\n    function readBytes7(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\n    function readBytes8(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\n    function readBytes9(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\n    function readBytes10(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\n    function readBytes11(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\n    function readBytes12(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\n    function readBytes13(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\n    function readBytes14(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\n    function readBytes15(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\n    function readBytes16(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\n    function readBytes17(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\n    function readBytes18(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\n    function readBytes19(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\n    function readBytes20(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\n    function readBytes21(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\n    function readBytes22(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\n    function readBytes23(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\n    function readBytes24(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\n    function readBytes25(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\n    function readBytes26(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\n    function readBytes27(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\n    function readBytes28(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\n    function readBytes29(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\n    function readBytes30(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\n    function readBytes31(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\n    function readBytes32(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\n    function readUint8(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\n    function readUint16(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\n    function readUint24(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\n    function readUint32(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\n    function readUint40(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\n    function readUint48(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\n    function readUint56(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\n    function readUint64(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\n    function readUint72(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\n    function readUint80(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\n    function readUint88(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\n    function readUint96(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\n    function readUint104(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\n    function readUint112(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\n    function readUint120(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\n    function readUint128(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\n    function readUint136(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\n    function readUint144(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\n    function readUint152(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\n    function readUint160(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\n    function readUint168(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\n    function readUint176(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\n    function readUint184(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\n    function readUint192(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\n    function readUint200(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\n    function readUint208(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\n    function readUint216(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\n    function readUint224(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\n    function readUint232(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\n    function readUint240(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\n    function readUint248(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\n    function readUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `cdPtr` in calldata.\n    function readInt8(\n        CalldataPointer cdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `cdPtr` in calldata.\n    function readInt16(\n        CalldataPointer cdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `cdPtr` in calldata.\n    function readInt24(\n        CalldataPointer cdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `cdPtr` in calldata.\n    function readInt32(\n        CalldataPointer cdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `cdPtr` in calldata.\n    function readInt40(\n        CalldataPointer cdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `cdPtr` in calldata.\n    function readInt48(\n        CalldataPointer cdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `cdPtr` in calldata.\n    function readInt56(\n        CalldataPointer cdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `cdPtr` in calldata.\n    function readInt64(\n        CalldataPointer cdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `cdPtr` in calldata.\n    function readInt72(\n        CalldataPointer cdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `cdPtr` in calldata.\n    function readInt80(\n        CalldataPointer cdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `cdPtr` in calldata.\n    function readInt88(\n        CalldataPointer cdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `cdPtr` in calldata.\n    function readInt96(\n        CalldataPointer cdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `cdPtr` in calldata.\n    function readInt104(\n        CalldataPointer cdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `cdPtr` in calldata.\n    function readInt112(\n        CalldataPointer cdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `cdPtr` in calldata.\n    function readInt120(\n        CalldataPointer cdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `cdPtr` in calldata.\n    function readInt128(\n        CalldataPointer cdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `cdPtr` in calldata.\n    function readInt136(\n        CalldataPointer cdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `cdPtr` in calldata.\n    function readInt144(\n        CalldataPointer cdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `cdPtr` in calldata.\n    function readInt152(\n        CalldataPointer cdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `cdPtr` in calldata.\n    function readInt160(\n        CalldataPointer cdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `cdPtr` in calldata.\n    function readInt168(\n        CalldataPointer cdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `cdPtr` in calldata.\n    function readInt176(\n        CalldataPointer cdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `cdPtr` in calldata.\n    function readInt184(\n        CalldataPointer cdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `cdPtr` in calldata.\n    function readInt192(\n        CalldataPointer cdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `cdPtr` in calldata.\n    function readInt200(\n        CalldataPointer cdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `cdPtr` in calldata.\n    function readInt208(\n        CalldataPointer cdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `cdPtr` in calldata.\n    function readInt216(\n        CalldataPointer cdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `cdPtr` in calldata.\n    function readInt224(\n        CalldataPointer cdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `cdPtr` in calldata.\n    function readInt232(\n        CalldataPointer cdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `cdPtr` in calldata.\n    function readInt240(\n        CalldataPointer cdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `cdPtr` in calldata.\n    function readInt248(\n        CalldataPointer cdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `cdPtr` in calldata.\n    function readInt256(\n        CalldataPointer cdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n}\n\nlibrary ReturndataReaders {\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `rdPtr` in returndata.\n    function readBool(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the address at `rdPtr` in returndata.\n    function readAddress(\n        ReturndataPointer rdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\n    function readBytes1(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\n    function readBytes2(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\n    function readBytes3(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\n    function readBytes4(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\n    function readBytes5(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\n    function readBytes6(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\n    function readBytes7(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\n    function readBytes8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\n    function readBytes9(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\n    function readBytes10(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\n    function readBytes11(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\n    function readBytes12(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\n    function readBytes13(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\n    function readBytes14(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\n    function readBytes15(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\n    function readBytes16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\n    function readBytes17(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\n    function readBytes18(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\n    function readBytes19(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\n    function readBytes20(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\n    function readBytes21(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\n    function readBytes22(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\n    function readBytes23(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\n    function readBytes24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\n    function readBytes25(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\n    function readBytes26(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\n    function readBytes27(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\n    function readBytes28(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\n    function readBytes29(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\n    function readBytes30(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\n    function readBytes31(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\n    function readBytes32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\n    function readUint8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\n    function readUint16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\n    function readUint24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\n    function readUint32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\n    function readUint40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\n    function readUint48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\n    function readUint56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\n    function readUint64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\n    function readUint72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\n    function readUint80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\n    function readUint88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\n    function readUint96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\n    function readUint104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\n    function readUint112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\n    function readUint120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\n    function readUint128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\n    function readUint136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\n    function readUint144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\n    function readUint152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\n    function readUint160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\n    function readUint168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\n    function readUint176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\n    function readUint184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\n    function readUint192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\n    function readUint200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\n    function readUint208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\n    function readUint216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\n    function readUint224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\n    function readUint232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\n    function readUint240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\n    function readUint248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\n    function readUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int8 at `rdPtr` in returndata.\n    function readInt8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int16 at `rdPtr` in returndata.\n    function readInt16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int24 at `rdPtr` in returndata.\n    function readInt24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int32 at `rdPtr` in returndata.\n    function readInt32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int40 at `rdPtr` in returndata.\n    function readInt40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int48 at `rdPtr` in returndata.\n    function readInt48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int56 at `rdPtr` in returndata.\n    function readInt56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int64 at `rdPtr` in returndata.\n    function readInt64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int72 at `rdPtr` in returndata.\n    function readInt72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int80 at `rdPtr` in returndata.\n    function readInt80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int88 at `rdPtr` in returndata.\n    function readInt88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int96 at `rdPtr` in returndata.\n    function readInt96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int104 at `rdPtr` in returndata.\n    function readInt104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int112 at `rdPtr` in returndata.\n    function readInt112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int120 at `rdPtr` in returndata.\n    function readInt120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int128 at `rdPtr` in returndata.\n    function readInt128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int136 at `rdPtr` in returndata.\n    function readInt136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int144 at `rdPtr` in returndata.\n    function readInt144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int152 at `rdPtr` in returndata.\n    function readInt152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int160 at `rdPtr` in returndata.\n    function readInt160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int168 at `rdPtr` in returndata.\n    function readInt168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int176 at `rdPtr` in returndata.\n    function readInt176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int184 at `rdPtr` in returndata.\n    function readInt184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int192 at `rdPtr` in returndata.\n    function readInt192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int200 at `rdPtr` in returndata.\n    function readInt200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int208 at `rdPtr` in returndata.\n    function readInt208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int216 at `rdPtr` in returndata.\n    function readInt216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int224 at `rdPtr` in returndata.\n    function readInt224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int232 at `rdPtr` in returndata.\n    function readInt232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int240 at `rdPtr` in returndata.\n    function readInt240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int248 at `rdPtr` in returndata.\n    function readInt248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int256 at `rdPtr` in returndata.\n    function readInt256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n}\n\nlibrary MemoryReaders {\n    /// @dev Reads the memory pointer at `mPtr` in memory.\n    function readMemoryPointer(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        value = mPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `mPtr` in memory.\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the address at `mPtr` in memory.\n    function readAddress(\n        MemoryPointer mPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `mPtr` in memory.\n    function readBytes1(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `mPtr` in memory.\n    function readBytes2(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `mPtr` in memory.\n    function readBytes3(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `mPtr` in memory.\n    function readBytes4(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `mPtr` in memory.\n    function readBytes5(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `mPtr` in memory.\n    function readBytes6(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `mPtr` in memory.\n    function readBytes7(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `mPtr` in memory.\n    function readBytes8(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `mPtr` in memory.\n    function readBytes9(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `mPtr` in memory.\n    function readBytes10(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `mPtr` in memory.\n    function readBytes11(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `mPtr` in memory.\n    function readBytes12(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `mPtr` in memory.\n    function readBytes13(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `mPtr` in memory.\n    function readBytes14(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `mPtr` in memory.\n    function readBytes15(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `mPtr` in memory.\n    function readBytes16(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `mPtr` in memory.\n    function readBytes17(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `mPtr` in memory.\n    function readBytes18(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `mPtr` in memory.\n    function readBytes19(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `mPtr` in memory.\n    function readBytes20(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `mPtr` in memory.\n    function readBytes21(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `mPtr` in memory.\n    function readBytes22(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `mPtr` in memory.\n    function readBytes23(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `mPtr` in memory.\n    function readBytes24(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `mPtr` in memory.\n    function readBytes25(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `mPtr` in memory.\n    function readBytes26(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `mPtr` in memory.\n    function readBytes27(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `mPtr` in memory.\n    function readBytes28(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `mPtr` in memory.\n    function readBytes29(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `mPtr` in memory.\n    function readBytes30(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `mPtr` in memory.\n    function readBytes31(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `mPtr` in memory.\n    function readBytes32(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `mPtr` in memory.\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `mPtr` in memory.\n    function readUint16(\n        MemoryPointer mPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `mPtr` in memory.\n    function readUint24(\n        MemoryPointer mPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `mPtr` in memory.\n    function readUint32(\n        MemoryPointer mPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `mPtr` in memory.\n    function readUint40(\n        MemoryPointer mPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `mPtr` in memory.\n    function readUint48(\n        MemoryPointer mPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `mPtr` in memory.\n    function readUint56(\n        MemoryPointer mPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `mPtr` in memory.\n    function readUint64(\n        MemoryPointer mPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `mPtr` in memory.\n    function readUint72(\n        MemoryPointer mPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `mPtr` in memory.\n    function readUint80(\n        MemoryPointer mPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `mPtr` in memory.\n    function readUint88(\n        MemoryPointer mPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `mPtr` in memory.\n    function readUint96(\n        MemoryPointer mPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `mPtr` in memory.\n    function readUint104(\n        MemoryPointer mPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `mPtr` in memory.\n    function readUint112(\n        MemoryPointer mPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `mPtr` in memory.\n    function readUint120(\n        MemoryPointer mPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `mPtr` in memory.\n    function readUint128(\n        MemoryPointer mPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `mPtr` in memory.\n    function readUint136(\n        MemoryPointer mPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `mPtr` in memory.\n    function readUint144(\n        MemoryPointer mPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `mPtr` in memory.\n    function readUint152(\n        MemoryPointer mPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `mPtr` in memory.\n    function readUint160(\n        MemoryPointer mPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `mPtr` in memory.\n    function readUint168(\n        MemoryPointer mPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `mPtr` in memory.\n    function readUint176(\n        MemoryPointer mPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `mPtr` in memory.\n    function readUint184(\n        MemoryPointer mPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `mPtr` in memory.\n    function readUint192(\n        MemoryPointer mPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `mPtr` in memory.\n    function readUint200(\n        MemoryPointer mPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `mPtr` in memory.\n    function readUint208(\n        MemoryPointer mPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `mPtr` in memory.\n    function readUint216(\n        MemoryPointer mPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `mPtr` in memory.\n    function readUint224(\n        MemoryPointer mPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `mPtr` in memory.\n    function readUint232(\n        MemoryPointer mPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `mPtr` in memory.\n    function readUint240(\n        MemoryPointer mPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `mPtr` in memory.\n    function readUint248(\n        MemoryPointer mPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `mPtr` in memory.\n    function readUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `mPtr` in memory.\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `mPtr` in memory.\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `mPtr` in memory.\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `mPtr` in memory.\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `mPtr` in memory.\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `mPtr` in memory.\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `mPtr` in memory.\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `mPtr` in memory.\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `mPtr` in memory.\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `mPtr` in memory.\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `mPtr` in memory.\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `mPtr` in memory.\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `mPtr` in memory.\n    function readInt104(\n        MemoryPointer mPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `mPtr` in memory.\n    function readInt112(\n        MemoryPointer mPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `mPtr` in memory.\n    function readInt120(\n        MemoryPointer mPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `mPtr` in memory.\n    function readInt128(\n        MemoryPointer mPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `mPtr` in memory.\n    function readInt136(\n        MemoryPointer mPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `mPtr` in memory.\n    function readInt144(\n        MemoryPointer mPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `mPtr` in memory.\n    function readInt152(\n        MemoryPointer mPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `mPtr` in memory.\n    function readInt160(\n        MemoryPointer mPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `mPtr` in memory.\n    function readInt168(\n        MemoryPointer mPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `mPtr` in memory.\n    function readInt176(\n        MemoryPointer mPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `mPtr` in memory.\n    function readInt184(\n        MemoryPointer mPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `mPtr` in memory.\n    function readInt192(\n        MemoryPointer mPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `mPtr` in memory.\n    function readInt200(\n        MemoryPointer mPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `mPtr` in memory.\n    function readInt208(\n        MemoryPointer mPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `mPtr` in memory.\n    function readInt216(\n        MemoryPointer mPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `mPtr` in memory.\n    function readInt224(\n        MemoryPointer mPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `mPtr` in memory.\n    function readInt232(\n        MemoryPointer mPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `mPtr` in memory.\n    function readInt240(\n        MemoryPointer mPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `mPtr` in memory.\n    function readInt248(\n        MemoryPointer mPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `mPtr` in memory.\n    function readInt256(\n        MemoryPointer mPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n}\n\nlibrary MemoryWriters {\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\n        assembly {\n            mstore(mPtr, valuePtr)\n        }\n    }\n\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, bool value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an address `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, address value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@rari-capital/solmate/=lib/solmate/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "murky/=lib/murky/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "solarray/=lib/solarray/src/",
      "solady/=lib/solady/",
      "seaport-sol/=lib/seaport-sol/",
      "seaport-types/=lib/seaport-types/",
      "seaport-core/=lib/seaport-core/",
      "seaport/=contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}