{"IVestingContract.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IVestingContract {\r\n    function completeInitialization() external;\r\n}"},"VestingContract.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IVestingContract.sol\";\n\ninterface IERC20 {\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n}\n\ncontract VestingContract is IVestingContract {\n\n    struct VestingInfo {\n        uint256 startingFrom;\n        uint256 interval;\n        uint256 tranches;\n    }\n\n    struct VestingInput {\n        VestingInfo info;\n        address[] owners;\n        uint256[] amounts;\n    }\n\n    struct Vesting {\n        uint256 infoIndex;\n        uint256[] timestamps;\n        uint256[] amounts;\n    }\n\n    uint256 private constant ONE_HUNDRED = 1e18;\n\n    address public rewardToken;\n\n    mapping(address =\u003e Vesting) private vestingOf;\n\n    VestingInfo[] public infos;\n\n    constructor(VestingInput[] memory inputs) {\n        for(uint256 i = 0; i \u003c inputs.length; i++) {\n            VestingInput memory input = inputs[i];\n            uint256 infoIndex = infos.length;\n            infos.push(input.info);\n            for(uint256 z = 0; z \u003c input.owners.length; z++) {\n                Vesting storage vesting = vestingOf[input.owners[z]];\n                vesting.infoIndex = infoIndex;\n                vesting.amounts.push(input.amounts[z]);\n            }\n        }\n    }\n\n    function completeInitialization() external override {\n        _setRewardToken(msg.sender);\n    }\n\n    function claim(address owner) external returns (uint256 amount) {\n        return _claim(rewardToken, owner, block.timestamp);\n    }\n\n    function claimBatch(address[] calldata owners) external returns (uint256[] memory amounts) {\n        amounts = new uint256[](owners.length);\n        address token = rewardToken;\n        uint256 blockTimestamp = block.timestamp;\n        for(uint256 i = 0; i \u003c owners.length; i++) {\n            amounts[i] = _claim(token, owners[i], blockTimestamp);\n        }\n    }\n\n    function _claim(address token, address owner, uint256 blockTimestamp) private returns(uint256 amount) {\n        if(token == address(0)) {\n            return 0;\n        }\n        Vesting storage vesting = _prepareVesting(owner);\n        if(vesting.amounts.length == 0) {\n            return 0;\n        }\n        uint256[] memory timestamps = vesting.timestamps;\n        for(uint256 i = 0; i \u003c timestamps.length; i++) {\n            if(timestamps[i] == 0) {\n                continue;\n            }\n            if(blockTimestamp \u003c timestamps[i]) {\n                break;\n            }\n            vesting.timestamps[i] = 0;\n            amount += vesting.amounts[i];\n        }\n        if(amount != 0) {\n            _safeTransfer(token, owner, amount);\n        }\n    }\n\n    function _prepareVesting(address owner) private returns(Vesting storage vesting) {\n        vesting = vestingOf[owner];\n        if(vesting.amounts.length \u003e 0 \u0026\u0026 vesting.timestamps.length == 0) {\n            uint256 amount = vesting.amounts[0];\n            vesting.amounts.pop();\n            VestingInfo memory info = infos[vesting.infoIndex];\n            uint256 splittedAmount = amount / info.tranches;\n            uint256 startingFrom = info.startingFrom;\n            startingFrom = startingFrom == 0 ? block.timestamp : startingFrom;\n            for(uint256 i = 0; i \u003c info.tranches; i++) {\n                vesting.timestamps.push(startingFrom + (info.interval * i));\n                vesting.amounts.push(splittedAmount);\n            }\n            vesting.amounts[vesting.amounts.length - 1] = (amount - (splittedAmount * (info.tranches - 1)));\n        }\n    }\n\n    function _setRewardToken(address token) private {\n        require(rewardToken == address(0));\n        rewardToken = token;\n    }\n\n    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) private {\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), \u0027TRANSFER_FAILED\u0027);\n    }\n\n    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n        assembly {\n            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n            let size := returndatasize()\n            returnData := mload(0x40)\n            mstore(returnData, size)\n            let returnDataPayloadStart := add(returnData, 0x20)\n            returndatacopy(returnDataPayloadStart, 0, size)\n            mstore(0x40, add(returnDataPayloadStart, size))\n            switch result case 0 {revert(returnDataPayloadStart, size)}\n        }\n    }\n}"}}