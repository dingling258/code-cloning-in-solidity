{{
  "language": "Solidity",
  "sources": {
    "src/staking/StakingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Vault} from \"../vault/Vault.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\n/// @notice Staking vault that is managed by a vault manager.\ncontract StakingVault is Vault {\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                         OVERRIDES                          */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev For EIP-712.\n    function _domainNameAndVersion()\n        internal\n        pure\n        override(EIP712)\n        returns (string memory, string memory)\n    {\n        return (\"StakingVault\", \"1\");\n    }\n}\n"
    },
    "src/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ERC1271} from \"solady/accounts/ERC1271.sol\";\nimport {ERC6551} from \"solady/accounts/ERC6551.sol\";\nimport {LibERC6551} from \"solady/accounts/LibERC6551.sol\";\nimport {UUPSUpgradeable} from \"solady/utils/UUPSUpgradeable.sol\";\n\n/// @notice ERC6551 vault that is managed by a vault manager.\nabstract contract Vault is ERC6551 {\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                       CUSTOM ERRORS                        */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev The function selector is not recognized.\n    error FnSelectorNotRecognized();\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                           EVENTS                           */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Emitted when the ERC1271 adapter is set.\n    event ERC1271AdapterSet(address indexed adapter);\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                          STORAGE                           */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev So that users can provide their own adapter if needed.\n    address public erc1271Adapter;\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                      PROXY OPERATIONS                      */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Returns the address stored in the ERC1967 implementation slot.\n    /// If this returns zero, send 0 ETH to the proxy to initialize it.\n    function erc1967Implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                       CONFIGURABLES                        */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Hook to override to check if the parameters to `execute` are approved.\n    /// This can be used to check if the caller is the token contract (i.e. VaultManager),\n    /// and allow calls to Asterix and AsterixMirror if they are blocked by default (e.g. for vesting).\n    function _afterExecute(address target, uint256 value, bytes calldata data, uint8 operation)\n        internal\n        virtual\n    {}\n\n    /// @dev Hook to override to check if the parameters to `executeBatch` are approved.\n    /// This can be used to check if the caller is the token contract (i.e. VaultManager),\n    /// and allow calls to Asterix and AsterixMirror if they are blocked by default (e.g. for vesting).\n    function _afterExecuteBatch(Call[] calldata calls, uint8 operation) internal virtual {}\n\n    /// @dev Returns whether the proxy is upgradeable.\n    /// Returns false by default.\n    /// For extra safety, such that we can be double-sure that the proxy is non-upgradeable.\n    function _isUpgradeable() internal view virtual returns (bool) {\n        return false;\n    }\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                      ERC1271 ADAPTER                       */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Allows a user to set a ERC1271 adapter.\n    function setERC1271Adapter(address adapter) public virtual onlyValidSigner {\n        erc1271Adapter = adapter;\n        emit ERC1271AdapterSet(adapter);\n        _updateState();\n    }\n\n    /// @dev Returns whether the `signature` is valid for the `hash.\n    function _erc1271IsValidSignature(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        override(ERC1271)\n        returns (bool)\n    {\n        if (ERC1271._erc1271IsValidSignature(hash, signature)) return true;\n        address adapter = erc1271Adapter;\n        return adapter != address(0)\n            && ERC1271(adapter).isValidSignature(hash, signature) == ERC1271.isValidSignature.selector;\n    }\n\n    /*«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-«-*/\n    /*                         OVERRIDES                          */\n    /*-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»-»*/\n\n    /// @dev Override for `execute`, such that `_afterExecute` is called.\n    function execute(address target, uint256 value, bytes calldata data, uint8 operation)\n        public\n        payable\n        virtual\n        override(ERC6551)\n        returns (bytes memory results)\n    {\n        results = ERC6551.execute(target, value, data, operation);\n        _afterExecute(target, value, data, operation);\n    }\n\n    /// @dev Override for `executeBatch`, such that `_afterExecuteBatch` is called.\n    function executeBatch(Call[] calldata calls, uint8 operation)\n        public\n        payable\n        virtual\n        override(ERC6551)\n        returns (bytes[] memory results)\n    {\n        results = ERC6551.executeBatch(calls, operation);\n        _afterExecuteBatch(calls, operation);\n    }\n\n    /// @dev This is used in the `onlyValidSigner` modifier,\n    /// which guards `execute` and `executeBatch`.\n    function _isValidSigner(address signer)\n        internal\n        view\n        virtual\n        override(ERC6551)\n        returns (bool)\n    {\n        // We also consider the token contract (i.e. the VaultManager) to also be a valid signer\n        // such that it can withdraw Asterix ERC20s and AsterixMirror ERC721s from the vault.\n        // This means we must be very careful to make sure that the VaultManager does NOT\n        // let anyone control the vaults of others.\n        return _signerIsTokenContract(signer) || ERC6551._isValidSigner(signer);\n    }\n\n    /// @dev Returns if `signer` is the vault manager.\n    function _signerIsTokenContract(address signer) internal view virtual returns (bool) {\n        // The token contract is immutably baked into the ERC6551 bytecode.\n        return signer == LibERC6551.tokenContract(address(this));\n    }\n\n    /// @dev To ensure that only the vault manager can upgrade the vault.\n    function _authorizeUpgrade(address) internal virtual override(ERC6551) {\n        if (!_signerIsTokenContract(msg.sender)) revert Unauthorized();\n        _updateState();\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Ensures that we must override `_isUpgradeable` to return true\n    /// to enable upgradeability.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        override(UUPSUpgradeable)\n    {\n        if (_isUpgradeable()) {\n            UUPSUpgradeable.upgradeToAndCall(newImplementation, data);\n        } else {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Handle token callbacks.\n    fallback() external payable virtual override(ERC6551) receiverFallback {\n        revert FnSelectorNotRecognized();\n    }\n}\n"
    },
    "lib/solady/src/utils/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"
    },
    "lib/solady/src/accounts/ERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {EIP712} from \"../utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"../utils/SignatureCheckerLib.sol\";\n\n/// @notice ERC1271 mixin with nested EIP-712 approach.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\nabstract contract ERC1271 is EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the ERC1271 signer.\n    /// Override to return the signer `isValidSignature` checks against.\n    function _erc1271Signer() internal view virtual returns (address);\n\n    /// @dev Returns whether the `msg.sender` is considered safe, such\n    /// that we don't need to use the nested EIP-712 workflow.\n    /// Override to return true for more callers.\n    /// See: https://mirror.xyz/curiousapple.eth/pFqAdW2LiJ-6S4sg_u1z08k4vK6BCJ33LcyXpnNb8yU\n    function _erc1271CallerIsSafe() internal view virtual returns (bool) {\n        // The canonical `MulticallerWithSender` at 0x000000000000D9ECebf3C23529de49815Dac1c4c\n        // is known to include the account in the hash to be signed.\n        return msg.sender == 0x000000000000D9ECebf3C23529de49815Dac1c4c;\n    }\n\n    /// @dev Validates the signature with ERC1271 return,\n    /// so that this account can also be used as a signer.\n    function isValidSignature(bytes32 hash, bytes calldata signature)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        bool success = _erc1271IsValidSignature(hash, signature);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `success ? bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) : 0xffffffff`.\n            // We use `0xffffffff` for invalid, in convention with the reference implementation.\n            result := shl(224, or(0x1626ba7e, sub(0, iszero(success))))\n        }\n    }\n\n    /// @dev Returns whether the `signature` is valid for the `hash.\n    function _erc1271IsValidSignature(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _erc1271IsValidSignatureViaSafeCaller(hash, signature)\n            || _erc1271IsValidSignatureViaNestedEIP712(hash, signature)\n            || _erc1271IsValidSignatureViaRPC(hash, signature);\n    }\n\n    /// @dev Performs the signature validation without nested EIP-712 if the caller is\n    /// a safe caller. A safe caller must include the address of this account in the hash.\n    function _erc1271IsValidSignatureViaSafeCaller(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        if (_erc1271CallerIsSafe()) {\n            result =\n                SignatureCheckerLib.isValidSignatureNowCalldata(_erc1271Signer(), hash, signature);\n        }\n    }\n\n    /// @dev ERC1271 signature validation (Nested EIP-712 workflow).\n    ///\n    /// This implementation uses ECDSA recovery. It also uses a nested EIP-712 approach to\n    /// prevent signature replays when a single EOA owns multiple smart contract accounts,\n    /// while still enabling wallet UIs (e.g. Metamask) to show the EIP-712 values.\n    ///\n    /// The `hash` parameter to this method is the `childHash`.\n    /// __________________________________________________________________________________________\n    ///\n    /// Glossary:\n    ///\n    /// - `DOMAIN_SEP_B`: The domain separator of the `childHash`.\n    ///   Provided by the front end. Intended to be the domain separator of the contract\n    ///   that will call `isValidSignature` on this account.\n    ///\n    /// - `DOMAIN_SEP_A`: The domain separator of this account.\n    ///   See: `EIP712._domainSeparator()`.\n    ///\n    /// - `Parent`: The parent struct type.\n    ///   To be defined by the front end, such that `child` can be visible via EIP-712.\n    /// __________________________________________________________________________________________\n    ///\n    /// For the default nested EIP-712 workflow, the final hash will be:\n    /// ```\n    ///     keccak256(\\x19\\x01 || DOMAIN_SEP_A ||\n    ///         hashStruct(Parent({\n    ///             childHash: keccak256(\\x19\\x01 || DOMAIN_SEP_B || hashStruct(originalStruct)),\n    ///             child: hashStruct(originalStruct)\n    ///         }))\n    ///     )\n    /// ```\n    /// where `||` denotes the concatenation operator for bytes.\n    /// The order of Parent's fields is important: `childHash` comes before `child`.\n    ///\n    /// The signature will be `r || s || v || PARENT_TYPEHASH || DOMAIN_SEP_B || child`,\n    /// where `child` is the bytes32 struct hash of the original struct.\n    ///\n    /// The `DOMAIN_SEP_B` and `child` will be used to verify if `childHash` is indeed correct.\n    /// __________________________________________________________________________________________\n    ///\n    /// For the `personalSign` workflow, the final hash will be:\n    /// ```\n    ///     keccak256(\\x19\\x01 || DOMAIN_SEP_A ||\n    ///         hashStruct(Parent({\n    ///             childHash: keccak256(\\x19Ethereum Signed Message:\\n ||\n    ///                 base10(bytes(someString).length) || someString)\n    ///         }))\n    ///     )\n    /// ```\n    /// where `||` denotes the concatenation operator for bytes.\n    /// The signature will be `r || s || v || PARENT_TYPEHASH`.\n    /// __________________________________________________________________________________________\n    ///\n    /// For demo and typescript code, see:\n    /// - https://github.com/junomonster/nested-eip-712\n    /// - https://github.com/frangio/eip712-wrapper-for-eip1271\n    ///\n    /// Their nomenclature may differ from ours, although the high-level idea is similar.\n    ///\n    /// Of course, if you are a wallet app maker and can update your app's UI at will,\n    /// you can choose a more minimalistic signature scheme like\n    /// `keccak256(abi.encode(address(this), hash))` instead of all these acrobatics.\n    /// All these are just for widespead out-of-the-box compatibility with other wallet apps.\n    function _erc1271IsValidSignatureViaNestedEIP712(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let o := add(signature.offset, sub(signature.length, 0x60))\n            calldatacopy(0x00, o, 0x60) // Copy the `DOMAIN_SEP_B` and child's structHash.\n            mstore(0x00, 0x1901) // Store the \"\\x19\\x01\" prefix, overwriting 0x00.\n            for {} 1 {} {\n                // Use the nested EIP-712 workflow if the reconstructed `childHash` matches,\n                // and the signature is at least 96 bytes long.\n                if iszero(or(xor(keccak256(0x1e, 0x42), hash), lt(signature.length, 0x60))) {\n                    // Truncate the `signature.length` by 3 words (96 bytes).\n                    signature.length := sub(signature.length, 0x60)\n                    mstore(0x00, calldataload(o)) // Store the `PARENT_TYPEHASH`.\n                    mstore(0x20, hash) // Store the `childHash`.\n                    // The `child` struct hash is already at 0x40.\n                    hash := keccak256(0x00, 0x60) // Compute the `parent` struct hash.\n                    break\n                }\n                // Else, use the `personalSign` workflow.\n                // If `signature.length` > 1 word (32 bytes), reduce by 1 word, else set to 0.\n                signature.length := mul(gt(signature.length, 0x20), sub(signature.length, 0x20))\n                // The `PARENT_TYPEHASH` is already at 0x40.\n                mstore(0x60, hash) // Store the `childHash`.\n                hash := keccak256(0x40, 0x40) // Compute the `parent` struct hash.\n                mstore(0x60, 0) // Restore the zero pointer.\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n        return SignatureCheckerLib.isValidSignatureNowCalldata(\n            _erc1271Signer(), _hashTypedData(hash), signature\n        );\n    }\n\n    /// @dev Performs the signature validation without nested EIP-712 to allow for easy sign ins.\n    /// This function must always return false or revert if called on-chain.\n    function _erc1271IsValidSignatureViaRPC(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        // Non-zero gasprice is a heuristic to check if a call is on-chain,\n        // but we can't fully depend on it because it can be manipulated.\n        // See: https://x.com/NoahCitron/status/1580359718341484544\n        if (tx.gasprice == 0) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let gasBurnHash := 0x31d8f1c26729207294 // uint72(bytes9(keccak256(\"gasBurnHash\"))).\n                if eq(hash, gasBurnHash) { invalid() } // Burns gas computationally efficiently.\n                let m := mload(0x40) // Cache the free memory pointer.\n                mstore(0x00, 0x1626ba7e) // `isValidSignature(bytes32,bytes)`.\n                mstore(0x20, gasBurnHash)\n                mstore(0x40, 0x40)\n                // Make a call to this with `gasBurnHash`, efficiently burning the gas provided.\n                // No valid transaction can consume more than the gaslimit.\n                // See: https://ethereum.github.io/yellowpaper/paper.pdf\n                // Most RPCs perform calls with a gas budget greater than the gaslimit.\n                pop(staticcall(add(100000, gaslimit()), address(), 0x1c, 0x64, 0x00, 0x00))\n                mstore(0x40, m) // Restore the free memory pointer.\n            }\n            result =\n                SignatureCheckerLib.isValidSignatureNowCalldata(_erc1271Signer(), hash, signature);\n        }\n    }\n}\n"
    },
    "lib/solady/src/accounts/ERC6551.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Receiver} from \"./Receiver.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {LibZip} from \"../utils/LibZip.sol\";\nimport {UUPSUpgradeable} from \"../utils/UUPSUpgradeable.sol\";\n\n/// @notice Simple ERC6551 account implementation.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC6551.sol)\n/// @author ERC6551 team (https://github.com/erc6551/reference/blob/main/src/examples/upgradeable/ERC6551AccountUpgradeable.sol)\n///\n/// @dev Recommended usage (regular):\n/// 1. Deploy the ERC6551 as an implementation contract, and verify it on Etherscan.\n/// 2. Use the canonical ERC6551Registry to deploy a clone to the ERC6551 implementation.\n///    The UUPSUpgradeable functions will simply become no-ops.\n///\n/// Recommended usage (upgradeable):\n/// 1. Deploy the ERC6551 as an implementation contract, and verify it on Etherscan.\n/// 2. Deploy the ERC6551Proxy pointing to the implementation.\n///    This relay proxy is required, but Etherscan verification of it is optional.\n/// 3. Use the canonical ERC6551Registry to deploy a clone to the ERC6551Proxy.\n///    If you want to reveal the \"Read as Proxy\" and \"Write as Proxy\" tabs on Etherscan,\n///    send 0 ETH to the clone to initialize its ERC1967 implementation slot,\n///    the click on \"Is this a proxy?\" on the clone's page on Etherscan.\n///\n/// Note:\n/// - This implementation does NOT include ERC4337 functionality.\n///   This is intentional, because the canonical ERC4337 entry point may still change and we\n///   don't want to encourage upgradeability by default for ERC6551 accounts just to handle this.\n///   We may include ERC4337 functionality once ERC4337 has been finalized.\n///   Recent updates to the account abstraction validation scope rules\n///   [ERC7562](https://eips.ethereum.org/EIPS/eip-7562) has made ERC6551 compatible with ERC4337.\n///   For an opinionated implementation, see https://github.com/tokenbound/contracts.\n///   If you want to add it yourself, you'll just need to add in the\n///   user operation validation functionality (and use ERC6551's execution functionality).\n/// - Please refer to the official [ERC6551](https://github.com/erc6551/reference) reference\n///   for latest updates on the ERC6551 standard, as well as canonical registry information.\nabstract contract ERC6551 is UUPSUpgradeable, Receiver, ERC1271 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Call struct for the `executeBatch` function.\n    struct Call {\n        address target;\n        uint256 value;\n        bytes data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The operation is not supported.\n    error OperationNotSupported();\n\n    /// @dev Self ownership detected.\n    error SelfOwnDetected();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC6551 state slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_ERC6551_STATE_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 internal constant _ERC6551_STATE_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffb919c7a5;\n\n    /// @dev Caches the chain ID in the deployed bytecode,\n    /// so that in the rare case of a hard fork, `owner` will still work.\n    uint256 private immutable _cachedChainId = block.chainid;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              TOKEN-BOUND OWNERSHIP OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the token-bound information.\n    function token()\n        public\n        view\n        virtual\n        returns (uint256 chainId, address tokenContract, uint256 tokenId)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            chainId := mload(0x00)\n            tokenContract := mload(0x20) // Upper 96 bits will be clean.\n            tokenId := mload(0x40)\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            if eq(mload(0x00), cachedChainId) {\n                let tokenContract := mload(0x20)\n                // `tokenId` is already at 0x40.\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                result :=\n                    mul( // Returns `address(0)` on failure or if contract does not exist.\n                        mload(0x20),\n                        and(\n                            gt(returndatasize(), 0x1f),\n                            staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                        )\n                    )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Returns if `signer` is an authorized signer.\n    function _isValidSigner(address signer) internal view virtual returns (bool) {\n        return signer == owner();\n    }\n\n    /// @dev Returns if `signer` is an authorized signer, with an optional `context`.\n    /// MUST return the bytes4 magic value `0x523e3260` if the given signer is valid.\n    /// By default, the holder of the non-fungible token the account is bound to\n    /// MUST be considered a valid signer.\n    function isValidSigner(address signer, bytes calldata context)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        context = context; // Silence unused variable warning.\n        bool isValid = _isValidSigner(signer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `isValid ? bytes4(keccak256(\"isValidSigner(address,bytes)\")) : 0x00000000`.\n            // We use `0x00000000` for invalid, in convention with the reference implementation.\n            result := shl(224, mul(0x523e3260, iszero(iszero(isValid))))\n        }\n    }\n\n    /// @dev Requires that the caller is a valid signer (i.e. the owner).\n    modifier onlyValidSigner() virtual {\n        if (!_isValidSigner(msg.sender)) revert Unauthorized();\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      STATE OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the current value of the state.\n    function state() public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_ERC6551_STATE_SLOT)\n        }\n    }\n\n    /// @dev Mutates the state. This function is required to be called in every\n    /// public / external function that may modify storage or emit events.\n    function _updateState() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _ERC6551_STATE_SLOT\n            let m := mload(0x40)\n            mstore(m, sload(s))\n            mstore(add(0x20, m), 0x40)\n            mstore(add(0x40, m), calldatasize())\n            calldatacopy(add(0x60, m), 0x00, add(0x20, calldatasize()))\n            sstore(s, keccak256(m, and(add(0x7f, calldatasize()), not(0x1f))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EXECUTION OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Execute a call from this account.\n    /// Reverts and bubbles up error if operation fails.\n    /// Returns the result of the operation.\n    ///\n    /// Accounts MUST accept the following operation parameter values:\n    /// - 0 = CALL\n    /// - 1 = DELEGATECALL\n    /// - 2 = CREATE\n    /// - 3 = CREATE2\n    ///\n    /// Accounts MAY support additional operations or restrict a signer's\n    /// ability to execute certain operations.\n    function execute(address target, uint256 value, bytes calldata data, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes memory result)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n        _updateState();\n    }\n\n    /// @dev Execute a sequence of calls from this account.\n    /// Reverts and bubbles up error if an operation fails.\n    /// Returns the results of the operations.\n    ///\n    /// This is a batch variant of `execute` and is not required for `IERC6551Executable`.\n    function executeBatch(Call[] calldata calls, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes[] memory results)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n        _updateState();\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC165                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6551: 0x6faff5f1, ERC6551Executable: 0x51945447.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x6faff5f1)), eq(s, 0x51945447))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OVERRIDES                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev To ensure that only the owner or the account itself can upgrade the implementation.\n    function _authorizeUpgrade(address)\n        internal\n        virtual\n        override(UUPSUpgradeable)\n        onlyValidSigner\n    {\n        _updateState();\n    }\n\n    /// @dev Uses the `owner` as the ERC1271 signer.\n    function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }\n\n    /// @dev For handling token callbacks.\n    /// Safe-transferred ERC721 tokens will trigger a ownership cycle check.\n    modifier receiverFallback() override(Receiver) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0x00))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            if eq(s, 0x150b7a02) {\n                extcodecopy(address(), 0x00, 0x4d, 0x60) // `chainId`, `tokenContract`, `tokenId`.\n                mstore(0x60, 0xfc0c546a) // `token()`.\n                for {} 1 {} {\n                    let tokenContract := mload(0x20)\n                    // `tokenId` is already at 0x40.\n                    mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                    let chainsEq := eq(mload(0x00), cachedChainId)\n                    let currentOwner :=\n                        mul(\n                            mload(0x20),\n                            and(\n                                and(gt(returndatasize(), 0x1f), chainsEq),\n                                staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                            )\n                        )\n                    if iszero(\n                        or(\n                            eq(currentOwner, address()),\n                            and(\n                                and(chainsEq, eq(tokenContract, caller())),\n                                eq(mload(0x40), calldataload(0x44))\n                            )\n                        )\n                    ) {\n                        if iszero(\n                            and(\n                                gt(returndatasize(), 0x5f),\n                                staticcall(gas(), currentOwner, 0x7c, 0x04, 0x00, 0x60)\n                            )\n                        ) {\n                            mstore(0x40, s) // Store `msg.sig`.\n                            return(0x5c, 0x20) // Return `msg.sig`.\n                        }\n                        continue\n                    }\n                    mstore(0x00, 0xaed146d3) // `SelfOwnDetected()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81)) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n\n    /// @dev Handle token callbacks. If no token callback is triggered,\n    /// use `LibZip.cdFallback` for generalized calldata decompression.\n    /// If you don't need either, re-override this function.\n    fallback() external payable virtual override(Receiver) receiverFallback {\n        LibZip.cdFallback();\n    }\n}\n"
    },
    "lib/solady/src/accounts/LibERC6551.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for interacting with ERC6551 accounts.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/LibERC6551.sol)\n/// @author ERC6551 team (https://github.com/erc6551/reference/blob/main/src/lib/ERC6551AccountLib.sol)\nlibrary LibERC6551 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Failed to create a ERC6551 account via the registry.\n    error AccountCreationFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The canonical ERC6551 registry address for EVM chains.\n    address internal constant REGISTRY = 0x000000006551c19487814612e58FE06813775758;\n\n    /// @dev The canonical ERC6551 registry bytecode for EVM chains.\n    /// Useful for forge tests:\n    /// `vm.etch(REGISTRY, REGISTRY_BYTECODE)`.\n    bytes internal constant REGISTRY_BYTECODE =\n        hex\"608060405234801561001057600080fd5b50600436106100365760003560e01c8063246a00211461003b5780638a54c52f1461006a575b600080fd5b61004e6100493660046101b7565b61007d565b6040516001600160a01b03909116815260200160405180910390f35b61004e6100783660046101b7565b6100e1565b600060806024608c376e5af43d82803e903d91602b57fd5bf3606c5285605d52733d60ad80600a3d3981f3363d3d373d3d3d363d7360495260ff60005360b76055206035523060601b60015284601552605560002060601b60601c60005260206000f35b600060806024608c376e5af43d82803e903d91602b57fd5bf3606c5285605d52733d60ad80600a3d3981f3363d3d373d3d3d363d7360495260ff60005360b76055206035523060601b600152846015526055600020803b61018b578560b760556000f580610157576320188a596000526004601cfd5b80606c52508284887f79f19b3655ee38b1ce526556b7731a20c8f218fbda4a3990b6cc4172fdf887226060606ca46020606cf35b8060601b60601c60005260206000f35b80356001600160a01b03811681146101b257600080fd5b919050565b600080600080600060a086880312156101cf57600080fd5b6101d88661019b565b945060208601359350604086013592506101f46060870161019b565b94979396509194608001359291505056fea2646970667358221220ea2fe53af507453c64dd7c1db05549fa47a298dfb825d6d11e1689856135f16764736f6c63430008110033\";\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                ACCOUNT BYTECODE OPERATIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the initialization code of the ERC6551 account.\n    function initCode(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer..\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xb7), tokenId_)\n            mstore(add(result, 0x97), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x77), chainId_)\n            mstore(add(result, 0x57), salt_)\n            mstore(add(result, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x28), implementation_)\n            mstore(add(result, 0x14), 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(result, 0xb7) // Store the length.\n            mstore(0x40, add(result, 0xd7)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC6551 account.\n    function initCodeHash(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            result := keccak256(add(result, 0x0c), 0xb7)\n        }\n    }\n\n    /// @dev Creates an account via the ERC6551 registry.\n    function createAccount(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x14), implementation_)\n            mstore(add(m, 0x34), salt_)\n            mstore(add(m, 0x54), chainId_)\n            mstore(add(m, 0x74), shr(96, shl(96, tokenContract_)))\n            mstore(add(m, 0x94), tokenId_)\n            // `createAccount(address,bytes32,uint256,address,uint256)`.\n            mstore(m, 0x8a54c52f000000000000000000000000)\n            if iszero(\n                and(\n                    gt(returndatasize(), 0x1f),\n                    call(gas(), REGISTRY, 0, add(m, 0x10), 0xa4, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x20188a59) // `AccountCreationFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the address of the ERC6551 account.\n    function account(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(result, 0x0c), 0xb7))\n            mstore(0x01, shl(96, REGISTRY))\n            mstore(0x15, salt_)\n            result := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns if `a` is an ERC6551 account with `expectedImplementation`.\n    function isERC6551Account(address a, address expectedImplementation)\n        internal\n        view\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer..\n            extcodecopy(a, add(m, 0x20), 0x0a, 0xa3)\n            let implementation_ := shr(96, mload(add(m, 0x20)))\n            if mul(\n                extcodesize(implementation_),\n                gt(eq(extcodesize(a), 0xad), shl(96, xor(expectedImplementation, implementation_)))\n            ) {\n                // Layout the variables and bytecode backwards.\n                mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n                mstore(add(m, 0x14), implementation_)\n                mstore(m, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n                // Compute and store the bytecode hash.\n                mstore8(0x00, 0xff) // Write the prefix.\n                mstore(0x35, keccak256(add(m, 0x0c), 0xb7))\n                mstore(0x01, shl(96, REGISTRY))\n                mstore(0x15, mload(add(m, 0x43)))\n                result := iszero(shl(96, xor(a, keccak256(0x00, 0x55))))\n                mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the implementation of the ERC6551 account `a`.\n    function implementation(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x0a, 0x14)\n            result := shr(96, mload(0x00))\n        }\n    }\n\n    /// @dev Returns the static variables of the ERC6551 account `a`.\n    function context(address a)\n        internal\n        view\n        returns (bytes32 salt_, uint256 chainId_, address tokenContract_, uint256 tokenId_)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(a, 0x00, 0x2d, 0x80)\n            salt_ := mload(0x00)\n            chainId_ := mload(0x20)\n            tokenContract_ := mload(0x40)\n            tokenId_ := mload(0x60)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Returns the salt of the ERC6551 account `a`.\n    function salt(address a) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x2d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the chain ID of the ERC6551 account `a`.\n    function chainId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x4d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the token contract of the ERC6551 account `a`.\n    function tokenContract(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x6d, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the token ID of the ERC6551 account `a`.\n    function tokenId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x8d, 0x20)\n            result := mload(0x00)\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For checking if the context is a delegate call.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// @dev Requires that the execution is performed through a proxy.\n    modifier onlyProxy() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // To enable use cases with an immutable default implementation in the bytecode,\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\n            // value stored in the implementation slot, which may not be initialized.\n            if eq(s, address()) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Requires that the execution is NOT performed via delegatecall.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(s, address())) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n"
    },
    "lib/solady/src/utils/SignatureCheckerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, s) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
    },
    "lib/solady/src/accounts/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Receiver mixin for ETH and safe-transferred ERC721 and ERC1155 tokens.\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n///\n/// @dev Note:\n/// - Handles all ERC721 and ERC1155 token safety callbacks.\n/// - Collapses function table gas overhead and code size.\n/// - Utilizes fallback so unknown calldata will pass on.\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual {}\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback {}\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n"
    },
    "lib/solady/src/utils/LibZip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                _u := mload(p_)\n                _u := or(shl(16, byte(2, _u)), or(shl(8, byte(1, _u)), byte(0, _u)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function mt(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p_ := add(mload(0x40), shl(2, i_))\n                mstore(p_, xor(mload(p_), shl(224, xor(shr(224, mload(p_)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            result := mload(0x40)\n            codecopy(result, codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(result, 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := mt(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let end := sub(literals(sub(add(ipStart, mload(data)), a), a, op), 0x7fe0)\n            let o := add(result, 0x20)\n            mstore(result, sub(end, o)) // Store the length.\n            for {} iszero(gt(o, end)) { o := add(o, 0x20) } { mstore(o, mload(add(o, 0x7fe0))) }\n            mstore(end, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(end, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            let end := add(add(data, 0x20), mload(data))\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                for {\n                    let g := eq(t, 7)\n                    let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if lt(j, l) { continue }\n                    data := add(data, add(2, g))\n                    op := add(op, l)\n                    break\n                }\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `fallback` function.\n    /// ```\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    ///     receive() external payable {} // Silence compiler warning to add a `receive` function.\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=test/utils/forge-std/",
      "murky/=lib/murky/",
      "dn404/=lib/dn404/src/",
      "solady/=lib/solady/src/",
      "ds-test/=lib/murky/lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/murky/lib/forge-std/src/",
      "murky/=lib/murky/",
      "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/",
      "solady/=lib/solady/src/",
      "soledge/=lib/soledge/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}