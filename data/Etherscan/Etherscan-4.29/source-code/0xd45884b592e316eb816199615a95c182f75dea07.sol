{{
  "language": "Solidity",
  "sources": {
    "src/modules/atomic-queue/AtomicQueue.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport { Math } from \"src/utils/Math.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { ReentrancyGuard } from \"@solmate/utils/ReentrancyGuard.sol\";\nimport { IAtomicSolver } from \"./IAtomicSolver.sol\";\n\n/**\n * @title AtomicQueue\n * @notice Allows users to create `AtomicRequests` that specify an ERC20 asset to `offer`\n *         and an ERC20 asset to `want` in return.\n * @notice Making atomic requests where the exchange rate between offer and want is not\n *         relatively stable is effectively the same as placing a limit order between\n *         those assets, so requests can be filled at a rate worse than the current market rate.\n * @notice It is possible for a user to make multiple requests that use the same offer asset.\n *         If this is done it is important that the user has approved the queue to spend the\n *         total amount of assets aggregated from all their requests, and to also have enough\n *         `offer` asset to cover the aggregate total request of `offerAmount`.\n * @author crispymangoes\n */\ncontract AtomicQueue is ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using Math for uint256;\n\n    // ========================================= STRUCTS =========================================\n\n    /**\n     * @notice Stores request information needed to fulfill a users atomic request.\n     * @param deadline unix timestamp for when request is no longer valid\n     * @param atomicPrice the price in terms of `want` asset the user wants their `offer` assets \"sold\" at\n     * @dev atomicPrice MUST be in terms of `want` asset decimals.\n     * @param offerAmount the amount of `offer` asset the user wants converted to `want` asset\n     * @param inSolve bool used during solves to prevent duplicate users, and to prevent redoing multiple checks\n     */\n    struct AtomicRequest {\n        uint64 deadline; // deadline to fulfill request\n        uint88 atomicPrice; // In terms of want asset decimals\n        uint96 offerAmount; // The amount of offer asset the user wants to sell.\n        bool inSolve; // Indicates whether this user is currently having their request fulfilled.\n    }\n\n    /**\n     * @notice Used in `viewSolveMetaData` helper function to return data in a clean struct.\n     * @param user the address of the user\n     * @param flags 8 bits indicating the state of the user only the first 4 bits are used XXXX0000\n     *              Either all flags are false(user is solvable) or only 1 is true(an error occurred).\n     *              From right to left\n     *              - 0: indicates user deadline has passed.\n     *              - 1: indicates user request has zero offer amount.\n     *              - 2: indicates user does not have enough offer asset in wallet.\n     *              - 3: indicates user has not given AtomicQueue approval.\n     * @param assetsToOffer the amount of offer asset to solve\n     * @param assetsForWant the amount of assets users want for their offer assets\n     */\n    struct SolveMetaData {\n        address user;\n        uint8 flags;\n        uint256 assetsToOffer;\n        uint256 assetsForWant;\n    }\n\n    // ========================================= GLOBAL STATE =========================================\n\n    /**\n     * @notice Maps user address to offer asset to want asset to a AtomicRequest struct.\n     */\n    mapping(address => mapping(ERC20 => mapping(ERC20 => AtomicRequest))) public userAtomicRequest;\n\n    //============================== ERRORS ===============================\n\n    error AtomicQueue__UserRepeated(address user);\n    error AtomicQueue__RequestDeadlineExceeded(address user);\n    error AtomicQueue__UserNotInSolve(address user);\n    error AtomicQueue__ZeroOfferAmount(address user);\n\n    //============================== EVENTS ===============================\n\n    /**\n     * @notice Emitted when `updateAtomicRequest` is called.\n     */\n    event AtomicRequestUpdated(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minPrice,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when `solve` exchanges a users offer asset for their want asset.\n     */\n    event AtomicRequestFulfilled(\n        address user,\n        address offerToken,\n        address wantToken,\n        uint256 offerAmountSpent,\n        uint256 wantAmountReceived,\n        uint256 timestamp\n    );\n\n    //============================== USER FUNCTIONS ===============================\n\n    /**\n     * @notice Get a users Atomic Request.\n     * @param user the address of the user to get the request for\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param want the ERC20 token they want in exchange for the offer\n     */\n    function getUserAtomicRequest(address user, ERC20 offer, ERC20 want) external view returns (AtomicRequest memory) {\n        return userAtomicRequest[user][offer][want];\n    }\n\n    /**\n     * @notice Helper function that returns either\n     *         true: Withdraw request is valid.\n     *         false: Withdraw request is not valid.\n     * @dev It is possible for a withdraw request to return false from this function, but using the\n     *      request in `updateAtomicRequest` will succeed, but solvers will not be able to include\n     *      the user in `solve` unless some other state is changed.\n     * @param offer the ERC0 token they want to exchange for the want\n     * @param user the address of the user making the request\n     * @param userRequest the request struct to validate\n     */\n    function isAtomicRequestValid(\n        ERC20 offer,\n        address user,\n        AtomicRequest calldata userRequest\n    ) external view returns (bool) {\n        // Validate amount.\n        if (userRequest.offerAmount > offer.balanceOf(user)) return false;\n        // Validate deadline.\n        if (block.timestamp > userRequest.deadline) return false;\n        // Validate approval.\n        if (offer.allowance(user, address(this)) < userRequest.offerAmount) return false;\n        // Validate offerAmount is nonzero.\n        if (userRequest.offerAmount == 0) return false;\n        // Validate atomicPrice is nonzero.\n        if (userRequest.atomicPrice == 0) return false;\n\n        return true;\n    }\n\n    /**\n     * @notice Allows user to add/update their withdraw request.\n     * @notice It is possible for a withdraw request with a zero atomicPrice to be made, and solved.\n     *         If this happens, users will be selling their shares for no assets in return.\n     *         To determine a safe atomicPrice, share.previewRedeem should be used to get\n     *         a good share price, then the user can lower it from there to make their request fill faster.\n     * @param offer the ERC20 token the user is offering in exchange for the want\n     * @param want the ERC20 token the user wants in exchange for offer\n     * @param userRequest the users request\n     */\n    function updateAtomicRequest(ERC20 offer, ERC20 want, AtomicRequest calldata userRequest) external nonReentrant {\n        AtomicRequest storage request = userAtomicRequest[msg.sender][offer][want];\n\n        request.deadline = userRequest.deadline;\n        request.atomicPrice = userRequest.atomicPrice;\n        request.offerAmount = userRequest.offerAmount;\n\n        // Emit full amount user has.\n        emit AtomicRequestUpdated(\n            msg.sender,\n            address(offer),\n            address(want),\n            userRequest.offerAmount,\n            userRequest.deadline,\n            userRequest.atomicPrice,\n            block.timestamp\n        );\n    }\n\n    //============================== SOLVER FUNCTIONS ===============================\n\n    /**\n     * @notice Called by solvers in order to exchange offer asset for want asset.\n     * @notice Solvers are optimistically transferred the offer asset, then are required to\n     *         approve this contract to spend enough of want assets to cover all requests.\n     * @dev It is very likely `solve` TXs will be front run if broadcasted to public mem pools,\n     *      so solvers should use private mem pools.\n     * @param offer the ERC20 offer token to solve for\n     * @param want the ERC20 want token to solve for\n     * @param users an array of user addresses to solve for\n     * @param runData extra data that is passed back to solver when `finishSolve` is called\n     * @param solver the address to make `finishSolve` callback to\n     */\n    function solve(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users,\n        bytes calldata runData,\n        address solver\n    ) external nonReentrant {\n        // Save offer asset decimals.\n        uint8 offerDecimals = offer.decimals();\n\n        uint256 assetsToOffer;\n        uint256 assetsForWant;\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (request.inSolve) revert AtomicQueue__UserRepeated(users[i]);\n            if (block.timestamp > request.deadline) revert AtomicQueue__RequestDeadlineExceeded(users[i]);\n            if (request.offerAmount == 0) revert AtomicQueue__ZeroOfferAmount(users[i]);\n\n            // User gets whatever their atomic price * offerAmount is.\n            assetsForWant += _calculateAssetAmount(request.offerAmount, request.atomicPrice, offerDecimals);\n\n            // If all checks above passed, the users request is valid and should be fulfilled.\n            assetsToOffer += request.offerAmount;\n            request.inSolve = true;\n            // Transfer shares from user to solver.\n            offer.safeTransferFrom(users[i], solver, request.offerAmount);\n        }\n\n        IAtomicSolver(solver).finishSolve(runData, msg.sender, offer, want, assetsToOffer, assetsForWant);\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest storage request = userAtomicRequest[users[i]][offer][want];\n\n            if (request.inSolve) {\n                // We know that the minimum price and deadline arguments are satisfied since this can only be true if they were.\n\n                // Send user their share of assets.\n                uint256 assetsToUser = _calculateAssetAmount(request.offerAmount, request.atomicPrice, offerDecimals);\n\n                want.safeTransferFrom(solver, users[i], assetsToUser);\n\n                emit AtomicRequestFulfilled(\n                    users[i],\n                    address(offer),\n                    address(want),\n                    request.offerAmount,\n                    assetsToUser,\n                    block.timestamp\n                );\n\n                // Set shares to withdraw to 0.\n                request.offerAmount = 0;\n                request.inSolve = false;\n            } else revert AtomicQueue__UserNotInSolve(users[i]);\n        }\n    }\n\n    /**\n     * @notice Helper function solvers can use to determine if users are solvable, and the required amounts to do so.\n     * @notice Repeated users are not accounted for in this setup, so if solvers have repeat users in their `users`\n     *         array the results can be wrong.\n     * @dev Since a user can have multiple requests with the same offer asset but different want asset, it is\n     *      possible for `viewSolveMetaData` to report no errors, but for a solve to fail, if any solves were done\n     *      between the time `viewSolveMetaData` and before `solve` is called.\n     * @param offer the ERC20 offer token to check for solvability\n     * @param want the ERC20 want token to check for solvability\n     * @param users an array of user addresses to check for solvability\n     */\n    function viewSolveMetaData(\n        ERC20 offer,\n        ERC20 want,\n        address[] calldata users\n    ) external view returns (SolveMetaData[] memory metaData, uint256 totalAssetsForWant, uint256 totalAssetsToOffer) {\n        // Save offer asset decimals.\n        uint8 offerDecimals = offer.decimals();\n\n        // Setup meta data.\n        metaData = new SolveMetaData[](users.length);\n\n        for (uint256 i; i < users.length; ++i) {\n            AtomicRequest memory request = userAtomicRequest[users[i]][offer][want];\n\n            metaData[i].user = users[i];\n\n            if (block.timestamp > request.deadline) {\n                metaData[i].flags |= uint8(1);\n            }\n            if (request.offerAmount == 0) {\n                metaData[i].flags |= uint8(1) << 1;\n            }\n            if (offer.balanceOf(users[i]) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 2;\n            }\n            if (offer.allowance(users[i], address(this)) < request.offerAmount) {\n                metaData[i].flags |= uint8(1) << 3;\n            }\n\n            metaData[i].assetsToOffer = request.offerAmount;\n\n            // User gets whatever their execution share price is.\n            uint256 userAssets = _calculateAssetAmount(request.offerAmount, request.atomicPrice, offerDecimals);\n            metaData[i].assetsForWant = userAssets;\n\n            // If flags is zero, no errors occurred.\n            if (metaData[i].flags == 0) {\n                totalAssetsForWant += userAssets;\n                totalAssetsToOffer += request.offerAmount;\n            }\n        }\n    }\n\n    //============================== INTERNAL FUNCTIONS ===============================\n\n    /**\n     * @notice Helper function to calculate the amount of want assets a users wants in exchange for\n     *         `offerAmount` of offer asset.\n     */\n    function _calculateAssetAmount(\n        uint256 offerAmount,\n        uint256 atomicPrice,\n        uint8 offerDecimals\n    ) internal pure returns (uint256) {\n        return atomicPrice.mulDivDown(offerAmount, 10 ** offerDecimals);\n    }\n}\n"
    },
    "src/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nlibrary Math {\n    /**\n     * @notice Substract with a floor of 0 for the result.\n     */\n    function subMinZero(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x - y : 0;\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function changeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        } else if (fromDecimals < toDecimals) {\n            return amount * 10 ** (toDecimals - fromDecimals);\n        } else {\n            return amount / 10 ** (fromDecimals - toDecimals);\n        }\n    }\n\n    // ===================================== OPENZEPPELIN'S MATH =====================================\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // ================================= SOLMATE's FIXEDPOINTMATHLIB =================================\n\n    uint256 public constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "src/modules/atomic-queue/IAtomicSolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\n\ninterface IAtomicSolver {\n    /**\n     * @notice This function must be implemented in order for an address to be a `solver`\n     *         for the AtomicQueue\n     * @param runData arbitrary bytes data that is dependent on how each solver is setup\n     *        it could contain swap data, or flash loan data, etc..\n     * @param initiator the address that initiated a solve\n     * @param offer the ERC20 asset sent to the solver\n     * @param want the ERC20 asset the solver must approve the queue for\n     * @param assetsToOffer the amount of `offer` sent to the solver\n     * @param assetsForWant the amount of `want` the solver must approve the queue for\n     */\n    function finishSolve(\n        bytes calldata runData,\n        address initiator,\n        ERC20 offer,\n        ERC20 want,\n        uint256 assetsToOffer,\n        uint256 assetsForWant\n    ) external;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@uniswap/v3-periphery/=lib/v3-periphery/",
      "@uniswap/v3-core/=lib/v3-core/",
      "@chainlink/=lib/chainlink/",
      "@uniswapV3P/=lib/v3-periphery/contracts/",
      "@uniswapV3C/=lib/v3-core/contracts/",
      "@balancer/=lib/balancer-v2-monorepo/pkg/",
      "@ccip/=lib/ccip/",
      "@pendle/=lib/pendle-core-v2-public/",
      "@balancer-labs/=lib/balancer-v2-monorepo/../../node_modules/@balancer-labs/",
      "axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/",
      "balancer-v2-monorepo/=lib/balancer-v2-monorepo/",
      "ccip/=lib/ccip/contracts/",
      "chainlink/=lib/chainlink/integration-tests/contracts/ethereum/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "pendle-core-v2-public/=lib/pendle-core-v2-public/contracts/",
      "solmate/=lib/solmate/src/",
      "v3-core/=lib/v3-core/contracts/",
      "v3-periphery/=lib/v3-periphery/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "libraries": {}
  }
}}