{{
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/GnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/EtherPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/GnosisSafeMath.sol\";\n\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafe is\n    EtherPaymentFallback,\n    Singleton,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using GnosisSafeMath for uint256;\n\n    string public constant VERSION = \"1.3.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\n    constructor() {\n        // By setting the threshold it is not possible to call setup anymore,\n        // so we create a Safe with 0 owners and threshold 1.\n        // This is an unusable Safe, perfect for the singleton\n        threshold = 1;\n    }\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    nonce\n                );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /// @dev Allows to estimate a Safe transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    /// @notice Deprecated in favor of common/StorageAccessible.sol and will be removed in next version.\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\n     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Gas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    SAFE_TX_TYPEHASH,\n                    to,\n                    value,\n                    keccak256(data),\n                    operation,\n                    safeTxGas,\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /// @dev Returns hash to be signed by owners.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param safeTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/base/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\n\n/// @title Executor - A contract that can execute transactions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Executor {\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 txGas\n    ) internal returns (bool success) {\n        if (operation == Enum.Operation.DelegateCall) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n            }\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/base/FallbackManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract FallbackManager is SelfAuthorized {\n    event ChangedFallbackHandler(address handler);\n\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    function internalSetFallbackHandler(address handler) internal {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, handler)\n        }\n    }\n\n    /// @dev Allows to add a contract to handle fallback calls.\n    ///      Only fallback calls without value and with data will be forwarded.\n    ///      This can only be done via a Safe transaction.\n    /// @param handler contract to handle fallback calls.\n    function setFallbackHandler(address handler) public authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let handler := sload(slot)\n            if iszero(handler) {\n                return(0, 0)\n            }\n            calldatacopy(0, 0, calldatasize())\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if iszero(success) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/base/GuardManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"../interfaces/IERC165.sol\";\n\ninterface Guard is IERC165 {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n\nabstract contract BaseGuard is Guard {\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return\n            interfaceId == type(Guard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract GuardManager is SelfAuthorized {\n    event ChangedGuard(address guard);\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address guard) external authorized {\n        if (guard != address(0)) {\n            require(Guard(guard).supportsInterface(type(Guard).interfaceId), \"GS300\");\n        }\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() internal view returns (address guard) {\n        bytes32 slot = GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            guard := sload(slot)\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/base/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/base/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/SelfAuthorized.sol\";\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager is SelfAuthorized {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    function setupOwners(address[] memory _owners, uint256 _threshold) internal {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"GS200\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this) && currentOwner != owner, \"GS203\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"GS204\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) public authorized {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n    /// @param oldOwner Owner address to be replaced.\n    /// @param newOwner New owner address.\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) public authorized {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS && newOwner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"GS204\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == oldOwner, \"GS205\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) public authorized {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract EtherPaymentFallback {\n    event SafeReceived(address indexed sender, uint256 value);\n\n    /// @dev Fallback function accepts Ether transactions.\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/SecuredTokenTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SecuredTokenTransfer - Secure token transfer\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SecuredTokenTransfer {\n    /// @dev Transfers a token and returns if it was a success\n    /// @param token Token that should be transferred\n    /// @param receiver Receiver to whom the token should be transferred\n    /// @param amount The amount of tokens that should be transferred\n    function transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool transferred) {\n        // 0xa9059cbb - keccack(\"transfer(address,uint256)\")\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We write the return value to scratch space.\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            switch returndatasize()\n                case 0 {\n                    transferred := success\n                }\n                case 0x20 {\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\n                }\n                default {\n                    transferred := 0\n                }\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/SelfAuthorized.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SelfAuthorized - authorizes current contract to perform actions\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SelfAuthorized {\n    function requireSelfCall() private view {\n        require(msg.sender == address(this), \"GS031\");\n    }\n\n    modifier authorized() {\n        // This is a function call as it minimized the bytecode size\n        requireSelfCall();\n        _;\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/SignatureDecoder.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract SignatureDecoder {\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    /// @param signatures concatenated rsv signatures\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            // Here we are loading the last 32 bytes, including 31 bytes\n            // of 's'. There is no 'mload8' to do this.\n            //\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/Singleton.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\n///         This contract is tightly coupled to our proxy contract (see `proxies/GnosisSafeProxy.sol`)\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Singleton {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\n    // It should also always be ensured that the address is stored alone (uses a full word)\n    address private singleton;\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/common/StorageAccessible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\n/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory) {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegatecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static).\n     *\n     * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n     * Specifically, the `returndata` after a call to this method will be:\n     * `success:bool || response.length:uint256 || response:bytes`.\n     *\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let success := delegatecall(gas(), targetContract, add(calldataPayload, 0x20), mload(calldataPayload), 0, 0)\n\n            mstore(0x00, success)\n            mstore(0x20, returndatasize())\n            returndatacopy(0x40, 0, returndatasize())\n            revert(0, add(returndatasize(), 0x40))\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/external/GnosisSafeMath.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title GnosisSafeMath\n * @dev Math operations with safety checks that revert on error\n * Renamed from SafeMath to GnosisSafeMath to avoid conflicts\n * TODO: remove once open zeppelin update to solc 0.5.0\n */\nlibrary GnosisSafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/proxies/GnosisSafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\n/// @author Richard Meissner - <richard@gnosis.io>\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract GnosisSafeProxy {\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /// @dev Constructor function sets address of singleton contract.\n    /// @param _singleton Singleton address.\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./GnosisSafeProxy.sol\";\nimport \"./IProxyCreationCallback.sol\";\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract GnosisSafeProxyFactory {\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param singleton Address of singleton contract.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\n        proxy = new GnosisSafeProxy(singleton);\n        if (data.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, singleton);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(GnosisSafeProxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///      This method is only meant as an utility to be called from other methods\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) internal returns (GnosisSafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        if (initializer.length > 0)\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    /// @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (GnosisSafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _singleton Address of singleton contract.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external returns (GnosisSafeProxy proxy) {\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/lib/safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"./GnosisSafeProxy.sol\";\n\ninterface IProxyCreationCallback {\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address _singleton,\n        bytes calldata initializer,\n        uint256 saltNonce\n    ) external;\n}\n"
    },
    "lib/unlockdv2-wallet/src/DelegationWalletFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { GnosisSafeProxyFactory, GnosisSafeProxy } from \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol\";\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IGnosisSafe } from \"./interfaces/IGnosisSafe.sol\";\nimport { TransactionGuard } from \"./libs/guards/TransactionGuard.sol\";\nimport { IDelegationWalletRegistry } from \"./interfaces/IDelegationWalletRegistry.sol\";\nimport { GnosisSafe } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport { GuardOwner } from \"./libs/owners/GuardOwner.sol\";\nimport { DelegationOwner } from \"./libs/owners/DelegationOwner.sol\";\nimport { ProtocolOwner } from \"./libs/owners/ProtocolOwner.sol\";\n\n/**\n * @title DelegationWalletFactory\n * @author BootNode\n * @dev Factory contract for deploying and configuring a new Delegation Wallet\n * Deploys a GnosisSafe, a DelegationOwner and a DelegationGuard, sets Safe wallet threshold to 1, the DelegationOwner\n * contract as owner together with the deployer and the DelegationGuard as the Safe's guard.\n */\ncontract DelegationWalletFactory {\n    /**\n     * @notice Stores the Safe proxy factory address.\n     */\n    address public immutable gnosisSafeProxyFactory;\n    /**\n     * @notice Stores the Safe implementation address.\n     */\n    address public immutable singleton;\n    /**\n     * @notice Stores the Safe CompatibilityFallbackHandler address.\n     */\n    address public immutable compatibilityFallbackHandler;\n    /**\n     * @notice Stores the TransactionGuard beacon contract address.\n     */\n    address public immutable guardBeacon;\n    /**\n     * @notice Stores the GuardOwner beacon contract address.\n     */\n    address public immutable guardOwnerBeacon;\n    /**\n     * @notice Stores the DelegationOwner beacon contract address.\n     */\n    address public immutable delegationOwnerBeacon;\n    /**\n     * @notice Stores the DelegationOwner beacon contract address.\n     */\n    address public immutable protocolOwnerBeacon;\n    /**\n     * @notice Stores the DelegationWalletRegistry contract address.\n     */\n    address public immutable registry;\n\n    event WalletDeployed(\n        address indexed safe,\n        address indexed owner,\n        address indexed guard,\n        address delegationOwner,\n        address protocolOwner,\n        address sender\n    );\n\n    constructor(\n        address _gnosisSafeProxyFactory,\n        address _singleton,\n        address _compatibilityFallbackHandler,\n        address _guardBeacon,\n        address _guardOwnerBeacon,\n        address _delegationOwnerBeacon,\n        address _protocolOwnerBeacon,\n        address _registry\n    ) {\n        gnosisSafeProxyFactory = _gnosisSafeProxyFactory;\n        singleton = _singleton;\n        compatibilityFallbackHandler = _compatibilityFallbackHandler;\n        guardBeacon = _guardBeacon;\n        guardOwnerBeacon = _guardOwnerBeacon;\n        delegationOwnerBeacon = _delegationOwnerBeacon;\n        protocolOwnerBeacon = _protocolOwnerBeacon;\n\n        registry = _registry;\n    }\n\n    /**\n     * @notice Deploys a new DelegationWallet with the msg.sender as the owner.\n     */\n    function deploy(address _delegationController) external returns (address, address, address, address) {\n        return deployFor(msg.sender, _delegationController);\n    }\n\n    /**\n     * @notice Deploys a new DelegationWallet for a given owner.\n     * @param _owner - The owner's address.\n     * @param _delegationController - Delegation controller owner\n     */\n    function deployFor(\n        address _owner,\n        address _delegationController\n    ) public returns (address, address, address, address) {\n        address safeProxy = address(\n            GnosisSafeProxyFactory(gnosisSafeProxyFactory).createProxy(singleton, new bytes(0))\n        );\n\n        // Proxy creation\n        address guardOwnerProxy = address(new BeaconProxy(guardOwnerBeacon, new bytes(0)));\n        address delegationOwnerProxy = address(new BeaconProxy(delegationOwnerBeacon, new bytes(0)));\n        address protocolOwnerProxy = address(new BeaconProxy(protocolOwnerBeacon, new bytes(0)));\n\n        // Set owners\n        address[] memory owners = new address[](4);\n        owners[0] = _owner;\n        owners[1] = guardOwnerProxy;\n        owners[2] = delegationOwnerProxy;\n        owners[3] = protocolOwnerProxy;\n\n        // setup owners and threshold, this should be done before delegationOwner.initialize because DelegationOwners\n        // has to be an owner to be able to set the guard\n        GnosisSafe(payable(safeProxy)).setup(\n            owners,\n            1,\n            address(0),\n            new bytes(0),\n            compatibilityFallbackHandler,\n            address(0),\n            0,\n            payable(address(0))\n        );\n\n        // Setup logic of the GUARD\n\n        //////////////////////////////////////////\n        // Initialize Owners Manager\n        //////////////////////////////////////////\n        // Guard OWNER\n        GuardOwner(guardOwnerProxy).initialize(\n            guardBeacon,\n            address(safeProxy),\n            _owner,\n            delegationOwnerProxy,\n            protocolOwnerProxy\n        );\n        address guard = address(GuardOwner(guardOwnerProxy).guard());\n        // Delegation OWNER\n        DelegationOwner(delegationOwnerProxy).initialize(\n            guard,\n            safeProxy,\n            _owner,\n            _delegationController,\n            protocolOwnerProxy\n        );\n        // Protocol OWNER\n        ProtocolOwner(protocolOwnerProxy).initialize(guard, address(safeProxy), _owner, delegationOwnerProxy);\n\n        // Save wallet\n        IDelegationWalletRegistry(registry).setWallet(\n            safeProxy,\n            _owner,\n            guard,\n            guardOwnerProxy,\n            delegationOwnerProxy,\n            protocolOwnerProxy\n        );\n\n        emit WalletDeployed(safeProxy, _owner, guard, delegationOwnerProxy, protocolOwnerProxy, msg.sender);\n\n        return (safeProxy, delegationOwnerProxy, protocolOwnerProxy, guardOwnerProxy);\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IACLManager\n * @author Unlockd\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager is IAccessControl {\n    function UNLOCK_PROTOCOL() external view returns (address);\n\n    /**\n     * @notice Returns the identifier of the UtokenAdmin role\n     * @return The id of the UtokenAdmin role\n     */\n    function UTOKEN_ADMIN() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the Protocol Admin role\n     * @return The id of the Protocol Admin role\n     */\n    function PROTOCOL_ADMIN() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the PriceUpdater role\n     * @return The id of the PriceUpdater role\n     */\n    function PRICE_UPDATER() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the EmergencyAdmin role\n     * @return The id of the EmergencyAdmin role\n     */\n    function AUCTION_ADMIN() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the EmergencyAdmin role\n     * @return The id of the EmergencyAdmin role\n     */\n    function EMERGENCY_ADMIN() external view returns (bytes32);\n\n    /**\n     * @notice Returns the identifier of the Governance Admin role\n     * @return The id of the PriceUpdater role\n     */\n    function GOVERNANCE_ADMIN() external view returns (bytes32);\n\n    /**\n     * @notice Set the address of the protocol\n     * @dev Is the main address of the protocol.Only can be updated by the ADMIN.\n     * @param protocol address of the protocol\n     */\n    function setProtocol(address protocol) external;\n\n    /**\n     * @notice Returns true if the address is the protocol, false otherwise\n     * @param protocol The address to check\n     * @return True if the given address is the protocol, false otherwise\n     */\n    function isProtocol(address protocol) external view returns (bool);\n\n    /**\n     * @notice Set the role as admin of a specific role.\n     * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n     * @param role The role to be managed by the admin role\n     * @param adminRole The admin role\n     */\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n    // UTOKEN\n    /**\n     * @notice Adds a new admin as  Utoken Admin\n     * @param admin The address of the new admin\n     */\n    function addUTokenAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as  Utoken Admin\n     * @param admin The address of the admin to remove\n     */\n    function removeUTokenAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is Utoken Admin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is  Utoken Admin, false otherwise\n     */\n    function isUTokenAdmin(address admin) external view returns (bool);\n\n    // PROTOCOL\n    /**\n     * @notice Adds a new admin as  Protocol Admin\n     * @param admin The address of the new admin\n     */\n    function addProtocolAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as  Protocol Admin\n     * @param admin The address of the admin to remove\n     */\n    function removeProtocolAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is Protocol Admin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is  Protocol Admin, false otherwise\n     */\n    function isProtocolAdmin(address admin) external view returns (bool);\n\n    // EMERGENCY\n    /**\n     * @notice Adds a new admin as EmergencyAdmin\n     * @param admin The address of the new admin\n     */\n    function addEmergencyAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as EmergencyAdmin\n     * @param admin The address of the admin to remove\n     */\n    function removeEmergencyAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is EmergencyAdmin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is EmergencyAdmin, false otherwise\n     */\n    function isEmergencyAdmin(address admin) external view returns (bool);\n\n    // PRICE UPDATER\n    /**\n     * @notice Adds a new admin as PriceUpdater\n     * @param admin The address of the new PriceUpdater\n     */\n    function addPriceUpdater(address admin) external;\n\n    /**\n     * @notice Removes an admin as PriceUpdater\n     * @param admin The address of the PriceUpdater to remove\n     */\n    function removePriceUpdater(address admin) external;\n\n    /**\n     * @notice Returns true if the address is PriceUpdater, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is PriceUpdater, false otherwise\n     */\n    function isPriceUpdater(address admin) external view returns (bool);\n\n    // Governance admin\n    /**\n     * @notice Adds a new admin as Govnernance admin\n     * @param admin The address of the new Governance admin\n     */\n    function addGovernanceAdmin(address admin) external;\n\n    /**\n     * @notice Removes an admin as Governance Admin\n     * @param admin The address of the Governance Admin to remove\n     */\n    function removeGovernanceAdmin(address admin) external;\n\n    /**\n     * @notice Returns true if the address is Governance Admin, false otherwise\n     * @param admin The address to check\n     * @return True if the given address is Governance Admin, false otherwise\n     */\n    function isGovernanceAdmin(address admin) external view returns (bool);\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IAllowedControllers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IAllowedControllers {\n    event Collections(address indexed collections, bool isAllowed);\n\n    event DelegationController(address indexed delegationController, bool isAllowed);\n\n    function isAllowedDelegationController(address _controller) external view returns (bool);\n\n    function isAllowedCollection(address _collection) external view returns (bool);\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/ICryptoPunks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface ICryptoPunks {\n    struct Offer {\n        bool isForSale;\n        uint256 punkIndex;\n        address seller;\n        uint256 minValue; // in ether\n        address onlySellTo; // specify to sell only to a specific person\n    }\n\n    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person\n    function punksOfferedForSale(uint256 punkIndex) external view returns (Offer memory);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address);\n\n    function transferPunk(address to, uint256 punkIndex) external;\n\n    function enterBidForPunk(uint punkIndex) external payable;\n\n    function acceptBidForPunk(uint punkIndex, uint minPrice) external;\n\n    function offerPunkForSale(uint punkIndex, uint minSalePriceInWei) external;\n\n    function offerPunkForSaleToAddress(uint256 punkIndex, uint256 minSalePriceInWei, address toAddress) external;\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IDelegationOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\ninterface IDelegationOwner {\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    event SetDelegationController(address indexed delegationController, bool allowed);\n    event SetLockController(address indexed lockController, bool allowed);\n    event NewDelegation(\n        address indexed asset,\n        uint256 indexed assetId,\n        uint256 from,\n        uint256 to,\n        address indexed delegatee,\n        address delegationController\n    );\n    event EndDelegation(address indexed asset, uint256 indexed assetId, address delegationController);\n    event ChangeOwner(address indexed asset, uint256 indexed assetId, address newOwner);\n    event DelegatedSignature(\n        uint256 from,\n        uint256 to,\n        address indexed delegatee,\n        address[] assets,\n        uint256[] assetIds,\n        address delegationController\n    );\n    event EndDelegatedSignature(address[] assets, uint256[] assetIds, address delegationController);\n\n    event ClaimedAsset(address indexed asset, uint256 indexed assetId, address indexed receiver);\n    event TransferredAsset(address indexed asset, uint256 indexed assetId, address indexed receiver);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Structs\n    ////////////////////////////////////////////////////////////////////////////////\n\n    struct SignatureAssets {\n        address[] assets;\n        uint256[] ids;\n    }\n\n    /**\n     * @notice Delegation information, it is used for assets and signatures.\n     *\n     * @param controller - The delegation controller address that created the delegations.\n     * @param delegatee - The delegatee address.\n     * @param from - The date (seconds timestamp) when the delegation starts.\n     * @param to - The date (seconds timestamp) when the delegation ends.\n     */\n    struct Delegation {\n        address controller;\n        address delegatee;\n        uint256 from;\n        uint256 to;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function delegate(address _asset, uint256 _assetId, address _delegatee, uint256 _duration) external;\n\n    function endDelegate(address _asset, uint256 _assetId) external;\n\n    function delegateSignature(\n        address[] calldata _assets,\n        uint256[] calldata _assetIds,\n        address _delegatee,\n        uint256 _duration\n    ) external;\n\n    // Lock Controller Functions\n\n    function claimAsset(address _asset, uint256 _assetId, address _receiver) external;\n\n    // Delegatee Functions\n    function execTransaction(\n        address _asset,\n        uint256 _assetId,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver\n    ) external returns (bool success);\n\n    function isAllowedFunction(address _asset, address _contract, bytes4 _selector) external view returns (bool);\n\n    function isAssetDelegated(address _asset, uint256 _assetId) external view returns (bool);\n\n    function isSignatureDelegated() external view returns (bool);\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IDelegationWalletRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\ninterface IDelegationWalletRegistry {\n    struct Wallet {\n        address wallet;\n        address owner;\n        address guard;\n        address guardOwner;\n        address delegationOwner;\n        address protocolOwner;\n    }\n\n    function setFactory(address _delegationWalletFactory) external;\n\n    function setWallet(\n        address _wallet,\n        address _owner,\n        address _guard,\n        address _guardOwner,\n        address _delegationGuard,\n        address _protocolOwner\n    ) external;\n\n    function getWallet(address _wallet) external view returns (Wallet memory);\n\n    function getOwnerWalletAddresses(address _owner) external view returns (address[] memory);\n\n    function getOwnerWalletAt(address _owner, uint256 _index) external view returns (Wallet memory);\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IERC721Extended.sol": {
      "content": "import { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IERC721Extended is IERC721 {\n    function burn(uint256 tokenId) external;\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IGnosisSafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGnosisSafe {\n    function nonce() external view returns (uint256);\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Setup function sets initial storage of contract.\n    /// @param _owners List of Safe owners.\n    /// @param _threshold Number of required confirmations for a Safe transaction.\n    /// @param to Contract address for optional delegate call.\n    /// @param data Data payload for optional delegate call.\n    /// @param fallbackHandler Handler for fallback calls to this contract\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\n    /// @param payment Value that should be paid\n    /// @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that\n    /// submitted the transaction.\n    ///      Note: The fees are always transferred, even if the user transaction fails.\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of Safe transaction.\n    /// @param data Data payload of Safe transaction.\n    /// @param operation Operation type of Safe transaction.\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature\n    /// check, payment of the refund)\n    /// @param gasPrice Gas price that should be used for the payment calculation.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n\n    function isModuleEnabled(address module) external view returns (bool);\n\n    function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4);\n\n    function isValidSignature(bytes32 _dataHash, bytes calldata _signature) external view returns (bytes4);\n\n    function signedMessages(bytes32 message) external view returns (uint256);\n\n    function getMessageHash(bytes memory message) external view returns (bytes32);\n\n    function domainSeparator() external view returns (bytes32);\n\n    function enableModule(address module) external;\n\n    function setFallbackHandler(address handler) external;\n\n    function setGuard(address guard) external;\n\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\n}\n"
    },
    "lib/unlockdv2-wallet/src/interfaces/IProtocolOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\ninterface IProtocolOwner {\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    event SetLockController(address indexed lockController, bool allowed);\n    event ChangeOwner(address indexed asset, uint256 indexed assetId, address newOwner);\n    event LockedAsset(\n        address indexed asset,\n        uint256 indexed assetId,\n        uint256 claimDate,\n        address indexed lockController\n    );\n\n    event UnlockedAsset(address indexed asset, uint256 indexed assetId, address indexed lockController);\n    event ClaimedAsset(address indexed asset, uint256 indexed assetId, address indexed receiver);\n    event TransferredAsset(address indexed asset, uint256 indexed assetId, address indexed receiver);\n\n    event SetLoanId(bytes32 index, bytes32 loanId);\n    event SetBatchLoanId(bytes32[] indexed assets, bytes32 indexed loanId);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function approveSale(\n        address _collection,\n        uint256 _tokenId,\n        address _underlyingAsset,\n        uint256 _amount,\n        address _marketApproval,\n        bytes32 _loanId\n    ) external;\n\n    // Delegatee Functions\n    function execTransaction(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver\n    ) external returns (bool success);\n\n    function delegateOneExecution(address to, bool value) external;\n\n    function isDelegatedExecution(address to) external view returns (bool);\n\n    function isAssetLocked(bytes32 _id) external view returns (bool);\n\n    function batchSetLoanId(bytes32[] calldata _assets, bytes32 _loanId) external;\n\n    function batchSetToZeroLoanId(bytes32[] calldata _assets) external;\n\n    function changeOwner(address _asset, uint256 _id, address _newOwner) external;\n\n    function getLoanId(bytes32 _assetId) external view returns (bytes32);\n\n    function setLoanId(bytes32 _assetId, bytes32 _loanId) external;\n\n    function safeSetLoanId(address _asset, uint256 _id, bytes32 _loanId) external;\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/base/BaseSafeOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\nimport { Guard } from \"@gnosis.pm/safe-contracts/contracts/base/GuardManager.sol\";\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { AssetLogic } from \"../logic/AssetLogic.sol\";\nimport { SafeLogic } from \"../logic/SafeLogic.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\nimport { ISignatureValidator } from \"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\n\ncontract BaseSafeOwner is ISignatureValidator {\n    /**\n     * @notice Execution protect\n     */\n    bool internal isExecuting;\n    bytes32 internal currentTxHash;\n    /**\n     * @notice Address of cryptoPunks\n     */\n    address public immutable cryptoPunks;\n    /**\n     * @notice The ACLManager address implementatiuon.\n     */\n    address public immutable aclManager;\n\n    /**\n     * @notice Safe wallet address.\n     */\n    address public safe;\n    /**\n     * @notice The owner of the DelegationWallet, it is set only once upon initialization. Since this contract works\n     * in tandem with DelegationGuard which do not allow to change the Safe owners, this owner can't change neither.\n     */\n    address public owner;\n\n    constructor(address _cryptoPunks, address _aclManager) {\n        cryptoPunks = _cryptoPunks;\n        aclManager = _aclManager;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n    /**\n     * @notice This modifier indicates that only the Delegation Controller can execute a given function.\n     */\n    modifier onlyOwner() {\n        if (owner != msg.sender) revert Errors.DelegationOwner__onlyOwner();\n        _;\n    }\n\n    modifier onlyProtocol() {\n        if (IACLManager(aclManager).isProtocol(msg.sender) == false) revert Errors.Caller_notProtocol();\n        _;\n    }\n\n    modifier onlyGov() {\n        if (IACLManager(aclManager).isGovernanceAdmin(msg.sender) == false) revert Errors.Caller_notGovernanceAdmin();\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Public\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Returns the hash of the NFTs.\n     */\n    function assetId(address _asset, uint256 _id) external pure returns (bytes32) {\n        return AssetLogic.assetId(_asset, _id);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Private\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Transfer an asset owned by the safe.\n     */\n    function _transferAsset(address _asset, uint256 _id, address _receiver) internal returns (bool) {\n        bytes memory payload = _asset == cryptoPunks\n            ? SafeLogic._transferPunksPayload(_asset, _id, _receiver, safe)\n            : SafeLogic._transferERC721Payload(_asset, _id, _receiver, safe);\n\n        isExecuting = true;\n        currentTxHash = IGnosisSafe(payable(safe)).getTransactionHash(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            IGnosisSafe(payable(safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        bool success = IGnosisSafe(safe).execTransaction(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n\n        return success;\n    }\n\n    /**\n     * @notice Approve an asset owned by the safe wallet.\n     */\n    function _approveAsset(address _asset, uint256 _id, address _receiver) internal returns (bool) {\n        bytes memory payload = _asset == cryptoPunks\n            ? SafeLogic._approvePunksPayload(_asset, _id, _receiver, safe)\n            : SafeLogic._approveERC721Payload(_asset, _id, _receiver, safe);\n\n        isExecuting = true;\n        currentTxHash = IGnosisSafe(payable(safe)).getTransactionHash(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            IGnosisSafe(payable(safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        bool success = IGnosisSafe(safe).execTransaction(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n\n        return success;\n    }\n\n    /**\n     * @notice Approve an asset owned by the safe wallet.\n     */\n    function _approveERC20(address _asset, uint256 _amount, address _receiver) internal returns (bool) {\n        bytes memory payload = SafeLogic._approveERC20Payload(_asset, _amount, _receiver, safe);\n\n        isExecuting = true;\n        currentTxHash = IGnosisSafe(payable(safe)).getTransactionHash(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            IGnosisSafe(payable(safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        bool success = IGnosisSafe(safe).execTransaction(\n            _asset,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n\n        return success;\n    }\n\n    /**\n     * @notice Validates that the signer is the current signature delegatee, or a valid transaction executed by a asset\n     * delegatee.\n     * @param _data Hash of the data signed on the behalf of address(msg.sender) which must be encoded as bytes,\n     * necessary to make it compatible how the Safe calls the function.\n     * @param _signature Signature byte array associated with _dataHash\n     */\n    function isValidSignature(\n        bytes memory _data,\n        bytes memory _signature\n    ) public view virtual override returns (bytes4) {\n        _data;\n        bytes32 txHash = abi.decode(_signature, (bytes32));\n        if (txHash != currentTxHash) revert Errors.DelegationOwner__isValidSignature_invalidExecSig();\n\n        return EIP1271_MAGIC_VALUE;\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/guards/TransactionGuard.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { IERC165 } from \"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\";\nimport { Guard } from \"@gnosis.pm/safe-contracts/contracts/base/GuardManager.sol\";\nimport { OwnerManager, GuardManager } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport { DelegationOwner } from \"../owners/DelegationOwner.sol\";\nimport { ICryptoPunks } from \"../../interfaces/ICryptoPunks.sol\";\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { IERC721Extended, IERC721 } from \"../../interfaces/IERC721Extended.sol\";\n\nimport { AssetLogic } from \"../logic/AssetLogic.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\n/**\n * @title TransactionGuard\n * @author Unlockd\n * @dev This contract protects the Wallet. Is attached to DelegationOwner but manager by ProtocolOwner and DelegationOwner\n * - Prevents delegated o locked assets from being transferred.\n * - Prevents the approval of delegated or locked assets.\n * - Prevents all approveForAll.\n * - Prevents change in the configuration of the DelegationWallet.\n * - Prevents the remotion a this contract as the Guard of the DelegationWallet.\n */\ncontract TransactionGuard is Guard, Initializable {\n    bytes4 internal constant ERC721_SAFE_TRANSFER_FROM =\n        bytes4(keccak256(bytes(\"safeTransferFrom(address,address,uint256)\")));\n    bytes4 internal constant ERC721_SAFE_TRANSFER_FROM_DATA =\n        bytes4(keccak256(bytes(\"safeTransferFrom(address,address,uint256,bytes)\")));\n\n    address public immutable cryptoPunks;\n    // Owners Manager\n    address public delegationOwner;\n    address public protocolOwner;\n    // Mapping managers\n    mapping(address => bool) public managerOwners;\n\n    // any time an asset is locked or delegated, the address is saved here so any address present in this mapping\n    // will be checked when a transfer is performed\n    // nft address => true/false\n    mapping(address => bool) internal checkAsset;\n\n    // keccak256(address, nft id) => true/false\n    mapping(bytes32 => bool) internal lockedAssets; // this locks assets until unlock\n\n    // keccak256(address, nft id) => delegation expiry\n    mapping(bytes32 => uint256) internal delegatedAssets; // this locks assets base on a date\n\n    /**\n     * @notice This modifier indicates that only the DelegationOwner contract can execute a given function.\n     */\n    modifier onlyManagersOwner() {\n        if (managerOwners[msg.sender] == false) revert Errors.TransactionGuard__onlyManagersOwner();\n        _;\n    }\n\n    constructor(address _cryptoPunks) {\n        cryptoPunks = _cryptoPunks;\n        _disableInitializers();\n    }\n\n    function initialize(address _delegationOwner, address _protocolOwner) public initializer {\n        if (_delegationOwner == address(0)) revert Errors.TransactionGuard__initialize_invalidDelegationOwner();\n        if (_protocolOwner == address(0)) revert Errors.TransactionGuard__initialize_invalidProtocolOwner();\n\n        delegationOwner = _delegationOwner;\n        protocolOwner = _protocolOwner;\n\n        // Set manager Owners\n        managerOwners[_delegationOwner] = true;\n        managerOwners[_protocolOwner] = true;\n    }\n\n    // solhint-disable-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /**\n     * @notice This function is called from Safe.execTransaction to perform checks before executing the transaction.\n     */\n    function checkTransaction(\n        address _to,\n        uint256,\n        bytes calldata _data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address _msgSender\n    ) external view override {\n        // malicious owner can execute transactions to smart contracts by using Enum.Operation.DelegateCall in order to\n        // manipulate the Safe's internal storage and even transfer locked NFTs out of the delegation wallet\n        if (operation == Enum.Operation.DelegateCall) revert Errors.TransactionGuard__checkTransaction_noDelegateCall();\n\n        // Transactions coming from DelegationOwner are already blocked/allowed there.\n        // The delegatee calls execTransaction on DelegationOwner, it checks allowance then calls execTransaction\n        // from Safe.\n        if (managerOwners[_msgSender] == false) {\n            _checkLocked(_to, _data);\n        }\n\n        // Ignore this check when is Protocol OWNER\n        if (_msgSender != protocolOwner) {\n            // approveForAll should be never allowed since can't be checked before delegating or locking\n            _checkApproveForAll(_data);\n\n            _checkConfiguration(_to, _data);\n        }\n    }\n\n    /**\n     * @notice This function is called from Safe.execTransaction to perform checks after executing the transaction.\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external view override {}\n\n    /**\n     * @notice Returns if an asset is locked.\n     * @param _id - The asset id.\n     */\n    function isLocked(bytes32 _id) external view returns (bool) {\n        return _isLocked(_id);\n    }\n\n    /**\n     * @notice Returns asset delegation expiry.\n     * @param _id - The asset id.\n     */\n    function getExpiry(bytes32 _id) external view returns (uint256) {\n        return delegatedAssets[_id];\n    }\n\n    /**\n     * @notice Sets the delegation expiry for a group of assets.\n     * @param _assets - The assets addresses.\n     * @param _ids - The assets ids.\n     * @param _expiry - The delegation expiry.\n     */\n    function setDelegationExpiries(\n        address[] calldata _assets,\n        uint256[] calldata _ids,\n        uint256 _expiry\n    ) external onlyManagersOwner {\n        uint256 length = _assets.length;\n        for (uint256 j; j < length; ) {\n            delegatedAssets[AssetLogic.assetId(_assets[j], _ids[j])] = _expiry;\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the delegation expiry for an assets.\n     * @param _asset - The asset address.\n     * @param _id - The asset id.\n     * @param _expiry - The delegation expiry.\n     */\n    function setDelegationExpiry(address _asset, uint256 _id, uint256 _expiry) external onlyManagersOwner {\n        delegatedAssets[AssetLogic.assetId(_asset, _id)] = _expiry;\n    }\n\n    /**\n     * @notice Sets an asset as locked.\n     * @param _id - The asset id.\n     */\n    function lockAsset(bytes32 _id) external onlyManagersOwner {\n        if (!_isLocked(_id)) {\n            lockedAssets[_id] = true;\n        }\n    }\n\n    /**\n     * @notice Sets an asset as unlocked.\n     * @param _id - The asset id.\n     */\n    function unlockAsset(bytes32 _id) external onlyManagersOwner {\n        if (_isLocked(_id)) {\n            lockedAssets[_id] = false;\n        }\n    }\n\n    /**\n     * @notice This function prevents the execution of some functions when the destination contract is a locked or\n     * delegated asset.\n     * @param _to - Destination address of Safe transaction.\n     * @param _data - Data payload of Safe transaction.\n     */\n    function _checkLocked(address _to, bytes calldata _data) internal view {\n        bytes4 selector = AssetLogic.getSelector(_data);\n        if (_to == cryptoPunks) {\n            if (selector == ICryptoPunks.transferPunk.selector) {\n                (, uint256 assetId) = abi.decode(_data[4:], (address, uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noTransfer();\n            } else if (selector == ICryptoPunks.offerPunkForSale.selector) {\n                (uint256 assetId, ) = abi.decode(_data[4:], (uint256, uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noApproval();\n            } else if (selector == ICryptoPunks.offerPunkForSaleToAddress.selector) {\n                (uint256 assetId, , ) = abi.decode(_data[4:], (uint256, uint256, address));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noApproval();\n            } else if (selector == ICryptoPunks.acceptBidForPunk.selector) {\n                (uint256 assetId, ) = abi.decode(_data[4:], (uint256, uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noTransfer();\n            }\n        } else {\n            if (_isTransfer(selector)) {\n                (, , uint256 assetId) = abi.decode(_data[4:], (address, address, uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noTransfer();\n            } else if (_isApproving(selector)) {\n                (, uint256 assetId) = abi.decode(_data[4:], (address, uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId)))\n                    revert Errors.TransactionGuard__checkLocked_noApproval();\n            } else if (_isBurning(selector)) {\n                uint256 assetId = abi.decode(_data[4:], (uint256));\n                if (_isDelegating(_to, assetId) || _isLocked(AssetLogic.assetId(_to, assetId))) {\n                    revert Errors.TransactionGuard__checkLocked_noBurn();\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice This function prevents the execution of the IERC721 setApprovalForAll function.\n     * @param _data - Data payload of Safe transaction.\n     */\n    function _checkApproveForAll(bytes calldata _data) internal pure {\n        bytes4 selector = AssetLogic.getSelector(_data);\n\n        if (selector == IERC721.setApprovalForAll.selector)\n            revert Errors.TransactionGuard__checkApproveForAll_noApprovalForAll();\n    }\n\n    /**\n     * @notice This function prevents changes in the configuration of the Safe.\n     * @param _to - Destination address of Safe transaction.\n     * @param _data - Data payload of Safe transaction.\n     */\n    function _checkConfiguration(address _to, bytes calldata _data) internal view {\n        bytes4 selector = AssetLogic.getSelector(_data);\n\n        if (_to == DelegationOwner(delegationOwner).safe()) {\n            // ownership change not allowed while this guard is configured\n            if (\n                selector == OwnerManager.addOwnerWithThreshold.selector ||\n                selector == OwnerManager.removeOwner.selector ||\n                selector == OwnerManager.swapOwner.selector ||\n                selector == OwnerManager.changeThreshold.selector\n            ) revert Errors.TransactionGuard__checkConfiguration_ownershipChangesNotAllowed();\n\n            // Guard change not allowed\n            if (selector == GuardManager.setGuard.selector)\n                revert Errors.TransactionGuard__checkConfiguration_guardChangeNotAllowed();\n\n            // Adding modules is not allowed\n            if (selector == IGnosisSafe.enableModule.selector)\n                revert Errors.TransactionGuard__checkConfiguration_enableModuleNotAllowed();\n\n            // Changing FallbackHandler is not allowed\n            if (selector == IGnosisSafe.setFallbackHandler.selector)\n                revert Errors.TransactionGuard__checkConfiguration_setFallbackHandlerNotAllowed();\n        }\n    }\n\n    /**\n     * @notice Checks if an asset is delegated.\n     * @param _asset - The asset addresses.\n     * @param _id - The asset id.\n     */\n    function _isDelegating(address _asset, uint256 _id) internal view returns (bool) {\n        return (block.timestamp <= delegatedAssets[AssetLogic.assetId(_asset, _id)]);\n    }\n\n    /**\n     * @notice Checks if an asset is locked.\n     * @param _id - Asset id\n     */\n    function _isLocked(bytes32 _id) internal view returns (bool) {\n        return lockedAssets[_id];\n    }\n\n    /**\n     * @notice Checks if `_selector` is one of the ERC721 possible transfers.\n     * @param _selector - Function selector.\n     */\n    function _isTransfer(bytes4 _selector) internal pure returns (bool) {\n        return (_selector == IERC721.transferFrom.selector ||\n            _selector == ERC721_SAFE_TRANSFER_FROM ||\n            _selector == ERC721_SAFE_TRANSFER_FROM_DATA);\n    }\n\n    function _isBurning(bytes4 _selector) internal pure returns (bool) {\n        return (_selector == IERC721Extended.burn.selector);\n    }\n\n    function _isApproving(bytes4 _selector) internal pure returns (bool) {\n        return (_selector == IERC721.approve.selector);\n    }\n\n    function supportsInterface(\n        bytes4 _interfaceId\n    )\n        external\n        view\n        virtual\n        returns (\n            // override\n            bool\n        )\n    {\n        return\n            _interfaceId == type(Guard).interfaceId || // 0xe6d7a83a\n            _interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nlibrary Errors {\n    // ========== General ===========\n    error Caller_notProtocol();\n    error Caller_notGovernanceAdmin();\n    error Caller_notAdmin();\n    // ========== Delegation Recipes ===========\n    error DelegationRecipes__add_arityMismatch();\n    error DelegationRecipes__remove_arityMismatch();\n\n    // ========== Delegation Owner ===========\n\n    error DelegationGuard__initialize_invalidGuardBeacon();\n    error DelegationGuard__initialize_invalidRecipes();\n    error DelegationGuard__initialize_invalidSafe();\n    error DelegationGuard__initialize_invalidOwner();\n    error DelegationGuard__initialize_aclManager();\n    error DelegationOwner__assetNotLocked();\n    error DelegationOwner__wrongLoanId();\n    error DelegationOwner__assetAlreadyLocked();\n    error DelegationOwner__collectionNotAllowed();\n    error DelegationOwner__onlyOwner();\n    error DelegationOwner__onlyDelegationController();\n    error DelegationOwner__onlyLockController();\n    error DelegationOwner__onlyDelegationCreator();\n    error DelegationOwner__onlySignatureDelegationCreator();\n    error DelegationOwner__onlyLockCreator();\n\n    error DelegationOwner__delegate_currentlyDelegated();\n    error DelegationOwner__delegate_invalidDelegatee();\n    error DelegationOwner__delegate_invalidDuration();\n    error DelegationOwner__delegate_assetLocked();\n\n    error DelegationOwner__deposit_collectionNotAllowed();\n    error DelegationOwner__delegateSignature_invalidArity();\n    error DelegationOwner__delegateSignature_currentlyDelegated();\n    error DelegationOwner__delegateSignature_invalidDelegatee();\n    error DelegationOwner__delegateSignature_invalidDuration();\n    error DelegationOwner__endDelegateSignature_invalidArity();\n\n    error DelegationOwner__isValidSignature_notDelegated();\n    error DelegationOwner__isValidSignature_invalidSigner();\n    error DelegationOwner__isValidSignature_invalidExecSig();\n\n    error DelegationOwner__execTransaction_notDelegated();\n    error DelegationOwner__execTransaction_invalidDelegatee();\n    error DelegationOwner__execTransaction_notAllowedFunction();\n    error DelegationOwner__execTransaction_notSuccess();\n\n    error DelegationOwner__lockAsset_assetLocked();\n    error DelegationOwner__lockAsset_invalidClaimDate();\n\n    error DelegationOwner__changeClaimDate_invalidClaimDate();\n\n    error DelegationOwner__claimAsset_assetNotClaimable();\n    error DelegationOwner__claimAsset_assetLocked();\n    error DelegationOwner__claimAsset_notSuccess();\n\n    error DelegationOwner__changeOwner_notSuccess();\n    error DelegationOwner__transferAsset_assetNotOwned();\n    error DelegationOwner__approveAsset_assetNotOwned();\n\n    error DelegationOwner__checkOwnedAndNotApproved_assetNotOwned();\n    error DelegationOwner__checkOwnedAndNotApproved_assetApproved();\n\n    error DelegationOwner__checkClaimDate_assetDelegatedLonger();\n    error DelegationOwner__checkClaimDate_signatureDelegatedLonger();\n\n    error DelegationOwner__lockCreatorChecks_assetNotLocked();\n    error DelegationOwner__lockCreatorChecks_onlyLockCreator();\n\n    error DelegationOwner__delegationCreatorChecks_notDelegated();\n    error DelegationOwner__delegationCreatorChecks_onlyDelegationCreator();\n\n    error DelegationOwner__setDelegationController_notAllowedController();\n    error DelegationOwner__setLockController_notAllowedController();\n\n    error DelegationOwner__batchSetLoanId_arityMismatch();\n    // ========== Guard Owner ===========\n    error GuardOwner__initialize_aclManager();\n    error GuardOwner__initialize_invalidGuardBeacon();\n    error GuardOwner__initialize_invalidSafe();\n    error GuardOwner__initialize_invalidOwner();\n    error GuardOwner__initialize_invalidDelegationOwner();\n    error GuardOwner__initialize_invalidProtocolOwner();\n\n    // ========== Transaction Guard ===========\n    error TransactionGuard__onlyManagersOwner();\n    error TransactionGuard__initialize_invalidDelegationOwner();\n    error TransactionGuard__initialize_invalidProtocolOwner();\n    error TransactionGuard__checkTransaction_noDelegateCall();\n    error TransactionGuard__checkApproveForAll_noApprovalForAll();\n\n    error TransactionGuard__checkLocked_noTransfer();\n    error TransactionGuard__checkLocked_noApproval();\n    error TransactionGuard__checkLocked_noBurn();\n    error TransactionGuard__checkConfiguration_ownershipChangesNotAllowed();\n    error TransactionGuard__checkConfiguration_guardChangeNotAllowed();\n    error TransactionGuard__checkConfiguration_enableModuleNotAllowed();\n    error TransactionGuard__checkConfiguration_setFallbackHandlerNotAllowed();\n\n    // ========== Allowed Collection ===========\n    error AllowedCollections__setCollectionsAllowances_invalidAddress();\n    error AllowedCollections__setCollectionsAllowances_arityMismatch();\n\n    error AllowedControllers__setLockControllerAllowances_arityMismatch();\n    error AllowedControllers__setDelegationControllerAllowances_arityMismatch();\n    error AllowedControllers__setDelegationControllerAllowance_invalidAddress();\n\n    // ========== Delegation Wallet Registry ===========\n    error DelegationWalletRegistry__onlyFactoryOrOwner();\n\n    error DelegationWalletRegistry__setFactory_invalidAddress();\n\n    error DelegationWalletRegistry__setWallet_invalidWalletAddress();\n    error DelegationWalletRegistry__setWallet_invalidOwnerAddress();\n    error DelegationWalletRegistry__setWallet_invalidDelegationOwnerAddress();\n    error DelegationWalletRegistry__setWallet_invalidGuardAddress();\n    error DelegationWalletRegistry__setWallet_invalidProtocolOwnerAddress();\n\n    // ========== Protocol OWNER ===========\n    error ProtocolOwner__invalidDelegatedAddressAddress();\n    error ProtocolOwner__execTransaction_notSuccess();\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/logic/AssetLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nlibrary AssetLogic {\n    function assetId(address _asset, uint256 _id) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_asset, _id));\n    }\n\n    function getSelector(bytes memory _data) internal pure returns (bytes4 selector) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            selector := mload(add(_data, 32))\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/logic/SafeLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ICryptoPunks } from \"../../interfaces/ICryptoPunks.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\nlibrary SafeLogic {\n    function _transferERC721Payload(\n        address _asset,\n        uint256 _id,\n        address _receiver,\n        address _safe\n    ) internal view returns (bytes memory) {\n        // safe should be owner\n        if (IERC721(_asset).ownerOf(_id) != _safe) revert Errors.DelegationOwner__transferAsset_assetNotOwned();\n\n        return abi.encodeWithSelector(IERC721.transferFrom.selector, _safe, _receiver, _id);\n    }\n\n    function _transferPunksPayload(\n        address _asset,\n        uint256 _id,\n        address _receiver,\n        address _safe\n    ) internal view returns (bytes memory) {\n        // safe should be owner\n        if (ICryptoPunks(_asset).punkIndexToAddress(_id) != _safe)\n            revert Errors.DelegationOwner__transferAsset_assetNotOwned();\n\n        return abi.encodeWithSelector(ICryptoPunks.transferPunk.selector, _receiver, _id);\n    }\n\n    // TODO: Check if this is safe\n    function _approvePunksPayload(\n        address _asset,\n        uint256 _id,\n        address _receiver,\n        address _safe\n    ) internal view returns (bytes memory) {\n        // safe should be owner\n        if (ICryptoPunks(_asset).punkIndexToAddress(_id) != _safe)\n            revert Errors.DelegationOwner__approveAsset_assetNotOwned();\n\n        return abi.encodeWithSelector(ICryptoPunks.offerPunkForSaleToAddress.selector, _receiver, 0, _id);\n    }\n\n    function _approveERC721Payload(\n        address _asset,\n        uint256 _id,\n        address _receiver,\n        address _safe\n    ) internal view returns (bytes memory) {\n        // safe should be owner\n        if (IERC721(_asset).ownerOf(_id) != _safe) revert Errors.DelegationOwner__approveAsset_assetNotOwned();\n\n        return abi.encodeWithSelector(IERC721.approve.selector, _receiver, _id);\n    }\n\n    function _approveERC20Payload(\n        address _asset,\n        uint256 _amount,\n        address _receiver,\n        address _safe\n    ) internal pure returns (bytes memory) {\n        _asset;\n        _safe;\n        return abi.encodeWithSelector(IERC20.approve.selector, _receiver, _amount);\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/owners/DelegationOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { ICryptoPunks } from \"../../interfaces/ICryptoPunks.sol\";\nimport { IAllowedControllers } from \"../../interfaces/IAllowedControllers.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { DelegationRecipes } from \"../recipes/DelegationRecipes.sol\";\n\nimport { TransactionGuard } from \"../guards/TransactionGuard.sol\";\nimport { AssetLogic } from \"../logic/AssetLogic.sol\";\nimport { SafeLogic } from \"../logic/SafeLogic.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\nimport { IDelegationOwner } from \"../../interfaces/IDelegationOwner.sol\";\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { GnosisSafe } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\n\nimport { BaseSafeOwner } from \"../base/BaseSafeOwner.sol\";\n\n/**\n * @title DelegationOwner\n * @author Unlockd\n * @dev This contract contains the logic that enables asset/signature delegates to interact with a Gnosis Safe wallet.\n * In the case of assets delegates, it will allow them to execute functions though the Safe, only those registered\n * as allowed on the DelegationRecipes contract.\n * In the case of signatures it validates that a signature was made by the current delegatee.\n * It is also used by the delegation controller to set delegations and the lock controller to lock, unlock and claim\n * assets.\n *\n * It should be use a proxy's implementation.\n */\ncontract DelegationOwner is Initializable, IDelegationOwner, BaseSafeOwner {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    bytes32 public constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /**\n     * @notice The DelegationRecipes address.\n     */\n    DelegationRecipes public immutable recipes;\n\n    /**\n     * @notice The AllowedControllers address.\n     */\n    IAllowedControllers public immutable allowedControllers;\n\n    /**\n     * @notice The delegation controller address. Allowed to execute delegation related functions.\n     */\n    mapping(address => bool) public delegationControllers;\n\n    /**\n     * @notice The DelegationGuard address.\n     */\n    TransactionGuard public guard;\n\n    /**\n     * @notice Stores the list of asset delegations. keccak256(address, nft id) => Delegation\n     */\n    mapping(bytes32 => Delegation) public delegations;\n\n    /**\n     * @notice Stores the current signature delegation.\n     */\n    Delegation public signatureDelegation;\n\n    /**\n     * @notice List of assetIds affected by last signatureDelegation. This is used for cheap checking if asset in\n     * included in current signature delegation.\n     */\n    mapping(uint256 => EnumerableSet.Bytes32Set) private signatureDelegationAssetsIds;\n\n    /**\n     * @notice List of assets and ids affected by last signatureDelegation. This is used mainly when ending the\n     * signature delegation to  be able to set the expiry of each asset on the guard. Using EnumerableSet.values from\n     * signatureDelegationAssetsIds may render the function uncallable if the set grows to a point where copying to\n     * memory consumes too much gas to fit in a block.\n     */\n    mapping(uint256 => SignatureAssets) private signatureDelegationAssets;\n\n    /**\n     * @notice Current signature delegation id\n     */\n    uint256 private currentSignatureDelegationAssets;\n\n    address private protocolOwner;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice This modifier indicates that only the Delegation Controller can execute a given function.\n     */\n    modifier onlyDelegationController() {\n        if (!delegationControllers[msg.sender]) revert Errors.DelegationOwner__onlyDelegationController();\n        _;\n    }\n\n    modifier onlyProtocolOwner() {\n        if (protocolOwner != msg.sender) revert Errors.DelegationOwner__onlyDelegationController();\n        _;\n    }\n\n    /**\n     * @dev Disables the initializer in order to prevent implementation initialization.\n     */\n    constructor(\n        address _cryptoPunks,\n        address _recipes,\n        address _allowedControllers,\n        address _aclManager\n    ) BaseSafeOwner(_cryptoPunks, _aclManager) {\n        if (_aclManager == address(0)) revert Errors.DelegationGuard__initialize_aclManager();\n\n        recipes = DelegationRecipes(_recipes);\n        allowedControllers = IAllowedControllers(_allowedControllers);\n\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the proxy state.\n     * @param _guard - The deployed guard\n     * @param _safe - The DelegationWallet address, the GnosisSafe.\n     * @param _owner - The owner of the DelegationWallet.\n     * @param _delegationController - The address that acts as the delegation controller.\n     * @param _protocolOwner - The address that acts as the delegation controller.\n     */\n    function initialize(\n        address _guard,\n        address _safe,\n        address _owner,\n        address _delegationController,\n        address _protocolOwner\n    ) public initializer {\n        if (_guard == address(0)) revert Errors.DelegationGuard__initialize_invalidGuardBeacon();\n        if (_safe == address(0)) revert Errors.DelegationGuard__initialize_invalidSafe();\n        if (_owner == address(0)) revert Errors.DelegationGuard__initialize_invalidOwner();\n\n        protocolOwner = _protocolOwner;\n        safe = _safe;\n        owner = _owner;\n        if (_delegationController != address(0)) {\n            _setDelegationController(_delegationController, true);\n        }\n        guard = TransactionGuard(_guard);\n    }\n\n    /**\n     * @notice Sets a delegation controller address as allowed or not.\n     * @param _delegationController - The new delegation controller address.\n     * @param _allowed - Allowance status.\n     */\n    function setDelegationController(address _delegationController, bool _allowed) external onlyGov {\n        _setDelegationController(_delegationController, _allowed);\n    }\n\n    /**\n     * @notice Delegates the usage of an asset to the `_delegatee` for a `_duration` of time.\n     * @param _asset - The asset address.\n     * @param _id - The asset id.\n     * @param _delegatee - The delegatee address.\n     * @param _duration - The duration of the delegation expressed in seconds.\n     */\n    function delegate(\n        address _asset,\n        uint256 _id,\n        address _delegatee,\n        uint256 _duration\n    ) external onlyDelegationController {\n        _checkOwnedAndNotApproved(_asset, _id);\n\n        bytes32 id = AssetLogic.assetId(_asset, _id);\n        Delegation storage delegation = delegations[id];\n\n        if (_isDelegating(delegation)) revert Errors.DelegationOwner__delegate_currentlyDelegated();\n        if (_delegatee == address(0)) revert Errors.DelegationOwner__delegate_invalidDelegatee();\n        if (_duration == 0) revert Errors.DelegationOwner__delegate_invalidDuration();\n        // @dev is the asset is locked you can't delegate\n        if (guard.isLocked(id)) revert Errors.DelegationOwner__delegate_assetLocked();\n\n        delegation.controller = msg.sender;\n        delegation.delegatee = _delegatee;\n        uint256 from = block.timestamp;\n        uint256 to = block.timestamp + _duration;\n        delegation.from = from;\n        delegation.to = to;\n\n        emit NewDelegation(_asset, _id, from, to, _delegatee, msg.sender);\n\n        guard.setDelegationExpiry(_asset, _id, to);\n    }\n\n    /**\n     * @notice Ends asset usage delegation.\n     * @param _asset - The asset address.\n     * @param _id - The asset id.\n     */\n    function endDelegate(address _asset, uint256 _id) external {\n        Delegation storage delegation = delegations[AssetLogic.assetId(_asset, _id)];\n        _delegationCreatorChecks(delegation);\n\n        delegation.to = 0;\n\n        emit EndDelegation(_asset, _id, msg.sender);\n\n        guard.setDelegationExpiry(_asset, _id, 0);\n    }\n\n    function forceEndDelegation(address _asset, uint256 _id) external onlyProtocolOwner {\n        Delegation storage delegation = delegations[AssetLogic.assetId(_asset, _id)];\n        delegation.to = 0;\n        emit EndDelegation(_asset, _id, msg.sender);\n        guard.setDelegationExpiry(_asset, _id, 0);\n    }\n\n    /**\n     * @notice Delegates the usage of the signature to the `_delegatee` for a `_duration` of time. Locking a group of\n     * assets in the wallet.\n     * @param _assets - The asset addresses.\n     * @param _ids - The asset ids.\n     * @param _delegatee - The delegatee address.\n     * @param _duration - The duration of the delegation expressed in seconds.\n     */\n    function delegateSignature(\n        address[] calldata _assets,\n        uint256[] calldata _ids,\n        address _delegatee,\n        uint256 _duration\n    ) external onlyDelegationController {\n        if (_assets.length != _ids.length) revert Errors.DelegationOwner__delegateSignature_invalidArity();\n        if (_isDelegating(signatureDelegation)) revert Errors.DelegationOwner__delegateSignature_currentlyDelegated();\n        if (_delegatee == address(0)) revert Errors.DelegationOwner__delegateSignature_invalidDelegatee();\n        if (_duration == 0) revert Errors.DelegationOwner__delegateSignature_invalidDuration();\n\n        uint256 delegationExpiry = block.timestamp + _duration;\n\n        currentSignatureDelegationAssets += 1;\n\n        uint256 length = _assets.length;\n        for (uint256 j; j < length; ) {\n            _checkOwnedAndNotApproved(_assets[j], _ids[j]);\n            bytes32 id = AssetLogic.assetId(_assets[j], _ids[j]);\n            // @dev is the asset is locked you can't delegate\n            if (guard.isLocked(id)) revert Errors.DelegationOwner__delegate_assetLocked();\n\n            signatureDelegationAssets[currentSignatureDelegationAssets].assets.push(_assets[j]);\n            signatureDelegationAssets[currentSignatureDelegationAssets].ids.push(_ids[j]);\n            signatureDelegationAssetsIds[currentSignatureDelegationAssets].add(id);\n\n            unchecked {\n                ++j;\n            }\n        }\n\n        Delegation memory newDelegation = Delegation(msg.sender, _delegatee, block.timestamp, delegationExpiry);\n\n        signatureDelegation = newDelegation;\n\n        emit DelegatedSignature(newDelegation.from, newDelegation.to, _delegatee, _assets, _ids, msg.sender);\n\n        guard.setDelegationExpiries(_assets, _ids, delegationExpiry);\n    }\n\n    /**\n     * @notice Ends the delegation of the usage of the signature for the `_delegatee`. Unlocking a group of assets.\n     */\n    function endDelegateSignature() external {\n        _delegationCreatorChecks(signatureDelegation);\n\n        signatureDelegation.to = 0;\n\n        emit EndDelegatedSignature(\n            signatureDelegationAssets[currentSignatureDelegationAssets].assets,\n            signatureDelegationAssets[currentSignatureDelegationAssets].ids,\n            msg.sender\n        );\n\n        guard.setDelegationExpiries(\n            signatureDelegationAssets[currentSignatureDelegationAssets].assets,\n            signatureDelegationAssets[currentSignatureDelegationAssets].ids,\n            0\n        );\n    }\n\n    /**\n     * @notice Execute a transaction through the GnosisSafe wallet.\n     * The sender should be the delegatee of the given asset and the function should be allowed for the collection.\n     * @param _asset - The delegated asset addresses.\n     * @param _id - The delegated asset ids.\n     * @param _to - Destination address of Safe transaction.\n     * @param _value - Ether value of Safe transaction.\n     * @param _data - Data payload of Safe transaction.\n     * @param _safeTxGas - Gas that should be used for the Safe transaction.\n     * @param _baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature\n     * check, payment of the refund)\n     * @param _gasPrice - Gas price that should be used for the payment calculation.\n     * @param _gasToken - Token address (or 0 if ETH) that is used for the payment.\n     * @param _refundReceiver - Address of receiver of gas payment (or 0 if tx.origin).\n     */\n    function execTransaction(\n        address _asset,\n        uint256 _id,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver\n    ) external returns (bool success) {\n        Delegation storage delegation = delegations[AssetLogic.assetId(_asset, _id)];\n\n        if (!_isDelegating(delegation)) revert Errors.DelegationOwner__execTransaction_notDelegated();\n        if (delegation.delegatee != msg.sender) revert Errors.DelegationOwner__execTransaction_invalidDelegatee();\n        if (!isAllowedFunction(_asset, _to, AssetLogic.getSelector(_data)))\n            revert Errors.DelegationOwner__execTransaction_notAllowedFunction();\n\n        isExecuting = true;\n        currentTxHash = IGnosisSafe(payable(safe)).getTransactionHash(\n            // Transaction info\n            _to,\n            _value,\n            _data,\n            Enum.Operation.Call,\n            _safeTxGas,\n            // Payment info\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            // Signature info\n            IGnosisSafe(payable(safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        (success) = IGnosisSafe(safe).execTransaction(\n            _to,\n            _value,\n            _data,\n            Enum.Operation.Call,\n            _safeTxGas,\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n\n        if (!success) revert Errors.DelegationOwner__execTransaction_notSuccess();\n    }\n\n    /**\n     * @notice Validates that the signer is the current signature delegatee, or a valid transaction executed by a asset\n     * delegatee.\n     * @param _data Hash of the data signed on the behalf of address(msg.sender) which must be encoded as bytes,\n     * necessary to make it compatible how the Safe calls the function.\n     * @param _signature Signature byte array associated with _dataHash\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view override returns (bytes4) {\n        if (!isExecuting) {\n            if (!_isDelegating(signatureDelegation)) revert Errors.DelegationOwner__isValidSignature_notDelegated();\n            // CompatibilityFallbackHandler encodes the bytes32 dataHash before calling the old version of i\n            // sValidSignature\n            bytes32 dataHash = abi.decode(_data, (bytes32));\n            address signer = ECDSA.recover(dataHash, _signature);\n            if (signatureDelegation.delegatee != signer)\n                revert Errors.DelegationOwner__isValidSignature_invalidSigner();\n        } else {\n            bytes32 txHash = abi.decode(_signature, (bytes32));\n            if (txHash != currentTxHash) revert Errors.DelegationOwner__isValidSignature_invalidExecSig();\n        }\n\n        return EIP1271_MAGIC_VALUE;\n    }\n\n    /**\n     * @notice Checks that a function is allowed to be executed by a delegatee of a given asset.\n     * @param _asset - The delegated asset addresses.\n     * @param _contract - The addresses of the destination contract.\n     * @param _selector - The selector of the destination function.\n     */\n    function isAllowedFunction(address _asset, address _contract, bytes4 _selector) public view returns (bool) {\n        return recipes.isAllowedFunction(_asset, _contract, _selector);\n    }\n\n    /**\n     * @notice Sends a asset to the `receiver`.\n     * @param _asset - The locked asset addresses.\n     * @param _id - The locked asset id.\n     * @param _receiver - The receiving address.\n     */\n    function claimAsset(address _asset, uint256 _id, address _receiver) external onlyOwner {\n        bytes32 id = AssetLogic.assetId(_asset, _id);\n\n        if (_isAssetDelegated(id)) revert Errors.DelegationOwner__claimAsset_assetNotClaimable();\n        if (guard.isLocked(id)) revert Errors.DelegationOwner__claimAsset_assetLocked();\n\n        bool success = _transferAsset(_asset, _id, _receiver);\n\n        if (!success) revert Errors.DelegationOwner__claimAsset_notSuccess();\n\n        emit ClaimedAsset(_asset, _id, _receiver);\n    }\n\n    /**\n     * @notice Returns if an asset is delegated or included in current signature delegation.\n     * @param _asset - The asset addresses.\n     * @param _id - The asset id.\n     */\n    function isAssetDelegated(address _asset, uint256 _id) external view returns (bool) {\n        return _isAssetDelegated(AssetLogic.assetId(_asset, _id));\n    }\n\n    /**\n     * @notice Returns if the signature is delegated.\n     */\n    function isSignatureDelegated() external view returns (bool) {\n        return _isDelegating(signatureDelegation);\n    }\n\n    //////////////////////////////////////////////\n    //       Internal functions\n    //////////////////////////////////////////////\n\n    function _setDelegationController(address _delegationController, bool _allowed) internal {\n        if (_allowed && !allowedControllers.isAllowedDelegationController(_delegationController))\n            revert Errors.DelegationOwner__setDelegationController_notAllowedController();\n        delegationControllers[_delegationController] = _allowed;\n        emit SetDelegationController(_delegationController, _allowed);\n    }\n\n    function _isAssetDelegated(bytes32 _id) internal view returns (bool) {\n        Delegation storage delegation = delegations[_id];\n        return (_isDelegating(delegation) ||\n            (_isDelegating(signatureDelegation) &&\n                signatureDelegationAssetsIds[currentSignatureDelegationAssets].contains(_id)));\n    }\n\n    function _isDelegating(Delegation storage _delegation) internal view returns (bool) {\n        return (_delegation.from <= block.timestamp && block.timestamp <= _delegation.to);\n    }\n\n    function _checkOwnedAndNotApproved(address _asset, uint256 _id) internal view {\n        if (_asset == cryptoPunks) {\n            // safe should be owner\n            if (ICryptoPunks(_asset).punkIndexToAddress(_id) != safe)\n                revert Errors.DelegationOwner__checkOwnedAndNotApproved_assetNotOwned();\n            // asset shouldn't be approved, it won't be possible to prevent the approved address to move the asset out\n            // of the safe\n            if (ICryptoPunks(_asset).punksOfferedForSale(_id).isForSale)\n                revert Errors.DelegationOwner__checkOwnedAndNotApproved_assetApproved();\n        } else {\n            // safe should be owner\n            if (IERC721(_asset).ownerOf(_id) != safe)\n                revert Errors.DelegationOwner__checkOwnedAndNotApproved_assetNotOwned();\n            // asset shouldn't be approved, it won't be possible to prevent the approved address to move the asset out\n            // f the safe\n            if (IERC721(_asset).getApproved(_id) != address(0))\n                revert Errors.DelegationOwner__checkOwnedAndNotApproved_assetApproved();\n        }\n    }\n\n    function _delegationCreatorChecks(Delegation storage _delegation) internal view {\n        if (!_isDelegating(_delegation)) revert Errors.DelegationOwner__delegationCreatorChecks_notDelegated();\n        if (_delegation.controller != msg.sender)\n            revert Errors.DelegationOwner__delegationCreatorChecks_onlyDelegationCreator();\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/owners/GuardOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { ICryptoPunks } from \"../../interfaces/ICryptoPunks.sol\";\nimport { IAllowedControllers } from \"../../interfaces/IAllowedControllers.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { DelegationRecipes } from \"../recipes/DelegationRecipes.sol\";\n\nimport { TransactionGuard } from \"../guards/TransactionGuard.sol\";\nimport { AssetLogic } from \"../logic/AssetLogic.sol\";\nimport { SafeLogic } from \"../logic/SafeLogic.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\nimport { IDelegationOwner } from \"../../interfaces/IDelegationOwner.sol\";\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { GnosisSafe } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\n\nimport { BaseSafeOwner } from \"../base/BaseSafeOwner.sol\";\n\ncontract GuardOwner is Initializable, BaseSafeOwner {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    bytes32 public constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    TransactionGuard public guard;\n\n    constructor(address _cryptoPunks, address _aclManager) BaseSafeOwner(_cryptoPunks, _aclManager) {\n        if (_aclManager == address(0)) revert Errors.GuardOwner__initialize_aclManager();\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _guardBeacon,\n        address _safe,\n        address _owner,\n        address _delegationOnwer,\n        address _protocolOwner\n    ) public initializer {\n        if (_guardBeacon == address(0)) revert Errors.GuardOwner__initialize_invalidGuardBeacon();\n        if (_safe == address(0)) revert Errors.GuardOwner__initialize_invalidSafe();\n        if (_owner == address(0)) revert Errors.GuardOwner__initialize_invalidOwner();\n        if (_delegationOnwer == address(0)) revert Errors.GuardOwner__initialize_invalidDelegationOwner();\n        if (_protocolOwner == address(0)) revert Errors.GuardOwner__initialize_invalidProtocolOwner();\n\n        safe = _safe;\n        owner = _owner;\n\n        address guardProxy = address(\n            new BeaconProxy(\n                _guardBeacon,\n                abi.encodeWithSelector(TransactionGuard.initialize.selector, _delegationOnwer, _protocolOwner)\n            )\n        );\n        guard = TransactionGuard(guardProxy);\n        // Set up guard\n        _setupGuard(_safe, guard);\n    }\n\n    function _setupGuard(address _safe, TransactionGuard _guard) internal {\n        // this requires this address to be a owner of the safe already\n        isExecuting = true;\n        bytes memory payload = abi.encodeWithSelector(IGnosisSafe.setGuard.selector, _guard);\n        currentTxHash = IGnosisSafe(payable(_safe)).getTransactionHash(\n            // Transaction info\n            safe,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            // Payment info\n            0,\n            0,\n            address(0),\n            payable(0),\n            // Signature info\n            IGnosisSafe(payable(_safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        IGnosisSafe(_safe).execTransaction(\n            safe,\n            0,\n            payload,\n            Enum.Operation.Call,\n            0,\n            0,\n            0,\n            address(0),\n            payable(0),\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/owners/ProtocolOwner.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { IGnosisSafe } from \"../../interfaces/IGnosisSafe.sol\";\nimport { ICryptoPunks } from \"../../interfaces/ICryptoPunks.sol\";\nimport { IACLManager } from \"../../interfaces/IACLManager.sol\";\nimport { IProtocolOwner } from \"../../interfaces/IProtocolOwner.sol\";\n\nimport { TransactionGuard } from \"../guards/TransactionGuard.sol\";\nimport { DelegationOwner } from \"./DelegationOwner.sol\";\nimport { AssetLogic } from \"../logic/AssetLogic.sol\";\nimport { SafeLogic } from \"../logic/SafeLogic.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { GnosisSafe } from \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport { ISignatureValidator } from \"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\n\nimport { BaseSafeOwner } from \"../base/BaseSafeOwner.sol\";\n\n/**\n * @title ProtocolOwner\n * @author Unlockd\n * @dev This contract contains the logic that enables asset/signature delegates to interact with a Gnosis Safe wallet.\n * In the case of assets delegates, it will allow them to execute functions though the Safe, only those registered\n * as allowed on the DelegationRecipes contract.\n * In the case of signatures it validates that a signature was made by the current delegate.\n * It is also used by the delegation controller to set delegations and the lock controller to lock, unlock and claim\n * assets.\n *\n * It should be use a proxy's implementation.\n */\ncontract ProtocolOwner is Initializable, BaseSafeOwner, IProtocolOwner {\n    // bytes32 public constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    DelegationOwner public delegationOwner;\n    mapping(bytes32 => bytes32) loansIds;\n    mapping(address => bool) oneTimeDelegation;\n    /**\n     * @notice The DelegationGuard address.\n     */\n    TransactionGuard public guard;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    modifier onlyOneTimeDelegation() {\n        if (oneTimeDelegation[msg.sender] == false) revert Errors.ProtocolOwner__invalidDelegatedAddressAddress();\n        _;\n    }\n\n    /**\n     * @dev Disables the initializer in order to prevent implementation initialization.\n     */\n    constructor(address _cryptoPunks, address _aclManager) BaseSafeOwner(_cryptoPunks, _aclManager) {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the proxy state.\n\n     * @param _safe - The DelegationWallet address, the GnosisSafe.\n     * @param _owner - The owner of the DelegationWallet.\n     * @param _delegationOwner - Use delegation owner\n     */\n    function initialize(address _guard, address _safe, address _owner, address _delegationOwner) public initializer {\n        if (_guard == address(0)) revert Errors.DelegationGuard__initialize_invalidGuardBeacon();\n        if (_safe == address(0)) revert Errors.DelegationGuard__initialize_invalidSafe();\n        if (_owner == address(0)) revert Errors.DelegationGuard__initialize_invalidOwner();\n\n        delegationOwner = DelegationOwner(_delegationOwner);\n        safe = _safe;\n        owner = _owner;\n\n        guard = TransactionGuard(_guard);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Public Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function approveSale(\n        address _collection,\n        uint256 _tokenId,\n        address _underlyingAsset,\n        uint256 _amount,\n        address _marketApproval,\n        bytes32 _loanId\n    ) external onlyOneTimeDelegation {\n        // Doesnt' matter if fails, it need to delegate again.\n        oneTimeDelegation[msg.sender] = false;\n\n        if (loansIds[AssetLogic.assetId(_collection, _tokenId)] != _loanId) {\n            revert Errors.DelegationOwner__wrongLoanId();\n        }\n        // Asset approval to the adapter to perform the sell\n        _approveAsset(_collection, _tokenId, _marketApproval);\n        // Approval of the ERC20 to repay the debs\n        _approveERC20(_underlyingAsset, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Execute a transaction through the GnosisSafe wallet.\n     * The sender should be the delegate of the given asset and the function should be allowed for the collection.\n     * @param _to - Destination address of Safe transaction.\n     * @param _value - Ether value of Safe transaction.\n     * @param _data - Data payload of Safe transaction.\n     * @param _safeTxGas - Gas that should be used for the Safe transaction.\n     * @param _baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature\n     * check, payment of the refund)\n     * @param _gasPrice - Gas price that should be used for the payment calculation.\n     * @param _gasToken - Token address (or 0 if ETH) that is used for the payment.\n     * @param _refundReceiver - Address of receiver of gas payment (or 0 if tx.origin).\n     */\n    function execTransaction(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver\n    ) external onlyOneTimeDelegation returns (bool success) {\n        // Doesnt' matter if fails, it need to delegate again.\n        oneTimeDelegation[msg.sender] = false;\n\n        // Admin execution no safe guard\n        isExecuting = true;\n        currentTxHash = IGnosisSafe(payable(safe)).getTransactionHash(\n            // Transaction info\n            _to,\n            _value,\n            _data,\n            Enum.Operation.Call,\n            _safeTxGas,\n            // Payment info\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            // Signature info\n            IGnosisSafe(payable(safe)).nonce()\n        );\n\n        // https://docs.gnosis-safe.io/contracts/signatures#contract-signature-eip-1271\n        bytes memory signature = abi.encodePacked(\n            abi.encode(address(this)), // r\n            abi.encode(uint256(65)), // s\n            bytes1(0), // v\n            abi.encode(currentTxHash.length),\n            currentTxHash\n        );\n\n        (success) = IGnosisSafe(safe).execTransaction(\n            _to,\n            _value,\n            _data,\n            Enum.Operation.Call,\n            _safeTxGas,\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            signature\n        );\n\n        isExecuting = false;\n        currentTxHash = bytes32(0);\n\n        if (!success) revert Errors.ProtocolOwner__execTransaction_notSuccess();\n    }\n\n    function delegateOneExecution(address to, bool value) external onlyProtocol {\n        if (to == address(0)) revert Errors.ProtocolOwner__invalidDelegatedAddressAddress();\n        oneTimeDelegation[to] = value;\n    }\n\n    function isDelegatedExecution(address to) external view returns (bool) {\n        return oneTimeDelegation[to];\n    }\n\n    /**\n     * @notice Returns if an asset is locked.\n     * @param _id - The asset id.\n     */\n    function isAssetLocked(bytes32 _id) external view returns (bool) {\n        return delegationOwner.guard().isLocked(_id);\n    }\n\n    /**\n     * @notice Return the LoanId assigned to a asset\n     *   0 means the asset is locked\n     */\n    function getLoanId(bytes32 index) external view returns (bytes32) {\n        return loansIds[index];\n    }\n\n    /**\n     * @notice set loan id assigned to a specific assetId\n     */\n    function setLoanId(bytes32 _index, bytes32 _loanId) external onlyProtocol {\n        _setLoanId(_index, _loanId);\n        emit SetLoanId(_index, _loanId);\n    }\n\n    /**\n     * @notice set loan id assigned to a specific assetId\n     */\n    function safeSetLoanId(address _asset, uint256 _id, bytes32 _loanId) external onlyProtocol {\n        bytes32 id = AssetLogic.assetId(_asset, _id);\n        // Reset approve\n        _approveAsset(_asset, _id, address(0));\n        // Lock asset\n        _setLoanId(id, _loanId);\n        emit SetLoanId(id, _loanId);\n    }\n\n    /**\n     * @notice change the current ownership of a asset\n     */\n    function changeOwner(address _asset, uint256 _id, address _newOwner) external onlyProtocol {\n        bytes32 id = AssetLogic.assetId(_asset, _id);\n\n        // We unlock the current asset\n        _setLoanId(id, 0);\n        // Force end delegation\n        delegationOwner.forceEndDelegation(_asset, _id);\n\n        bool success = _transferAsset(_asset, _id, _newOwner);\n        if (!success) revert Errors.DelegationOwner__changeOwner_notSuccess();\n\n        emit ChangeOwner(_asset, _id, _newOwner);\n    }\n\n    /**\n     * @notice batch function to set to 0 a group of assets\n     */\n    function batchSetToZeroLoanId(bytes32[] calldata _assets) external onlyProtocol {\n        uint256 cachedAssets = _assets.length;\n        for (uint256 i = 0; i < cachedAssets; ) {\n            if (loansIds[_assets[i]] == 0) revert Errors.DelegationOwner__assetNotLocked();\n            _setLoanId(_assets[i], 0);\n            unchecked {\n                i++;\n            }\n        }\n        emit SetBatchLoanId(_assets, 0);\n    }\n\n    /**\n     * @notice batch function to set to different from 0 a group of assets\n     */\n    function batchSetLoanId(bytes32[] calldata _assets, bytes32 _loanId) external onlyProtocol {\n        uint256 cachedAssets = _assets.length;\n        for (uint256 i = 0; i < cachedAssets; ) {\n            if (loansIds[_assets[i]] != 0) revert Errors.DelegationOwner__assetAlreadyLocked();\n            _setLoanId(_assets[i], _loanId);\n            unchecked {\n                i++;\n            }\n        }\n        emit SetBatchLoanId(_assets, _loanId);\n    }\n\n    //////////////////////////////////////////////\n    //       Internal functions\n    //////////////////////////////////////////////\n\n    function _setLoanId(bytes32 _assetId, bytes32 _loanId) internal {\n        loansIds[_assetId] = _loanId;\n\n        // We update the guard from DelegationOwner\n        if (_loanId == 0) {\n            guard.unlockAsset(_assetId);\n        } else {\n            guard.lockAsset(_assetId);\n        }\n    }\n}\n"
    },
    "lib/unlockdv2-wallet/src/libs/recipes/DelegationRecipes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.19;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { Errors } from \"../helpers/Errors.sol\";\n\n/**\n * @title DelegationRecipes\n * @author BootNode\n * @dev Registers the functions that will be allowed to be executed by assets delegates.\n * Functions are grouped by target contract and asset collection.\n */\ncontract DelegationRecipes is Ownable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // collection address -> keccak256(collection, contract, selector)\n    mapping(address => EnumerableSet.Bytes32Set) internal functionByCollection;\n\n    // keccak256(collection, contract, selector) -> description\n    mapping(bytes32 => string) public functionDescriptions;\n\n    event AddRecipe(address indexed collection, address[] contracts, bytes4[] selectors, string[] description);\n\n    event RemoveRecipe(address indexed collection, address[] contracts, bytes4[] selectors);\n\n    /**\n     * @notice Adds a group of allowed functions to a collection.\n     * @param _collection - The asset collection address.\n     * @param _contracts - The target contract addresses.\n     * @param _selectors - The allowed function selectors.\n     */\n    function add(\n        address _collection,\n        address[] calldata _contracts,\n        bytes4[] calldata _selectors,\n        string[] calldata _descriptions\n    ) external onlyOwner {\n        if (_contracts.length != _selectors.length || _selectors.length != _descriptions.length)\n            revert Errors.DelegationRecipes__add_arityMismatch();\n\n        bytes32 functionId;\n        uint256 length = _contracts.length;\n        for (uint256 i; i < length; ) {\n            functionId = keccak256(abi.encodePacked(_collection, _contracts[i], _selectors[i]));\n            functionByCollection[_collection].add(functionId);\n            functionDescriptions[functionId] = _descriptions[i];\n\n            emit AddRecipe(_collection, _contracts, _selectors, _descriptions);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Removes a group of allowed functions from a collection.\n     * @param _collection - The owner's address.\n     * @param _contracts - The owner's address.\n     * @param _selectors - The owner's address.\n     */\n    function remove(\n        address _collection,\n        address[] calldata _contracts,\n        bytes4[] calldata _selectors\n    ) external onlyOwner {\n        if (_contracts.length != _selectors.length) revert Errors.DelegationRecipes__remove_arityMismatch();\n\n        bytes32 functionId;\n        uint256 length = _contracts.length;\n        for (uint256 i; i < length; ) {\n            functionId = keccak256(abi.encodePacked(_collection, _contracts[i], _selectors[i]));\n            functionByCollection[_collection].remove(functionId);\n            delete functionDescriptions[functionId];\n\n            emit RemoveRecipe(_collection, _contracts, _selectors);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if a function is allowed for a collection.\n     * @param _collection - The owner's address.\n     * @param _contract - The owner's address.\n     * @param _selector - The owner's address.\n     */\n    function isAllowedFunction(address _collection, address _contract, bytes4 _selector) external view returns (bool) {\n        bytes32 functionId = keccak256(abi.encodePacked(_collection, _contract, _selector));\n        return functionByCollection[_collection].contains(functionId);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "solady/=lib/solady/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "@chainlink/=lib/chainlink/",
      "@unlockd-wallet/=lib/unlockdv2-wallet/",
      "@solady/=lib/solady/src/",
      "@maxapy/=lib/maxapy/src/",
      "@gnosis.pm/safe-contracts/=lib/unlockdv2-wallet/lib/safe-contracts/",
      "chainlink/=lib/chainlink/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "maxapy/=lib/maxapy/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/contracts/",
      "safe-contracts/=lib/unlockdv2-wallet/lib/safe-contracts/contracts/",
      "unlockdv2-wallet/=lib/unlockdv2-wallet/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  },
  "language": "Solidity"
}}