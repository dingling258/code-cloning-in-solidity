{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address) {\n        return _getRoleMember(role, index);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return _getRoleMemberCount(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/IReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IReentrancyGuard } from './IReentrancyGuard.sol';\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard is IReentrancyGuard {\n    uint256 internal constant REENTRANCY_STATUS_LOCKED = 2;\n    uint256 internal constant REENTRANCY_STATUS_UNLOCKED = 1;\n\n    modifier nonReentrant() virtual {\n        if (_isReentrancyGuardLocked()) revert ReentrancyGuard__ReentrantCall();\n        _lockReentrancyGuard();\n        _;\n        _unlockReentrancyGuard();\n    }\n\n    /**\n     * @notice returns true if the reentrancy guard is locked, false otherwise\n     */\n    function _isReentrancyGuardLocked() internal view virtual returns (bool) {\n        return\n            ReentrancyGuardStorage.layout().status == REENTRANCY_STATUS_LOCKED;\n    }\n\n    /**\n     * @notice lock functions that use the nonReentrant modifier\n     */\n    function _lockReentrancyGuard() internal virtual {\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_LOCKED;\n    }\n\n    /**\n     * @notice unlock functions that use the nonReentrant modifier\n     */\n    function _unlockReentrancyGuard() internal virtual {\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_UNLOCKED;\n    }\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/internal/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\n\nimport { LibAccessControl } from \"../libraries/LibAccessControl.sol\";\nimport { LibWhitelabel } from \"../libraries/LibWhitelabel.sol\";\n\nabstract contract WhitelistInternal is AccessControlInternal {\n    modifier onlyWhitelisted(address account, bytes32 productId) {\n        LibWhitelabel.DiamondStorage storage ds = LibWhitelabel.diamondStorage();\n        require(!ds.isWhitelistEnabled[productId] || _hasRole(LibAccessControl.WHITELISTED_ROLE, account), \"Whitelist: caller is not whitelisted\");\n        _;\n    }\n}\n"
    },
    "contracts/common/admin/libraries/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibAccessControl {\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant WHITELIST_ADMIN_ROLE = keccak256(\"WHITELIST_ADMIN_ROLE\");\n    bytes32 internal constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n}\n"
    },
    "contracts/common/admin/libraries/LibWhitelabel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibWhitelabel {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"floki.whitelabel.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(bytes32 => bool) isWhitelistEnabled; // bytes32 is productIdentifier generated using keccak256\n    }\n\n    event WhitelistedAdded(address indexed account);\n    event WhitelistedRemoved(address indexed account);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/common/diamonds/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IPausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\n\ninterface IPausableFacet is IPausable {\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamondHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\nimport { IReentrancyGuard } from \"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol\";\n\nimport { IPausableFacet, IPausable } from \"../interfaces/IPausableFacet.sol\";\n\nlibrary LibDiamondHelpers {\n    function getAccessControlSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](7);\n        functionSelectors[0] = IAccessControl.hasRole.selector;\n        functionSelectors[1] = IAccessControl.getRoleAdmin.selector;\n        functionSelectors[2] = IAccessControl.grantRole.selector;\n        functionSelectors[3] = IAccessControl.revokeRole.selector;\n        functionSelectors[4] = IAccessControl.renounceRole.selector;\n        functionSelectors[5] = IAccessControl.getRoleMember.selector;\n        functionSelectors[6] = IAccessControl.getRoleMemberCount.selector;\n    }\n\n    function getPausableSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](3);\n        functionSelectors[0] = IPausable.paused.selector;\n        functionSelectors[1] = IPausableFacet.pause.selector;\n        functionSelectors[2] = IPausableFacet.unpause.selector;\n    }\n\n    function getReentrancyGuardSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](0);\n    }\n}\n"
    },
    "contracts/launchpad/facets/LaunchPadFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\n\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport { ILaunchPadFactory, ILaunchPadCommon } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadPayment } from \"../interfaces/ILaunchPadPayment.sol\";\nimport { ILaunchPadPricing } from \"../interfaces/ILaunchPadPricing.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectInit } from \"../interfaces/ILaunchPadProjectInit.sol\";\nimport { LibLaunchPadFactoryStorage } from \"../libraries/LaunchPadFactoryStorage.sol\";\nimport { LibLaunchPadProjectStorage } from \"../libraries/LaunchPadProjectStorage.sol\";\nimport { LibLaunchPadConsts } from \"../libraries/LaunchPadConsts.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../../common/diamonds/libraries/LibDiamond.sol\";\nimport { LibDiamondHelpers } from \"../../common/diamonds/libraries/LibDiamondHelpers.sol\";\nimport { Diamond } from \"../../common/diamonds/Diamond.sol\";\nimport { ITokenLauncherERC20, ITokenLauncherCommon } from \"../../token-launcher/interfaces/ITokenLauncherERC20.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"../../token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol\";\nimport { ITokenFiERC20 } from \"../../token-launcher/interfaces/ITokenFiERC20.sol\";\nimport { WhitelistInternal } from \"../../common/admin/internal/WhitelistInternal.sol\";\n\ncontract LaunchPadFactoryFacet is ILaunchPadFactory, WhitelistInternal {\n    using SafeMath for uint256;\n\n    function addInvestorToLaunchPad(address investor) external override {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        // Can only be called by a launchpad contract\n        require(ds.isLaunchPad[msg.sender], \"LaunchPadFactoryFacet:addInvestorToLaunchPad: LaunchPad does not exist\");\n        ds.launchPadsByInvestor[investor].push(msg.sender);\n    }\n\n    function createLaunchPad(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput\n    ) external payable override onlyWhitelisted(msg.sender, LibLaunchPadConsts.PRODUCT_ID) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        if (storeInput.launchPadType == LaunchPadType.FlokiPadCreatedBefore) {\n            // create a TokenFiERC20 token by using TokenLauncherERC20\n            // payment would be ignored because launchpad factory has a discount NFT\n            address tokenAdress = ITokenLauncherERC20(ds.tokenLauncherERC20).createErc20(\n                ITokenLauncherERC20.CreateErc20Input({\n                    name: storeInput.createErc20Input.name,\n                    symbol: storeInput.createErc20Input.symbol,\n                    logo: storeInput.createErc20Input.logo,\n                    decimals: storeInput.createErc20Input.decimals,\n                    initialSupply: storeInput.launchPadInfo.fundTarget.hardCap + storeInput.createErc20Input.treasuryReserved,\n                    maxSupply: storeInput.createErc20Input.maxSupply,\n                    treasury: address(this),\n                    owner: storeInput.createErc20Input.owner,\n                    referrer: storeInput.referrer,\n                    tokenStore: ds.tokenLauncherStore,\n                    fees: ITokenLauncherERC20.Fees({\n                        transferFee: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        burn: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        reflection: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        buyback: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false })\n                    }),\n                    buybackHandler: ds.tokenLauncherBuybackHandler,\n                    paymentMethod: ITokenLauncherCommon.PaymentMethod(uint256(storeInput.paymentMethod))\n                })\n            );\n            storeInput.launchPadInfo.tokenAddress = tokenAdress;\n        } else if (storeInput.launchPadType == LaunchPadType.FlokiPadCreatedAfter) {\n            // create a TokenFiERC20 token by using TokenLauncherERC20\n            // payment would be ignored because launchpad factory has a discount NFT\n            require(storeInput.createErc20Input.owner != address(0), \"LaunchPadFactory::createLaunchPad(): owner cannot be Address Zero \");\n            require(\n                storeInput.createErc20Input.maxSupply >= storeInput.launchPadInfo.fundTarget.hardCap,\n                \"LaunchPadFactory::createLaunchPad(): maxSupply cannot be smaller than launchPad hardCap\"\n            );\n            storeInput.launchPadInfo.tokenAddress = address(0);\n        } else {\n            revert(\"LaunchPadFactory: Invalid launchPadType\");\n        }\n\n        // First let's calculate the price\n        uint256 usdPrice = ILaunchPadPricing(address(this)).getPrice(msg.sender, storeInput.launchPadType);\n        // Now let's process the payment\n        ILaunchPadPayment.ProcessPaymentInput memory paymentInput = ILaunchPadPayment.ProcessPaymentInput({\n            referrer: storeInput.referrer,\n            usdPrice: usdPrice,\n            user: msg.sender,\n            paymentMethod: storeInput.paymentMethod\n        });\n        ILaunchPadPayment(address(this)).processPayment{ value: msg.value }(paymentInput);\n\n        // Create the new LaunchPad\n        LibDiamond.DiamondStorage storage diamondStorage = LibDiamond.diamondStorage();\n        LibDiamond.FacetAddressAndPosition memory diamondCutFacet = diamondStorage.selectorToFacetAndPosition[IDiamondCut.diamondCut.selector];\n        address launchPad = address(new Diamond(address(this), diamondCutFacet.facetAddress));\n\n        _prepareLaunchPadDiamond(launchPad, storeInput);\n\n        // Transfer token to the launchpad and treasury address\n        if (storeInput.launchPadType == LaunchPadType.FlokiPadCreatedBefore) {\n            IERC20(storeInput.launchPadInfo.tokenAddress).transfer(address(launchPad), storeInput.launchPadInfo.fundTarget.hardCap);\n            IERC20(storeInput.launchPadInfo.tokenAddress).transfer(storeInput.createErc20Input.owner, storeInput.createErc20Input.treasuryReserved);\n        }\n\n        // Log new launchPad into store\n        _addLaunchPad(storeInput, launchPad, usdPrice);\n    }\n\n    function createTokenAfterICO(address launchPad) external payable override onlyLaunchPadOwner(launchPad) {\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress == address(0),\n            \"LaunchPadFactory:createTokenAfterICO: Token address is already set\"\n        );\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:createTokenAfterICO: LaunchPad does not exist\");\n\n        CreateErc20Input memory createErc20Input = ds.tokenInfoByLaunchPadAddress[launchPad];\n\n        // create a TokenFiERC20 token by using TokenLauncherERC20\n        // payment would be ignored because launchpad factory has a discount NFT\n        address tokenAddress = ITokenLauncherERC20(ds.tokenLauncherERC20).createErc20{ value: msg.value }(\n            ITokenLauncherERC20.CreateErc20Input({\n                name: createErc20Input.name,\n                symbol: createErc20Input.symbol,\n                logo: createErc20Input.logo,\n                decimals: createErc20Input.decimals,\n                initialSupply: ILaunchPadProject(launchPad).totalTokensSold() + createErc20Input.treasuryReserved,\n                maxSupply: createErc20Input.maxSupply,\n                treasury: address(this),\n                owner: address(this),\n                referrer: address(0),\n                tokenStore: ds.tokenLauncherStore,\n                fees: ITokenLauncherERC20.Fees({\n                    transferFee: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                    burn: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                    reflection: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                    buyback: ITokenLauncherERC20.FeeDetails({ percentage: 0, onlyOnSwaps: false })\n                }),\n                buybackHandler: ds.tokenLauncherBuybackHandler,\n                paymentMethod: ITokenLauncherCommon.PaymentMethod(0)\n            })\n        );\n        ILaunchPadProject(launchPad).setTokenAddress(tokenAddress);\n        ITokenFiERC20(tokenAddress).updateTreasury(createErc20Input.owner);\n        IAccessControl(tokenAddress).grantRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, createErc20Input.owner);\n        IAccessControl(tokenAddress).renounceRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, address(this));\n\n        // Transfer the totalTokensSold() amount to the launchpad\n        IERC20(tokenAddress).transfer(launchPad, ILaunchPadProject(launchPad).totalTokensSold());\n        // Transfer the treasury amount to the treasury\n        IERC20(tokenAddress).transfer(createErc20Input.owner, createErc20Input.treasuryReserved);\n    }\n\n    function createV2LiquidityPool(address launchPad) external payable override onlyLaunchPadOwner(launchPad) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:createV2LiquidityPool: LaunchPad does not exist\");\n\n        ILaunchPadCommon.LaunchPadInfo memory launchPadInfo = ILaunchPadProject(launchPad).getLaunchPadInfo();\n        require(block.timestamp > launchPadInfo.startTimestamp.add(launchPadInfo.duration), \"Sale is still ongoing\");\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress != address(0),\n            \"LaunchPadFactory:addV2Liquidity: Token address is 0 - token does not exist\"\n        );\n        require(launchPadInfo.idoInfo.enabled == true, \"LaunchPad:addV2Liquidity: IDO is not enabled\");\n\n        uint256 tokenDecimals = IERC20Metadata(launchPadInfo.tokenAddress).decimals();\n        ITokenLauncherLiquidityPoolFactory.CreateV2Input memory createV2Input = ITokenLauncherLiquidityPoolFactory.CreateV2Input({\n            owner: launchPadInfo.owner,\n            treasury: launchPadInfo.owner,\n            liquidityPoolDetails: ITokenLauncherLiquidityPoolFactory.LiquidityPoolDetails({\n                sourceToken: launchPadInfo.tokenAddress,\n                pairedToken: launchPadInfo.idoInfo.pairToken,\n                amountSourceToken: launchPadInfo.idoInfo.amountToList,\n                amountPairedToken: launchPadInfo.idoInfo.price.mul(launchPadInfo.idoInfo.amountToList).div(10 ** tokenDecimals),\n                routerAddress: launchPadInfo.idoInfo.dexRouter\n            }),\n            lockLPDetails: ITokenLauncherLiquidityPoolFactory.LockLPDetails({\n                lockLPTokenPercentage: 0,\n                unlockTimestamp: 0,\n                beneficiary: launchPadInfo.owner,\n                isVesting: false\n            }),\n            buybackDetails: ITokenLauncherLiquidityPoolFactory.BuyBackDetails({\n                pairToken: launchPadInfo.idoInfo.pairToken,\n                router: launchPadInfo.idoInfo.dexRouter,\n                liquidityBasisPoints: 0,\n                priceImpactBasisPoints: 0\n            })\n        });\n\n        ITokenLauncherERC20(ds.tokenLauncherERC20).createV2LiquidityPool{ value: msg.value }(createV2Input);\n    }\n\n    function getLaunchPadsPaginated(uint256 quantity, uint256 page) external view override returns (address[] memory) {\n        require(quantity > 0, \"LaunchPad: quantity must be greater than 0\");\n        require(page > 0, \"LaunchPad: page must be greater than 0\");\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        uint256 offset = quantity * (page - 1);\n        uint256 size = quantity;\n        if (offset + size > ds.launchPads.length) {\n            size = ds.launchPads.length - offset;\n        }\n        address[] memory launchPads = new address[](size);\n        for (uint256 i = 0; i < size; i++) {\n            launchPads[i] = ds.launchPads[offset + i];\n        }\n        return launchPads;\n    }\n\n    function getLaunchPadsByInvestorPaginated(address investor, uint256 quantity, uint256 page) external view override returns (address[] memory) {\n        require(quantity > 0, \"LaunchPad: quantity must be greater than 0\");\n        require(page > 0, \"LaunchPad: page must be greater than 0\");\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        uint256 offset = quantity * (page - 1);\n        uint256 size = quantity;\n        if (offset + size > ds.launchPadsByInvestor[investor].length) {\n            size = ds.launchPadsByInvestor[investor].length - offset;\n        }\n        address[] memory launchPads = new address[](size);\n        for (uint256 i = 0; i < size; i++) {\n            launchPads[i] = ds.launchPadsByInvestor[investor][offset + i];\n        }\n        return launchPads;\n    }\n\n    function getLaunchPadCountByOwner(address owner) external view override returns (uint256) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        return ds.launchPadsByOwner[owner].length;\n    }\n\n    function getLaunchPadsByOwnerPaginated(address owner, uint256 quantity, uint256 page) external view override returns (address[] memory) {\n        require(quantity > 0, \"LaunchPad: quantity must be greater than 0\");\n        require(page > 0, \"LaunchPad: page must be greater than 0\");\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        uint256 offset = quantity * (page - 1);\n        uint256 size = quantity;\n        if (offset + size > ds.launchPadsByOwner[owner].length) {\n            size = ds.launchPadsByOwner[owner].length - offset;\n        }\n        address[] memory launchPads = new address[](size);\n        for (uint256 i = 0; i < size; i++) {\n            launchPads[i] = ds.launchPadsByOwner[owner][offset + i];\n        }\n        return launchPads;\n    }\n\n    function getMaxTokenCreationDeadline() external view returns (uint256) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        return ds.maxTokenCreationDeadline;\n    }\n\n    function tokenLauncherERC20() external view override returns (address) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        return ds.tokenLauncherERC20;\n    }\n\n    function launchPadTokenInfo(address launchPadAddress) external view returns (CreateErc20Input memory createErc20Input) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        return ds.tokenInfoByLaunchPadAddress[launchPadAddress];\n    }\n\n    function updateLaunchPadOwner(address launchPadAddress, address newOwner) external override {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        address owner = ds.launchPadOwner[launchPadAddress];\n        require(msg.sender == owner, \"LaunchPadStore: Not owner\");\n        require(owner != newOwner, \"LaunchPadStore: Same owner\");\n        require(newOwner != address(0), \"LaunchPadStore: New owner cannot be 0\");\n        address[] storage launchPads = ds.launchPadsByOwner[owner];\n\n        bool _launchPadExists = false;\n        for (uint256 i = 0; i < ds.launchPadsByOwner[owner].length; i++) {\n            if (ds.launchPadsByOwner[owner][i] == launchPadAddress) {\n                ds.launchPadsByOwner[owner][i] = ds.launchPadsByOwner[owner][launchPads.length - 1];\n                ds.launchPadsByOwner[owner].pop();\n                _launchPadExists = true;\n                break;\n            }\n        }\n        require(_launchPadExists == true, \"LaunchPadStore: LaunchPad does not exist\");\n\n        ds.launchPadsByOwner[newOwner].push(launchPadAddress);\n        ds.launchPadOwner[launchPadAddress] = newOwner;\n        emit LibLaunchPadFactoryStorage.LaunchPadOwnerUpdated(ds.currentBlockLaunchPadOwnerUpdated, owner, newOwner);\n        ds.currentBlockLaunchPadOwnerUpdated = block.number;\n    }\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        uint256 oldMaxTokenCreationDeadline = ds.maxTokenCreationDeadline;\n        ds.maxTokenCreationDeadline = newMaxTokenCreationDeadline;\n        emit LibLaunchPadFactoryStorage.MaxTokenCreationDeadlineUpdated(oldMaxTokenCreationDeadline, newMaxTokenCreationDeadline);\n    }\n\n    function _addLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input, address launchPad, uint256 usdPrice) private {\n        require(input.launchPadInfo.owner != address(0), \"LaunchPadFactory: Owner cannot be 0\");\n        ILaunchPadFactory.StoreLaunchPadInput memory storeInput = ILaunchPadFactory.StoreLaunchPadInput({\n            launchPadType: input.launchPadType,\n            launchPadAddress: launchPad,\n            owner: input.launchPadInfo.owner,\n            referrer: input.referrer,\n            usdPrice: usdPrice\n        });\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        ds.launchPadsByOwner[storeInput.owner].push(storeInput.launchPadAddress);\n        ds.launchPads.push(storeInput.launchPadAddress);\n        ds.isLaunchPad[storeInput.launchPadAddress] = true;\n        ds.launchPadOwner[storeInput.launchPadAddress] = storeInput.owner;\n        ds.tokenInfoByLaunchPadAddress[storeInput.launchPadAddress] = input.createErc20Input;\n        ds.currentBlockLaunchPadCreated = block.number;\n        emit LibLaunchPadFactoryStorage.LaunchPadCreated(ds.currentBlockLaunchPadCreated, storeInput.launchPadType, storeInput.owner, storeInput);\n    }\n\n    function _prepareLaunchPadDiamond(address launchPad, ILaunchPadCommon.CreateLaunchPadInput memory input) private {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\n\n        // Add LaunchPadProjectFacet\n        bytes4[] memory functionSelectors = new bytes4[](22);\n        functionSelectors[0] = ILaunchPadProject.buyTokens.selector;\n        functionSelectors[1] = ILaunchPadProject.claimTokens.selector;\n        functionSelectors[2] = ILaunchPadProject.claimedTokensByUser.selector;\n        functionSelectors[3] = ILaunchPadProject.getFeeShare.selector;\n        functionSelectors[4] = ILaunchPadProject.getLaunchPadAddress.selector;\n        functionSelectors[5] = ILaunchPadProject.getLaunchPadInfo.selector;\n        functionSelectors[6] = ILaunchPadProject.getProjectOwnerRole.selector;\n        functionSelectors[7] = ILaunchPadProject.getReleasedTokensPercentage.selector;\n        functionSelectors[8] = ILaunchPadProject.getReleaseSchedule.selector;\n        functionSelectors[9] = ILaunchPadProject.getTokensAvailableToBeClaimed.selector;\n        functionSelectors[10] = ILaunchPadProject.getTokenCreationDeadline.selector;\n        functionSelectors[11] = ILaunchPadProject.paidTokenAmountByUser.selector;\n        functionSelectors[12] = ILaunchPadProject.purchasedAmountByUser.selector;\n        functionSelectors[13] = ILaunchPadProject.refund.selector;\n        functionSelectors[14] = ILaunchPadProject.refundOnSoftCapFailure.selector;\n        functionSelectors[15] = ILaunchPadProject.refundOnTokenCreationExpired.selector;\n        functionSelectors[16] = ILaunchPadProject.setTokenAddress.selector;\n        functionSelectors[17] = ILaunchPadProject.tokenDecimals.selector;\n        functionSelectors[18] = ILaunchPadProject.totalTokensClaimed.selector;\n        functionSelectors[19] = ILaunchPadProject.totalTokensSold.selector;\n        functionSelectors[20] = ILaunchPadProject.withdrawFees.selector;\n        functionSelectors[21] = ILaunchPadProject.withdrawTokens.selector;\n\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: ds.launchPadProjectFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add AccessControlFacet\n        functionSelectors = LibDiamondHelpers.getAccessControlSelectors();\n        cut[1] = IDiamondCut.FacetCut({ facetAddress: ds.accessControlFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add PausableFacet\n        functionSelectors = LibDiamondHelpers.getPausableSelectors();\n        cut[2] = IDiamondCut.FacetCut({ facetAddress: ds.pausableFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add Facets to LaunchPad Diamond and initialize it\n        bytes memory _calldata = abi.encodeCall(ILaunchPadProjectInit.init, input);\n        IDiamondCut(launchPad).diamondCut(cut, ds.launchPadProjectDiamondInit, _calldata);\n    }\n\n    modifier onlyAdmin() {\n        require(\n            IAccessControl(address(this)).hasRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, msg.sender),\n            \"LaunchPadFactory: Only admin can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyLaunchPadOwner(address launchPad) {\n        require(\n            IAccessControl(launchPad).hasRole(LibLaunchPadProjectStorage.LAUNCHPAD_OWNER_ROLE, msg.sender),\n            \"LaunchPadFactory: Only project owner can call this function\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILaunchPadCommon {\n    enum LaunchPadType {\n        FlokiPadCreatedBefore,\n        FlokiPadCreatedAfter\n    }\n\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        TOKENFI\n    }\n\n    struct IdoInfo {\n        bool enabled;\n        address dexRouter;\n        address pairToken;\n        uint256 price;\n        uint256 amountToList;\n    }\n\n    struct RefundInfo {\n        uint256 penaltyFeePercent;\n        uint256 expireDuration;\n    }\n\n    struct FundTarget {\n        uint256 softCap;\n        uint256 hardCap;\n    }\n\n    struct ReleaseSchedule {\n        uint256 timestamp;\n        uint256 percent;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 maxSupply;\n        address owner;\n        uint256 treasuryReserved;\n    }\n\n    struct LaunchPadInfo {\n        address owner;\n        address tokenAddress;\n        address paymentTokenAddress;\n        uint256 price;\n        FundTarget fundTarget;\n        uint256 maxInvestPerWallet;\n        uint256 startTimestamp;\n        uint256 duration;\n        uint256 tokenCreationDeadline;\n        RefundInfo refundInfo;\n        IdoInfo idoInfo;\n    }\n\n    struct CreateLaunchPadInput {\n        LaunchPadType launchPadType;\n        LaunchPadInfo launchPadInfo;\n        ReleaseSchedule[] releaseSchedule;\n        CreateErc20Input createErc20Input;\n        address referrer;\n        PaymentMethod paymentMethod;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadFactory is ILaunchPadCommon {\n    struct StoreLaunchPadInput {\n        ILaunchPadCommon.LaunchPadType launchPadType;\n        address launchPadAddress;\n        address owner;\n        address referrer;\n        uint256 usdPrice;\n    }\n\n    function addInvestorToLaunchPad(address investor) external;\n\n    function createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input) external payable;\n\n    function createTokenAfterICO(address launchPadAddress) external payable;\n\n    function createV2LiquidityPool(address launchPadAddress) external payable;\n\n    function getLaunchPadsPaginated(uint256 quantity, uint256 page) external view returns (address[] memory);\n\n    function getLaunchPadsByInvestorPaginated(address investor, uint256 quantity, uint256 page) external view returns (address[] memory);\n\n    function getLaunchPadCountByOwner(address owner) external view returns (uint256);\n    \n    function getLaunchPadsByOwnerPaginated(address owner, uint256 quantity, uint256 page) external view returns (address[] memory);\n\n    function getMaxTokenCreationDeadline() external view returns (uint256);\n\n    function launchPadTokenInfo(address launchPadAddress) external view returns (CreateErc20Input memory createErc20Input);\n\n    function tokenLauncherERC20() external view returns (address);\n\n    function updateLaunchPadOwner(address tokenAddress, address newOwner) external;\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadPayment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadPayment is ILaunchPadCommon {\n    struct ProcessPaymentInput {\n        address referrer;\n        uint256 usdPrice;\n        address user;\n        PaymentMethod paymentMethod;\n    }\n\n    struct ProcessPaymentOutput {\n        PaymentMethod paymentMethod;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n    }\n\n    function getRouterAddress() external view returns (address);\n\n    function getTokenFiToken() external view returns (address);\n\n    function getTreasury() external view returns (address);\n\n    function getUsdToken() external view returns (address);\n\n    function processPayment(ProcessPaymentInput memory params) external payable;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadPricing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadPricing is ILaunchPadCommon {\n    function getFeePercentage() external view returns (uint256);\n\n    function getPrice(address user, LaunchPadType launchPadType) external view returns (uint256); // returns usd value includes the decimals (6)\n\n    function setDeployLaunchPadPrice(uint256 newPrice, LaunchPadType launchPadType) external;\n\n    function setFeePercentage(uint256 newFeePercentage) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProject {\n    function buyTokens(uint256 tokenAmount) external payable;\n\n    function claimTokens() external;\n\n    function claimedTokensByUser(address user) external view returns (uint256);\n\n    function getFeeShare() external view returns (uint256);\n\n    function getLaunchPadAddress() external view returns (address);\n\n    function getLaunchPadInfo() external view returns (ILaunchPadCommon.LaunchPadInfo memory);\n\n    function getProjectOwnerRole() external view returns (bytes32);\n\n    function getReleasedTokensPercentage() external view returns (uint256);\n\n    function getReleaseSchedule() external view returns (ILaunchPadCommon.ReleaseSchedule[] memory);\n\n    function getTokensAvailableToBeClaimed(address user) external view returns (uint256);\n\n    function getTokenCreationDeadline() external view returns (uint256);\n\n    function paidTokenAmountByUser(address user) external view returns (uint256);\n\n    function purchasedAmountByUser(address user) external view returns (uint256);\n\n    function refund(uint256 tokenAmount) external;\n\n    function refundOnSoftCapFailure() external;\n\n    function refundOnTokenCreationExpired(uint256 tokenAmount) external;\n\n    function setTokenAddress(address tokenAddress) external;\n\n    function tokenDecimals() external view returns (uint256);\n\n    function totalTokensClaimed() external view returns (uint256);\n\n    function totalTokensSold() external view returns (uint256);\n\n    function withdrawFees() external;\n\n    function withdrawTokens(address _tokenAddress) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectInit {\n    function init(ILaunchPadCommon.CreateLaunchPadInput memory input) external;\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibLaunchPadConsts {\n    bytes32 internal constant PRODUCT_ID = keccak256(\"tokenfi.launchpad\");\n    uint256 internal constant BASIS_POINTS = 10_000;\n    uint256 internal constant REFERRER_BASIS_POINTS = 2_500;\n    uint256 internal constant BURN_BASIS_POINTS = 5_000;\n    address internal constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactory } from \"../interfaces/ILaunchPadFactory.sol\";\n\nlibrary LibLaunchPadFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        address[] launchPads;\n        mapping(address => address[]) launchPadsByOwner;\n        mapping(address => address[]) launchPadsByInvestor;\n        mapping(address => address) launchPadOwner;\n        mapping(address => bool) isLaunchPad;\n        mapping(address => ILaunchPadFactory.CreateErc20Input) tokenInfoByLaunchPadAddress;\n        uint256 currentBlockLaunchPadCreated;\n        uint256 currentBlockLaunchPadOwnerUpdated;\n        address tokenLauncherERC20;\n        address tokenLauncherStore;\n        address tokenLauncherBuybackHandler;\n        address launchPadProjectFacet;\n        address accessControlFacet;\n        address pausableFacet;\n        address launchPadProjectDiamondInit;\n        address tokenfiToken;\n        address usdToken;\n        address router;\n        address treasury;\n        uint256 maxTokenCreationDeadline;\n    }\n\n    event LaunchPadCreated(\n        uint256 indexed previousBlock,\n        ILaunchPadCommon.LaunchPadType indexed launchPadType,\n        address indexed owner,\n        ILaunchPadFactory.StoreLaunchPadInput launchPad\n    );\n    event LaunchPadOwnerUpdated(uint256 indexed previousBlock, address owner, address newOwner);\n    event MaxTokenCreationDeadlineUpdated(uint256 indexed previousMaxTokenCreationDeadline, uint256 newMaxTokenCreationDeadline);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadProjectStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadPayment } from \"../interfaces/ILaunchPadPayment.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice storage for LaunchPads created by users\n\nlibrary LibLaunchPadProjectStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.project.diamond.storage\");\n    bytes32 internal constant LAUNCHPAD_OWNER_ROLE = keccak256(\"LAUNCHPAD_OWNER_ROLE\");\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    struct DiamondStorage {\n        ILaunchPadCommon.LaunchPadInfo launchPadInfo;\n        address launchPadFactory;\n        uint256 totalTokensSold;\n        uint256 totalTokensClaimed;\n        uint256 feePercentage; // in basis points 1e4\n        bool feeShareCollected;\n        ILaunchPadCommon.ReleaseSchedule[] releaseSchedule;\n        mapping(address => uint256) purchasedAmountByUser;\n        mapping(address => uint256) claimedAmountByUser;\n        mapping(address => uint256) paidTokenAmountByUser;\n    }\n\n    event TokensPurchased(address indexed buyer, uint256 amount);\n    event TokensRefunded(address indexed buyer, uint256 amount);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherERC20 } from \"./ITokenLauncherERC20.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"./ITokenLauncherLiquidityPoolFactory.sol\";\n\ninterface ITokenFiERC20 {\n    function addExchangePool(address pool) external;\n    function addExemptAddress(address account) external;\n    function excludeAccount(address account) external;\n    function includeAccount(address account) external;\n    function isExchangePool(address pool) external view returns (bool);\n    function isExcludedFromReflectionRewards(address account) external view returns (bool);\n    function isExemptedFromTax(address account) external view returns (bool);\n    function mint(address to, uint256 amount) external;\n    function reflect(uint256 tAmount) external;\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function removeExchangePool(address pool) external;\n    function removeExemptAddress(address account) external;\n    function setBuybackDetails(ITokenLauncherLiquidityPoolFactory.BuyBackDetails memory _buybackDetails) external;\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n    function updateFees(ITokenLauncherERC20.Fees memory _fees) external;\n    function updateTokenLauncher(address _newTokenLauncher) external;\n    function updateTreasury(address _newTreasury) external;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherCommon {\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        FLOKI\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"./ITokenLauncherCommon.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"./ITokenLauncherLiquidityPoolFactory.sol\";\n\ninterface ITokenLauncherERC20 is ITokenLauncherCommon {\n    struct FeeDetails {\n        uint256 percentage;\n        bool onlyOnSwaps;\n    }\n\n    struct Fees {\n        FeeDetails transferFee;\n        FeeDetails burn;\n        FeeDetails reflection;\n        FeeDetails buyback;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 initialSupply;\n        uint256 maxSupply;\n        address treasury;\n        address owner;\n        address referrer;\n        address tokenStore;\n        Fees fees;\n        address buybackHandler;\n        PaymentMethod paymentMethod;\n    }\n\n    function tokenLauncherStore() external returns (address);\n\n    function liquidityPoolFactory() external returns (address);\n\n    function buybackHandler() external returns (address);\n\n    function createErc20(CreateErc20Input memory input) external payable returns (address);\n\n    function createV2LiquidityPool(ITokenLauncherLiquidityPoolFactory.CreateV2Input memory input) external payable;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherLiquidityPoolFactory {\n    struct LiquidityPoolDetails {\n        address sourceToken;\n        address pairedToken;\n        uint256 amountSourceToken;\n        uint256 amountPairedToken;\n        address routerAddress;\n    }\n\n    struct LockLPDetails {\n        uint256 lockLPTokenPercentage;\n        uint256 unlockTimestamp;\n        address beneficiary;\n        bool isVesting;\n    }\n\n    struct BuyBackDetails {\n        address pairToken;\n        address router;\n        uint256 liquidityBasisPoints;\n        uint256 priceImpactBasisPoints;\n    }\n\n    struct CreateV2Input {\n        address owner;\n        address treasury;\n        LiquidityPoolDetails liquidityPoolDetails;\n        LockLPDetails lockLPDetails;\n        BuyBackDetails buybackDetails;\n    }\n\n    struct CreateV2Output {\n        address liquidityPoolToken;\n        uint256 liquidity;\n    }\n\n    function createV2LiquidityPool(CreateV2Input memory input) external payable returns (CreateV2Output memory);\n}\n"
    }
  }
}}