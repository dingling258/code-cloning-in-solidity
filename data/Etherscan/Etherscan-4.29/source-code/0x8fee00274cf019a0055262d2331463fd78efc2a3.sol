{{
  "language": "Solidity",
  "sources": {
    "CCIPRewriter.sol": {
      "content": "/// @author raffy.eth\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.23;\r\n\r\n// interfaces\r\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport {ENS} from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\r\nimport {IExtendedResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\r\nimport {IMulticallable} from \"@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol\";\r\nimport {IReverseRegistrar} from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol\";\r\n\r\n// libraries\r\nimport {Base32} from \"./Base32.sol\";\r\nimport {BytesUtils} from \"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\";\r\n\r\n// https://eips.ethereum.org/EIPS/eip-3668\r\nerror OffchainLookup(address from, string[] urls, bytes request, bytes4 callback, bytes carry);\r\n\r\ncontract CCIPRewriter is IERC165, IExtendedResolver {\r\n\tusing BytesUtils for bytes;\r\n\r\n\terror Unreachable(bytes name); \r\n\terror InvalidBase32(bytes name);\r\n\r\n\tENS immutable _ens;\r\n\tconstructor(ENS ens) {\r\n\t\t_ens = ens;\r\n\t\t_rr().claim(msg.sender);\r\n\t}\r\n\r\n\tfunction _rr() internal view returns (IReverseRegistrar) {\r\n\t\t// https://adraffy.github.io/keccak.js/test/demo.html#algo=namehash&s=addr.reverse&escape=1&encoding=utf8\r\n\t\treturn IReverseRegistrar(_ens.owner(0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2));\r\n\t}\r\n \r\n\tfunction supportsInterface(bytes4 x) external pure returns (bool) {\r\n\t\treturn x == type(IERC165).interfaceId \r\n\t\t\t|| x == type(IExtendedResolver).interfaceId\r\n\t\t\t|| x == 0x87f60257; // https://adraffy.github.io/keccak.js/test/demo.html#algo=evm&s=CCIPRewriter&escape=1&encoding=utf8\r\n\t}\r\n\r\n\t// reflect into the reverse record\r\n\tfunction _resolveBasename(bytes32, bytes memory data) internal view returns (bytes memory) {\r\n\t\tbytes32 node = _rr().node(address(this));\r\n\t\taddress resolver = _ens.resolver(node);\r\n\t\tif (resolver != address(0)) {\r\n\t\t\tassembly { mstore(add(data, 36), node) }\r\n\t\t\t(bool ok, bytes memory v) = resolver.staticcall(data);\r\n\t\t\tif (ok) return v;\r\n\t\t}\r\n\t\treturn new bytes(64);\r\n\t}\r\n\r\n\t// IExtendedResolver\r\n\tfunction resolve(bytes memory name, bytes memory data) external view returns (bytes memory v) {\r\n\t\tunchecked {\r\n\t\t\t// look for [name].{base32}.[basename]\r\n\t\t\t(bytes32 node, uint256 offset, uint256 offset2) = _findSelf(name);\r\n\t\t\tif (offset == 0 || offset2 == 0) return _resolveBasename(node, data);\r\n\t\t\tuint256 name_ptr;\r\n\t\t\tassembly { name_ptr := add(add(name, 32), offset2) }\r\n\t\t\toffset2 += 1;\r\n\t\t\t(bool valid, bytes memory url) = Base32.decode(name_ptr + 1, offset - offset2);\r\n\t\t\tif (!valid) revert InvalidBase32(name);\r\n\t\t\tstring[] memory urls = new string[](1);\r\n\t\t\turls[0] = string(url);\r\n\t\t\tassembly { \r\n\t\t\t\tmstore8(name_ptr, 0) // terminate\r\n\t\t\t\tmstore(name, offset2) // truncate\r\n\t\t\t}\r\n\t\t\t(, address resolver, bool wild, ) = _findResolver(name);\r\n\t\t\tif (resolver == address(0)) return new bytes(64);\r\n\t\t\tnode = name.namehash(0);\r\n\t\t\tassembly { mstore(add(data, 36), node) } // rewrite the target\r\n\t\t\tbool ok;\r\n\t\t\tif (wild) {\r\n\t\t\t\t(ok, v) = resolver.staticcall(abi.encodeCall(IExtendedResolver.resolve, (name, data)));\r\n\t\t\t\tif (ok) {\r\n\t\t\t\t\tv = abi.decode(v, (bytes));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (bytes4(v) != OffchainLookup.selector) assembly { revert(add(v, 32), mload(v)) }\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\tmstore(add(v, 4), sub(mload(v), 4)) \r\n\t\t\t\t\t\tv := add(v, 4)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(address sender, , bytes memory request, bytes4 callback, bytes memory carry) = abi.decode(v, (address, string[], bytes, bytes4, bytes));\r\n\t\t\t\t\trevert OffchainLookup(address(this), urls, request, this.resolveCallback.selector, abi.encode(sender, callback, carry));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t(ok, v) = resolver.staticcall(data);\r\n\t\t\t\tif (!ok) assembly { revert(add(v, 32), mload(v)) } // propagate error\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction resolveCallback(bytes calldata response, bytes calldata extra) external view returns (bytes memory) {\r\n\t\t(address sender, bytes4 callback, bytes memory carry) = abi.decode(extra, (address, bytes4, bytes));\r\n\t\t(bool ok, bytes memory v) = sender.staticcall(abi.encodeWithSelector(callback, response, carry));\r\n\t\tif (!ok) assembly { revert(add(v, 32), mload(v)) }\r\n\t\tassembly { return(add(v, 32), mload(v)) }\r\n\t}\r\n\r\n\tfunction _findSelf(bytes memory name) internal view returns (bytes32 node, uint256 offset, uint256 offset2) {\r\n\t\tunchecked {\r\n\t\t\twhile (true) {\r\n\t\t\t\tnode = name.namehash(offset);\r\n\t\t\t\tif (_ens.resolver(node) == address(this)) break;\r\n\t\t\t\tuint256 size = uint256(uint8(name[offset]));\r\n\t\t\t\tif (size == 0) revert Unreachable(name);\r\n\t\t\t\toffset2 = offset;\r\n\t\t\t\toffset += 1 + size;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction _findResolver(bytes memory name) internal view returns (bytes32 node, address resolver, bool wild, uint256 offset) {\r\n\t\tunchecked {\r\n\t\t\twhile (true) {\r\n\t\t\t\tnode = name.namehash(offset);\r\n\t\t\t\tresolver = _ens.resolver(node);\r\n\t\t\t\tif (resolver != address(0)) break;\r\n\t\t\t\toffset += 1 + uint256(uint8(name[offset]));\r\n\t\t\t}\r\n \t\t\ttry IERC165(resolver).supportsInterface{gas: 30000}(type(IExtendedResolver).interfaceId) returns (bool quacks) {\r\n\t\t\t\twild = quacks;\r\n\t\t\t} catch {\r\n\t\t\t}\r\n\t\t\tif (offset != 0 && !wild) revert Unreachable(name);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nlibrary BytesUtils {\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /**\n     * @dev Returns the ENS namehash of a DNS-encoded name.\n     * @param self The DNS-encoded name to hash.\n     * @param offset The offset at which to start hashing.\n     * @return The namehash of the name.\n     */\n    function namehash(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\n        if (labelhash == bytes32(0)) {\n            require(offset == self.length - 1, \"namehash: Junk at end of name\");\n            return bytes32(0);\n        }\n        return\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\n    }\n\n    /**\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\n     * @param self The byte string to read a label from.\n     * @param idx The index to read a label at.\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\n     * @return newIdx The index of the start of the next label.\n     */\n    function readLabel(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\n        require(idx < self.length, \"readLabel: Index out of bounds\");\n        uint256 len = uint256(uint8(self[idx]));\n        if (len > 0) {\n            labelhash = keccak(self, idx + 1, len);\n        } else {\n            labelhash = bytes32(0);\n        }\n        newIdx = idx + len + 1;\n    }\n}\n"
    },
    "Base32.sol": {
      "content": "/// @author raffy.eth\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.23;\r\n\r\nlibrary Base32 {\r\n\r\n\tfunction decode(uint256 pos, uint256 len) internal pure returns (bool ok, bytes memory) {\r\n\t\tunchecked {\r\n\t\t\tuint256 n = (len * 5) >> 3;\r\n\t\t\tbytes memory v = new bytes(n);\r\n\t\t\tuint256 clip;\r\n\t\t\tuint256 ammo;\r\n\t\t\tuint256 bits;\r\n\t\t\tuint256 word;\r\n\t\t\tfor (uint256 i; i < n; i += 1) {\r\n\t\t\t\twhile (bits < 8) {\r\n\t\t\t\t\tif (ammo == 0) {\r\n\t\t\t\t\t\tammo = 32;\r\n\t\t\t\t\t\tassembly { clip := mload(pos) }\r\n\t\t\t\t\t\tpos += ammo;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tuint256 x = _indexOf(clip >> 248);\r\n\t\t\t\t\tif (x == 32) return (false, '');\r\n\t\t\t\t\tclip <<= 8;\r\n\t\t\t\t\tammo -= 1;\r\n\t\t\t\t\tword = (word << 5) | x;\r\n\t\t\t\t\tbits += 5;\r\n\t\t\t\t}\r\n\t\t\t\tv[i] = bytes1(uint8(word >> (bits -= 8)));\r\n\t\t\t}\r\n\t\t\treturn (true, v);\r\n\t\t}\r\n\t}\r\n\r\n\t// \"abcdefghijklmnopqrstuvwxyz234567\";\r\n\tfunction _indexOf(uint256 x) internal pure returns (uint256) {\r\n\t\tif (x >= 97 && x <= 122) {\r\n\t\t\treturn x - 97;\r\n\t\t} else if (x >= 50 && x <= 55) {\r\n\t\t\treturn x - 24; // 50-26\r\n\t\t} else {\r\n\t\t\treturn 32;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 420
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "remappings": []
  }
}}