{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address) {\n        return _getRoleMember(role, index);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return _getRoleMemberCount(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/IReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IReentrancyGuard } from './IReentrancyGuard.sol';\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard is IReentrancyGuard {\n    uint256 internal constant REENTRANCY_STATUS_LOCKED = 2;\n    uint256 internal constant REENTRANCY_STATUS_UNLOCKED = 1;\n\n    modifier nonReentrant() virtual {\n        if (_isReentrancyGuardLocked()) revert ReentrancyGuard__ReentrantCall();\n        _lockReentrancyGuard();\n        _;\n        _unlockReentrancyGuard();\n    }\n\n    /**\n     * @notice returns true if the reentrancy guard is locked, false otherwise\n     */\n    function _isReentrancyGuardLocked() internal view virtual returns (bool) {\n        return\n            ReentrancyGuardStorage.layout().status == REENTRANCY_STATUS_LOCKED;\n    }\n\n    /**\n     * @notice lock functions that use the nonReentrant modifier\n     */\n    function _lockReentrancyGuard() internal virtual {\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_LOCKED;\n    }\n\n    /**\n     * @notice unlock functions that use the nonReentrant modifier\n     */\n    function _unlockReentrancyGuard() internal virtual {\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_UNLOCKED;\n    }\n}\n"
    },
    "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/internal/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\n\nimport { LibAccessControl } from \"../libraries/LibAccessControl.sol\";\nimport { LibWhitelabel } from \"../libraries/LibWhitelabel.sol\";\n\nabstract contract WhitelistInternal is AccessControlInternal {\n    modifier onlyWhitelisted(address account, bytes32 productId) {\n        LibWhitelabel.DiamondStorage storage ds = LibWhitelabel.diamondStorage();\n        require(!ds.isWhitelistEnabled[productId] || _hasRole(LibAccessControl.WHITELISTED_ROLE, account), \"Whitelist: caller is not whitelisted\");\n        _;\n    }\n}\n"
    },
    "contracts/common/admin/libraries/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibAccessControl {\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant WHITELIST_ADMIN_ROLE = keccak256(\"WHITELIST_ADMIN_ROLE\");\n    bytes32 internal constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n}\n"
    },
    "contracts/common/admin/libraries/LibWhitelabel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibWhitelabel {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"floki.whitelabel.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(bytes32 => bool) isWhitelistEnabled; // bytes32 is productIdentifier generated using keccak256\n    }\n\n    event WhitelistedAdded(address indexed account);\n    event WhitelistedRemoved(address indexed account);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/common/diamonds/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondProxy {\n    function implementation() external view returns (address);\n\n    function setImplementation(address _implementation) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IPausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\n\ninterface IPausableFacet is IPausable {\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamondHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\nimport { IReentrancyGuard } from \"@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol\";\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondProxy } from \"../interfaces/IDiamondProxy.sol\";\nimport { IPausableFacet, IPausable } from \"../interfaces/IPausableFacet.sol\";\n\nlibrary LibDiamondHelpers {\n    function getAccessControlSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](7);\n        functionSelectors[0] = IAccessControl.hasRole.selector;\n        functionSelectors[1] = IAccessControl.getRoleAdmin.selector;\n        functionSelectors[2] = IAccessControl.grantRole.selector;\n        functionSelectors[3] = IAccessControl.revokeRole.selector;\n        functionSelectors[4] = IAccessControl.renounceRole.selector;\n        functionSelectors[5] = IAccessControl.getRoleMember.selector;\n        functionSelectors[6] = IAccessControl.getRoleMemberCount.selector;\n    }\n\n    function getPausableSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](3);\n        functionSelectors[0] = IPausable.paused.selector;\n        functionSelectors[1] = IPausableFacet.pause.selector;\n        functionSelectors[2] = IPausableFacet.unpause.selector;\n    }\n\n    function getDiamondLoupeSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](4);\n        functionSelectors[0] = IDiamondLoupe.facetFunctionSelectors.selector;\n        functionSelectors[1] = IDiamondLoupe.facetAddress.selector;\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        functionSelectors[3] = IDiamondLoupe.facets.selector;\n    }\n\n    function getDiamondProxySelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](2);\n        functionSelectors[0] = IDiamondProxy.implementation.selector;\n        functionSelectors[1] = IDiamondProxy.setImplementation.selector;\n    }\n\n    function getReentrancyGuardSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](0);\n    }\n}\n"
    },
    "contracts/launchpad/facets/LaunchPadFactoryAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\n\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport { ILaunchPadFactoryAdmin, ILaunchPadCommon } from \"../interfaces/ILaunchPadFactoryAdmin.sol\";\nimport { ILaunchPadPayment } from \"../interfaces/ILaunchPadPayment.sol\";\nimport { ILaunchPadPricing } from \"../interfaces/ILaunchPadPricing.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectInit } from \"../interfaces/ILaunchPadProjectInit.sol\";\nimport { LibLaunchPadFactoryStorage } from \"../libraries/LaunchPadFactoryStorage.sol\";\nimport { LibLaunchPadProjectStorage } from \"../libraries/LaunchPadProjectStorage.sol\";\nimport { LibLaunchPadConsts } from \"../libraries/LaunchPadConsts.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../../common/diamonds/libraries/LibDiamond.sol\";\nimport { LibDiamondHelpers } from \"../../common/diamonds/libraries/LibDiamondHelpers.sol\";\nimport { Diamond } from \"../../common/diamonds/Diamond.sol\";\nimport { ITokenLauncherERC20, ITokenLauncherCommon } from \"../../token-launcher/interfaces/ITokenLauncherERC20.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"../../token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol\";\nimport { ITokenFiERC20 } from \"../../token-launcher/interfaces/ITokenFiERC20.sol\";\nimport { WhitelistInternal } from \"../../common/admin/internal/WhitelistInternal.sol\";\n\ncontract LaunchPadFactoryAdminFacet is ILaunchPadFactoryAdmin {\n    function removeLaunchpad(address launchpad) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.isLaunchPad[launchpad], \"LaunchPadFactory: LaunchPad does not exist\");\n        address owner = ds.launchPadOwner[launchpad];\n        // remove launchpad from owner\n        for (uint256 i = 0; i < ds.launchPadsByOwner[owner].length; i++) {\n            if (ds.launchPadsByOwner[owner][i] == launchpad) {\n                ds.launchPadsByOwner[owner][i] = ds.launchPadsByOwner[owner][ds.launchPadsByOwner[owner].length - 1];\n                ds.launchPadsByOwner[owner].pop();\n                break;\n            }\n        }\n        address[] memory investors = ILaunchPadProject(launchpad).getAllInvestors();\n        // remove launchpad from investors\n        for (uint256 i = 0; i < investors.length; i++) {\n            for (uint256 j = 0; j < ds.launchPadsByInvestor[investors[i]].length; j++) {\n                if (ds.launchPadsByInvestor[investors[i]][j] == launchpad) {\n                    ds.launchPadsByInvestor[investors[i]][j] = ds.launchPadsByInvestor[investors[i]][ds.launchPadsByInvestor[investors[i]].length - 1];\n                    ds.launchPadsByInvestor[investors[i]].pop();\n                    break;\n                }\n            }\n        }\n        // remove launchpad\n        for (uint256 i = 0; i < ds.launchPads.length; i++) {\n            if (ds.launchPads[i] == launchpad) {\n                ds.launchPads[i] = ds.launchPads[ds.launchPads.length - 1];\n                ds.launchPads.pop();\n                break;\n            }\n        }\n        ds.launchPadOwner[launchpad] = address(0);\n        ds.isLaunchPad[launchpad] = false;\n        emit LibLaunchPadFactoryStorage.LaunchpadRemoved(launchpad, owner);\n    }\n\n    function upgradeLaunchPadProjectFacets(\n        address launchPad,\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) external onlyAdmin {\n        IDiamondCut(launchPad).diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        uint256 oldMaxTokenCreationDeadline = ds.maxTokenCreationDeadline;\n        ds.maxTokenCreationDeadline = newMaxTokenCreationDeadline;\n        emit LibLaunchPadFactoryStorage.MaxTokenCreationDeadlineUpdated(oldMaxTokenCreationDeadline, newMaxTokenCreationDeadline);\n    }\n\n    modifier onlyAdmin() {\n        require(\n            IAccessControl(address(this)).hasRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, msg.sender),\n            \"LaunchPadFactory: Only admin can call this function\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILaunchPadCommon {\n    enum LaunchPadType {\n        FlokiPadCreatedBefore,\n        FlokiPadCreatedAfter\n    }\n\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        TOKENFI\n    }\n\n    struct IdoInfo {\n        bool enabled;\n        address dexRouter;\n        address pairToken;\n        uint256 price;\n        uint256 amountToList;\n    }\n\n    struct RefundInfo {\n        uint256 penaltyFeePercent;\n        uint256 expireDuration;\n    }\n\n    struct FundTarget {\n        uint256 softCap;\n        uint256 hardCap;\n    }\n\n    struct ReleaseSchedule {\n        uint256 timestamp;\n        uint256 percent;\n    }\n\n    struct ReleaseScheduleV2 {\n        uint256 timestamp;\n        uint256 percent;\n        bool isVesting;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 maxSupply;\n        address owner;\n        uint256 treasuryReserved;\n    }\n\n    struct LaunchPadInfo {\n        address owner;\n        address tokenAddress;\n        address paymentTokenAddress;\n        uint256 price;\n        FundTarget fundTarget;\n        uint256 maxInvestPerWallet;\n        uint256 startTimestamp;\n        uint256 duration;\n        uint256 tokenCreationDeadline;\n        RefundInfo refundInfo;\n        IdoInfo idoInfo;\n    }\n\n    struct CreateLaunchPadInput {\n        LaunchPadType launchPadType;\n        LaunchPadInfo launchPadInfo;\n        ReleaseScheduleV2[] releaseSchedule;\n        CreateErc20Input createErc20Input;\n        address referrer;\n        PaymentMethod paymentMethod;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\n\ninterface ILaunchPadFactory is ILaunchPadCommon {\n    struct StoreLaunchPadInput {\n        ILaunchPadCommon.LaunchPadType launchPadType;\n        address launchPadAddress;\n        address owner;\n        address referrer;\n        uint256 usdPrice;\n    }\n\n    function addInvestorToLaunchPad(address investor) external;\n\n    function createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input) external payable;\n\n    function createTokenAfterICO(address launchPadAddress) external payable;\n\n    function setExistingTokenAfterICO(address launchPad, address tokenAddress, uint256 amount) external;\n\n    function createV2LiquidityPool(address launchPadAddress) external payable;\n\n    function updateLaunchPadOwner(address tokenAddress, address newOwner) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactoryAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\n\ninterface ILaunchPadFactoryAdmin is ILaunchPadCommon {\n    function removeLaunchpad(address launchpad) external;\n\n    function upgradeLaunchPadProjectFacets(address launchPad, IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) external;\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadPayment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadPayment is ILaunchPadCommon {\n    struct ProcessPaymentInput {\n        address referrer;\n        uint256 usdPrice;\n        address user;\n        PaymentMethod paymentMethod;\n    }\n\n    struct ProcessPaymentOutput {\n        PaymentMethod paymentMethod;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n    }\n\n    function getRouterAddress() external view returns (address);\n\n    function getTokenFiToken() external view returns (address);\n\n    function getTreasury() external view returns (address);\n\n    function getUsdToken() external view returns (address);\n\n    function processPayment(ProcessPaymentInput memory params) external payable;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadPricing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadPricing is ILaunchPadCommon {\n    function getFeePercentage() external view returns (uint256);\n\n    function getPrice(address user, LaunchPadType launchPadType) external view returns (uint256); // returns usd value includes the decimals (6)\n\n    function setDeployLaunchPadPrice(uint256 newPrice, LaunchPadType launchPadType) external;\n\n    function setFeePercentage(uint256 newFeePercentage) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProject {\n    struct PurchasedInfo {\n        uint256 purchasedTokenAmount;\n        uint256 claimedTokenAmount;\n        uint256 paidTokenAmount;\n    }\n\n    function buyTokens(uint256 tokenAmount) external payable;\n\n    function claimTokens() external;\n\n    function getFeeShare() external view returns (uint256);\n\n    function getLaunchPadAddress() external view returns (address);\n\n    function getLaunchPadInfo() external view returns (ILaunchPadCommon.LaunchPadInfo memory);\n\n    function getProjectOwnerRole() external view returns (bytes32);\n\n    function getReleasedTokensPercentage() external view returns (uint256);\n\n    function getReleaseSchedule() external view returns (ILaunchPadCommon.ReleaseScheduleV2[] memory);\n\n    function getTokensAvailableToBeClaimed(address user) external view returns (uint256);\n\n    function getTokenCreationDeadline() external view returns (uint256);\n\n    function getPurchasedInfoByUser(address user) external view returns (PurchasedInfo memory);\n\n    function getInvestorsLength() external view returns (uint256);\n\n    function getAllInvestors() external view returns (address[] memory);\n\n    function getInvestorAddressByIndex(uint256 index) external view returns (address);\n\n    function refund(uint256 tokenAmount) external;\n\n    function refundOnSoftCapFailure() external;\n\n    function refundOnTokenCreationExpired(uint256 tokenAmount) external;\n\n    function setTokenAddress(address tokenAddress) external;\n\n    function tokenDecimals() external view returns (uint256);\n\n    function totalTokensClaimed() external view returns (uint256);\n\n    function totalTokensSold() external view returns (uint256);\n\n    function withdrawFees() external;\n\n    function withdrawTokens(address _tokenAddress) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectInit {\n    function init(ILaunchPadCommon.CreateLaunchPadInput memory input) external;\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibLaunchPadConsts {\n    bytes32 internal constant PRODUCT_ID = keccak256(\"tokenfi.launchpad\");\n    uint256 internal constant BASIS_POINTS = 10_000;\n    uint256 internal constant REFERRER_BASIS_POINTS = 2_500;\n    uint256 internal constant BURN_BASIS_POINTS = 5_000;\n    address internal constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactory } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\n\nlibrary LibLaunchPadFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        address[] launchPads;\n        mapping(address => address[]) launchPadsByOwner;\n        mapping(address => address[]) launchPadsByInvestor;\n        mapping(address => address) launchPadOwner;\n        mapping(address => bool) isLaunchPad;\n        mapping(address => ILaunchPadFactory.CreateErc20Input) tokenInfoByLaunchPadAddress;\n        uint256 currentBlockLaunchPadCreated;\n        uint256 currentBlockLaunchPadOwnerUpdated;\n        address tokenLauncherERC20;\n        address tokenLauncherStore;\n        address tokenLauncherBuybackHandler;\n        address launchPadProjectFacet;\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address launchPadProjectDiamondInit;\n        address tokenfiToken;\n        address usdToken;\n        address router;\n        address treasury;\n        uint256 maxTokenCreationDeadline;\n    }\n\n    event LaunchPadCreated(\n        uint256 indexed previousBlock,\n        ILaunchPadCommon.LaunchPadType indexed launchPadType,\n        address indexed owner,\n        ILaunchPadFactory.StoreLaunchPadInput launchPad\n    );\n    event LaunchPadOwnerUpdated(uint256 indexed previousBlock, address owner, address newOwner);\n    event MaxTokenCreationDeadlineUpdated(uint256 indexed previousMaxTokenCreationDeadline, uint256 newMaxTokenCreationDeadline);\n    event LaunchpadRemoved(address indexed launchPadAddress, address indexed owner);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getLaunchPadProjectSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](23);\n        functionSelectors[0] = ILaunchPadProject.buyTokens.selector;\n        functionSelectors[1] = ILaunchPadProject.claimTokens.selector;\n        functionSelectors[2] = ILaunchPadProject.getPurchasedInfoByUser.selector;\n        functionSelectors[3] = ILaunchPadProject.getFeeShare.selector;\n        functionSelectors[4] = ILaunchPadProject.getLaunchPadAddress.selector;\n        functionSelectors[5] = ILaunchPadProject.getLaunchPadInfo.selector;\n        functionSelectors[6] = ILaunchPadProject.getProjectOwnerRole.selector;\n        functionSelectors[7] = ILaunchPadProject.getReleasedTokensPercentage.selector;\n        functionSelectors[8] = ILaunchPadProject.getReleaseSchedule.selector;\n        functionSelectors[9] = ILaunchPadProject.getTokensAvailableToBeClaimed.selector;\n        functionSelectors[10] = ILaunchPadProject.getTokenCreationDeadline.selector;\n        functionSelectors[11] = ILaunchPadProject.getInvestorsLength.selector;\n        functionSelectors[12] = ILaunchPadProject.getAllInvestors.selector;\n        functionSelectors[13] = ILaunchPadProject.getInvestorAddressByIndex.selector;\n        functionSelectors[14] = ILaunchPadProject.refund.selector;\n        functionSelectors[15] = ILaunchPadProject.refundOnSoftCapFailure.selector;\n        functionSelectors[16] = ILaunchPadProject.refundOnTokenCreationExpired.selector;\n        functionSelectors[17] = ILaunchPadProject.setTokenAddress.selector;\n        functionSelectors[18] = ILaunchPadProject.tokenDecimals.selector;\n        functionSelectors[19] = ILaunchPadProject.totalTokensClaimed.selector;\n        functionSelectors[20] = ILaunchPadProject.totalTokensSold.selector;\n        functionSelectors[21] = ILaunchPadProject.withdrawFees.selector;\n        functionSelectors[22] = ILaunchPadProject.withdrawTokens.selector;\n\n        return functionSelectors;\n    }\n}\n"
    },
    "contracts/launchpad/libraries/LaunchPadProjectStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\n\n/// @notice storage for LaunchPads created by users\n\nlibrary LibLaunchPadProjectStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.project.diamond.storage\");\n    bytes32 internal constant LAUNCHPAD_OWNER_ROLE = keccak256(\"LAUNCHPAD_OWNER_ROLE\");\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    struct DiamondStorage {\n        ILaunchPadCommon.LaunchPadInfo launchPadInfo;\n        address launchPadFactory;\n        uint256 totalTokensSold;\n        uint256 totalTokensClaimed;\n        uint256 feePercentage; // in basis points 1e4\n        bool feeShareCollected;\n        ILaunchPadCommon.ReleaseSchedule[] releaseSchedule;\n        ILaunchPadCommon.ReleaseScheduleV2[] releaseScheduleV2;\n        mapping(address => ILaunchPadProject.PurchasedInfo) purchasedInfoByUser;\n        address[] investors;\n    }\n\n    event TokensPurchased(address indexed buyer, uint256 amount);\n    event TokensRefunded(address indexed buyer, uint256 amount);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherERC20 } from \"./ITokenLauncherERC20.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"./ITokenLauncherLiquidityPoolFactory.sol\";\n\ninterface ITokenFiERC20 {\n    function addExchangePool(address pool) external;\n    function addExemptAddress(address account) external;\n    function excludeAccount(address account) external;\n    function includeAccount(address account) external;\n    function isExchangePool(address pool) external view returns (bool);\n    function isExcludedFromReflectionRewards(address account) external view returns (bool);\n    function isExemptedFromTax(address account) external view returns (bool);\n    function mint(address to, uint256 amount) external;\n    function reflect(uint256 tAmount) external;\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function removeExchangePool(address pool) external;\n    function removeExemptAddress(address account) external;\n    function setBuybackDetails(ITokenLauncherLiquidityPoolFactory.BuyBackDetails memory _buybackDetails) external;\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n    function updateFees(ITokenLauncherERC20.Fees memory _fees) external;\n    function updateTokenLauncher(address _newTokenLauncher) external;\n    function updateTreasury(address _newTreasury) external;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherCommon {\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        FLOKI\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"./ITokenLauncherCommon.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"./ITokenLauncherLiquidityPoolFactory.sol\";\n\ninterface ITokenLauncherERC20 is ITokenLauncherCommon {\n    struct FeeDetails {\n        uint256 percentage;\n        bool onlyOnSwaps;\n    }\n\n    struct Fees {\n        FeeDetails transferFee;\n        FeeDetails burn;\n        FeeDetails reflection;\n        FeeDetails buyback;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 initialSupply;\n        uint256 maxSupply;\n        address treasury;\n        address owner;\n        address referrer;\n        address tokenStore;\n        Fees fees;\n        address buybackHandler;\n        PaymentMethod paymentMethod;\n    }\n\n    function tokenLauncherStore() external returns (address);\n\n    function liquidityPoolFactory() external returns (address);\n\n    function buybackHandler() external returns (address);\n\n    function createErc20(CreateErc20Input memory input) external payable returns (address);\n\n    function createV2LiquidityPool(ITokenLauncherLiquidityPoolFactory.CreateV2Input memory input) external payable;\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherLiquidityPoolFactory {\n    struct LiquidityPoolDetails {\n        address sourceToken;\n        address pairedToken;\n        uint256 amountSourceToken;\n        uint256 amountPairedToken;\n        address routerAddress;\n    }\n\n    struct LockLPDetails {\n        uint256 lockLPTokenPercentage;\n        uint256 unlockTimestamp;\n        address beneficiary;\n        bool isVesting;\n    }\n\n    struct BuyBackDetails {\n        address pairToken;\n        address router;\n        uint256 liquidityBasisPoints;\n        uint256 priceImpactBasisPoints;\n    }\n\n    struct CreateV2Input {\n        address owner;\n        address treasury;\n        LiquidityPoolDetails liquidityPoolDetails;\n        LockLPDetails lockLPDetails;\n        BuyBackDetails buybackDetails;\n    }\n\n    struct CreateV2Output {\n        address liquidityPoolToken;\n        uint256 liquidity;\n    }\n\n    function createV2LiquidityPool(CreateV2Input memory input) external payable returns (CreateV2Output memory);\n}\n"
    }
  }
}}